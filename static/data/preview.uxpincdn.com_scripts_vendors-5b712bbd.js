function _typeof2(obj) {
    return (_typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj
    })(obj)
}(function() {
    "use strict";

    function EventEmitter() {}

    function indexOfListener(listeners, listener) {
        for (var i = listeners.length; i--;)
            if (listeners[i].listener === listener) return i;
        return -1
    }

    function alias(name) {
        return function() {
            return this[name].apply(this, arguments)
        }
    }
    var proto = EventEmitter.prototype,
        exports = this,
        originalGlobalValue = exports.EventEmitter;
    proto.getListeners = function(evt) {
        var response, key, events = this._getEvents();
        if (evt instanceof RegExp) {
            response = {};
            for (key in events) events.hasOwnProperty(key) && evt.test(key) && (response[key] = events[key])
        } else response = events[evt] || (events[evt] = []);
        return response
    }, proto.flattenListeners = function(listeners) {
        var i, flatListeners = [];
        for (i = 0; i < listeners.length; i += 1) flatListeners.push(listeners[i].listener);
        return flatListeners
    }, proto.getListenersAsObject = function(evt) {
        var response, listeners = this.getListeners(evt);
        return listeners instanceof Array && (response = {}, response[evt] = listeners), response || listeners
    }, proto.addListener = function(evt, listener) {
        var key, listeners = this.getListenersAsObject(evt),
            listenerIsWrapped = "object" === _typeof2(listener);
        for (key in listeners) listeners.hasOwnProperty(key) && indexOfListener(listeners[key], listener) === -1 && listeners[key].push(listenerIsWrapped ? listener : {
            listener: listener,
            once: !1
        });
        return this
    }, proto.on = alias("addListener"), proto.addOnceListener = function(evt, listener) {
        return this.addListener(evt, {
            listener: listener,
            once: !0
        })
    }, proto.once = alias("addOnceListener"), proto.defineEvent = function(evt) {
        return this.getListeners(evt), this
    }, proto.defineEvents = function(evts) {
        for (var i = 0; i < evts.length; i += 1) this.defineEvent(evts[i]);
        return this
    }, proto.removeListener = function(evt, listener) {
        var index, key, listeners = this.getListenersAsObject(evt);
        for (key in listeners) listeners.hasOwnProperty(key) && (index = indexOfListener(listeners[key], listener), index !== -1 && listeners[key].splice(index, 1));
        return this
    }, proto.off = alias("removeListener"), proto.addListeners = function(evt, listeners) {
        return this.manipulateListeners(!1, evt, listeners)
    }, proto.removeListeners = function(evt, listeners) {
        return this.manipulateListeners(!0, evt, listeners)
    }, proto.manipulateListeners = function(remove, evt, listeners) {
        var i, value, single = remove ? this.removeListener : this.addListener,
            multiple = remove ? this.removeListeners : this.addListeners;
        if ("object" !== _typeof2(evt) || evt instanceof RegExp)
            for (i = listeners.length; i--;) single.call(this, evt, listeners[i]);
        else
            for (i in evt) evt.hasOwnProperty(i) && (value = evt[i]) && ("function" == typeof value ? single.call(this, i, value) : multiple.call(this, i, value));
        return this
    }, proto.removeEvent = function(evt) {
        var key, type = _typeof2(evt),
            events = this._getEvents();
        if ("string" === type) delete events[evt];
        else if (evt instanceof RegExp)
            for (key in events) events.hasOwnProperty(key) && evt.test(key) && delete events[key];
        else delete this._events;
        return this
    }, proto.removeAllListeners = alias("removeEvent"), proto.emitEvent = function(evt, args) {
        var listener, i, key, response, listeners = this.getListenersAsObject(evt);
        for (key in listeners)
            if (listeners.hasOwnProperty(key))
                for (i = listeners[key].length; i--;) listener = listeners[key][i], listener.once === !0 && this.removeListener(evt, listener.listener), response = listener.listener.apply(this, args || []), response === this._getOnceReturnValue() && this.removeListener(evt, listener.listener);
        return this
    }, proto.trigger = alias("emitEvent"), proto.emit = function(evt) {
        var args = Array.prototype.slice.call(arguments, 1);
        return this.emitEvent(evt, args)
    }, proto.setOnceReturnValue = function(value) {
        return this._onceReturnValue = value, this
    }, proto._getOnceReturnValue = function() {
        return !this.hasOwnProperty("_onceReturnValue") || this._onceReturnValue
    }, proto._getEvents = function() {
        return this._events || (this._events = {})
    }, EventEmitter.noConflict = function() {
        return exports.EventEmitter = originalGlobalValue, EventEmitter
    }, "function" == typeof define && define.amd ? define(function() {
        return EventEmitter
    }) : "object" === ("undefined" == typeof module ? "undefined" : _typeof2(module)) && module.exports ? module.exports = EventEmitter : this.EventEmitter = EventEmitter
}).call(this),
    function() {
        var root = this,
            previousUnderscore = root._,
            ArrayProto = Array.prototype,
            ObjProto = Object.prototype,
            FuncProto = Function.prototype,
            push = ArrayProto.push,
            slice = ArrayProto.slice,
            concat = ArrayProto.concat,
            toString = ObjProto.toString,
            hasOwnProperty = ObjProto.hasOwnProperty,
            nativeIsArray = Array.isArray,
            nativeKeys = Object.keys,
            nativeBind = FuncProto.bind,
            _ = function _(obj) {
                return obj instanceof _ ? obj : this instanceof _ ? void(this._wrapped = obj) : new _(obj)
            };
        "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = _), exports._ = _) : root._ = _, _.VERSION = "1.7.0";
        var createCallback = function(func, context, argCount) {
            if (void 0 === context) return func;
            switch (null == argCount ? 3 : argCount) {
                case 1:
                    return function(value) {
                        return func.call(context, value)
                    };
                case 2:
                    return function(value, other) {
                        return func.call(context, value, other)
                    };
                case 3:
                    return function(value, index, collection) {
                        return func.call(context, value, index, collection)
                    };
                case 4:
                    return function(accumulator, value, index, collection) {
                        return func.call(context, accumulator, value, index, collection)
                    }
            }
            return function() {
                return func.apply(context, arguments)
            }
        };
        _.iteratee = function(value, context, argCount) {
            return null == value ? _.identity : _.isFunction(value) ? createCallback(value, context, argCount) : _.isObject(value) ? _.matches(value) : _.property(value)
        }, _.each = _.forEach = function(obj, iteratee, context) {
            if (null == obj) return obj;
            iteratee = createCallback(iteratee, context);
            var i, length = obj.length;
            if (length === +length)
                for (i = 0; i < length; i++) iteratee(obj[i], i, obj);
            else {
                var keys = _.keys(obj);
                for (i = 0, length = keys.length; i < length; i++) iteratee(obj[keys[i]], keys[i], obj)
            }
            return obj
        }, _.map = _.collect = function(obj, iteratee, context) {
            if (null == obj) return [];
            iteratee = _.iteratee(iteratee, context);
            for (var currentKey, keys = obj.length !== +obj.length && _.keys(obj), length = (keys || obj).length, results = Array(length), index = 0; index < length; index++) currentKey = keys ? keys[index] : index, results[index] = iteratee(obj[currentKey], currentKey, obj);
            return results
        };
        var reduceError = "Reduce of empty array with no initial value";
        _.reduce = _.foldl = _.inject = function(obj, iteratee, memo, context) {
            null == obj && (obj = []), iteratee = createCallback(iteratee, context, 4);
            var currentKey, keys = obj.length !== +obj.length && _.keys(obj),
                length = (keys || obj).length,
                index = 0;
            if (arguments.length < 3) {
                if (!length) throw new TypeError(reduceError);
                memo = obj[keys ? keys[index++] : index++]
            }
            for (; index < length; index++) currentKey = keys ? keys[index] : index, memo = iteratee(memo, obj[currentKey], currentKey, obj);
            return memo
        }, _.reduceRight = _.foldr = function(obj, iteratee, memo, context) {
            null == obj && (obj = []), iteratee = createCallback(iteratee, context, 4);
            var currentKey, keys = obj.length !== +obj.length && _.keys(obj),
                index = (keys || obj).length;
            if (arguments.length < 3) {
                if (!index) throw new TypeError(reduceError);
                memo = obj[keys ? keys[--index] : --index]
            }
            for (; index--;) currentKey = keys ? keys[index] : index, memo = iteratee(memo, obj[currentKey], currentKey, obj);
            return memo
        }, _.find = _.detect = function(obj, predicate, context) {
            var result;
            return predicate = _.iteratee(predicate, context), _.some(obj, function(value, index, list) {
                if (predicate(value, index, list)) return result = value, !0
            }), result
        }, _.filter = _.select = function(obj, predicate, context) {
            var results = [];
            return null == obj ? results : (predicate = _.iteratee(predicate, context), _.each(obj, function(value, index, list) {
                predicate(value, index, list) && results.push(value)
            }), results)
        }, _.reject = function(obj, predicate, context) {
            return _.filter(obj, _.negate(_.iteratee(predicate)), context)
        }, _.every = _.all = function(obj, predicate, context) {
            if (null == obj) return !0;
            predicate = _.iteratee(predicate, context);
            var index, currentKey, keys = obj.length !== +obj.length && _.keys(obj),
                length = (keys || obj).length;
            for (index = 0; index < length; index++)
                if (currentKey = keys ? keys[index] : index, !predicate(obj[currentKey], currentKey, obj)) return !1;
            return !0
        }, _.some = _.any = function(obj, predicate, context) {
            if (null == obj) return !1;
            predicate = _.iteratee(predicate, context);
            var index, currentKey, keys = obj.length !== +obj.length && _.keys(obj),
                length = (keys || obj).length;
            for (index = 0; index < length; index++)
                if (currentKey = keys ? keys[index] : index, predicate(obj[currentKey], currentKey, obj)) return !0;
            return !1
        }, _.contains = _.include = function(obj, target) {
            return null != obj && (obj.length !== +obj.length && (obj = _.values(obj)), _.indexOf(obj, target) >= 0)
        }, _.invoke = function(obj, method) {
            var args = slice.call(arguments, 2),
                isFunc = _.isFunction(method);
            return _.map(obj, function(value) {
                return (isFunc ? method : value[method]).apply(value, args)
            })
        }, _.pluck = function(obj, key) {
            return _.map(obj, _.property(key))
        }, _.where = function(obj, attrs) {
            return _.filter(obj, _.matches(attrs))
        }, _.findWhere = function(obj, attrs) {
            return _.find(obj, _.matches(attrs))
        }, _.max = function(obj, iteratee, context) {
            var value, computed, result = -(1 / 0),
                lastComputed = -(1 / 0);
            if (null == iteratee && null != obj) {
                obj = obj.length === +obj.length ? obj : _.values(obj);
                for (var i = 0, length = obj.length; i < length; i++) value = obj[i], value > result && (result = value)
            } else iteratee = _.iteratee(iteratee, context), _.each(obj, function(value, index, list) {
                computed = iteratee(value, index, list), (computed > lastComputed || computed === -(1 / 0) && result === -(1 / 0)) && (result = value, lastComputed = computed)
            });
            return result
        }, _.min = function(obj, iteratee, context) {
            var value, computed, result = 1 / 0,
                lastComputed = 1 / 0;
            if (null == iteratee && null != obj) {
                obj = obj.length === +obj.length ? obj : _.values(obj);
                for (var i = 0, length = obj.length; i < length; i++) value = obj[i], value < result && (result = value)
            } else iteratee = _.iteratee(iteratee, context), _.each(obj, function(value, index, list) {
                computed = iteratee(value, index, list), (computed < lastComputed || computed === 1 / 0 && result === 1 / 0) && (result = value, lastComputed = computed)
            });
            return result
        }, _.shuffle = function(obj) {
            for (var rand, set = obj && obj.length === +obj.length ? obj : _.values(obj), length = set.length, shuffled = Array(length), index = 0; index < length; index++) rand = _.random(0, index), rand !== index && (shuffled[index] = shuffled[rand]), shuffled[rand] = set[index];
            return shuffled
        }, _.sample = function(obj, n, guard) {
            return null == n || guard ? (obj.length !== +obj.length && (obj = _.values(obj)), obj[_.random(obj.length - 1)]) : _.shuffle(obj).slice(0, Math.max(0, n))
        }, _.sortBy = function(obj, iteratee, context) {
            return iteratee = _.iteratee(iteratee, context), _.pluck(_.map(obj, function(value, index, list) {
                return {
                    value: value,
                    index: index,
                    criteria: iteratee(value, index, list)
                }
            }).sort(function(left, right) {
                var a = left.criteria,
                    b = right.criteria;
                if (a !== b) {
                    if (a > b || void 0 === a) return 1;
                    if (a < b || void 0 === b) return -1
                }
                return left.index - right.index
            }), "value")
        };
        var group = function(behavior) {
            return function(obj, iteratee, context) {
                var result = {};
                return iteratee = _.iteratee(iteratee, context), _.each(obj, function(value, index) {
                    var key = iteratee(value, index, obj);
                    behavior(result, value, key)
                }), result
            }
        };
        _.groupBy = group(function(result, value, key) {
            _.has(result, key) ? result[key].push(value) : result[key] = [value]
        }), _.indexBy = group(function(result, value, key) {
            result[key] = value
        }), _.countBy = group(function(result, value, key) {
            _.has(result, key) ? result[key]++ : result[key] = 1
        }), _.sortedIndex = function(array, obj, iteratee, context) {
            iteratee = _.iteratee(iteratee, context, 1);
            for (var value = iteratee(obj), low = 0, high = array.length; low < high;) {
                var mid = low + high >>> 1;
                iteratee(array[mid]) < value ? low = mid + 1 : high = mid
            }
            return low
        }, _.toArray = function(obj) {
            return obj ? _.isArray(obj) ? slice.call(obj) : obj.length === +obj.length ? _.map(obj, _.identity) : _.values(obj) : []
        }, _.size = function(obj) {
            return null == obj ? 0 : obj.length === +obj.length ? obj.length : _.keys(obj).length
        }, _.partition = function(obj, predicate, context) {
            predicate = _.iteratee(predicate, context);
            var pass = [],
                fail = [];
            return _.each(obj, function(value, key, obj) {
                (predicate(value, key, obj) ? pass : fail).push(value)
            }), [pass, fail]
        }, _.first = _.head = _.take = function(array, n, guard) {
            if (null != array) return null == n || guard ? array[0] : n < 0 ? [] : slice.call(array, 0, n)
        }, _.initial = function(array, n, guard) {
            return slice.call(array, 0, Math.max(0, array.length - (null == n || guard ? 1 : n)))
        }, _.last = function(array, n, guard) {
            if (null != array) return null == n || guard ? array[array.length - 1] : slice.call(array, Math.max(array.length - n, 0))
        }, _.rest = _.tail = _.drop = function(array, n, guard) {
            return slice.call(array, null == n || guard ? 1 : n)
        }, _.compact = function(array) {
            return _.filter(array, _.identity)
        };
        var flatten = function flatten(input, shallow, strict, output) {
            if (shallow && _.every(input, _.isArray)) return concat.apply(output, input);
            for (var i = 0, length = input.length; i < length; i++) {
                var value = input[i];
                _.isArray(value) || _.isArguments(value) ? shallow ? push.apply(output, value) : flatten(value, shallow, strict, output) : strict || output.push(value)
            }
            return output
        };
        _.flatten = function(array, shallow) {
            return flatten(array, shallow, !1, [])
        }, _.without = function(array) {
            return _.difference(array, slice.call(arguments, 1))
        }, _.uniq = _.unique = function(array, isSorted, iteratee, context) {
            if (null == array) return [];
            _.isBoolean(isSorted) || (context = iteratee, iteratee = isSorted, isSorted = !1), null != iteratee && (iteratee = _.iteratee(iteratee, context));
            for (var result = [], seen = [], i = 0, length = array.length; i < length; i++) {
                var value = array[i];
                if (isSorted) i && seen === value || result.push(value), seen = value;
                else if (iteratee) {
                    var computed = iteratee(value, i, array);
                    _.indexOf(seen, computed) < 0 && (seen.push(computed), result.push(value))
                } else _.indexOf(result, value) < 0 && result.push(value)
            }
            return result
        }, _.union = function() {
            return _.uniq(flatten(arguments, !0, !0, []))
        }, _.intersection = function(array) {
            if (null == array) return [];
            for (var result = [], argsLength = arguments.length, i = 0, length = array.length; i < length; i++) {
                var item = array[i];
                if (!_.contains(result, item)) {
                    for (var j = 1; j < argsLength && _.contains(arguments[j], item); j++);
                    j === argsLength && result.push(item)
                }
            }
            return result
        }, _.difference = function(array) {
            var rest = flatten(slice.call(arguments, 1), !0, !0, []);
            return _.filter(array, function(value) {
                return !_.contains(rest, value)
            })
        }, _.zip = function(array) {
            if (null == array) return [];
            for (var length = _.max(arguments, "length").length, results = Array(length), i = 0; i < length; i++) results[i] = _.pluck(arguments, i);
            return results
        }, _.object = function(list, values) {
            if (null == list) return {};
            for (var result = {}, i = 0, length = list.length; i < length; i++) values ? result[list[i]] = values[i] : result[list[i][0]] = list[i][1];
            return result
        }, _.indexOf = function(array, item, isSorted) {
            if (null == array) return -1;
            var i = 0,
                length = array.length;
            if (isSorted) {
                if ("number" != typeof isSorted) return i = _.sortedIndex(array, item), array[i] === item ? i : -1;
                i = isSorted < 0 ? Math.max(0, length + isSorted) : isSorted
            }
            for (; i < length; i++)
                if (array[i] === item) return i;
            return -1
        }, _.lastIndexOf = function(array, item, from) {
            if (null == array) return -1;
            var idx = array.length;
            for ("number" == typeof from && (idx = from < 0 ? idx + from + 1 : Math.min(idx, from + 1)); --idx >= 0;)
                if (array[idx] === item) return idx;
            return -1
        }, _.range = function(start, stop, step) {
            arguments.length <= 1 && (stop = start || 0, start = 0), step = step || 1;
            for (var length = Math.max(Math.ceil((stop - start) / step), 0), range = Array(length), idx = 0; idx < length; idx++, start += step) range[idx] = start;
            return range
        };
        var Ctor = function() {};
        _.bind = function(func, context) {
            var args, _bound;
            if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
            if (!_.isFunction(func)) throw new TypeError("Bind must be called on a function");
            return args = slice.call(arguments, 2), _bound = function() {
                if (!(this instanceof _bound)) return func.apply(context, args.concat(slice.call(arguments)));
                Ctor.prototype = func.prototype;
                var self = new Ctor;
                Ctor.prototype = null;
                var result = func.apply(self, args.concat(slice.call(arguments)));
                return _.isObject(result) ? result : self
            }
        }, _.partial = function(func) {
            var boundArgs = slice.call(arguments, 1);
            return function() {
                for (var position = 0, args = boundArgs.slice(), i = 0, length = args.length; i < length; i++) args[i] === _ && (args[i] = arguments[position++]);
                for (; position < arguments.length;) args.push(arguments[position++]);
                return func.apply(this, args)
            }
        }, _.bindAll = function(obj) {
            var i, key, length = arguments.length;
            if (length <= 1) throw new Error("bindAll must be passed function names");
            for (i = 1; i < length; i++) key = arguments[i], obj[key] = _.bind(obj[key], obj);
            return obj
        }, _.memoize = function(func, hasher) {
            var memoize = function memoize(key) {
                var cache = memoize.cache,
                    address = hasher ? hasher.apply(this, arguments) : key;
                return _.has(cache, address) || (cache[address] = func.apply(this, arguments)), cache[address]
            };
            return memoize.cache = {}, memoize
        }, _.delay = function(func, wait) {
            var args = slice.call(arguments, 2);
            return setTimeout(function() {
                return func.apply(null, args)
            }, wait)
        }, _.defer = function(func) {
            return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)))
        }, _.throttle = function(func, wait, options) {
            var context, args, result, timeout = null,
                previous = 0;
            options || (options = {});
            var later = function() {
                previous = options.leading === !1 ? 0 : _.now(), timeout = null, result = func.apply(context, args), timeout || (context = args = null)
            };
            return function() {
                var now = _.now();
                previous || options.leading !== !1 || (previous = now);
                var remaining = wait - (now - previous);
                return context = this, args = arguments, remaining <= 0 || remaining > wait ? (clearTimeout(timeout), timeout = null, previous = now, result = func.apply(context, args), timeout || (context = args = null)) : timeout || options.trailing === !1 || (timeout = setTimeout(later, remaining)), result
            }
        }, _.debounce = function(func, wait, immediate) {
            var timeout, args, context, timestamp, result, later = function later() {
                var last = _.now() - timestamp;
                last < wait && last > 0 ? timeout = setTimeout(later, wait - last) : (timeout = null, immediate || (result = func.apply(context, args), timeout || (context = args = null)))
            };
            return function() {
                context = this, args = arguments, timestamp = _.now();
                var callNow = immediate && !timeout;
                return timeout || (timeout = setTimeout(later, wait)), callNow && (result = func.apply(context, args), context = args = null), result
            }
        }, _.wrap = function(func, wrapper) {
            return _.partial(wrapper, func)
        }, _.negate = function(predicate) {
            return function() {
                return !predicate.apply(this, arguments)
            }
        }, _.compose = function() {
            var args = arguments,
                start = args.length - 1;
            return function() {
                for (var i = start, result = args[start].apply(this, arguments); i--;) result = args[i].call(this, result);
                return result
            }
        }, _.after = function(times, func) {
            return function() {
                if (--times < 1) return func.apply(this, arguments)
            }
        }, _.before = function(times, func) {
            var memo;
            return function() {
                return --times > 0 ? memo = func.apply(this, arguments) : func = null, memo
            }
        }, _.once = _.partial(_.before, 2), _.keys = function(obj) {
            if (!_.isObject(obj)) return [];
            if (nativeKeys) return nativeKeys(obj);
            var keys = [];
            for (var key in obj) _.has(obj, key) && keys.push(key);
            return keys
        }, _.values = function(obj) {
            for (var keys = _.keys(obj), length = keys.length, values = Array(length), i = 0; i < length; i++) values[i] = obj[keys[i]];
            return values
        }, _.pairs = function(obj) {
            for (var keys = _.keys(obj), length = keys.length, pairs = Array(length), i = 0; i < length; i++) pairs[i] = [keys[i], obj[keys[i]]];
            return pairs
        }, _.invert = function(obj) {
            for (var result = {}, keys = _.keys(obj), i = 0, length = keys.length; i < length; i++) result[obj[keys[i]]] = keys[i];
            return result
        }, _.functions = _.methods = function(obj) {
            var names = [];
            for (var key in obj) _.isFunction(obj[key]) && names.push(key);
            return names.sort()
        }, _.extend = function(obj) {
            if (!_.isObject(obj)) return obj;
            for (var source, prop, i = 1, length = arguments.length; i < length; i++) {
                source = arguments[i];
                for (prop in source) hasOwnProperty.call(source, prop) && (obj[prop] = source[prop])
            }
            return obj
        }, _.pick = function(obj, iteratee, context) {
            var key, result = {};
            if (null == obj) return result;
            if (_.isFunction(iteratee)) {
                iteratee = createCallback(iteratee, context);
                for (key in obj) {
                    var value = obj[key];
                    iteratee(value, key, obj) && (result[key] = value)
                }
            } else {
                var keys = concat.apply([], slice.call(arguments, 1));
                obj = new Object(obj);
                for (var i = 0, length = keys.length; i < length; i++) key = keys[i], key in obj && (result[key] = obj[key])
            }
            return result
        }, _.omit = function(obj, iteratee, context) {
            if (_.isFunction(iteratee)) iteratee = _.negate(iteratee);
            else {
                var keys = _.map(concat.apply([], slice.call(arguments, 1)), String);
                iteratee = function(value, key) {
                    return !_.contains(keys, key)
                }
            }
            return _.pick(obj, iteratee, context)
        }, _.defaults = function(obj) {
            if (!_.isObject(obj)) return obj;
            for (var i = 1, length = arguments.length; i < length; i++) {
                var source = arguments[i];
                for (var prop in source) void 0 === obj[prop] && (obj[prop] = source[prop])
            }
            return obj
        }, _.clone = function(obj) {
            return _.isObject(obj) ? _.isArray(obj) ? obj.slice() : _.extend({}, obj) : obj
        }, _.tap = function(obj, interceptor) {
            return interceptor(obj), obj
        };
        var eq = function eq(a, b, aStack, bStack) {
            if (a === b) return 0 !== a || 1 / a === 1 / b;
            if (null == a || null == b) return a === b;
            a instanceof _ && (a = a._wrapped), b instanceof _ && (b = b._wrapped);
            var className = toString.call(a);
            if (className !== toString.call(b)) return !1;
            switch (className) {
                case "[object RegExp]":
                case "[object String]":
                    return "" + a == "" + b;
                case "[object Number]":
                    return +a !== +a ? +b !== +b : 0 === +a ? 1 / +a === 1 / b : +a === +b;
                case "[object Date]":
                case "[object Boolean]":
                    return +a === +b
            }
            if ("object" != _typeof2(a) || "object" != _typeof2(b)) return !1;
            for (var length = aStack.length; length--;)
                if (aStack[length] === a) return bStack[length] === b;
            var aCtor = a.constructor,
                bCtor = b.constructor;
            if (aCtor !== bCtor && "constructor" in a && "constructor" in b && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor)) return !1;
            aStack.push(a), bStack.push(b);
            var size, result;
            if ("[object Array]" === className) {
                if (size = a.length, result = size === b.length)
                    for (; size-- && (result = eq(a[size], b[size], aStack, bStack)););
            } else {
                var key, keys = _.keys(a);
                if (size = keys.length, result = _.keys(b).length === size)
                    for (; size-- && (key = keys[size], result = _.has(b, key) && eq(a[key], b[key], aStack, bStack)););
            }
            return aStack.pop(), bStack.pop(), result
        };
        _.isEqual = function(a, b) {
            return eq(a, b, [], [])
        }, _.isEmpty = function(obj) {
            if (null == obj) return !0;
            if (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)) return 0 === obj.length;
            for (var key in obj)
                if (_.has(obj, key)) return !1;
            return !0
        }, _.isElement = function(obj) {
            return !(!obj || 1 !== obj.nodeType)
        }, _.isArray = nativeIsArray || function(obj) {
            return "[object Array]" === toString.call(obj)
        }, _.isObject = function(obj) {
            var type = _typeof2(obj);
            return "function" === type || "object" === type && !!obj
        }, _.each(["Arguments", "Function", "String", "Number", "Date", "RegExp"], function(name) {
            _["is" + name] = function(obj) {
                return toString.call(obj) === "[object " + name + "]"
            }
        }), _.isArguments(arguments) || (_.isArguments = function(obj) {
            return _.has(obj, "callee")
        }), "function" != typeof /./ && (_.isFunction = function(obj) {
            return "function" == typeof obj || !1
        }), _.isFinite = function(obj) {
            return isFinite(obj) && !isNaN(parseFloat(obj))
        }, _.isNaN = function(obj) {
            return _.isNumber(obj) && obj !== +obj
        }, _.isBoolean = function(obj) {
            return obj === !0 || obj === !1 || "[object Boolean]" === toString.call(obj)
        }, _.isNull = function(obj) {
            return null === obj
        }, _.isUndefined = function(obj) {
            return void 0 === obj
        }, _.has = function(obj, key) {
            return null != obj && hasOwnProperty.call(obj, key)
        }, _.noConflict = function() {
            return root._ = previousUnderscore, this
        }, _.identity = function(value) {
            return value
        }, _.constant = function(value) {
            return function() {
                return value
            }
        }, _.noop = function() {}, _.property = function(key) {
            return function(obj) {
                return obj[key]
            }
        }, _.matches = function(attrs) {
            var pairs = _.pairs(attrs),
                length = pairs.length;
            return function(obj) {
                if (null == obj) return !length;
                obj = new Object(obj);
                for (var i = 0; i < length; i++) {
                    var pair = pairs[i],
                        key = pair[0];
                    if (pair[1] !== obj[key] || !(key in obj)) return !1
                }
                return !0
            }
        }, _.times = function(n, iteratee, context) {
            var accum = Array(Math.max(0, n));
            iteratee = createCallback(iteratee, context, 1);
            for (var i = 0; i < n; i++) accum[i] = iteratee(i);
            return accum
        }, _.random = function(min, max) {
            return null == max && (max = min, min = 0), min + Math.floor(Math.random() * (max - min + 1))
        }, _.now = Date.now || function() {
            return (new Date).getTime()
        };
        var escapeMap = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#x27;",
                "`": "&#x60;"
            },
            unescapeMap = _.invert(escapeMap),
            createEscaper = function(map) {
                var escaper = function(match) {
                        return map[match]
                    },
                    source = "(?:" + _.keys(map).join("|") + ")",
                    testRegexp = RegExp(source),
                    replaceRegexp = RegExp(source, "g");
                return function(string) {
                    return string = null == string ? "" : "" + string, testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string
                }
            };
        _.escape = createEscaper(escapeMap), _.unescape = createEscaper(unescapeMap), _.result = function(object, property) {
            if (null != object) {
                var value = object[property];
                return _.isFunction(value) ? object[property]() : value
            }
        };
        var idCounter = 0;
        _.uniqueId = function(prefix) {
            var id = ++idCounter + "";
            return prefix ? prefix + id : id
        }, _.templateSettings = {
            evaluate: /<%([\s\S]+?)%>/g,
            interpolate: /<%=([\s\S]+?)%>/g,
            escape: /<%-([\s\S]+?)%>/g
        };
        var noMatch = /(.)^/,
            escapes = {
                "'": "'",
                "\\": "\\",
                "\r": "r",
                "\n": "n",
                "\u2028": "u2028",
                "\u2029": "u2029"
            },
            escaper = /\\|'|\r|\n|\u2028|\u2029/g,
            escapeChar = function(match) {
                return "\\" + escapes[match]
            };
        _.template = function(text, settings, oldSettings) {
            !settings && oldSettings && (settings = oldSettings), settings = _.defaults({}, settings, _.templateSettings);
            var matcher = RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join("|") + "|$", "g"),
                index = 0,
                source = "__p+='";
            text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
                return source += text.slice(index, offset).replace(escaper, escapeChar), index = offset + match.length, escape ? source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'" : interpolate ? source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'" : evaluate && (source += "';\n" + evaluate + "\n__p+='"), match
            }), source += "';\n", settings.variable || (source = "with(obj||{}){\n" + source + "}\n"), source = "var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n" + source + "return __p;\n";
            try {
                var render = new Function(settings.variable || "obj", "_", source)
            } catch (e) {
                throw e.source = source, e
            }
            var template = function(data) {
                    return render.call(this, data, _)
                },
                argument = settings.variable || "obj";
            return template.source = "function(" + argument + "){\n" + source + "}", template
        }, _.chain = function(obj) {
            var instance = _(obj);
            return instance._chain = !0, instance
        };
        var result = function(obj) {
            return this._chain ? _(obj).chain() : obj
        };
        _.mixin = function(obj) {
            _.each(_.functions(obj), function(name) {
                var func = _[name] = obj[name];
                _.prototype[name] = function() {
                    var args = [this._wrapped];
                    return push.apply(args, arguments), result.call(this, func.apply(_, args))
                }
            })
        }, _.mixin(_), _.each(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function(name) {
            var method = ArrayProto[name];
            _.prototype[name] = function() {
                var obj = this._wrapped;
                return method.apply(obj, arguments), "shift" !== name && "splice" !== name || 0 !== obj.length || delete obj[0], result.call(this, obj)
            }
        }), _.each(["concat", "join", "slice"], function(name) {
            var method = ArrayProto[name];
            _.prototype[name] = function() {
                return result.call(this, method.apply(this._wrapped, arguments))
            }
        }), _.prototype.value = function() {
            return this._wrapped
        }, "function" == typeof define && define.amd && define("underscore", [], function() {
            return _
        })
    }.call(this),
    function() {
        var define, _requireModule, require, requirejs;
        ! function() {
            var registry = {},
                seen = {};
            define = function(name, deps, callback) {
                registry[name] = {
                    deps: deps,
                    callback: callback
                }
            }, requirejs = require = _requireModule = function(name) {
                function resolve(child) {
                    if ("." !== child.charAt(0)) return child;
                    for (var parts = child.split("/"), parentBase = name.split("/").slice(0, -1), i = 0, l = parts.length; i < l; i++) {
                        var part = parts[i];
                        if (".." === part) parentBase.pop();
                        else {
                            if ("." === part) continue;
                            parentBase.push(part)
                        }
                    }
                    return parentBase.join("/")
                }
                if (requirejs._eak_seen = registry, seen[name]) return seen[name];
                if (seen[name] = {}, !registry[name]) throw new Error("Could not find module " + name);
                for (var exports, mod = registry[name], deps = mod.deps, callback = mod.callback, reified = [], i = 0, l = deps.length; i < l; i++) "exports" === deps[i] ? reified.push(exports = {}) : reified.push(_requireModule(resolve(deps[i])));
                var value = callback.apply(this, reified);
                return seen[name] = exports || value
            }
        }(), define("promise/all", ["./utils", "exports"], function(__dependency1__, __exports__) {
            "use strict";

            function all(promises) {
                var Promise = this;
                if (!isArray(promises)) throw new TypeError("You must pass an array to all.");
                return new Promise(function(resolve, reject) {
                    function resolver(index) {
                        return function(value) {
                            resolveAll(index, value)
                        }
                    }

                    function resolveAll(index, value) {
                        results[index] = value, 0 === --remaining && resolve(results)
                    }
                    var promise, results = [],
                        remaining = promises.length;
                    0 === remaining && resolve([]);
                    for (var i = 0; i < promises.length; i++) promise = promises[i], promise && isFunction(promise.then) ? promise.then(resolver(i), reject) : resolveAll(i, promise)
                })
            }
            var isArray = __dependency1__.isArray,
                isFunction = __dependency1__.isFunction;
            __exports__.all = all
        }), define("promise/asap", ["exports"], function(__exports__) {
            "use strict";

            function useNextTick() {
                return function() {
                    process.nextTick(flush)
                }
            }

            function useMutationObserver() {
                var iterations = 0,
                    observer = new BrowserMutationObserver(flush),
                    node = document.createTextNode("");
                return observer.observe(node, {
                        characterData: !0
                    }),
                    function() {
                        node.data = iterations = ++iterations % 2
                    }
            }

            function useSetTimeout() {
                return function() {
                    local.setTimeout(flush, 1)
                }
            }

            function flush() {
                for (var i = 0; i < queue.length; i++) {
                    var tuple = queue[i],
                        callback = tuple[0],
                        arg = tuple[1];
                    callback(arg)
                }
                queue = []
            }

            function asap(callback, arg) {
                var length = queue.push([callback, arg]);
                1 === length && scheduleFlush()
            }
            var scheduleFlush, browserGlobal = "undefined" != typeof window ? window : {},
                BrowserMutationObserver = browserGlobal.MutationObserver || browserGlobal.WebKitMutationObserver,
                local = "undefined" != typeof global ? global : void 0 === this ? window : this,
                queue = [];
            scheduleFlush = "undefined" != typeof process && "[object process]" === {}.toString.call(process) ? useNextTick() : BrowserMutationObserver ? useMutationObserver() : useSetTimeout(), __exports__.asap = asap
        }), define("promise/config", ["exports"], function(__exports__) {
            "use strict";

            function configure(name, value) {
                return 2 !== arguments.length ? config[name] : void(config[name] = value)
            }
            var config = {
                instrument: !1
            };
            __exports__.config = config, __exports__.configure = configure
        }), define("promise/polyfill", ["./promise", "./utils", "exports"], function(__dependency1__, __dependency2__, __exports__) {
            "use strict";

            function polyfill() {
                var local;
                local = "undefined" != typeof global ? global : "undefined" != typeof window && window.document ? window : self;
                var es6PromiseSupport = "Promise" in local && "resolve" in local.Promise && "reject" in local.Promise && "all" in local.Promise && "race" in local.Promise && function() {
                    var resolve;
                    return new local.Promise(function(r) {
                        resolve = r
                    }), isFunction(resolve)
                }();
                es6PromiseSupport || (local.Promise = RSVPPromise)
            }
            var RSVPPromise = __dependency1__.Promise,
                isFunction = __dependency2__.isFunction;
            __exports__.polyfill = polyfill
        }), define("promise/promise", ["./config", "./utils", "./all", "./race", "./resolve", "./reject", "./asap", "exports"], function(__dependency1__, __dependency2__, __dependency3__, __dependency4__, __dependency5__, __dependency6__, __dependency7__, __exports__) {
            "use strict";

            function Promise(resolver) {
                if (!isFunction(resolver)) throw new TypeError("You must pass a resolver function as the first argument to the promise constructor");
                if (!(this instanceof Promise)) throw new TypeError("Failed to construct 'Promise': Please use the 'new' operator, this object constructor cannot be called as a function.");
                this._subscribers = [], invokeResolver(resolver, this)
            }

            function invokeResolver(resolver, promise) {
                function resolvePromise(value) {
                    resolve(promise, value)
                }

                function rejectPromise(reason) {
                    reject(promise, reason)
                }
                try {
                    resolver(resolvePromise, rejectPromise)
                } catch (e) {
                    rejectPromise(e)
                }
            }

            function invokeCallback(settled, promise, callback, detail) {
                var value, error, succeeded, failed, hasCallback = isFunction(callback);
                if (hasCallback) try {
                    value = callback(detail), succeeded = !0
                } catch (e) {
                    failed = !0, error = e
                } else value = detail, succeeded = !0;
                handleThenable(promise, value) || (hasCallback && succeeded ? resolve(promise, value) : failed ? reject(promise, error) : settled === FULFILLED ? resolve(promise, value) : settled === REJECTED && reject(promise, value))
            }

            function subscribe(parent, child, onFulfillment, onRejection) {
                var subscribers = parent._subscribers,
                    length = subscribers.length;
                subscribers[length] = child, subscribers[length + FULFILLED] = onFulfillment, subscribers[length + REJECTED] = onRejection
            }

            function publish(promise, settled) {
                for (var child, callback, subscribers = promise._subscribers, detail = promise._detail, i = 0; i < subscribers.length; i += 3) child = subscribers[i], callback = subscribers[i + settled], invokeCallback(settled, child, callback, detail);
                promise._subscribers = null
            }

            function handleThenable(promise, value) {
                var resolved, then = null;
                try {
                    if (promise === value) throw new TypeError("A promises callback cannot return that same promise.");
                    if (objectOrFunction(value) && (then = value.then, isFunction(then))) return then.call(value, function(val) {
                        return !!resolved || (resolved = !0, void(value !== val ? resolve(promise, val) : fulfill(promise, val)))
                    }, function(val) {
                        return !!resolved || (resolved = !0, void reject(promise, val))
                    }), !0
                } catch (error) {
                    return !!resolved || (reject(promise, error), !0)
                }
                return !1
            }

            function resolve(promise, value) {
                promise === value ? fulfill(promise, value) : handleThenable(promise, value) || fulfill(promise, value)
            }

            function fulfill(promise, value) {
                promise._state === PENDING && (promise._state = SEALED, promise._detail = value, config.async(publishFulfillment, promise))
            }

            function reject(promise, reason) {
                promise._state === PENDING && (promise._state = SEALED, promise._detail = reason, config.async(publishRejection, promise))
            }

            function publishFulfillment(promise) {
                publish(promise, promise._state = FULFILLED)
            }

            function publishRejection(promise) {
                publish(promise, promise._state = REJECTED)
            }
            var config = __dependency1__.config,
                objectOrFunction = (__dependency1__.configure, __dependency2__.objectOrFunction),
                isFunction = __dependency2__.isFunction,
                all = (__dependency2__.now, __dependency3__.all),
                race = __dependency4__.race,
                staticResolve = __dependency5__.resolve,
                staticReject = __dependency6__.reject,
                asap = __dependency7__.asap;
            config.async = asap;
            var PENDING = void 0,
                SEALED = 0,
                FULFILLED = 1,
                REJECTED = 2;
            Promise.prototype = {
                constructor: Promise,
                _state: void 0,
                _detail: void 0,
                _subscribers: void 0,
                then: function(onFulfillment, onRejection) {
                    var promise = this,
                        thenPromise = new this.constructor(function() {});
                    if (this._state) {
                        var callbacks = arguments;
                        config.async(function() {
                            invokeCallback(promise._state, thenPromise, callbacks[promise._state - 1], promise._detail)
                        })
                    } else subscribe(this, thenPromise, onFulfillment, onRejection);
                    return thenPromise
                },
                catch: function(onRejection) {
                    return this.then(null, onRejection)
                }
            }, Promise.all = all, Promise.race = race, Promise.resolve = staticResolve, Promise.reject = staticReject, __exports__.Promise = Promise
        }), define("promise/race", ["./utils", "exports"], function(__dependency1__, __exports__) {
            "use strict";

            function race(promises) {
                var Promise = this;
                if (!isArray(promises)) throw new TypeError("You must pass an array to race.");
                return new Promise(function(resolve, reject) {
                    for (var promise, i = 0; i < promises.length; i++) promise = promises[i], promise && "function" == typeof promise.then ? promise.then(resolve, reject) : resolve(promise)
                })
            }
            var isArray = __dependency1__.isArray;
            __exports__.race = race
        }), define("promise/reject", ["exports"], function(__exports__) {
            "use strict";

            function reject(reason) {
                var Promise = this;
                return new Promise(function(resolve, reject) {
                    reject(reason)
                })
            }
            __exports__.reject = reject
        }), define("promise/resolve", ["exports"], function(__exports__) {
            "use strict";

            function resolve(value) {
                if (value && "object" === _typeof2(value) && value.constructor === this) return value;
                var Promise = this;
                return new Promise(function(resolve) {
                    resolve(value)
                })
            }
            __exports__.resolve = resolve
        }), define("promise/utils", ["exports"], function(__exports__) {
            "use strict";

            function objectOrFunction(x) {
                return isFunction(x) || "object" === _typeof2(x) && null !== x
            }

            function isFunction(x) {
                return "function" == typeof x
            }

            function isArray(x) {
                return "[object Array]" === Object.prototype.toString.call(x)
            }
            var now = Date.now || function() {
                return (new Date).getTime()
            };
            __exports__.objectOrFunction = objectOrFunction, __exports__.isFunction = isFunction, __exports__.isArray = isArray, __exports__.now = now
        }), _requireModule("promise/polyfill").polyfill()
    }(),
    function(global) {
        "use strict";

        function crossBrowser_initKeyboardEvent(type, dict) {
            var e;
            e = _initKeyboardEvent_type ? document.createEvent("KeyboardEvent") : document.createEvent("Event");
            var _prop_name, localDict = {};
            for (_prop_name in _keyboardEvent_properties_dictionary) own(_keyboardEvent_properties_dictionary, _prop_name) && (localDict[_prop_name] = (own(dict, _prop_name) && dict || _keyboardEvent_properties_dictionary)[_prop_name]);
            var _ctrlKey = localDict.ctrlKey,
                _shiftKey = localDict.shiftKey,
                _altKey = localDict.altKey,
                _metaKey = localDict.metaKey,
                _altGraphKey = localDict.altGraphKey,
                _modifiersListArg = _initKeyboardEvent_type > 3 ? ((_ctrlKey ? "Control" : "") + (_shiftKey ? " Shift" : "") + (_altKey ? " Alt" : "") + (_metaKey ? " Meta" : "") + (_altGraphKey ? " AltGraph" : "")).trim() : null,
                _key = localDict.key + "",
                _char = localDict.char + "",
                _location = localDict.location,
                _keyCode = localDict.keyCode || (localDict.keyCode = _key && _key.charCodeAt(0) || 0),
                _charCode = localDict.charCode || (localDict.charCode = _char && _char.charCodeAt(0) || 0),
                _bubbles = localDict.bubbles,
                _cancelable = localDict.cancelable,
                _repeat = localDict.repeat,
                _locale = localDict.locale,
                _view = global;
            localDict.which || (localDict.which = localDict.keyCode), "initKeyEvent" in e ? e.initKeyEvent(type, _bubbles, _cancelable, _view, _ctrlKey, _altKey, _shiftKey, _metaKey, _keyCode, _charCode) : _initKeyboardEvent_type && "initKeyboardEvent" in e ? 1 === _initKeyboardEvent_type ? e.initKeyboardEvent(type, _bubbles, _cancelable, _view, _key, _location, _ctrlKey, _shiftKey, _altKey, _metaKey, _altGraphKey) : 2 === _initKeyboardEvent_type ? e.initKeyboardEvent(type, _bubbles, _cancelable, _view, _ctrlKey, _altKey, _shiftKey, _metaKey, _keyCode, _charCode) : 3 === _initKeyboardEvent_type ? e.initKeyboardEvent(type, _bubbles, _cancelable, _view, _key, _location, _ctrlKey, _altKey, _shiftKey, _metaKey, _altGraphKey) : 4 === _initKeyboardEvent_type ? e.initKeyboardEvent(type, _bubbles, _cancelable, _view, _key, _location, _modifiersListArg, _repeat, _locale) : e.initKeyboardEvent(type, _bubbles, _cancelable, _view, _char, _key, _location, _modifiersListArg, _repeat, _locale) : e.initEvent(type, _bubbles, _cancelable);
            for (_prop_name in _keyboardEvent_properties_dictionary)
                if (own(_keyboardEvent_properties_dictionary, _prop_name) && e[_prop_name] !== localDict[_prop_name]) try {
                    delete e[_prop_name], _Object_defineProperty(e, _prop_name, {
                        writable: !0,
                        value: localDict[_prop_name]
                    })
                } catch (e) {}
            return e
        }
        var _initKeyboardEvent_type = function(e) {
                try {
                    return e.initKeyboardEvent("keyup", !1, !1, global, "+", 3, !0, !1, !0, !1, !1), "+" === (e.keyIdentifier || e.key) && 3 === (e.keyLocation || e.location) && (e.ctrlKey ? e.altKey ? 1 : 3 : e.shiftKey ? 2 : 4) || 9
                } catch (__e__) {
                    _initKeyboardEvent_type = 0
                }
            }(document.createEvent("KeyboardEvent")),
            _keyboardEvent_properties_dictionary = {
                char: "",
                key: "",
                location: 0,
                ctrlKey: !1,
                shiftKey: !1,
                altKey: !1,
                metaKey: !1,
                repeat: !1,
                locale: "",
                detail: 0,
                bubbles: !1,
                cancelable: !1,
                keyCode: 0,
                charCode: 0,
                which: 0
            },
            own = Function.prototype.call.bind(Object.prototype.hasOwnProperty),
            _Object_defineProperty = Object.defineProperty || function(obj, prop, val) {
                "value" in val && (obj[prop] = val.value)
            };
        global.crossBrowser_initKeyboardEvent = crossBrowser_initKeyboardEvent
    }(window),
    function(global) {
        "use strict";
        global.LIVE_SHARE = {}
    }(window),
    function(nsp) {
        "use strict";
        var enums = function() {
            return {
                SESSION_TYPES: {
                    TESTING: "test",
                    SHARING: "share"
                },
                SESSION_STATUS: {
                    ACTIVE: "active",
                    OVER: "sessionIsOver",
                    RESERVATION: "reservation",
                    QUIT: "quit",
                    BANNED: "banned",
                    AUTHORIZATION_FAILED: "authorizationFailed",
                    ROOM_IS_FULL: "roomIsFull",
                    NOT_FOUND: "notFound",
                    UNKNOWN: "unknowError"
                },
                USER_TYPES: {
                    HOST: "host",
                    VIEWER: "viewer",
                    TESTER: "tester"
                },
                EVENTS: {
                    ERROR: "error",
                    CONNECT_ERROR: "connect_error",
                    CONNECT: "connect",
                    DISCONNECT: "disconnect",
                    START: "start",
                    FINISH: "finish",
                    CREATE: "create",
                    CREATED: "created",
                    JOIN: "join",
                    JOINED: "joined",
                    COLLABORATOR_JOIN: "collaboratorJoin",
                    COLLABORATOR_LEFT: "collaboratorLeft",
                    COLLABORATION_END: "collaborationEnd",
                    UPDATE_COLLABORATORS_SETTINGS: "updateCollaboratorsSettings",
                    REMOVE_COLLABORATOR: "removeCollaborator",
                    SET_ROOM_OPTION: "setRoomOption",
                    OPTIONS_CHANGED: "optionChanged",
                    FOLLOW_CURSOR: "followCursor",
                    FOLLOW_CURSOR_ON: "followCursorOn",
                    FOLLOW_CURSOR_OFF: "followCursorOff",
                    CURSOR_MOVE: "cursorMove",
                    SHOW_CLICK: "showClick",
                    DOM: "DOMEvent",
                    MUTE: "mute",
                    PAGE_CHANGE: "pageChange",
                    PAGE_CHANGED: "pageChanged",
                    UPDATE_TASKS: "updateTasks",
                    RESOLVE_TASK: "resolveTask",
                    TESTER_JOINED: "testerJoinedToSession",
                    ALLOW_START: "allowStart",
                    VIDEO_PARTICIPANT_JOINED: "videoParticipantJoined",
                    VIDEO_PARTICIPANT_LEFT: "videoParticipantLeft",
                    MEDIA_ACCESS: "mediaAccess"
                },
                MEDIA_ACCESS_TYPE: {
                    REQUEST: "request",
                    ALLOWED: "allowed",
                    DENIED: "denied"
                },
                ROOM_SETTINGS: {
                    SHOW_CURSOR: "showCursor",
                    TRIGGER_EVENTS: "triggerEvents",
                    ALLWAYS_FOLLOW_HOST: "allwaysFollowHost",
                    DISABLE_VOICE: "disableVoice",
                    CAN_CLOSE_TASKS: "canCloseTasks",
                    SEE_SITEMAP: "seeSitemap"
                },
                LOG_MESSAGES: {
                    CONNECT: "Connecting to socket namespace",
                    ESTABLISH: "Socket connection established",
                    START: "Creating session",
                    JOIN: "Joining session",
                    INITIALIZING: "Initializing modules",
                    INITIALIZED: "Session initialized",
                    OVER: "Session is over"
                }
            }
        }();
        nsp.enums = enums
    }(window.LIVE_SHARE),
    function(liveShare) {
        "use strict";
        var Logger = function(name, prefix) {
                this.name = name, this.separator = prefix
            },
            proto = Logger.prototype;
        proto.getCurrentTime = function() {
            var date = new Date;
            return [date.getHours(), date.getMinutes(), date.getSeconds()].join(":")
        }, proto.getPrefix = function(params) {
            return params = _.extend({
                withDate: !0
            }, params || {}), params.withDate ? [this.name, this.getCurrentTime()].join(this.separator) : this.name
        }, proto.log = function(message) {
            window.console.log([this.getPrefix(), message].join(this.separator))
        }, proto.error = function(message) {
            window.console.error([this.getPrefix(), message].join(this.separator))
        }, proto.warn = function(message) {
            window.console.warn([this.getPrefix(), message].join(this.separator))
        }, proto.count = function(message) {
            window.console.count([this.getPrefix({
                withDate: !1
            }), message].join(this.separator))
        };
        var attachLogger = function(namespace, name, prefix) {
            var logger = new Logger(name, prefix);
            namespace.log = logger.log.bind(logger), namespace.error = logger.error.bind(logger), namespace.count = logger.count.bind(logger), namespace.warn = logger.warn.bind(logger)
        };
        attachLogger(liveShare, "LiveShare", " | ")
    }(window.LIVE_SHARE),
    function(namespace) {
        "use strict";
        var DOMHelper = {
            getSelector: function(el) {
                var path = [];
                do path.unshift(el.nodeName.toLowerCase() + (el.className ? ".".concat(el.className.replace(" ", ".")) : "")); while ("html" != el.nodeName.toLowerCase() && (el = el.parentNode));
                return path.join(" > ")
            },
            getElement: function(selector) {
                if ("window" === selector) return window;
                if (selector.tagName) return selector;
                if ("string" == typeof selector) {
                    var el = document.querySelector(selector);
                    if (el) return el
                }
                return null
            },
            getEventCategory: function(type) {
                return null
            },
            getBaseEventData: function() {
                return {
                    time: +new Date
                }
            },
            serializeEvent: function(e) {
                var serializedEvent;
                return serializedEvent = e instanceof MouseEvent ? this.serializeMouseEvent(e) : e instanceof KeyboardEvent ? this.serializeKeyboardEvent(e) : e instanceof HashChangeEvent ? this.serializeHashChangeEvent(e) : {
                    type: e.type
                }, serializedEvent.time = +new Date, serializedEvent
            },
            serializeMouseEvent: function(e) {
                return {
                    eventCategory: "MouseEvent",
                    type: e.type,
                    clientX: e.clientX,
                    clientY: e.clientY,
                    screenX: e.screenX,
                    screenY: e.screenY
                }
            },
            serializeKeyboardEvent: function(e) {
                return {
                    eventCategory: "KeyboardEvent",
                    type: e.type,
                    keyCode: e.keyCode,
                    location: e.location
                }
            },
            serializeHashChangeEvent: function(e) {
                return {
                    eventCategory: "HashChangeEvent",
                    newURL: e.newURL,
                    oldURL: e.oldURL
                }
            },
            deserializeEvent: function(serializedEvent) {
                var eventCategory = serializedEvent.eventCategory || this.getEventCategory(serializedEvent.type);
                if ("MouseEvent" === eventCategory) return this.deserializeMouseEvent(serializedEvent);
                if ("KeyboardEvent" === eventCategory) return this.deserializeKeyboardEvent(serializedEvent);
                if ("HashChangeEvent" === eventCategory) return this.deserializeHashChangeEvent(serializedEvent);
                throw new Error("Unknown event type")
            },
            deserializeMouseEvent: function(serializedEvent) {
                var e;
                return "function" == typeof document.createEvent && (e = document.createEvent("MouseEvent"), e.initMouseEvent(serializedEvent.type, !0, "mousemove" !== serializedEvent.type, window, 0, serializedEvent.screenX, serializedEvent.screenY, serializedEvent.clientX, serializedEvent.clientY, !1, !1, !1, !1, 0, document.body.parentNode)), e
            },
            deserializeKeyboardEvent: function(serializedEvent) {
                var e = window.crossBrowser_initKeyboardEvent(serializedEvent.type, serializedEvent);
                return e
            },
            deserializeHashChangeEvent: function(serializedEvent) {
                var e = new HashChangeEvent("hashchange", {
                    newURL: serializedEvent.newURL,
                    oldURL: serializedEvent.oldURL
                });
                return e
            }
        };
        namespace.DOMHelper = DOMHelper
    }(window.LIVE_SHARE),
    function(nsp) {
        "use strict";
        var SILENT_EVENTS_MAP = {},
            DOMEventDispatcher = function(selector) {
                if ("undefined" == typeof selector) return this;
                if (this.el = this.getElement(selector), !this.el) throw new Error("There is no element ".concat(selector, "  to dispatch event"));
                this.el.customListeners || (this.el.customListeners = {})
            };
        DOMEventDispatcher.prototype = _.extend(DOMEventDispatcher.prototype, nsp.DOMHelper), DOMEventDispatcher.prototype.handleEvent = function(e, additionalData) {
            if (eventDispatcher.socket && !this.isSilentOnce(e.type)) {
                var serializedEvent = this.serializeEvent(e);
                serializedEvent = _.extend(serializedEvent, additionalData || {}), serializedEvent.selector || (serializedEvent.selector = this.getSelector(e.target)), serializedEvent.time = +new Date, eventDispatcher.socket.emit(nsp.enums.EVENTS.DOM, serializedEvent)
            }
        }, DOMEventDispatcher.prototype.setSilentOnce = function(eventType) {
            SILENT_EVENTS_MAP[eventType] = !0
        }, DOMEventDispatcher.prototype.isSilentOnce = function(eventType) {
            var value = SILENT_EVENTS_MAP[eventType];
            return SILENT_EVENTS_MAP[eventType] = !1, value
        }, DOMEventDispatcher.prototype.on = function(type, listener, useCapture) {
            this.el.customListeners[listener] = this.callListener.bind(this, listener), this.el.addEventListener(type, this.el.customListeners[listener], useCapture)
        }, DOMEventDispatcher.prototype.off = function(type, listener) {
            this.el.removeEventListener(type, this.el.customListeners[listener]), this.el.customListeners[listener] = null
        }, DOMEventDispatcher.prototype.callListener = function(listener, e) {
            this.handleEvent(e), listener(e)
        }, DOMEventDispatcher.prototype.emit = function(serializedEvent) {
            switch (this.setSilentOnce(serializedEvent.type), serializedEvent.type) {
                case "focusin":
                    this.el.focus();
                    break;
                case "focusout":
                    this.el.blur();
                    break;
                case "input":
                    this.el.value = serializedEvent.value;
                    break;
                case "change":
                    this.el.checked = serializedEvent.checked;
                    break;
                case "hashchange":
                    this.el.location.replace(serializedEvent.newURL);
                    break;
                default:
                    var event = this.deserializeEvent(serializedEvent);
                    event && (this.el.dispatchEvent ? this.el.dispatchEvent(event) : this.el.fireEvent && this.el.fireEvent("on".concat(serializedEvent.type), event))
            }
        };
        var eventDispatcher = function(el) {
            return new DOMEventDispatcher(el)
        };
        eventDispatcher.handleEvent = function(e, eventsData) {
            DOMEventDispatcher.prototype.handleEvent.apply(eventDispatcher(), arguments)
        }, nsp.eventDispatcher = eventDispatcher
    }(window.LIVE_SHARE),
    function(nsp) {
        "use strict";
        var EventsQueue = (nsp.enums.EVENTS, function(queue) {
                this.queue = queue || [], this.length = this.queue.length
            }),
            proto = EventsQueue.prototype;
        proto = _.extend(proto, EventEmitter.prototype), proto.push = function(data) {
            "HashChangeEvent" === data.eventCategory && (this.queue.length = 0), this.queue.unshift(data), this.length = this.queue.length
        }, proto.pop = function() {
            var data = this.queue.pop();
            return this.length = this.queue.length, data
        }, proto.executeQueue = function() {
            var _this3 = this;
            return new Promise(function(resolve, reject) {
                _this3._fireLastEvent(resolve, reject)
            })
        }, proto._fireLastEvent = function(resolve, reject) {
            var _this4 = this;
            if (!this.length) return resolve();
            var eventData = this.pop();
            this._emitEvent(eventData).then(function() {
                _this4._fireLastEvent(resolve, reject)
            })
        }, proto._emitEvent = function(eventData) {
            return new Promise(function(resolve, reject) {
                if ("HashChangeEvent" === eventData.eventCategory) {
                    if (document.URL.indexOf(eventData.newURL) > -1) return resolve();
                    try {
                        nsp.eventDispatcher(eventData.selector).emit(eventData)
                    } catch (e) {
                        console.error(e)
                    }
                } else {
                    try {
                        nsp.eventDispatcher(eventData.selector).emit(eventData)
                    } catch (e) {
                        console.error(e)
                    }
                    setTimeout(function() {
                        resolve()
                    }, 1)
                }
            })
        }, nsp.EventsQueue = EventsQueue
    }(window.LIVE_SHARE),
    function(namespace) {
        "use strict";
        var FormEvents = {
            wrapperSelector: null,
            eventsRefs: {},
            handleFormEvents: function() {
                var wrapper = document.querySelector(this.wrapperSelector);
                this.eventsRefs.dispatchFormEvent = this.dispatchFormEvent.bind(this), wrapper.addEventListener("focusin", this.eventsRefs.dispatchFormEvent), wrapper.addEventListener("focusout", this.eventsRefs.dispatchFormEvent), this.eventsRefs.change = this.change.bind(this), wrapper.addEventListener("change", this.eventsRefs.change), this.eventsRefs.input = this.input.bind(this), wrapper.addEventListener("input", this.eventsRefs.input)
            },
            unhandleFormEvents: function() {
                var wrapper = document.querySelector(this.wrapperSelector);
                wrapper.removeEventListener("focusin", this.eventsRefs.dispatchFormEvent), wrapper.removeEventListener("focusout", this.eventsRefs.dispatchFormEvent), wrapper.removeEventListener("change", this.eventsRefs.change), wrapper.removeEventListener("input", this.eventsRefs.input)
            },
            dispatchFormEvent: function(e, additionalData) {
                try {
                    namespace.eventDispatcher.handleEvent(e, _.extend({
                        selector: this.getElementUniqueSelector(e.target),
                        time: +new Date
                    }, additionalData || {}))
                } catch (e) {
                    console.error(e)
                }
            },
            getElementUniqueSelector: function(el) {
                var path = [];
                do {
                    if (el.id) {
                        path.unshift("#".concat(el.id));
                        break
                    }
                    path.unshift(el.nodeName.toLowerCase() + (el.className ? ".".concat(el.className.replace(" ", ".")) : ""))
                } while ("html" !== el.nodeName.toLowerCase() && (el = el.parentNode));
                return path.join(">")
            },
            input: function(e) {
                this.dispatchFormEvent(e, {
                    value: e.target.value
                })
            },
            change: function(e) {
                this.dispatchFormEvent(e, {
                    checked: e.target.checked
                })
            }
        };
        namespace.FormEvents = FormEvents
    }(LIVE_SHARE),
    function(nsp) {
        "use strict";
        var EVENTS = nsp.enums.EVENTS,
            FollowCursorInterface = {
                silentScroll: !1,
                currentFollowing: null,
                onScrolleventRef: null,
                onScroll: function() {
                    this.silentScroll || this.followCursorOff(this.currentFollowing), this.silentScroll = !1
                },
                followCursorOn: function(id) {
                    this.currentFollowing = id, this.onScrolleventRef = this.onScroll.bind(this), this.options.scrolledElement.addEventListener("scroll", this.onScrolleventRef), this.emit(EVENTS.FOLLOW_CURSOR_ON, id)
                },
                followCursorOff: function(id) {
                    this.me.settings.toggleFollow && (this.currentFollowing = null, this.options.scrolledElement.removeEventListener("scroll", this.onScrolleventRef), this.collaboratorsCollection.get(id).stopFollowingMe(), this.emit(EVENTS.FOLLOW_CURSOR_OFF, id))
                },
                followCursor: function(data) {
                    if (this.currentFollowing) {
                        var relativeElementBounds = this.options.relativeElement.getBoundingClientRect(),
                            SPACING = 100,
                            top = Math.abs(relativeElementBounds.top),
                            left = Math.abs(relativeElementBounds.left),
                            bottom = top + window.innerHeight - 35,
                            right = left + window.innerWidth,
                            newTop = top,
                            newLeft = left;
                        data.y + SPACING > bottom ? newTop = top + (data.y + SPACING - bottom) : data.y - SPACING < top && (newTop = top - (top + SPACING - data.y)), data.x + SPACING > right ? newLeft = left + (data.x + SPACING - right) : data.x < left + SPACING && (newLeft = left - (left + SPACING - data.x)), newLeft === left && newTop === top || (this.silentScroll = !0, this.options.scrolledElement.scrollLeft = newLeft, this.silentScroll = !0, this.options.scrolledElement.scrollTop = newTop)
                    }
                },
                destroyFollowCursor: function() {
                    this.options.scrolledElement.removeEventListener("scroll", this.onScrolleventRef)
                }
            };
        nsp.FollowCursorInterface = FollowCursorInterface
    }(window.LIVE_SHARE),
    function(nsp) {
        "use strict";
        var UserGeneric = function(data, socket) {
            this.el = null, this.id = data.id, this.name = data.name, this.color = data.color, this.type = data.type, this.settings = data.settings, this.customData = data.customData, this.videoChat = data.videoChat, this.scrolledElement = data.scrolledElement, this.relativeElement = data.relativeElement, this.canvasElement = data.canvasElement, this.me
        };
        UserGeneric.prototype = _.extend(UserGeneric.prototype, EventEmitter.prototype), UserGeneric.prototype.toJSON = function() {
            return {
                id: this.id,
                name: this.name,
                me: this.me,
                color: this.color,
                type: this.type,
                isFollowed: !!this.isFollowed,
                leadCursor: !!this.settings.leadCursor,
                settings: this.settings,
                muted: this.settings.muted,
                customData: this.customData
            }
        }, UserGeneric.prototype.isHost = function() {
            return nsp.enums.USER_TYPES.HOST === this.type
        }, UserGeneric.prototype.renderAvatar = function() {
            this.el = document.createElement("li");
            var wrapper = document.createElement("a");
            wrapper.className = "user avatar", wrapper.href = "#";
            var avatar = document.createElement("strong");
            avatar.textContent = "KZ", wrapper.appendChild(avatar);
            var tooltip = document.createElement("span");
            tooltip.className = "tiny-tooltip", tooltip.textContent = "Click to chat", wrapper.appendChild(tooltip);
            var color = document.createElement("span");
            color.className = "user-color", color.style.background = this.color, wrapper.appendChild(color);
            var remove = document.createElement("span");
            return remove.className = "delete-user icon-font-rounded-close-outline only-icon-font", wrapper.appendChild(remove), this.el.appendChild(wrapper), this.el
        }, UserGeneric.prototype.destroy = function() {}, nsp.UserGeneric = UserGeneric
    }(window.LIVE_SHARE),
    function(namespace) {
        "use strict";
        var Cursor = function(relativeElement, color) {
            this.relativeElement = relativeElement, this.el = null, this.color = color
        };
        Cursor.prototype.render = function() {
            return this.el = document.createElement("div"), this.el.style.background = this.color, this.el.classList.add("collaborator-cursor"), this.el
        }, Cursor.prototype.destroy = function() {
            this.el.parentNode.removeChild(this.el)
        }, Cursor.prototype.move = function(data) {
            this.el.style.top = "".concat(data.y, "px"), this.el.style.left = "".concat(data.x, "px")
        }, Cursor.prototype.showClick = function(data) {
            var el = this.createClickGhost(data);
            this.relativeElement.appendChild(el), setTimeout(function() {
                el.classList.add("show"), setTimeout(function() {
                    el.parentNode.removeChild(el), el = null
                }, 800)
            }, 20)
        }, Cursor.prototype.createClickGhost = function(data) {
            var el = document.createElement("div");
            return el.classList.add("click-ghost"), el.style.top = "".concat(data.y, "px"), el.style.left = "".concat(data.x, "px"), el.style.borderColor = this.color, el
        }, namespace.Cursor = Cursor
    }(window.LIVE_SHARE),
    function(nsp) {
        "use strict";
        var EVENTS = nsp.enums.EVENTS,
            ROOM_SETTINGS = nsp.enums.ROOM_SETTINGS,
            Collaborator = function(data, socket) {
                nsp.UserGeneric.apply(this, arguments), this.cursor = null, this.isFollowed = !1, this.followButtonEl = !1, this.me = !1
            };
        Collaborator.prototype = Object.create(nsp.UserGeneric.prototype), Collaborator.prototype.constructor = Collaborator, Collaborator.prototype.render = function() {
            this.settings.showCursor && this.renderCursor(), this.settings.leadCursor && this.followMe()
        }, Collaborator.prototype.renderAvatar = function() {
            var el = nsp.UserGeneric.prototype.renderAvatar.apply(this, arguments);
            return this.settings.leadCursor && (this.followButtonEl = document.createElement("button"), this.followButtonEl.textContent = "Follow", this.followButtonEl.className = "follow", this.followButtonEl.addEventListener("click", this.followButtonClicked.bind(this)), this.isFollowed && this.markAsFollowed(), el.appendChild(this.followButtonEl)), el
        }, Collaborator.prototype.markAsFollowed = function() {
            this.followButtonEl && (this.followButtonEl.disabled = !0)
        }, Collaborator.prototype.unmarkAsFollowed = function() {
            this.followButtonEl && (this.followButtonEl.disabled = !1)
        }, Collaborator.prototype.followButtonClicked = function() {
            this.followMe()
        }, Collaborator.prototype.followMe = function() {
            this.isFollowed = !0, this.markAsFollowed(), this.emit(EVENTS.FOLLOW_CURSOR, this.id)
        }, Collaborator.prototype.stopFollowingMe = function() {
            this.isFollowed = !1, this.unmarkAsFollowed()
        }, Collaborator.prototype.toggleCursorVisibility = function(force) {
            this.settings.showCursor || force ? this.renderCursor() : this.destroyCursor()
        }, Collaborator.prototype.renderCursor = function() {
            this.cursor || (this.cursor = new nsp.Cursor(this.relativeElement, this.color), this.relativeElement.appendChild(this.cursor.render()))
        }, Collaborator.prototype.destroyCursor = function() {
            this.cursor && (this.cursor.destroy(), this.cursor = null), this.stopFollowingMe()
        }, Collaborator.prototype.destroy = function() {
            this.destroyCursor(), this.el && this.el.parentNode.removeChild(this.el)
        }, Collaborator.prototype.cursorMove = function(data) {
            this.cursor && this.cursor.move(data.data)
        }, Collaborator.prototype.showClick = function(data) {
            this.cursor && this.cursor.showClick(data.data)
        }, Collaborator.prototype.updateSettings = function(data) {
            var _this5 = this;
            _.each(data, function(optionVal, optionName) {
                _this5.settings[optionName] !== optionVal && (_this5.settings[optionName] = optionVal, optionName === ROOM_SETTINGS.SHOW_CURSOR && _this5.toggleCursorVisibility())
            })
        }, nsp.Collaborator = Collaborator
    }(window.LIVE_SHARE),
    function(nsp) {
        "use strict";
        var EVENTS = nsp.enums.EVENTS,
            CollaboratorsCollection = function(usersData) {
                this.collaborators = [], this.el = null
            };
        CollaboratorsCollection.prototype = _.extend(CollaboratorsCollection.prototype, EventEmitter.prototype), CollaboratorsCollection.prototype.constructor = CollaboratorsCollection, CollaboratorsCollection.prototype.each = function(cb) {
            this.collaborators.forEach(function(collaborator) {
                cb(collaborator)
            })
        }, CollaboratorsCollection.prototype.add = function(data) {
            if (Array.isArray(arguments[0])) return arguments[0].map(function(userData) {
                return this.add(userData)
            }, this);
            if (!this.collaborators[data.id]) {
                var collaborator = new nsp.Collaborator(data);
                return this.collaborators.push(collaborator), collaborator.on(EVENTS.FOLLOW_CURSOR, this.triggerFollow.bind(this)), collaborator.render(), this.emit("add", collaborator), collaborator
            }
            return this.collaborators[data.id]
        }, CollaboratorsCollection.prototype.remove = function(id) {
            this.collaborators = _.reject(this.collaborators, function(collaborator) {
                return collaborator.id === id && (collaborator.destroy(), !0)
            })
        }, CollaboratorsCollection.prototype.get = function(id) {
            return _.find(this.collaborators, {
                id: id
            })
        }, CollaboratorsCollection.prototype.destroy = function() {
            this.each(function(collaborator) {
                collaborator.destroy()
            })
        }, CollaboratorsCollection.prototype.triggerFollow = function(id) {
            this.emit(EVENTS.FOLLOW_CURSOR, id)
        }, CollaboratorsCollection.prototype.updateSettings = function(data) {
            var _this6 = this;
            data.forEach(function(settings) {
                var userId = Object.keys(settings)[0],
                    user = _this6.get(userId);
                user && user.updateSettings(settings[userId])
            })
        }, nsp.CollaboratorsCollection = CollaboratorsCollection
    }(window.LIVE_SHARE),
    function(nsp) {
        "use strict";
        var EMIT_DELAY = 50,
            EVENTS = nsp.enums.EVENTS,
            ROOM_SETTINGS = nsp.enums.ROOM_SETTINGS,
            sequenceNo = 0,
            MyEvents = function(data, socket) {
                nsp.UserGeneric.apply(this, arguments), this.wrapperSelector = ".preview-container", this.eventRefs = {}, this.socket = socket
            };
        MyEvents.prototype = Object.create(nsp.UserGeneric.prototype), MyEvents.prototype = _.extend(MyEvents.prototype, nsp.DOMHelper), MyEvents.prototype = _.extend(MyEvents.prototype, nsp.FormEvents), MyEvents.prototype.constructor = MyEvents, MyEvents.prototype.emit = function(event, data) {
            this.socket.emit(event, {
                data: data,
                sequenceNo: ++sequenceNo
            })
        }, MyEvents.prototype.start = function() {
            var _this7 = this;
            _.each(this.settings, function(val, key) {
                _this7.toggleOption(key, val)
            }), this.eventRefs.beforeUnload = this.beforeUnload.bind(this), window.addEventListener("beforeunload", this.eventRefs.beforeUnload)
        }, MyEvents.prototype.toggleOption = function(key, val) {
            this.settings[key] = val, key === ROOM_SETTINGS.TRIGGER_EVENTS ? this.toggleTriggerEvents() : key === ROOM_SETTINGS.SHOW_CURSOR && this.toggleShowCursor()
        }, MyEvents.prototype.toggleShowCursor = function(isOn) {
            this.settings.showCursor || isOn ? this.showCursorOn() : this.showCursorOff()
        }, MyEvents.prototype.showCursorOn = function() {
            this.eventRefs.cursorPosition = this.emitCursorPosition.bind(this), this.relativeElement.addEventListener("mousemove", this.eventRefs.cursorPosition), this.eventRefs.showClick = this.emitShowClick.bind(this), this.relativeElement.addEventListener("click", this.eventRefs.showClick)
        }, MyEvents.prototype.showCursorOff = function() {
            this.relativeElement.removeEventListener("mousemove", this.eventRefs.cursorPosition), this.relativeElement.removeEventListener("click", this.eventRefs.showClick)
        }, MyEvents.prototype.toggleTriggerEvents = function(isOn) {
            this.settings.triggerEvents || isOn ? this.triggerEventsOn() : this.triggerEventsOff()
        }, MyEvents.prototype.triggerEventsOn = function() {
            this.canvasElement.classList.remove("prevent-all"), this.eventRefs.pageChange = this.emitPageChange.bind(this), window.addEventListener("hashchange", this.eventRefs.pageChange), this.eventRefs.preventKeyEvent && window.removeEventListener("keydown", this.eventRefs.preventKeyEvent)
        }, MyEvents.prototype.triggerEventsOff = function() {
            this.canvasElement.classList.add("prevent-all"), window.removeEventListener("hashchange", this.eventRefs.pageChange), this.eventRefs.preventKeyEvent = this.preventKeyEvent.bind(this), window.addEventListener("keydown", this.eventRefs.preventKeyEvent)
        }, MyEvents.prototype.preventKeyEvent = function(e) {
            e.preventDefault(), e.stopPropagation()
        }, MyEvents.prototype.beforeUnload = function(e) {
            var confirmationMessage = "Are you sure you want to quit live session?";
            return (e || window.event).returnValue = confirmationMessage, confirmationMessage
        }, MyEvents.prototype.emitShowClick = function(e) {
            var relativeElementBounds = this.relativeElement.getBoundingClientRect();
            this.emit(EVENTS.SHOW_CLICK, _.extend({
                x: e.pageX - relativeElementBounds.left,
                y: e.pageY - relativeElementBounds.top
            }, this.getBaseEventData()))
        }, MyEvents.prototype.emitCursorPosition = _.throttle(function(e) {
            var relativeElementBounds = this.relativeElement.getBoundingClientRect();
            this.emit(EVENTS.CURSOR_MOVE, _.extend({
                x: e.pageX - relativeElementBounds.left,
                y: e.pageY - relativeElementBounds.top
            }, this.getBaseEventData()))
        }, EMIT_DELAY), MyEvents.prototype.emitPageChange = function(e) {
            this.emit(EVENTS.PAGE_CHANGE, _.extend({
                newURL: e.newURL
            }, this.getBaseEventData()))
        }, MyEvents.prototype.emitFocusToggle = function(e) {
            this.socket.emit(EVENTS.DOM, this.serializeEvent(e))
        }, MyEvents.prototype.destroy = function() {
            this.canvasElement.classList.remove("prevent-all"), window.removeEventListener("hashchange", this.eventRefs.pageChange), window.removeEventListener("beforeunload", this.eventRefs.beforeUnload), window.removeEventListener("keydown", this.eventRefs.preventKeyEvent), this.showCursorOff()
        }, nsp.MyEvents = MyEvents
    }(window.LIVE_SHARE),
    function(namespace) {
        "use strict";
        var Me = function(data, socket) {
            namespace.MyEvents.apply(this, arguments), this.me = !0
        };
        Me.prototype = Object.create(namespace.MyEvents.prototype), Me.prototype.constructor = namespace.Me, Me.prototype.start = function() {
            namespace.MyEvents.prototype.start.apply(this, arguments)
        }, Me.prototype.destroy = function() {
            namespace.MyEvents.prototype.destroy.apply(this, arguments)
        }, namespace.Me = Me
    }(window.LIVE_SHARE),
    function(namespace) {
        "use strict";
        var CollaboratorsListView = function(user, collaboratorsCollection) {
            this.el = null, this.user = user, this.collaboratorsCollection = collaboratorsCollection
        };
        CollaboratorsListView.prototype.render = function() {
            this.el = document.createElement("ul"), this.el.className = "users-list horizontal";
            var frag = document.createDocumentFragment();
            return frag.appendChild(this.user.renderAvatar()), this.collaboratorsCollection.each(function(model) {
                frag.appendChild(model.renderAvatar())
            }), this.el.appendChild(frag), this.collaboratorsCollection.on("add", this.renderCollaboratorIcon.bind(this)), this.el
        }, CollaboratorsListView.prototype.renderCollaboratorIcon = function(model) {
            this.el && this.el.appendChild(model.renderAvatar())
        }, namespace.CollaboratorsListView = CollaboratorsListView
    }(window.LIVE_SHARE),
    function(namespace) {
        "use strict";
        var EVENTS = namespace.enums.EVENTS,
            VoiceChat = function(url) {};
        VoiceChat.prototype = _.extend(VoiceChat.prototype, EventEmitter.prototype), VoiceChat.prototype.constructor = VoiceChat, VoiceChat.prototype.init = function(roomData, userData) {
            var sessionId = roomData.sessionId,
                apiKey = roomData.apiKey,
                token = userData.token;
            this._createSession(sessionId, apiKey, token), this._initPublisher(apiKey)
        }, VoiceChat.prototype._createSession = function(sessionId, apiKey, token) {
            this.session = OT.initSession(apiKey, sessionId), this.session.on({
                sessionConnected: function() {
                    this.session.publish(this.publisher)
                }.bind(this),
                streamCreated: function(event) {
                    this.session.subscribe(event.stream), this.emit(EVENTS.VIDEO_PARTICIPANT_JOINED)
                }.bind(this),
                streamDestroyed: function() {
                    this.emit(EVENTS.VIDEO_PARTICIPANT_LEFT)
                }.bind(this)
            }), this.session.connect(token)
        }, VoiceChat.prototype._initPublisher = function(apiKey) {
            this.publisher = OT.initPublisher("publisher", {
                publishAudio: !0,
                videoSource: null
            }), this.attachMediaAccessEvents()
        }, VoiceChat.prototype.attachMediaAccessEvents = function(value) {
            var _this8 = this,
                MEDIA_ACCESS_TYPE = LiveShare.enums.MEDIA_ACCESS_TYPE;
            this.publisher.on("accessDialogOpened", function() {
                _this8.emit(EVENTS.MEDIA_ACCESS, MEDIA_ACCESS_TYPE.REQUEST)
            }), this.publisher.on("accessAllowed", function() {
                _this8.emit(EVENTS.MEDIA_ACCESS, MEDIA_ACCESS_TYPE.ALLOWED)
            }), this.publisher.on("accessDenied", function() {
                _this8.emit(EVENTS.MEDIA_ACCESS, MEDIA_ACCESS_TYPE.DENIED);
            })
        }, VoiceChat.prototype.mute = function(value) {
            this.publisher.publishAudio(!value)
        }, VoiceChat.prototype.destroy = function() {
            this.session.disconnect()
        }, namespace.VoiceChat = VoiceChat
    }(window.LIVE_SHARE),
    function(namespace) {
        "use strict";
        var EVENTS = namespace.enums.EVENTS,
            videoWidth = 200,
            videoHeight = 150,
            VideoChat = function(url) {};
        VideoChat.prototype = _.extend(VideoChat.prototype, EventEmitter.prototype), VideoChat.prototype.constructor = VideoChat, VideoChat.prototype.init = function(roomData, userData, publishVideo) {
            var sessionId = roomData.sessionId,
                apiKey = roomData.apiKey,
                token = userData.token;
            this._createSession(sessionId, apiKey, token), this._initPublisher(apiKey, publishVideo)
        }, VideoChat.prototype._createSession = function(sessionId, apiKey, token) {
            this.session = OT.initSession(apiKey, sessionId), this.session.on({
                sessionConnected: function(e) {
                    this.session.publish(this.publisher)
                }.bind(this),
                streamCreated: function(e) {
                    var subContainer = document.createElement("div");
                    subContainer.id = "stream-".concat(e.stream.streamId), document.getElementById("subscribers").appendChild(subContainer), this.session.subscribe(e.stream, subContainer, {
                        width: videoWidth,
                        height: videoHeight,
                        style: {
                            buttonDisplayMode: "off"
                        }
                    }), this.emit(EVENTS.VIDEO_PARTICIPANT_JOINED)
                }.bind(this),
                streamDestroyed: function(e) {
                    this.emit(EVENTS.VIDEO_PARTICIPANT_LEFT)
                }.bind(this)
            }), this.session.connect(token)
        }, VideoChat.prototype._initPublisher = function(apiKey, publishVideo) {
            this.publisher = OT.initPublisher("publisher", {
                publishAudio: !0,
                publishVideo: publishVideo,
                width: videoWidth,
                height: videoHeight,
                resolution: "640x480",
                style: {
                    buttonDisplayMode: "off"
                }
            }), this.attachMediaAccessEvents()
        }, VideoChat.prototype.attachMediaAccessEvents = function(value) {
            var _this9 = this,
                MEDIA_ACCESS_TYPE = LiveShare.enums.MEDIA_ACCESS_TYPE;
            this.publisher.on("accessDialogOpened", function() {
                _this9.emit(EVENTS.MEDIA_ACCESS, MEDIA_ACCESS_TYPE.REQUEST)
            }), this.publisher.on("accessAllowed", function() {
                _this9.emit(EVENTS.MEDIA_ACCESS, MEDIA_ACCESS_TYPE.ALLOWED)
            }), this.publisher.on("accessDenied", function() {
                _this9.emit(EVENTS.MEDIA_ACCESS, MEDIA_ACCESS_TYPE.DENIED)
            })
        }, VideoChat.prototype.mute = function(value) {
            this.publisher.publishAudio(!value)
        }, VideoChat.prototype.destroy = function() {
            this.session.disconnect()
        }, namespace.VideoChat = VideoChat
    }(window.LIVE_SHARE),
    function(nsp) {
        "use strict";
        var EVENTS = nsp.enums.EVENTS,
            LOG_MESSAGES = nsp.enums.LOG_MESSAGES,
            ROOM_SETTINGS = nsp.enums.ROOM_SETTINGS,
            NO_ANIMATIONS_CLASS = "no-animations",
            sequenceNo = 0,
            outOfOrderQueue = {},
            Collaboration = function(options, socket) {
                this.options = options, this.socket = socket, this.collaboratorsCollection = null, this.collaboratorsListView = null, this.me = null, this.roomData = null, this.isSession = !1, this.voiceChat = null, this.videoChat = null, this.eventsQueue = null, this.pageLoading = !1
            };
        Collaboration.prototype = _.extend(Collaboration.prototype, EventEmitter.prototype), Collaboration.prototype = _.extend(Collaboration.prototype, nsp.DOMHelper), Collaboration.prototype = _.extend(Collaboration.prototype, nsp.FollowCursorInterface), Collaboration.prototype.constructor = Collaboration, Collaboration.prototype.processOutOfOrderQueue = function() {
            var orderedList = Object.keys(outOfOrderQueue).sort();
            orderedList.forEach(function(orderedSequenceNo) {
                var row = outOfOrderQueue[sequenceNo];
                row.resolve(row.data), delete outOfOrderQueue[sequenceNo]
            })
        }, Collaboration.prototype.parseSocketData = function(data) {
            return new Promise(function(resolve, reject) {
                return data.hasOwnProperty(sequenceNo) ? (++sequenceNo, this.processOutOfOrderQueue(), void resolve(data.data)) : void resolve(data)
            })
        }, Collaboration.prototype.create = function(roomData, userData) {
            var _this10 = this;
            return new Promise(function(resolve, reject) {
                nsp.log(LOG_MESSAGES.START), _this10.socket.on(EVENTS.CREATED, _this10.start.bind(_this10, resolve)), _this10.socket.on(EVENTS.FINISH, function(data) {
                    reject(new Error(data.type))
                }), _this10.socket.emit(EVENTS.CREATE, roomData, userData)
            })
        }, Collaboration.prototype.join = function(settings, userData) {
            var _this11 = this;
            return new Promise(function(resolve, reject) {
                nsp.log(LOG_MESSAGES.JOIN), _this11.socket.on(EVENTS.JOINED, _this11.start.bind(_this11, resolve)), _this11.socket.on(EVENTS.FINISH, function(data) {
                    reject(new Error(data.type))
                }), _this11.socket.emit(EVENTS.JOIN, settings, userData)
            })
        }, Collaboration.prototype.start = function(resolve, data) {
            var _this12 = this;
            nsp.log(LOG_MESSAGES.INITIALIZING), this.eventsQueue = new nsp.EventsQueue(data.roomData.eventsQueue), this.isSession = !0;
            var userData = data.userData;
            userData.scrolledElement = this.options.scrolledElement, userData.relativeElement = this.options.relativeElement, userData.canvasElement = this.options.canvasElement, this.me = new nsp.Me(userData, this.socket), this.me.start();
            var roomData = data.roomData;
            this.collaboratorsCollection = new nsp.CollaboratorsCollection, this.collaboratorsCollection.on(EVENTS.FOLLOW_CURSOR, this.followCursorOn.bind(this)), roomData.collaborators = _.reject(roomData.collaborators, function(el) {
                return el.id === userData.id
            }), this.collaboratorsCollection.add(roomData.collaborators.map(function(collaborator) {
                return collaborator.scrolledElement = _this12.options.scrolledElement, collaborator.relativeElement = _this12.options.relativeElement, collaborator.canvasElement = _this12.options.canvasElement, collaborator
            })), this.options.renderCollaboratorsList && (this.collaboratorsListView = new nsp.CollaboratorsListView(this.user, this.collaboratorsCollection), document.body.appendChild(this.collaboratorsListView.render())), nsp.eventDispatcher.socket = this.socket, this.attachEvents(), this.roomData = roomData, roomData.collaborators = this.getCollaboratorsData(), this.executeEventsQueue().then(function() {
                resolve(roomData), _this12.emit(EVENTS.START), nsp.log(LOG_MESSAGES.INITIALIZED)
            }).catch(console.error)
        }, Collaboration.prototype.startUTSession = function(userType) {
            userType && (this.videoChat = new nsp.VideoChat, this.videoChat.init(this.roomData.videoChat, this.me.videoChat, !this.me.isHost()), this.videoChat.on(EVENTS.VIDEO_PARTICIPANT_JOINED, this.onVideoParticipantJoined.bind(this)), this.videoChat.on(EVENTS.VIDEO_PARTICIPANT_LEFT, this.onVideoParticipantLeft.bind(this)), this.videoChat.on(EVENTS.MEDIA_ACCESS, this.onMediaAccess.bind(this)), userType === LiveShare.enums.USER_TYPES.TESTER && this.socket.emit(EVENTS.TESTER_JOINED))
        }, Collaboration.prototype.startLPSession = function() {
            this.voiceChat = new nsp.VoiceChat, this.voiceChat.init(this.roomData.videoChat, this.me.videoChat), this.voiceChat.on(EVENTS.VIDEO_PARTICIPANT_JOINED, this.onVideoParticipantJoined.bind(this)), this.voiceChat.on(EVENTS.VIDEO_PARTICIPANT_LEFT, this.onVideoParticipantLeft.bind(this)), this.voiceChat.on(EVENTS.MEDIA_ACCESS, this.onMediaAccess.bind(this))
        }, Collaboration.prototype.quit = function(data) {
            this.removeCollaborator(), this.finish({
                type: nsp.enums.SESSION_STATUS.QUIT
            })
        }, Collaboration.prototype.getCollaboratorsData = function() {
            var collection = this.collaboratorsCollection.collaborators.concat([this.me]);
            return collection = collection.map(function(collaborator) {
                return collaborator.toJSON()
            }), _.sortBy(collection, {
                type: nsp.enums.USER_TYPES.VIEWER
            })
        }, Collaboration.prototype.attachEvents = function() {
            this.socket.on(EVENTS.FINISH, this.finish.bind(this)), this.socket.on(EVENTS.COLLABORATOR_JOIN, this.onCollaboratorJoin.bind(this)), this.socket.on(EVENTS.COLLABORATOR_LEFT, this.onCollaboratorLeft.bind(this)), this.socket.on(EVENTS.COLLABORATION_END, this.onCollaborationEnd.bind(this)), this.socket.on(EVENTS.CURSOR_MOVE, this.onUpdateCursorPosition.bind(this)), this.socket.on(EVENTS.SHOW_CLICK, this.onShowClick.bind(this)), this.socket.on(EVENTS.DOM, this.onFireDOMEvent.bind(this)), this.socket.on(EVENTS.PAGE_CHANGE, this.onPageChange.bind(this)), this.socket.on(EVENTS.OPTIONS_CHANGED, this.onOptionChanged.bind(this)), this.socket.on(EVENTS.UPDATE_COLLABORATORS_SETTINGS, this.onUpdateCollaboratorsSettings.bind(this)), this.socket.on(EVENTS.MUTE, this.onMute.bind(this)), this.socket.on(EVENTS.UPDATE_TASKS, this.onUpdateTasks.bind(this)), this.socket.on(EVENTS.TESTER_JOINED, this.onTesterJoined.bind(this))
        }, Collaboration.prototype.onCollaboratorJoin = function(socketData) {
            var data = _.extend(socketData, {
                    scrolledElement: this.options.scrolledElement,
                    relativeElement: this.options.relativeElement,
                    canvasElement: this.options.canvasElement
                }),
                collaborator = this.collaboratorsCollection.add(data);
            this.emit(EVENTS.COLLABORATOR_JOIN, collaborator.toJSON())
        }, Collaboration.prototype.onCollaboratorLeft = function(id) {
            var collaborator = this.collaboratorsCollection.get(id);
            collaborator && (this.collaboratorsCollection.remove(id), this.emit(EVENTS.COLLABORATOR_LEFT, id))
        }, Collaboration.prototype.removeCollaborator = function(id) {
            this.socket.emit(EVENTS.REMOVE_COLLABORATOR, id)
        }, Collaboration.prototype.onCollaborationEnd = function(data) {
            this.emit(EVENTS.FINISH, data), this.destroy()
        }, Collaboration.prototype.mute = function(value) {
            this.me.settings.muted = value, this.socket.emit(EVENTS.MUTE, value), this.voiceChat && this.voiceChat.mute(value)
        }, Collaboration.prototype.onUpdateCursorPosition = function(socketData) {
            var _this13 = this;
            this.parseSocketData(socketData).then(function(data) {
                var collaborator = _this13.collaboratorsCollection.get(data.userID);
                collaborator.cursorMove(data), collaborator.settings.leadCursor && _this13.followCursor(data.data)
            })
        }, Collaboration.prototype.onShowClick = function(socketData) {
            var _this14 = this;
            this.parseSocketData(socketData).then(function(data) {
                _this14.collaboratorsCollection.get(data.userID).showClick(data)
            })
        }, Collaboration.prototype.onFireDOMEvent = function(data) {
            if (this.pageLoading) this.eventsQueue.push(data);
            else try {
                nsp.eventDispatcher(data.selector).emit(data)
            } catch (e) {}
        }, Collaboration.prototype.onPageChange = function(socketData) {
            this.parseSocketData(socketData).then(function(data) {
                window.location.replace(data.newURL)
            })
        }, Collaboration.prototype.onMute = function(data) {
            this.collaboratorsCollection.get(data.userID).settings.muted = data.muted, this.emit(EVENTS.MUTE)
        }, Collaboration.prototype.onUpdateTasks = function(data) {
            this.emit(EVENTS.UPDATE_TASKS, data)
        }, Collaboration.prototype.setOption = function(key, val) {
            var data = {};
            data[key] = val, this.socket.emit(EVENTS.SET_ROOM_OPTION, data)
        }, Collaboration.prototype.onOptionChanged = function(data, id) {
            id === this.me.id && (this.me.toggleOption(data.key, data.val), [ROOM_SETTINGS.CAN_CLOSE_TASKS, ROOM_SETTINGS.SEE_SITEMAP].indexOf(data.key) > -1 && this.emit(EVENTS.OPTIONS_CHANGED, data))
        }, Collaboration.prototype.onVideoParticipantJoined = function() {
            this.emit(EVENTS.VIDEO_PARTICIPANT_JOINED)
        }, Collaboration.prototype.onVideoParticipantLeft = function() {
            this.emit(EVENTS.VIDEO_PARTICIPANT_LEFT)
        }, Collaboration.prototype.onMediaAccess = function(value) {
            this.emit(EVENTS.MEDIA_ACCESS, value)
        }, Collaboration.prototype.onUpdateCollaboratorsSettings = function(data) {
            this.collaboratorsCollection.updateSettings(data)
        }, Collaboration.prototype.onPageChangeStart = function() {
            this.pageLoading = !0
        }, Collaboration.prototype.onPageChangeFinish = function() {
            this.eventsQueue.emit(EVENTS.PAGE_CHANGED), this.pageLoading = !1
        }, Collaboration.prototype.executeEventsQueue = function() {
            var _this15 = this;
            return new Promise(function(resolve) {
                return _this15.eventsQueue.length ? (_this15.options.relativeElement.classList.add(NO_ANIMATIONS_CLASS), void setTimeout(function() {
                    _this15.eventsQueue.executeQueue().then(function() {
                        setTimeout(function() {
                            _this15.options.relativeElement.classList.remove(NO_ANIMATIONS_CLASS), _this15.pageLoading = !1, resolve()
                        }, 10)
                    }).catch(console.error)
                }, 10)) : (resolve(), void(_this15.pageLoading = !1))
            })
        }, Collaboration.prototype.resolveTask = function(taskId) {
            this.socket.emit(EVENTS.RESOLVE_TASK, taskId)
        }, Collaboration.prototype.onTesterJoined = function(data) {
            this.emit(EVENTS.TESTER_JOINED, {
                started_at: new Date
            })
        }, Collaboration.prototype.finish = function(data) {
            this.emit(EVENTS.FINISH, data), this.destroy(), nsp.log(LOG_MESSAGES.OVER)
        }, Collaboration.prototype.destroy = function(data) {
            this.isSession = !1, this.me.destroy(), this.me = null, this.collaboratorsCollection.destroy(), this.collaboratorsCollection = null, nsp.eventDispatcher.socket = null, this.destroyFollowCursor(), this.socket.removeAllListeners(), this.socket.disconnect(), this.voiceChat && this.voiceChat.destroy(), this.videoChat && this.videoChat.destroy()
        }, nsp.Collaboration = Collaboration
    }(window.LIVE_SHARE),
    function(global, nsp) {
        "use strict";
        var EVENTS = nsp.enums.EVENTS,
            LOG_MESSAGES = nsp.enums.LOG_MESSAGES,
            LiveShare = function(options) {
                this.options = options, this.eventDispatcher = nsp.eventDispatcher, this.options.scrolledElement = this._validateContainer(this.options.scrolledElement), this.options.relativeElement = this._validateContainer(this.options.relativeElement), this.options.canvasElement = this._validateContainer(this.options.canvasElement), this.collaboration = null, this.socket, this.eventsToBroadcast = [EVENTS.START, EVENTS.FINISH, EVENTS.DOM, EVENTS.COLLABORATOR_JOIN, EVENTS.COLLABORATOR_LEFT, EVENTS.FOLLOW_CURSOR_ON, EVENTS.FOLLOW_CURSOR_OFF, EVENTS.MUTE, EVENTS.UPDATE_TASKS, EVENTS.OPTIONS_CHANGED, EVENTS.TESTER_JOINED, EVENTS.VIDEO_PARTICIPANT_JOINED, EVENTS.VIDEO_PARTICIPANT_LEFT, EVENTS.MEDIA_ACCESS]
            };
        LiveShare.prototype = _.extend(LiveShare.prototype, EventEmitter.prototype), LiveShare.prototype.constructor = LiveShare, LiveShare.prototype._validateContainer = function(selector) {
            if ("undefined" != typeof selector.tagName) return selector;
            var el = document.querySelector(selector);
            return el ? el : document.body
        }, LiveShare.prototype._connect = function() {
            var _this16 = this;
            return nsp.log(LOG_MESSAGES.CONNECT), new Promise(function(resolve, reject) {
                _this16.socket = io.connect(_this16.options.socketURL, {
                    reconnectionAttempts: /\.com$/.test(global.location.hostname) ? 1 / 0 : 1
                }), _this16.socket.on(EVENTS.ERROR, function(err) {
                    reject(new Error(err))
                }), _this16.socket.on(EVENTS.CONNECT_ERROR, function(err) {
                    reject(new Error(err))
                }), _this16.socket.on(EVENTS.CONNECT, function() {
                    nsp.log(LOG_MESSAGES.ESTABLISH), _this16._connected(resolve)
                }), _this16.checkIsExtensionInstalled(reject)
            })
        }, LiveShare.prototype._connected = function(resolve) {
            var _this17 = this;
            this.collaboration = new nsp.Collaboration(this.options, this.socket), this._broadcastEvents(this.eventsToBroadcast), this.socket.on(EVENTS.DISCONNECT, function() {
                _this17.collaboration.finish({
                    type: nsp.enums.SESSION_STATUS.OVER
                })
            }), resolve(this.socket)
        }, LiveShare.prototype.checkIsExtensionInstalled = function(resolve, reject) {}, LiveShare.prototype._broadcastEvents = function(events) {
            var _this18 = this;
            events.forEach(function(event) {
                _this18.collaboration.on(event, _this18._broadcastEvent.bind(_this18, event))
            })
        }, LiveShare.prototype._broadcastEvent = function(event, data) {
            this.emit(event, data)
        }, LiveShare.prototype.create = function(settings, userData) {
            return this._connect().then(this._create.bind(this, settings, userData))
        }, LiveShare.prototype.join = function(settings, userData) {
            return this._connect().then(this._join.bind(this, settings, userData))
        }, LiveShare.prototype.quit = function() {
            this.collaboration.quit()
        }, LiveShare.prototype._create = function(settings, userData) {
            return this.collaboration.create(settings, userData)
        }, LiveShare.prototype._join = function(settings, userData) {
            return this.collaboration.join(settings, userData)
        }, LiveShare.prototype.getCollaboratorsData = function() {
            return this.collaboration.getCollaboratorsData()
        }, LiveShare.prototype.getMyData = function() {
            return this.collaboration.me.toJSON()
        }, LiveShare.prototype.getHostData = function() {
            return _.find(this.getCollaboratorsData(), {
                type: nsp.enums.USER_TYPES.HOST
            })
        }, LiveShare.prototype.getRoomId = function() {
            return this.collaboration.roomData.roomID
        }, LiveShare.prototype.removeCollaborator = function(id) {
            this.collaboration.removeCollaborator(id)
        }, LiveShare.prototype.followCursor = function(id) {
            var collaborator = this.collaboration.collaboratorsCollection.get(id);
            collaborator && collaborator.settings.leadCursor && collaborator.followMe()
        }, LiveShare.prototype.mute = function(value) {
            this.collaboration.mute(value)
        }, LiveShare.prototype.isSession = function() {
            return !!this.collaboration && this.collaboration.isSession
        }, LiveShare.prototype.isHostSession = function() {
            return this.isSession() && this.collaboration.me.isHost()
        }, LiveShare.prototype.setOption = function(key, val) {
            this.collaboration.setOption(key, val)
        }, LiveShare.prototype.onPageChangeStart = function() {
            this.collaboration.onPageChangeStart()
        }, LiveShare.prototype.onPageChangeFinish = function() {
            this.collaboration.onPageChangeFinish()
        }, LiveShare.prototype.startUTSession = function(userType) {
            this.collaboration.startUTSession(userType)
        }, LiveShare.prototype.startLPSession = function() {
            this.collaboration.startLPSession()
        }, LiveShare.prototype.resolveTask = function(taskId) {
            this.collaboration.resolveTask(taskId)
        }, LiveShare.enums = nsp.enums, global.LiveShare = LiveShare
    }(window, window.LIVE_SHARE),
    function(window) {
        "use strict";

        function errorHandlingConfig(config) {
            return isObject(config) ? (isDefined(config.objectMaxDepth) && (minErrConfig.objectMaxDepth = isValidObjectMaxDepth(config.objectMaxDepth) ? config.objectMaxDepth : NaN), void(isDefined(config.urlErrorParamsEnabled) && isBoolean(config.urlErrorParamsEnabled) && (minErrConfig.urlErrorParamsEnabled = config.urlErrorParamsEnabled))) : minErrConfig
        }

        function isValidObjectMaxDepth(maxDepth) {
            return isNumber(maxDepth) && maxDepth > 0
        }

        function minErr(module, ErrorConstructor) {
            ErrorConstructor = ErrorConstructor || Error;
            var url = "https://errors.angularjs.org/1.8.0/",
                regex = url.replace(".", "\\.") + "[\\s\\S]*",
                errRegExp = new RegExp(regex, "g");
            return function() {
                var paramPrefix, i, code = arguments[0],
                    template = arguments[1],
                    message = "[" + (module ? module + ":" : "") + code + "] ",
                    templateArgs = sliceArgs(arguments, 2).map(function(arg) {
                        return toDebugString(arg, minErrConfig.objectMaxDepth)
                    });
                if (message += template.replace(/\{\d+\}/g, function(match) {
                        var index = +match.slice(1, -1);
                        return index < templateArgs.length ? templateArgs[index].replace(errRegExp, "") : match
                    }), message += "\n" + url + (module ? module + "/" : "") + code, minErrConfig.urlErrorParamsEnabled)
                    for (i = 0, paramPrefix = "?"; i < templateArgs.length; i++, paramPrefix = "&") message += paramPrefix + "p" + i + "=" + encodeURIComponent(templateArgs[i]);
                return new ErrorConstructor(message)
            }
        }

        function isArrayLike(obj) {
            if (null == obj || isWindow(obj)) return !1;
            if (isArray(obj) || isString(obj) || jqLite && obj instanceof jqLite) return !0;
            var length = "length" in Object(obj) && obj.length;
            return isNumber(length) && (length >= 0 && length - 1 in obj || "function" == typeof obj.item)
        }

        function forEach(obj, iterator, context) {
            var key, length;
            if (obj)
                if (isFunction(obj))
                    for (key in obj) "prototype" !== key && "length" !== key && "name" !== key && obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj);
                else if (isArray(obj) || isArrayLike(obj)) {
                var isPrimitive = "object" !== _typeof2(obj);
                for (key = 0, length = obj.length; key < length; key++)(isPrimitive || key in obj) && iterator.call(context, obj[key], key, obj)
            } else if (obj.forEach && obj.forEach !== forEach) obj.forEach(iterator, context, obj);
            else if (isBlankObject(obj))
                for (key in obj) iterator.call(context, obj[key], key, obj);
            else if ("function" == typeof obj.hasOwnProperty)
                for (key in obj) obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj);
            else
                for (key in obj) hasOwnProperty.call(obj, key) && iterator.call(context, obj[key], key, obj);
            return obj
        }

        function forEachSorted(obj, iterator, context) {
            for (var keys = Object.keys(obj).sort(), i = 0; i < keys.length; i++) iterator.call(context, obj[keys[i]], keys[i]);
            return keys
        }

        function reverseParams(iteratorFn) {
            return function(value, key) {
                iteratorFn(key, value)
            }
        }

        function nextUid() {
            return ++uid
        }

        function setHashKey(obj, h) {
            h ? obj.$$hashKey = h : delete obj.$$hashKey
        }

        function baseExtend(dst, objs, deep) {
            for (var h = dst.$$hashKey, i = 0, ii = objs.length; i < ii; ++i) {
                var obj = objs[i];
                if (isObject(obj) || isFunction(obj))
                    for (var keys = Object.keys(obj), j = 0, jj = keys.length; j < jj; j++) {
                        var key = keys[j],
                            src = obj[key];
                        deep && isObject(src) ? isDate(src) ? dst[key] = new Date(src.valueOf()) : isRegExp(src) ? dst[key] = new RegExp(src) : src.nodeName ? dst[key] = src.cloneNode(!0) : isElement(src) ? dst[key] = src.clone() : "__proto__" !== key && (isObject(dst[key]) || (dst[key] = isArray(src) ? [] : {}), baseExtend(dst[key], [src], !0)) : dst[key] = src
                    }
            }
            return setHashKey(dst, h), dst
        }

        function extend(dst) {
            return baseExtend(dst, slice.call(arguments, 1), !1)
        }

        function merge(dst) {
            return baseExtend(dst, slice.call(arguments, 1), !0)
        }

        function toInt(str) {
            return parseInt(str, 10)
        }

        function inherit(parent, extra) {
            return extend(Object.create(parent), extra)
        }

        function noop() {}

        function identity($) {
            return $
        }

        function valueFn(value) {
            return function() {
                return value
            }
        }

        function hasCustomToString(obj) {
            return isFunction(obj.toString) && obj.toString !== toString
        }

        function isUndefined(value) {
            return "undefined" == typeof value
        }

        function isDefined(value) {
            return "undefined" != typeof value
        }

        function isObject(value) {
            return null !== value && "object" === _typeof2(value)
        }

        function isBlankObject(value) {
            return null !== value && "object" === _typeof2(value) && !getPrototypeOf(value)
        }

        function isString(value) {
            return "string" == typeof value
        }

        function isNumber(value) {
            return "number" == typeof value
        }

        function isDate(value) {
            return "[object Date]" === toString.call(value)
        }

        function isArray(arr) {
            return Array.isArray(arr) || arr instanceof Array
        }

        function isError(value) {
            var tag = toString.call(value);
            switch (tag) {
                case "[object Error]":
                    return !0;
                case "[object Exception]":
                    return !0;
                case "[object DOMException]":
                    return !0;
                default:
                    return value instanceof Error
            }
        }

        function isFunction(value) {
            return "function" == typeof value
        }

        function isRegExp(value) {
            return "[object RegExp]" === toString.call(value)
        }

        function isWindow(obj) {
            return obj && obj.window === obj
        }

        function isScope(obj) {
            return obj && obj.$evalAsync && obj.$watch
        }

        function isFile(obj) {
            return "[object File]" === toString.call(obj)
        }

        function isFormData(obj) {
            return "[object FormData]" === toString.call(obj)
        }

        function isBlob(obj) {
            return "[object Blob]" === toString.call(obj)
        }

        function isBoolean(value) {
            return "boolean" == typeof value
        }

        function isPromiseLike(obj) {
            return obj && isFunction(obj.then)
        }

        function isTypedArray(value) {
            return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value))
        }

        function isArrayBuffer(obj) {
            return "[object ArrayBuffer]" === toString.call(obj)
        }

        function isElement(node) {
            return !(!node || !(node.nodeName || node.prop && node.attr && node.find))
        }

        function makeMap(str) {
            var i, obj = {},
                items = str.split(",");
            for (i = 0; i < items.length; i++) obj[items[i]] = !0;
            return obj
        }

        function nodeName_(element) {
            return lowercase(element.nodeName || element[0] && element[0].nodeName)
        }

        function includes(array, obj) {
            return Array.prototype.indexOf.call(array, obj) !== -1
        }

        function arrayRemove(array, value) {
            var index = array.indexOf(value);
            return index >= 0 && array.splice(index, 1), index
        }

        function copy(source, destination, maxDepth) {
            function copyRecurse(source, destination, maxDepth) {
                if (maxDepth--, maxDepth < 0) return "...";
                var key, h = destination.$$hashKey;
                if (isArray(source))
                    for (var i = 0, ii = source.length; i < ii; i++) destination.push(copyElement(source[i], maxDepth));
                else if (isBlankObject(source))
                    for (key in source) destination[key] = copyElement(source[key], maxDepth);
                else if (source && "function" == typeof source.hasOwnProperty)
                    for (key in source) source.hasOwnProperty(key) && (destination[key] = copyElement(source[key], maxDepth));
                else
                    for (key in source) hasOwnProperty.call(source, key) && (destination[key] = copyElement(source[key], maxDepth));
                return setHashKey(destination, h), destination
            }

            function copyElement(source, maxDepth) {
                if (!isObject(source)) return source;
                var index = stackSource.indexOf(source);
                if (index !== -1) return stackDest[index];
                if (isWindow(source) || isScope(source)) throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
                var needsRecurse = !1,
                    destination = copyType(source);
                return void 0 === destination && (destination = isArray(source) ? [] : Object.create(getPrototypeOf(source)), needsRecurse = !0), stackSource.push(source), stackDest.push(destination), needsRecurse ? copyRecurse(source, destination, maxDepth) : destination
            }

            function copyType(source) {
                switch (toString.call(source)) {
                    case "[object Int8Array]":
                    case "[object Int16Array]":
                    case "[object Int32Array]":
                    case "[object Float32Array]":
                    case "[object Float64Array]":
                    case "[object Uint8Array]":
                    case "[object Uint8ClampedArray]":
                    case "[object Uint16Array]":
                    case "[object Uint32Array]":
                        return new source.constructor(copyElement(source.buffer), source.byteOffset, source.length);
                    case "[object ArrayBuffer]":
                        if (!source.slice) {
                            var copied = new ArrayBuffer(source.byteLength);
                            return new Uint8Array(copied).set(new Uint8Array(source)), copied
                        }
                        return source.slice(0);
                    case "[object Boolean]":
                    case "[object Number]":
                    case "[object String]":
                    case "[object Date]":
                        return new source.constructor(source.valueOf());
                    case "[object RegExp]":
                        var re = new RegExp(source.source, source.toString().match(/[^/]*$/)[0]);
                        return re.lastIndex = source.lastIndex, re;
                    case "[object Blob]":
                        return new source.constructor([source], {
                            type: source.type
                        })
                }
                if (isFunction(source.cloneNode)) return source.cloneNode(!0)
            }
            var stackSource = [],
                stackDest = [];
            if (maxDepth = isValidObjectMaxDepth(maxDepth) ? maxDepth : NaN, destination) {
                if (isTypedArray(destination) || isArrayBuffer(destination)) throw ngMinErr("cpta", "Can't copy! TypedArray destination cannot be mutated.");
                if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
                return isArray(destination) ? destination.length = 0 : forEach(destination, function(value, key) {
                    "$$hashKey" !== key && delete destination[key]
                }), stackSource.push(source), stackDest.push(destination), copyRecurse(source, destination, maxDepth)
            }
            return copyElement(source, maxDepth)
        }

        function simpleCompare(a, b) {
            return a === b || a !== a && b !== b
        }

        function equals(o1, o2) {
            if (o1 === o2) return !0;
            if (null === o1 || null === o2) return !1;
            if (o1 !== o1 && o2 !== o2) return !0;
            var length, key, keySet, t1 = _typeof2(o1),
                t2 = _typeof2(o2);
            if (t1 === t2 && "object" === t1) {
                if (!isArray(o1)) {
                    if (isDate(o1)) return !!isDate(o2) && simpleCompare(o1.getTime(), o2.getTime());
                    if (isRegExp(o1)) return !!isRegExp(o2) && o1.toString() === o2.toString();
                    if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2)) return !1;
                    keySet = createMap();
                    for (key in o1)
                        if ("$" !== key.charAt(0) && !isFunction(o1[key])) {
                            if (!equals(o1[key], o2[key])) return !1;
                            keySet[key] = !0
                        } for (key in o2)
                        if (!(key in keySet) && "$" !== key.charAt(0) && isDefined(o2[key]) && !isFunction(o2[key])) return !1;
                    return !0
                }
                if (!isArray(o2)) return !1;
                if ((length = o1.length) === o2.length) {
                    for (key = 0; key < length; key++)
                        if (!equals(o1[key], o2[key])) return !1;
                    return !0
                }
            }
            return !1
        }

        function concat(array1, array2, index) {
            return array1.concat(slice.call(array2, index))
        }

        function sliceArgs(args, startIndex) {
            return slice.call(args, startIndex || 0)
        }

        function bind(self, fn) {
            var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
            return !isFunction(fn) || fn instanceof RegExp ? fn : curryArgs.length ? function() {
                return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs)
            } : function() {
                return arguments.length ? fn.apply(self, arguments) : fn.call(self)
            }
        }

        function toJsonReplacer(key, value) {
            var val = value;
            return "string" == typeof key && "$" === key.charAt(0) && "$" === key.charAt(1) ? val = void 0 : isWindow(value) ? val = "$WINDOW" : value && window.document === value ? val = "$DOCUMENT" : isScope(value) && (val = "$SCOPE"), val
        }

        function toJson(obj, pretty) {
            if (!isUndefined(obj)) return isNumber(pretty) || (pretty = pretty ? 2 : null), JSON.stringify(obj, toJsonReplacer, pretty)
        }

        function fromJson(json) {
            return isString(json) ? JSON.parse(json) : json
        }

        function timezoneToOffset(timezone, fallback) {
            timezone = timezone.replace(ALL_COLONS, "");
            var requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
            return isNumberNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset
        }

        function addDateMinutes(date, minutes) {
            return date = new Date(date.getTime()), date.setMinutes(date.getMinutes() + minutes), date
        }

        function convertTimezoneToLocal(date, timezone, reverse) {
            reverse = reverse ? -1 : 1;
            var dateTimezoneOffset = date.getTimezoneOffset(),
                timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
            return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset))
        }

        function startingTag(element) {
            element = jqLite(element).clone().empty();
            var elemHtml = jqLite("<div></div>").append(element).html();
            try {
                return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/, function(match, nodeName) {
                    return "<" + lowercase(nodeName)
                })
            } catch (e) {
                return lowercase(elemHtml)
            }
        }

        function tryDecodeURIComponent(value) {
            try {
                return decodeURIComponent(value)
            } catch (e) {}
        }

        function parseKeyValue(keyValue) {
            var obj = {};
            return forEach((keyValue || "").split("&"), function(keyValue) {
                var splitPoint, key, val;
                keyValue && (key = keyValue = keyValue.replace(/\+/g, "%20"), splitPoint = keyValue.indexOf("="), splitPoint !== -1 && (key = keyValue.substring(0, splitPoint), val = keyValue.substring(splitPoint + 1)), key = tryDecodeURIComponent(key), isDefined(key) && (val = !isDefined(val) || tryDecodeURIComponent(val), hasOwnProperty.call(obj, key) ? isArray(obj[key]) ? obj[key].push(val) : obj[key] = [obj[key], val] : obj[key] = val))
            }), obj
        }

        function toKeyValue(obj) {
            var parts = [];
            return forEach(obj, function(value, key) {
                isArray(value) ? forEach(value, function(arrayValue) {
                    parts.push(encodeUriQuery(key, !0) + (arrayValue === !0 ? "" : "=" + encodeUriQuery(arrayValue, !0)))
                }) : parts.push(encodeUriQuery(key, !0) + (value === !0 ? "" : "=" + encodeUriQuery(value, !0)))
            }), parts.length ? parts.join("&") : ""
        }

        function encodeUriSegment(val) {
            return encodeUriQuery(val, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+")
        }

        function encodeUriQuery(val, pctEncodeSpaces) {
            return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+")
        }

        function getNgAttribute(element, ngAttr) {
            var attr, i, ii = ngAttrPrefixes.length;
            for (i = 0; i < ii; ++i)
                if (attr = ngAttrPrefixes[i] + ngAttr, isString(attr = element.getAttribute(attr))) return attr;
            return null
        }

        function allowAutoBootstrap(document) {
            var script = document.currentScript;
            if (!script) return !0;
            if (!(script instanceof window.HTMLScriptElement || script instanceof window.SVGScriptElement)) return !1;
            var attributes = script.attributes,
                srcs = [attributes.getNamedItem("src"), attributes.getNamedItem("href"), attributes.getNamedItem("xlink:href")];
            return srcs.every(function(src) {
                if (!src) return !0;
                if (!src.value) return !1;
                var link = document.createElement("a");
                if (link.href = src.value, document.location.origin === link.origin) return !0;
                switch (link.protocol) {
                    case "http:":
                    case "https:":
                    case "ftp:":
                    case "blob:":
                    case "file:":
                    case "data:":
                        return !0;
                    default:
                        return !1
                }
            })
        }

        function angularInit(element, bootstrap) {
            var appElement, module, config = {};
            if (forEach(ngAttrPrefixes, function(prefix) {
                    var name = prefix + "app";
                    !appElement && element.hasAttribute && element.hasAttribute(name) && (appElement = element, module = element.getAttribute(name))
                }), forEach(ngAttrPrefixes, function(prefix) {
                    var candidate, name = prefix + "app";
                    !appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]")) && (appElement = candidate, module = candidate.getAttribute(name))
                }), appElement) {
                if (!isAutoBootstrapAllowed) return void window.console.error("AngularJS: disabling automatic bootstrap. <script> protocol indicates an extension, document.location.href does not match.");
                config.strictDi = null !== getNgAttribute(appElement, "strict-di"), bootstrap(appElement, module ? [module] : [], config)
            }
        }

        function bootstrap(element, modules, config) {
            isObject(config) || (config = {});
            var defaultConfig = {
                strictDi: !1
            };
            config = extend(defaultConfig, config);
            var doBootstrap = function() {
                    if (element = jqLite(element), element.injector()) {
                        var tag = element[0] === window.document ? "document" : startingTag(element);
                        throw ngMinErr("btstrpd", "App already bootstrapped with this element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"))
                    }
                    modules = modules || [], modules.unshift(["$provide", function($provide) {
                        $provide.value("$rootElement", element)
                    }]), config.debugInfoEnabled && modules.push(["$compileProvider", function($compileProvider) {
                        $compileProvider.debugInfoEnabled(!0)
                    }]), modules.unshift("ng");
                    var injector = createInjector(modules, config.strictDi);
                    return injector.invoke(["$rootScope", "$rootElement", "$compile", "$injector", function(scope, element, compile, injector) {
                        scope.$apply(function() {
                            element.data("$injector", injector), compile(element)(scope)
                        })
                    }]), injector
                },
                NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/,
                NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
            return window && NG_ENABLE_DEBUG_INFO.test(window.name) && (config.debugInfoEnabled = !0, window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "")), window && !NG_DEFER_BOOTSTRAP.test(window.name) ? doBootstrap() : (window.name = window.name.replace(NG_DEFER_BOOTSTRAP, ""), angular.resumeBootstrap = function(extraModules) {
                return forEach(extraModules, function(module) {
                    modules.push(module)
                }), doBootstrap()
            }, void(isFunction(angular.resumeDeferredBootstrap) && angular.resumeDeferredBootstrap()))
        }

        function reloadWithDebugInfo() {
            window.name = "NG_ENABLE_DEBUG_INFO!" + window.name, window.location.reload()
        }

        function getTestability(rootElement) {
            var injector = angular.element(rootElement).injector();
            if (!injector) throw ngMinErr("test", "no injector found for element argument to getTestability");
            return injector.get("$$testability")
        }

        function snake_case(name, separator) {
            return separator = separator || "_", name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {
                return (pos ? separator : "") + letter.toLowerCase()
            })
        }

        function bindJQuery() {
            var originalCleanData;
            if (!bindJQueryFired) {
                var jqName = jq();
                jQuery = isUndefined(jqName) ? window.jQuery : jqName ? window[jqName] : void 0, jQuery && jQuery.fn.on ? (jqLite = jQuery, extend(jQuery.fn, {
                    scope: JQLitePrototype.scope,
                    isolateScope: JQLitePrototype.isolateScope,
                    controller: JQLitePrototype.controller,
                    injector: JQLitePrototype.injector,
                    inheritedData: JQLitePrototype.inheritedData
                })) : jqLite = JQLite, originalCleanData = jqLite.cleanData, jqLite.cleanData = function(elems) {
                    for (var events, elem, i = 0; null != (elem = elems[i]); i++) events = (jqLite._data(elem) || {}).events, events && events.$destroy && jqLite(elem).triggerHandler("$destroy");
                    originalCleanData(elems)
                }, angular.element = jqLite, bindJQueryFired = !0
            }
        }

        function UNSAFE_restoreLegacyJqLiteXHTMLReplacement() {
            JQLite.legacyXHTMLReplacement = !0
        }

        function assertArg(arg, name, reason) {
            if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
            return arg
        }

        function assertArgFn(arg, name, acceptArrayAnnotation) {
            return acceptArrayAnnotation && isArray(arg) && (arg = arg[arg.length - 1]), assertArg(isFunction(arg), name, "not a function, got " + (arg && "object" === _typeof2(arg) ? arg.constructor.name || "Object" : _typeof2(arg))), arg
        }

        function assertNotHasOwnProperty(name, context) {
            if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context)
        }

        function getter(obj, path, bindFnToScope) {
            if (!path) return obj;
            for (var key, keys = path.split("."), lastInstance = obj, len = keys.length, i = 0; i < len; i++) key = keys[i], obj && (obj = (lastInstance = obj)[key]);
            return !bindFnToScope && isFunction(obj) ? bind(lastInstance, obj) : obj
        }

        function getBlockNodes(nodes) {
            for (var blockNodes, node = nodes[0], endNode = nodes[nodes.length - 1], i = 1; node !== endNode && (node = node.nextSibling); i++)(blockNodes || nodes[i] !== node) && (blockNodes || (blockNodes = jqLite(slice.call(nodes, 0, i))), blockNodes.push(node));
            return blockNodes || nodes
        }

        function createMap() {
            return Object.create(null)
        }

        function stringify(value) {
            if (null == value) return "";
            switch (_typeof2(value)) {
                case "string":
                    break;
                case "number":
                    value = "" + value;
                    break;
                default:
                    value = !hasCustomToString(value) || isArray(value) || isDate(value) ? toJson(value) : value.toString()
            }
            return value
        }

        function setupModuleLoader(window) {
            function ensure(obj, name, factory) {
                return obj[name] || (obj[name] = factory())
            }
            var $injectorMinErr = minErr("$injector"),
                ngMinErr = minErr("ng"),
                angular = ensure(window, "angular", Object);
            return angular.$$minErr = angular.$$minErr || minErr, ensure(angular, "module", function() {
                var modules = {};
                return function(name, requires, configFn) {
                    var _info = {},
                        assertNotHasOwnProperty = function(name, context) {
                            if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context)
                        };
                    return assertNotHasOwnProperty(name, "module"), requires && modules.hasOwnProperty(name) && (modules[name] = null), ensure(modules, name, function() {
                        function invokeLater(provider, method, insertMethod, queue) {
                            return queue || (queue = invokeQueue),
                                function() {
                                    return queue[insertMethod || "push"]([provider, method, arguments]), moduleInstance
                                }
                        }

                        function invokeLaterAndSetModuleName(provider, method, queue) {
                            return queue || (queue = invokeQueue),
                                function(recipeName, factoryFunction) {
                                    return factoryFunction && isFunction(factoryFunction) && (factoryFunction.$$moduleName = name), queue.push([provider, method, arguments]), moduleInstance
                                }
                        }
                        if (!requires) throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", name);
                        var invokeQueue = [],
                            configBlocks = [],
                            runBlocks = [],
                            config = invokeLater("$injector", "invoke", "push", configBlocks),
                            moduleInstance = {
                                _invokeQueue: invokeQueue,
                                _configBlocks: configBlocks,
                                _runBlocks: runBlocks,
                                info: function(value) {
                                    if (isDefined(value)) {
                                        if (!isObject(value)) throw ngMinErr("aobj", "Argument '{0}' must be an object", "value");
                                        return _info = value, this
                                    }
                                    return _info
                                },
                                requires: requires,
                                name: name,
                                provider: invokeLaterAndSetModuleName("$provide", "provider"),
                                factory: invokeLaterAndSetModuleName("$provide", "factory"),
                                service: invokeLaterAndSetModuleName("$provide", "service"),
                                value: invokeLater("$provide", "value"),
                                constant: invokeLater("$provide", "constant", "unshift"),
                                decorator: invokeLaterAndSetModuleName("$provide", "decorator", configBlocks),
                                animation: invokeLaterAndSetModuleName("$animateProvider", "register"),
                                filter: invokeLaterAndSetModuleName("$filterProvider", "register"),
                                controller: invokeLaterAndSetModuleName("$controllerProvider", "register"),
                                directive: invokeLaterAndSetModuleName("$compileProvider", "directive"),
                                component: invokeLaterAndSetModuleName("$compileProvider", "component"),
                                config: config,
                                run: function(block) {
                                    return runBlocks.push(block), this
                                }
                            };
                        return configFn && config(configFn), moduleInstance
                    })
                }
            })
        }

        function shallowCopy(src, dst) {
            if (isArray(src)) {
                dst = dst || [];
                for (var i = 0, ii = src.length; i < ii; i++) dst[i] = src[i]
            } else if (isObject(src)) {
                dst = dst || {};
                for (var key in src) "$" === key.charAt(0) && "$" === key.charAt(1) || (dst[key] = src[key])
            }
            return dst || src
        }

        function serializeObject(obj, maxDepth) {
            var seen = [];
            return isValidObjectMaxDepth(maxDepth) && (obj = angular.copy(obj, null, maxDepth)), JSON.stringify(obj, function(key, val) {
                if (val = toJsonReplacer(key, val), isObject(val)) {
                    if (seen.indexOf(val) >= 0) return "...";
                    seen.push(val)
                }
                return val
            })
        }

        function toDebugString(obj, maxDepth) {
            return "function" == typeof obj ? obj.toString().replace(/ \{[\s\S]*$/, "") : isUndefined(obj) ? "undefined" : "string" != typeof obj ? serializeObject(obj, maxDepth) : obj
        }

        function publishExternalAPI(angular) {
            extend(angular, {
                errorHandlingConfig: errorHandlingConfig,
                bootstrap: bootstrap,
                copy: copy,
                extend: extend,
                merge: merge,
                equals: equals,
                element: jqLite,
                forEach: forEach,
                injector: createInjector,
                noop: noop,
                bind: bind,
                toJson: toJson,
                fromJson: fromJson,
                identity: identity,
                isUndefined: isUndefined,
                isDefined: isDefined,
                isString: isString,
                isFunction: isFunction,
                isObject: isObject,
                isNumber: isNumber,
                isElement: isElement,
                isArray: isArray,
                version: version,
                isDate: isDate,
                callbacks: {
                    $$counter: 0
                },
                getTestability: getTestability,
                reloadWithDebugInfo: reloadWithDebugInfo,
                UNSAFE_restoreLegacyJqLiteXHTMLReplacement: UNSAFE_restoreLegacyJqLiteXHTMLReplacement,
                $$minErr: minErr,
                $$csp: csp,
                $$encodeUriSegment: encodeUriSegment,
                $$encodeUriQuery: encodeUriQuery,
                $$lowercase: lowercase,
                $$stringify: stringify,
                $$uppercase: uppercase
            }), angularModule = setupModuleLoader(window), angularModule("ng", ["ngLocale"], ["$provide", function($provide) {
                $provide.provider({
                    $$sanitizeUri: $$SanitizeUriProvider
                }), $provide.provider("$compile", $CompileProvider).directive({
                    a: htmlAnchorDirective,
                    input: inputDirective,
                    textarea: inputDirective,
                    form: formDirective,
                    script: scriptDirective,
                    select: selectDirective,
                    option: optionDirective,
                    ngBind: ngBindDirective,
                    ngBindHtml: ngBindHtmlDirective,
                    ngBindTemplate: ngBindTemplateDirective,
                    ngClass: ngClassDirective,
                    ngClassEven: ngClassEvenDirective,
                    ngClassOdd: ngClassOddDirective,
                    ngCloak: ngCloakDirective,
                    ngController: ngControllerDirective,
                    ngForm: ngFormDirective,
                    ngHide: ngHideDirective,
                    ngIf: ngIfDirective,
                    ngInclude: ngIncludeDirective,
                    ngInit: ngInitDirective,
                    ngNonBindable: ngNonBindableDirective,
                    ngPluralize: ngPluralizeDirective,
                    ngRef: ngRefDirective,
                    ngRepeat: ngRepeatDirective,
                    ngShow: ngShowDirective,
                    ngStyle: ngStyleDirective,
                    ngSwitch: ngSwitchDirective,
                    ngSwitchWhen: ngSwitchWhenDirective,
                    ngSwitchDefault: ngSwitchDefaultDirective,
                    ngOptions: ngOptionsDirective,
                    ngTransclude: ngTranscludeDirective,
                    ngModel: ngModelDirective,
                    ngList: ngListDirective,
                    ngChange: ngChangeDirective,
                    pattern: patternDirective,
                    ngPattern: patternDirective,
                    required: requiredDirective,
                    ngRequired: requiredDirective,
                    minlength: minlengthDirective,
                    ngMinlength: minlengthDirective,
                    maxlength: maxlengthDirective,
                    ngMaxlength: maxlengthDirective,
                    ngValue: ngValueDirective,
                    ngModelOptions: ngModelOptionsDirective
                }).directive({
                    ngInclude: ngIncludeFillContentDirective,
                    input: hiddenInputBrowserCacheDirective
                }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives), $provide.provider({
                    $anchorScroll: $AnchorScrollProvider,
                    $animate: $AnimateProvider,
                    $animateCss: $CoreAnimateCssProvider,
                    $$animateJs: $$CoreAnimateJsProvider,
                    $$animateQueue: $$CoreAnimateQueueProvider,
                    $$AnimateRunner: $$AnimateRunnerFactoryProvider,
                    $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
                    $browser: $BrowserProvider,
                    $cacheFactory: $CacheFactoryProvider,
                    $controller: $ControllerProvider,
                    $document: $DocumentProvider,
                    $$isDocumentHidden: $$IsDocumentHiddenProvider,
                    $exceptionHandler: $ExceptionHandlerProvider,
                    $filter: $FilterProvider,
                    $$forceReflow: $$ForceReflowProvider,
                    $interpolate: $InterpolateProvider,
                    $interval: $IntervalProvider,
                    $$intervalFactory: $$IntervalFactoryProvider,
                    $http: $HttpProvider,
                    $httpParamSerializer: $HttpParamSerializerProvider,
                    $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                    $httpBackend: $HttpBackendProvider,
                    $xhrFactory: $xhrFactoryProvider,
                    $jsonpCallbacks: $jsonpCallbacksProvider,
                    $location: $LocationProvider,
                    $log: $LogProvider,
                    $parse: $ParseProvider,
                    $rootScope: $RootScopeProvider,
                    $q: $QProvider,
                    $$q: $$QProvider,
                    $sce: $SceProvider,
                    $sceDelegate: $SceDelegateProvider,
                    $sniffer: $SnifferProvider,
                    $$taskTrackerFactory: $$TaskTrackerFactoryProvider,
                    $templateCache: $TemplateCacheProvider,
                    $templateRequest: $TemplateRequestProvider,
                    $$testability: $$TestabilityProvider,
                    $timeout: $TimeoutProvider,
                    $window: $WindowProvider,
                    $$rAF: $$RAFProvider,
                    $$jqLite: $$jqLiteProvider,
                    $$Map: $$MapProvider,
                    $$cookieReader: $$CookieReaderProvider
                })
            }]).info({
                angularVersion: "1.8.0"
            })
        }

        function jqNextId() {
            return ++jqId
        }

        function cssKebabToCamel(name) {
            return kebabToCamel(name.replace(MS_HACK_REGEXP, "ms-"))
        }

        function fnCamelCaseReplace(all, letter) {
            return letter.toUpperCase()
        }

        function kebabToCamel(name) {
            return name.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace)
        }

        function jqLiteIsTextNode(html) {
            return !HTML_REGEXP.test(html)
        }

        function jqLiteAcceptsData(node) {
            var nodeType = node.nodeType;
            return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT
        }

        function jqLiteHasData(node) {
            for (var key in jqCache[node.ng339]) return !0;
            return !1
        }

        function jqLiteBuildFragment(html, context) {
            var tmp, tag, wrap, finalHtml, i, fragment = context.createDocumentFragment(),
                nodes = [];
            if (jqLiteIsTextNode(html)) nodes.push(context.createTextNode(html));
            else {
                if (tmp = fragment.appendChild(context.createElement("div")), tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase(), finalHtml = JQLite.legacyXHTMLReplacement ? html.replace(XHTML_TAG_REGEXP, "<$1></$2>") : html, msie < 10)
                    for (wrap = wrapMapIE9[tag] || wrapMapIE9._default, tmp.innerHTML = wrap[1] + finalHtml + wrap[2], i = wrap[0]; i--;) tmp = tmp.firstChild;
                else {
                    for (wrap = wrapMap[tag] || [], i = wrap.length; --i > -1;) tmp.appendChild(window.document.createElement(wrap[i])), tmp = tmp.firstChild;
                    tmp.innerHTML = finalHtml
                }
                nodes = concat(nodes, tmp.childNodes), tmp = fragment.firstChild, tmp.textContent = ""
            }
            return fragment.textContent = "", fragment.innerHTML = "", forEach(nodes, function(node) {
                fragment.appendChild(node)
            }), fragment
        }

        function jqLiteParseHTML(html, context) {
            context = context || window.document;
            var parsed;
            return (parsed = SINGLE_TAG_REGEXP.exec(html)) ? [context.createElement(parsed[1])] : (parsed = jqLiteBuildFragment(html, context)) ? parsed.childNodes : []
        }

        function jqLiteWrapNode(node, wrapper) {
            var parent = node.parentNode;
            parent && parent.replaceChild(wrapper, node), wrapper.appendChild(node)
        }

        function JQLite(element) {
            if (element instanceof JQLite) return element;
            var argIsString;
            if (isString(element) && (element = trim(element), argIsString = !0), !(this instanceof JQLite)) {
                if (argIsString && "<" !== element.charAt(0)) throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
                return new JQLite(element)
            }
            argIsString ? jqLiteAddNodes(this, jqLiteParseHTML(element)) : isFunction(element) ? jqLiteReady(element) : jqLiteAddNodes(this, element)
        }

        function jqLiteClone(element) {
            return element.cloneNode(!0)
        }

        function jqLiteDealoc(element, onlyDescendants) {
            !onlyDescendants && jqLiteAcceptsData(element) && jqLite.cleanData([element]), element.querySelectorAll && jqLite.cleanData(element.querySelectorAll("*"))
        }

        function isEmptyObject(obj) {
            var name;
            for (name in obj) return !1;
            return !0
        }

        function removeIfEmptyData(element) {
            var expandoId = element.ng339,
                expandoStore = expandoId && jqCache[expandoId],
                events = expandoStore && expandoStore.events,
                data = expandoStore && expandoStore.data;
            data && !isEmptyObject(data) || events && !isEmptyObject(events) || (delete jqCache[expandoId], element.ng339 = void 0)
        }

        function jqLiteOff(element, type, fn, unsupported) {
            if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
            var expandoStore = jqLiteExpandoStore(element),
                events = expandoStore && expandoStore.events,
                handle = expandoStore && expandoStore.handle;
            if (handle) {
                if (type) {
                    var removeHandler = function(type) {
                        var listenerFns = events[type];
                        isDefined(fn) && arrayRemove(listenerFns || [], fn), isDefined(fn) && listenerFns && listenerFns.length > 0 || (element.removeEventListener(type, handle), delete events[type])
                    };
                    forEach(type.split(" "), function(type) {
                        removeHandler(type), MOUSE_EVENT_MAP[type] && removeHandler(MOUSE_EVENT_MAP[type])
                    })
                } else
                    for (type in events) "$destroy" !== type && element.removeEventListener(type, handle), delete events[type];
                removeIfEmptyData(element)
            }
        }

        function jqLiteRemoveData(element, name) {
            var expandoId = element.ng339,
                expandoStore = expandoId && jqCache[expandoId];
            expandoStore && (name ? delete expandoStore.data[name] : expandoStore.data = {}, removeIfEmptyData(element))
        }

        function jqLiteExpandoStore(element, createIfNecessary) {
            var expandoId = element.ng339,
                expandoStore = expandoId && jqCache[expandoId];
            return createIfNecessary && !expandoStore && (element.ng339 = expandoId = jqNextId(), expandoStore = jqCache[expandoId] = {
                events: {},
                data: {},
                handle: void 0
            }), expandoStore
        }

        function jqLiteData(element, key, value) {
            if (jqLiteAcceptsData(element)) {
                var prop, isSimpleSetter = isDefined(value),
                    isSimpleGetter = !isSimpleSetter && key && !isObject(key),
                    massGetter = !key,
                    expandoStore = jqLiteExpandoStore(element, !isSimpleGetter),
                    data = expandoStore && expandoStore.data;
                if (isSimpleSetter) data[kebabToCamel(key)] = value;
                else {
                    if (massGetter) return data;
                    if (isSimpleGetter) return data && data[kebabToCamel(key)];
                    for (prop in key) data[kebabToCamel(prop)] = key[prop]
                }
            }
        }

        function jqLiteHasClass(element, selector) {
            return !!element.getAttribute && (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1
        }

        function jqLiteRemoveClass(element, cssClasses) {
            if (cssClasses && element.setAttribute) {
                var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " "),
                    newClasses = existingClasses;
                forEach(cssClasses.split(" "), function(cssClass) {
                    cssClass = trim(cssClass), newClasses = newClasses.replace(" " + cssClass + " ", " ")
                }), newClasses !== existingClasses && element.setAttribute("class", trim(newClasses))
            }
        }

        function jqLiteAddClass(element, cssClasses) {
            if (cssClasses && element.setAttribute) {
                var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " "),
                    newClasses = existingClasses;
                forEach(cssClasses.split(" "), function(cssClass) {
                    cssClass = trim(cssClass), newClasses.indexOf(" " + cssClass + " ") === -1 && (newClasses += cssClass + " ")
                }), newClasses !== existingClasses && element.setAttribute("class", trim(newClasses))
            }
        }

        function jqLiteAddNodes(root, elements) {
            if (elements)
                if (elements.nodeType) root[root.length++] = elements;
                else {
                    var length = elements.length;
                    if ("number" == typeof length && elements.window !== elements) {
                        if (length)
                            for (var i = 0; i < length; i++) root[root.length++] = elements[i]
                    } else root[root.length++] = elements
                }
        }

        function jqLiteController(element, name) {
            return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller")
        }

        function jqLiteInheritedData(element, name, value) {
            element.nodeType === NODE_TYPE_DOCUMENT && (element = element.documentElement);
            for (var names = isArray(name) ? name : [name]; element;) {
                for (var i = 0, ii = names.length; i < ii; i++)
                    if (isDefined(value = jqLite.data(element, names[i]))) return value;
                element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host
            }
        }

        function jqLiteEmpty(element) {
            for (jqLiteDealoc(element, !0); element.firstChild;) element.removeChild(element.firstChild)
        }

        function jqLiteRemove(element, keepData) {
            keepData || jqLiteDealoc(element);
            var parent = element.parentNode;
            parent && parent.removeChild(element)
        }

        function jqLiteDocumentLoaded(action, win) {
            win = win || window, "complete" === win.document.readyState ? win.setTimeout(action) : jqLite(win).on("load", action)
        }

        function jqLiteReady(fn) {
            function trigger() {
                window.document.removeEventListener("DOMContentLoaded", trigger), window.removeEventListener("load", trigger), fn()
            }
            "complete" === window.document.readyState ? window.setTimeout(fn) : (window.document.addEventListener("DOMContentLoaded", trigger), window.addEventListener("load", trigger))
        }

        function getBooleanAttrName(element, name) {
            var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
            return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr
        }

        function getAliasedAttrName(name) {
            return ALIASED_ATTR[name]
        }

        function createEventHandler(element, events) {
            var eventHandler = function(event, type) {
                event.isDefaultPrevented = function() {
                    return event.defaultPrevented
                };
                var eventFns = events[type || event.type],
                    eventFnsLength = eventFns ? eventFns.length : 0;
                if (eventFnsLength) {
                    if (isUndefined(event.immediatePropagationStopped)) {
                        var originalStopImmediatePropagation = event.stopImmediatePropagation;
                        event.stopImmediatePropagation = function() {
                            event.immediatePropagationStopped = !0, event.stopPropagation && event.stopPropagation(), originalStopImmediatePropagation && originalStopImmediatePropagation.call(event)
                        }
                    }
                    event.isImmediatePropagationStopped = function() {
                        return event.immediatePropagationStopped === !0
                    };
                    var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
                    eventFnsLength > 1 && (eventFns = shallowCopy(eventFns));
                    for (var i = 0; i < eventFnsLength; i++) event.isImmediatePropagationStopped() || handlerWrapper(element, event, eventFns[i])
                }
            };
            return eventHandler.elem = element, eventHandler
        }

        function defaultHandlerWrapper(element, event, handler) {
            handler.call(element, event)
        }

        function specialMouseHandlerWrapper(target, event, handler) {
            var related = event.relatedTarget;
            related && (related === target || jqLiteContains.call(target, related)) || handler.call(target, event)
        }

        function $$jqLiteProvider() {
            this.$get = function() {
                return extend(JQLite, {
                    hasClass: function(node, classes) {
                        return node.attr && (node = node[0]), jqLiteHasClass(node, classes)
                    },
                    addClass: function(node, classes) {
                        return node.attr && (node = node[0]), jqLiteAddClass(node, classes)
                    },
                    removeClass: function(node, classes) {
                        return node.attr && (node = node[0]), jqLiteRemoveClass(node, classes)
                    }
                })
            }
        }

        function hashKey(obj, nextUidFn) {
            var key = obj && obj.$$hashKey;
            if (key) return "function" == typeof key && (key = obj.$$hashKey()), key;
            var objType = _typeof2(obj);
            return key = "function" === objType || "object" === objType && null !== obj ? obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)() : objType + ":" + obj
        }

        function NgMapShim() {
            this._keys = [], this._values = [], this._lastKey = NaN, this._lastIndex = -1
        }

        function stringifyFn(fn) {
            return Function.prototype.toString.call(fn)
        }

        function extractArgs(fn) {
            var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, ""),
                args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
            return args
        }

        function anonFn(fn) {
            var args = extractArgs(fn);
            return args ? "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn"
        }

        function annotate(fn, strictDi, name) {
            var $inject, argDecl, last;
            if ("function" == typeof fn) {
                if (!($inject = fn.$inject)) {
                    if ($inject = [], fn.length) {
                        if (strictDi) throw isString(name) && name || (name = fn.name || anonFn(fn)), $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                        argDecl = extractArgs(fn), forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg) {
                            arg.replace(FN_ARG, function(all, underscore, name) {
                                $inject.push(name)
                            })
                        })
                    }
                    fn.$inject = $inject
                }
            } else isArray(fn) ? (last = fn.length - 1, assertArgFn(fn[last], "fn"), $inject = fn.slice(0, last)) : assertArgFn(fn, "fn", !0);
            return $inject
        }

        function createInjector(modulesToLoad, strictDi) {
            function supportObject(delegate) {
                return function(key, value) {
                    return isObject(key) ? void forEach(key, reverseParams(delegate)) : delegate(key, value)
                }
            }

            function provider(name, provider_) {
                if (assertNotHasOwnProperty(name, "service"), (isFunction(provider_) || isArray(provider_)) && (provider_ = providerInjector.instantiate(provider_)), !provider_.$get) throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
                return providerCache[name + providerSuffix] = provider_
            }

            function enforceReturnValue(name, factory) {
                return function() {
                    var result = instanceInjector.invoke(factory, this);
                    if (isUndefined(result)) throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                    return result
                }
            }

            function factory(name, factoryFn, enforce) {
                return provider(name, {
                    $get: enforce !== !1 ? enforceReturnValue(name, factoryFn) : factoryFn
                })
            }

            function service(name, constructor) {
                return factory(name, ["$injector", function($injector) {
                    return $injector.instantiate(constructor)
                }])
            }

            function value(name, val) {
                return factory(name, valueFn(val), !1)
            }

            function constant(name, value) {
                assertNotHasOwnProperty(name, "constant"), providerCache[name] = value, instanceCache[name] = value
            }

            function decorator(serviceName, decorFn) {
                var origProvider = providerInjector.get(serviceName + providerSuffix),
                    orig$get = origProvider.$get;
                origProvider.$get = function() {
                    var origInstance = instanceInjector.invoke(orig$get, origProvider);
                    return instanceInjector.invoke(decorFn, null, {
                        $delegate: origInstance
                    })
                }
            }

            function loadModules(modulesToLoad) {
                assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), "modulesToLoad", "not an array");
                var moduleFn, runBlocks = [];
                return forEach(modulesToLoad, function(module) {
                    function runInvokeQueue(queue) {
                        var i, ii;
                        for (i = 0, ii = queue.length; i < ii; i++) {
                            var invokeArgs = queue[i],
                                provider = providerInjector.get(invokeArgs[0]);
                            provider[invokeArgs[1]].apply(provider, invokeArgs[2])
                        }
                    }
                    if (!loadedModules.get(module)) {
                        loadedModules.set(module, !0);
                        try {
                            isString(module) ? (moduleFn = angularModule(module), instanceInjector.modules[module] = moduleFn, runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks), runInvokeQueue(moduleFn._invokeQueue), runInvokeQueue(moduleFn._configBlocks)) : isFunction(module) ? runBlocks.push(providerInjector.invoke(module)) : isArray(module) ? runBlocks.push(providerInjector.invoke(module)) : assertArgFn(module, "module")
                        } catch (e) {
                            throw isArray(module) && (module = module[module.length - 1]), e.message && e.stack && e.stack.indexOf(e.message) === -1 && (e = e.message + "\n" + e.stack), $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e)
                        }
                    }
                }), runBlocks
            }

            function createInternalInjector(cache, factory) {
                function getService(serviceName, caller) {
                    if (cache.hasOwnProperty(serviceName)) {
                        if (cache[serviceName] === INSTANTIATING) throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                        return cache[serviceName]
                    }
                    try {
                        return path.unshift(serviceName), cache[serviceName] = INSTANTIATING, cache[serviceName] = factory(serviceName, caller), cache[serviceName]
                    } catch (err) {
                        throw cache[serviceName] === INSTANTIATING && delete cache[serviceName], err
                    } finally {
                        path.shift()
                    }
                }

                function injectionArgs(fn, locals, serviceName) {
                    for (var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName), i = 0, length = $inject.length; i < length; i++) {
                        var key = $inject[i];
                        if ("string" != typeof key) throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                        args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName))
                    }
                    return args
                }

                function isClass(func) {
                    if (msie || "function" != typeof func) return !1;
                    var result = func.$$ngIsClass;
                    return isBoolean(result) || (result = func.$$ngIsClass = /^class\b/.test(stringifyFn(func))), result
                }

                function invoke(fn, self, locals, serviceName) {
                    "string" == typeof locals && (serviceName = locals, locals = null);
                    var args = injectionArgs(fn, locals, serviceName);
                    return isArray(fn) && (fn = fn[fn.length - 1]), isClass(fn) ? (args.unshift(null), new(Function.prototype.bind.apply(fn, args))) : fn.apply(self, args)
                }

                function instantiate(Type, locals, serviceName) {
                    var ctor = isArray(Type) ? Type[Type.length - 1] : Type,
                        args = injectionArgs(Type, locals, serviceName);
                    return args.unshift(null), new(Function.prototype.bind.apply(ctor, args))
                }
                return {
                    invoke: invoke,
                    instantiate: instantiate,
                    get: getService,
                    annotate: createInjector.$$annotate,
                    has: function(name) {
                        return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name)
                    }
                }
            }
            strictDi = strictDi === !0;
            var INSTANTIATING = {},
                providerSuffix = "Provider",
                path = [],
                loadedModules = new NgMap,
                providerCache = {
                    $provide: {
                        provider: supportObject(provider),
                        factory: supportObject(factory),
                        service: supportObject(service),
                        value: supportObject(value),
                        constant: supportObject(constant),
                        decorator: decorator
                    }
                },
                providerInjector = providerCache.$injector = createInternalInjector(providerCache, function(serviceName, caller) {
                    throw angular.isString(caller) && path.push(caller), $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "))
                }),
                instanceCache = {},
                protoInstanceInjector = createInternalInjector(instanceCache, function(serviceName, caller) {
                    var provider = providerInjector.get(serviceName + providerSuffix, caller);
                    return instanceInjector.invoke(provider.$get, provider, void 0, serviceName)
                }),
                instanceInjector = protoInstanceInjector;
            providerCache["$injector" + providerSuffix] = {
                $get: valueFn(protoInstanceInjector)
            }, instanceInjector.modules = providerInjector.modules = createMap();
            var runBlocks = loadModules(modulesToLoad);
            return instanceInjector = protoInstanceInjector.get("$injector"), instanceInjector.strictDi = strictDi, forEach(runBlocks, function(fn) {
                fn && instanceInjector.invoke(fn)
            }), instanceInjector.loadNewModules = function(mods) {
                forEach(loadModules(mods), function(fn) {
                    fn && instanceInjector.invoke(fn)
                })
            }, instanceInjector
        }

        function $AnchorScrollProvider() {
            var autoScrollingEnabled = !0;
            this.disableAutoScrolling = function() {
                autoScrollingEnabled = !1
            }, this.$get = ["$window", "$location", "$rootScope", function($window, $location, $rootScope) {
                function getFirstAnchor(list) {
                    var result = null;
                    return Array.prototype.some.call(list, function(element) {
                        if ("a" === nodeName_(element)) return result = element, !0
                    }), result
                }

                function getYOffset() {
                    var offset = scroll.yOffset;
                    if (isFunction(offset)) offset = offset();
                    else if (isElement(offset)) {
                        var elem = offset[0],
                            style = $window.getComputedStyle(elem);
                        offset = "fixed" !== style.position ? 0 : elem.getBoundingClientRect().bottom
                    } else isNumber(offset) || (offset = 0);
                    return offset
                }

                function scrollTo(elem) {
                    if (elem) {
                        elem.scrollIntoView();
                        var offset = getYOffset();
                        if (offset) {
                            var elemTop = elem.getBoundingClientRect().top;
                            $window.scrollBy(0, elemTop - offset)
                        }
                    } else $window.scrollTo(0, 0)
                }

                function scroll(hash) {
                    hash = isString(hash) ? hash : isNumber(hash) ? hash.toString() : $location.hash();
                    var elm;
                    hash ? (elm = document.getElementById(hash)) ? scrollTo(elm) : (elm = getFirstAnchor(document.getElementsByName(hash))) ? scrollTo(elm) : "top" === hash && scrollTo(null) : scrollTo(null)
                }
                var document = $window.document;
                return autoScrollingEnabled && $rootScope.$watch(function() {
                    return $location.hash()
                }, function(newVal, oldVal) {
                    newVal === oldVal && "" === newVal || jqLiteDocumentLoaded(function() {
                        $rootScope.$evalAsync(scroll)
                    })
                }), scroll
            }]
        }

        function mergeClasses(a, b) {
            return a || b ? a ? b ? (isArray(a) && (a = a.join(" ")), isArray(b) && (b = b.join(" ")), a + " " + b) : a : b : ""
        }

        function extractElementNode(element) {
            for (var i = 0; i < element.length; i++) {
                var elm = element[i];
                if (elm.nodeType === ELEMENT_NODE) return elm
            }
        }

        function splitClasses(classes) {
            isString(classes) && (classes = classes.split(" "));
            var obj = createMap();
            return forEach(classes, function(klass) {
                klass.length && (obj[klass] = !0)
            }), obj
        }

        function prepareAnimateOptions(options) {
            return isObject(options) ? options : {}
        }

        function getHash(url) {
            var index = url.indexOf("#");
            return index === -1 ? "" : url.substr(index)
        }

        function trimEmptyHash(url) {
            return url.replace(/#$/, "")
        }

        function Browser(window, document, $log, $sniffer, $$taskTrackerFactory) {
            function cacheStateAndFireUrlChange() {
                pendingLocation = null, fireStateOrUrlChange()
            }

            function cacheState() {
                cachedState = getCurrentState(), cachedState = isUndefined(cachedState) ? null : cachedState, equals(cachedState, lastCachedState) && (cachedState = lastCachedState), lastCachedState = cachedState, lastHistoryState = cachedState
            }

            function fireStateOrUrlChange() {
                var prevLastHistoryState = lastHistoryState;
                cacheState(), lastBrowserUrl === self.url() && prevLastHistoryState === cachedState || (lastBrowserUrl = self.url(), lastHistoryState = cachedState, forEach(urlChangeListeners, function(listener) {
                    listener(self.url(), cachedState)
                }))
            }
            var self = this,
                location = window.location,
                history = window.history,
                setTimeout = window.setTimeout,
                clearTimeout = window.clearTimeout,
                pendingDeferIds = {},
                taskTracker = $$taskTrackerFactory($log);
            self.isMock = !1, self.$$completeOutstandingRequest = taskTracker.completeTask, self.$$incOutstandingRequestCount = taskTracker.incTaskCount, self.notifyWhenNoOutstandingRequests = taskTracker.notifyWhenNoPendingTasks;
            var cachedState, lastHistoryState, lastBrowserUrl = location.href,
                baseElement = document.find("base"),
                pendingLocation = null,
                getCurrentState = $sniffer.history ? function() {
                    try {
                        return history.state
                    } catch (e) {}
                } : noop;
            cacheState(), self.url = function(url, replace, state) {
                if (isUndefined(state) && (state = null), location !== window.location && (location = window.location), history !== window.history && (history = window.history), url) {
                    var sameState = lastHistoryState === state;
                    if (url = urlResolve(url).href, lastBrowserUrl === url && (!$sniffer.history || sameState)) return self;
                    var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                    return lastBrowserUrl = url, lastHistoryState = state, !$sniffer.history || sameBase && sameState ? (sameBase || (pendingLocation = url), replace ? location.replace(url) : sameBase ? location.hash = getHash(url) : location.href = url, location.href !== url && (pendingLocation = url)) : (history[replace ? "replaceState" : "pushState"](state, "", url), cacheState()), pendingLocation && (pendingLocation = url), self
                }
                return trimEmptyHash(pendingLocation || location.href)
            }, self.state = function() {
                return cachedState
            };
            var urlChangeListeners = [],
                urlChangeInit = !1,
                lastCachedState = null;
            self.onUrlChange = function(callback) {
                return urlChangeInit || ($sniffer.history && jqLite(window).on("popstate", cacheStateAndFireUrlChange), jqLite(window).on("hashchange", cacheStateAndFireUrlChange), urlChangeInit = !0), urlChangeListeners.push(callback), callback
            }, self.$$applicationDestroyed = function() {
                jqLite(window).off("hashchange popstate", cacheStateAndFireUrlChange)
            }, self.$$checkUrlChange = fireStateOrUrlChange, self.baseHref = function() {
                var href = baseElement.attr("href");
                return href ? href.replace(/^(https?:)?\/\/[^/]*/, "") : ""
            }, self.defer = function(fn, delay, taskType) {
                var timeoutId;
                return delay = delay || 0, taskType = taskType || taskTracker.DEFAULT_TASK_TYPE, taskTracker.incTaskCount(taskType), timeoutId = setTimeout(function() {
                    delete pendingDeferIds[timeoutId], taskTracker.completeTask(fn, taskType)
                }, delay), pendingDeferIds[timeoutId] = taskType, timeoutId
            }, self.defer.cancel = function(deferId) {
                if (pendingDeferIds.hasOwnProperty(deferId)) {
                    var taskType = pendingDeferIds[deferId];
                    return delete pendingDeferIds[deferId], clearTimeout(deferId), taskTracker.completeTask(noop, taskType), !0
                }
                return !1
            }
        }

        function $BrowserProvider() {
            this.$get = ["$window", "$log", "$sniffer", "$document", "$$taskTrackerFactory", function($window, $log, $sniffer, $document, $$taskTrackerFactory) {
                return new Browser($window, $document, $log, $sniffer, $$taskTrackerFactory)
            }]
        }

        function $CacheFactoryProvider() {
            this.$get = function() {
                function cacheFactory(cacheId, options) {
                    function refresh(entry) {
                        entry !== freshEnd && (staleEnd ? staleEnd === entry && (staleEnd = entry.n) : staleEnd = entry, link(entry.n, entry.p), link(entry, freshEnd), freshEnd = entry, freshEnd.n = null)
                    }

                    function link(nextEntry, prevEntry) {
                        nextEntry !== prevEntry && (nextEntry && (nextEntry.p = prevEntry), prevEntry && (prevEntry.n = nextEntry))
                    }
                    if (cacheId in caches) throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                    var size = 0,
                        stats = extend({}, options, {
                            id: cacheId
                        }),
                        data = createMap(),
                        capacity = options && options.capacity || Number.MAX_VALUE,
                        lruHash = createMap(),
                        freshEnd = null,
                        staleEnd = null;
                    return caches[cacheId] = {
                        put: function(key, value) {
                            if (!isUndefined(value)) {
                                if (capacity < Number.MAX_VALUE) {
                                    var lruEntry = lruHash[key] || (lruHash[key] = {
                                        key: key
                                    });
                                    refresh(lruEntry)
                                }
                                return key in data || size++, data[key] = value, size > capacity && this.remove(staleEnd.key), value
                            }
                        },
                        get: function(key) {
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key];
                                if (!lruEntry) return;
                                refresh(lruEntry)
                            }
                            return data[key]
                        },
                        remove: function(key) {
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key];
                                if (!lruEntry) return;
                                lruEntry === freshEnd && (freshEnd = lruEntry.p), lruEntry === staleEnd && (staleEnd = lruEntry.n), link(lruEntry.n, lruEntry.p), delete lruHash[key]
                            }
                            key in data && (delete data[key], size--)
                        },
                        removeAll: function() {
                            data = createMap(), size = 0, lruHash = createMap(), freshEnd = staleEnd = null
                        },
                        destroy: function() {
                            data = null, stats = null, lruHash = null, delete caches[cacheId]
                        },
                        info: function() {
                            return extend({}, stats, {
                                size: size
                            })
                        }
                    }
                }
                var caches = {};
                return cacheFactory.info = function() {
                    var info = {};
                    return forEach(caches, function(cache, cacheId) {
                        info[cacheId] = cache.info()
                    }), info
                }, cacheFactory.get = function(cacheId) {
                    return caches[cacheId]
                }, cacheFactory
            }
        }

        function $TemplateCacheProvider() {
            this.$get = ["$cacheFactory", function($cacheFactory) {
                return $cacheFactory("templates")
            }]
        }

        function UNINITIALIZED_VALUE() {}

        function $CompileProvider($provide, $$sanitizeUriProvider) {
            function parseIsolateBindings(scope, directiveName, isController) {
                var LOCAL_REGEXP = /^([@&]|[=<](\*?))(\??)\s*([\w$]*)$/,
                    bindings = createMap();
                return forEach(scope, function(definition, scopeName) {
                    if (definition = definition.trim(), definition in bindingCache) return void(bindings[scopeName] = bindingCache[definition]);
                    var match = definition.match(LOCAL_REGEXP);
                    if (!match) throw $compileMinErr("iscp", "Invalid {3} for directive '{0}'. Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, isController ? "controller bindings definition" : "isolate scope definition");
                    bindings[scopeName] = {
                        mode: match[1][0],
                        collection: "*" === match[2],
                        optional: "?" === match[3],
                        attrName: match[4] || scopeName
                    }, match[4] && (bindingCache[definition] = bindings[scopeName])
                }), bindings
            }

            function parseDirectiveBindings(directive, directiveName) {
                var bindings = {
                    isolateScope: null,
                    bindToController: null
                };
                if (isObject(directive.scope) && (directive.bindToController === !0 ? (bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, !0), bindings.isolateScope = {}) : bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, !1)), isObject(directive.bindToController) && (bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, !0)), bindings.bindToController && !directive.controller) throw $compileMinErr("noctrl", "Cannot bind to controller without directive '{0}'s controller.", directiveName);
                return bindings
            }

            function assertValidDirectiveName(name) {
                var letter = name.charAt(0);
                if (!letter || letter !== lowercase(letter)) throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
                if (name !== name.trim()) throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name)
            }

            function getDirectiveRequire(directive) {
                var require = directive.require || directive.controller && directive.name;
                return !isArray(require) && isObject(require) && forEach(require, function(value, key) {
                    var match = value.match(REQUIRE_PREFIX_REGEXP),
                        name = value.substring(match[0].length);
                    name || (require[key] = match[0] + key)
                }), require
            }

            function getDirectiveRestrict(restrict, name) {
                if (restrict && (!isString(restrict) || !/[EACM]/.test(restrict))) throw $compileMinErr("badrestrict", "Restrict property '{0}' of directive '{1}' is invalid", restrict, name);
                return restrict || "EA"
            }
            var hasDirectives = {},
                Suffix = "Directive",
                COMMENT_DIRECTIVE_REGEXP = /^\s*directive:\s*([\w-]+)\s+(.*)$/,
                CLASS_DIRECTIVE_REGEXP = /(([\w-]+)(?::([^;]+))?;?)/,
                ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"),
                REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/,
                EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/,
                bindingCache = createMap();
            this.directive = function registerDirective(name, directiveFactory) {
                return assertArg(name, "name"), assertNotHasOwnProperty(name, "directive"), isString(name) ? (assertValidDirectiveName(name), assertArg(directiveFactory, "directiveFactory"), hasDirectives.hasOwnProperty(name) || (hasDirectives[name] = [], $provide.factory(name + Suffix, ["$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                    var directives = [];
                    return forEach(hasDirectives[name], function(directiveFactory, index) {
                        try {
                            var directive = $injector.invoke(directiveFactory);
                            isFunction(directive) ? directive = {
                                compile: valueFn(directive)
                            } : !directive.compile && directive.link && (directive.compile = valueFn(directive.link)), directive.priority = directive.priority || 0, directive.index = index, directive.name = directive.name || name, directive.require = getDirectiveRequire(directive), directive.restrict = getDirectiveRestrict(directive.restrict, name), directive.$$moduleName = directiveFactory.$$moduleName, directives.push(directive)
                        } catch (e) {
                            $exceptionHandler(e)
                        }
                    }), directives
                }])), hasDirectives[name].push(directiveFactory)) : forEach(name, reverseParams(registerDirective)), this
            }, this.component = function registerComponent(name, options) {
                function factory($injector) {
                    function makeInjectable(fn) {
                        return isFunction(fn) || isArray(fn) ? function(tElement, tAttrs) {
                            return $injector.invoke(fn, this, {
                                $element: tElement,
                                $attrs: tAttrs
                            })
                        } : fn
                    }
                    var template = options.template || options.templateUrl ? options.template : "",
                        ddo = {
                            controller: controller,
                            controllerAs: identifierForController(options.controller) || options.controllerAs || "$ctrl",
                            template: makeInjectable(template),
                            templateUrl: makeInjectable(options.templateUrl),
                            transclude: options.transclude,
                            scope: {},
                            bindToController: options.bindings || {},
                            restrict: "E",
                            require: options.require
                        };
                    return forEach(options, function(val, key) {
                        "$" === key.charAt(0) && (ddo[key] = val)
                    }), ddo
                }
                if (!isString(name)) return forEach(name, reverseParams(bind(this, registerComponent))), this;
                var controller = options.controller || function() {};
                return forEach(options, function(val, key) {
                    "$" === key.charAt(0) && (factory[key] = val, isFunction(controller) && (controller[key] = val))
                }), factory.$inject = ["$injector"], this.directive(name, factory)
            }, this.aHrefSanitizationWhitelist = function(regexp) {
                return isDefined(regexp) ? ($$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp), this) : $$sanitizeUriProvider.aHrefSanitizationWhitelist()
            }, this.imgSrcSanitizationWhitelist = function(regexp) {
                return isDefined(regexp) ? ($$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp), this) : $$sanitizeUriProvider.imgSrcSanitizationWhitelist()
            };
            var debugInfoEnabled = !0;
            this.debugInfoEnabled = function(enabled) {
                return isDefined(enabled) ? (debugInfoEnabled = enabled, this) : debugInfoEnabled
            };
            var strictComponentBindingsEnabled = !1;
            this.strictComponentBindingsEnabled = function(enabled) {
                return isDefined(enabled) ? (strictComponentBindingsEnabled = enabled, this) : strictComponentBindingsEnabled
            };
            var TTL = 10;
            this.onChangesTtl = function(value) {
                return arguments.length ? (TTL = value, this) : TTL
            };
            var commentDirectivesEnabledConfig = !0;
            this.commentDirectivesEnabled = function(value) {
                return arguments.length ? (commentDirectivesEnabledConfig = value, this) : commentDirectivesEnabledConfig
            };
            var cssClassDirectivesEnabledConfig = !0;
            this.cssClassDirectivesEnabled = function(value) {
                return arguments.length ? (cssClassDirectivesEnabledConfig = value, this) : cssClassDirectivesEnabledConfig
            };
            var PROP_CONTEXTS = createMap();
            this.addPropertySecurityContext = function(elementName, propertyName, ctx) {
                    var key = elementName.toLowerCase() + "|" + propertyName.toLowerCase();
                    if (key in PROP_CONTEXTS && PROP_CONTEXTS[key] !== ctx) throw $compileMinErr("ctxoverride", "Property context '{0}.{1}' already set to '{2}', cannot override to '{3}'.", elementName, propertyName, PROP_CONTEXTS[key], ctx);
                    return PROP_CONTEXTS[key] = ctx, this
                },
                function() {
                    function registerContext(ctx, values) {
                        forEach(values, function(v) {
                            PROP_CONTEXTS[v.toLowerCase()] = ctx
                        })
                    }
                    registerContext(SCE_CONTEXTS.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]), registerContext(SCE_CONTEXTS.CSS, ["*|style"]), registerContext(SCE_CONTEXTS.URL, ["area|href", "area|ping", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "input|src", "ins|cite", "q|cite"]), registerContext(SCE_CONTEXTS.MEDIA_URL, ["audio|src", "img|src", "img|srcset", "source|src", "source|srcset", "track|src", "video|src", "video|poster"]), registerContext(SCE_CONTEXTS.RESOURCE_URL, ["*|formAction", "applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "form|action", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src"])
                }(), this.$get = ["$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$sce", "$animate", function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate) {
                    function flushOnChangesQueue() {
                        try {
                            if (!--onChangesTtl) throw onChangesQueue = void 0, $compileMinErr("infchng", "{0} $onChanges() iterations reached. Aborting!\n", TTL);
                            $rootScope.$apply(function() {
                                for (var i = 0, ii = onChangesQueue.length; i < ii; ++i) try {
                                    onChangesQueue[i]()
                                } catch (e) {
                                    $exceptionHandler(e)
                                }
                                onChangesQueue = void 0
                            })
                        } finally {
                            onChangesTtl++
                        }
                    }

                    function sanitizeSrcset(value, invokeType) {
                        if (!value) return value;
                        if (!isString(value)) throw $compileMinErr("srcset", 'Can\'t pass trusted values to `{0}`: "{1}"', invokeType, value.toString());
                        for (var result = "", trimmedSrcset = trim(value), srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/, pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/, rawUris = trimmedSrcset.split(pattern), nbrUrisWith2parts = Math.floor(rawUris.length / 2), i = 0; i < nbrUrisWith2parts; i++) {
                            var innerIdx = 2 * i;
                            result += $sce.getTrustedMediaUrl(trim(rawUris[innerIdx])), result += " " + trim(rawUris[innerIdx + 1])
                        }
                        var lastTuple = trim(rawUris[2 * i]).split(/\s/);
                        return result += $sce.getTrustedMediaUrl(trim(lastTuple[0])), 2 === lastTuple.length && (result += " " + trim(lastTuple[1])), result
                    }

                    function Attributes(element, attributesToCopy) {
                        if (attributesToCopy) {
                            var i, l, key, keys = Object.keys(attributesToCopy);
                            for (i = 0, l = keys.length; i < l; i++) key = keys[i], this[key] = attributesToCopy[key]
                        } else this.$attr = {};
                        this.$$element = element
                    }

                    function setSpecialAttr(element, attrName, value) {
                        specialAttrHolder.innerHTML = "<span " + attrName + ">";
                        var attributes = specialAttrHolder.firstChild.attributes,
                            attribute = attributes[0];
                        attributes.removeNamedItem(attribute.name), attribute.value = value, element.attributes.setNamedItem(attribute)
                    }

                    function safeAddClass($element, className) {
                        try {
                            $element.addClass(className)
                        } catch (e) {}
                    }

                    function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                        $compileNodes instanceof jqLite || ($compileNodes = jqLite($compileNodes));
                        var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                        compile.$$addScopeClass($compileNodes);
                        var namespace = null;
                        return function(scope, cloneConnectFn, options) {
                            if (!$compileNodes) throw $compileMinErr("multilink", "This element has already been linked.");
                            assertArg(scope, "scope"), previousCompileContext && previousCompileContext.needsNewScope && (scope = scope.$parent.$new()), options = options || {};
                            var parentBoundTranscludeFn = options.parentBoundTranscludeFn,
                                transcludeControllers = options.transcludeControllers,
                                futureParentElement = options.futureParentElement;
                            parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude && (parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude), namespace || (namespace = detectNamespaceForChildElements(futureParentElement));
                            var $linkNode;
                            if ($linkNode = "html" !== namespace ? jqLite(wrapTemplate(namespace, jqLite("<div></div>").append($compileNodes).html())) : cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes, transcludeControllers)
                                for (var controllerName in transcludeControllers) $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                            return compile.$$addScopeInfo($linkNode, scope), cloneConnectFn && cloneConnectFn($linkNode, scope), compositeLinkFn && compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn), cloneConnectFn || ($compileNodes = compositeLinkFn = null), $linkNode
                        }
                    }

                    function detectNamespaceForChildElements(parentElement) {
                        var node = parentElement && parentElement[0];
                        return node && "foreignobject" !== nodeName_(node) && toString.call(node).match(/SVG/) ? "svg" : "html"
                    }

                    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                        function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                            var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn, stableNodeList;
                            if (nodeLinkFnFound) {
                                var nodeListLength = nodeList.length;
                                for (stableNodeList = new Array(nodeListLength), i = 0; i < linkFns.length; i += 3) idx = linkFns[i], stableNodeList[idx] = nodeList[idx]
                            } else stableNodeList = nodeList;
                            for (i = 0, ii = linkFns.length; i < ii;) node = stableNodeList[linkFns[i++]], nodeLinkFn = linkFns[i++], childLinkFn = linkFns[i++], nodeLinkFn ? (nodeLinkFn.scope ? (childScope = scope.$new(), compile.$$addScopeInfo(jqLite(node), childScope)) : childScope = scope, childBoundTranscludeFn = nodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn) : !nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn ? parentBoundTranscludeFn : !parentBoundTranscludeFn && transcludeFn ? createBoundTranscludeFn(scope, transcludeFn) : null, nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn)) : childLinkFn && childLinkFn(scope, node.childNodes, void 0, parentBoundTranscludeFn)
                        }
                        for (var attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound, linkFns = [], notLiveList = isArray(nodeList) || nodeList instanceof jqLite, i = 0; i < nodeList.length; i++) attrs = new Attributes, 11 === msie && mergeConsecutiveTextNodes(nodeList, i, notLiveList), directives = collectDirectives(nodeList[i], [], attrs, 0 === i ? maxPriority : void 0, ignoreDirective), nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null, nodeLinkFn && nodeLinkFn.scope && compile.$$addScopeClass(attrs.$$element), childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn), (nodeLinkFn || childLinkFn) && (linkFns.push(i, nodeLinkFn, childLinkFn), linkFnFound = !0, nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn), previousCompileContext = null;
                        return linkFnFound ? compositeLinkFn : null
                    }

                    function mergeConsecutiveTextNodes(nodeList, idx, notLiveList) {
                        var sibling, node = nodeList[idx],
                            parent = node.parentNode;
                        if (node.nodeType === NODE_TYPE_TEXT)
                            for (;;) {
                                if (sibling = parent ? node.nextSibling : nodeList[idx + 1], !sibling || sibling.nodeType !== NODE_TYPE_TEXT) break;
                                node.nodeValue = node.nodeValue + sibling.nodeValue, sibling.parentNode && sibling.parentNode.removeChild(sibling), notLiveList && sibling === nodeList[idx + 1] && nodeList.splice(idx + 1, 1)
                            }
                    }

                    function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                        function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                            return transcludedScope || (transcludedScope = scope.$new(!1, containingScope), transcludedScope.$$transcluded = !0), transcludeFn(transcludedScope, cloneFn, {
                                parentBoundTranscludeFn: previousBoundTranscludeFn,
                                transcludeControllers: controllers,
                                futureParentElement: futureParentElement
                            })
                        }
                        var boundSlots = boundTranscludeFn.$$slots = createMap();
                        for (var slotName in transcludeFn.$$slots) transcludeFn.$$slots[slotName] ? boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn) : boundSlots[slotName] = null;
                        return boundTranscludeFn
                    }

                    function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                        var match, nodeName, className, nodeType = node.nodeType,
                            attrsMap = attrs.$attr;
                        switch (nodeType) {
                            case NODE_TYPE_ELEMENT:
                                nodeName = nodeName_(node), addDirective(directives, directiveNormalize(nodeName), "E", maxPriority, ignoreDirective);
                                for (var attr, name, nName, value, ngPrefixMatch, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                                    var multiElementMatch, attrStartName = !1,
                                        attrEndName = !1,
                                        isNgAttr = !1,
                                        isNgProp = !1,
                                        isNgEvent = !1;
                                    attr = nAttrs[j], name = attr.name, value = attr.value, nName = directiveNormalize(name.toLowerCase()), (ngPrefixMatch = nName.match(NG_PREFIX_BINDING)) ? (isNgAttr = "Attr" === ngPrefixMatch[1], isNgProp = "Prop" === ngPrefixMatch[1], isNgEvent = "On" === ngPrefixMatch[1], name = name.replace(PREFIX_REGEXP, "").toLowerCase().substr(4 + ngPrefixMatch[1].length).replace(/_(.)/g, function(match, letter) {
                                        return letter.toUpperCase()
                                    })) : (multiElementMatch = nName.match(MULTI_ELEMENT_DIR_RE)) && directiveIsMultiElement(multiElementMatch[1]) && (attrStartName = name, attrEndName = name.substr(0, name.length - 5) + "end", name = name.substr(0, name.length - 6)), isNgProp || isNgEvent ? (attrs[nName] = value, attrsMap[nName] = attr.name, isNgProp ? addPropertyDirective(node, directives, nName, name) : addEventDirective(directives, nName, name)) : (nName = directiveNormalize(name.toLowerCase()), attrsMap[nName] = name, !isNgAttr && attrs.hasOwnProperty(nName) || (attrs[nName] = value, getBooleanAttrName(node, nName) && (attrs[nName] = !0)), addAttrInterpolateDirective(node, directives, value, nName, isNgAttr), addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName))
                                }
                                if ("input" === nodeName && "hidden" === node.getAttribute("type") && node.setAttribute("autocomplete", "off"), !cssClassDirectivesEnabled) break;
                                if (className = node.className, isObject(className) && (className = className.animVal), isString(className) && "" !== className)
                                    for (; match = CLASS_DIRECTIVE_REGEXP.exec(className);) nName = directiveNormalize(match[2]), addDirective(directives, nName, "C", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[3])), className = className.substr(match.index + match[0].length);
                                break;
                            case NODE_TYPE_TEXT:
                                addTextInterpolateDirective(directives, node.nodeValue);
                                break;
                            case NODE_TYPE_COMMENT:
                                if (!commentDirectivesEnabled) break;
                                collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective)
                        }
                        return directives.sort(byPriority), directives
                    }

                    function collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                        try {
                            var match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                            if (match) {
                                var nName = directiveNormalize(match[1]);
                                addDirective(directives, nName, "M", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[2]))
                            }
                        } catch (e) {}
                    }

                    function groupScan(node, attrStart, attrEnd) {
                        var nodes = [],
                            depth = 0;
                        if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                            do {
                                if (!node) throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                                node.nodeType === NODE_TYPE_ELEMENT && (node.hasAttribute(attrStart) && depth++, node.hasAttribute(attrEnd) && depth--), nodes.push(node), node = node.nextSibling
                            } while (depth > 0)
                        } else nodes.push(node);
                        return jqLite(nodes)
                    }

                    function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                        return function(scope, element, attrs, controllers, transcludeFn) {
                            return element = groupScan(element[0], attrStart, attrEnd), linkFn(scope, element, attrs, controllers, transcludeFn)
                        }
                    }

                    function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                        var compiled;
                        return eager ? compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) : function() {
                            return compiled || (compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext), $compileNodes = transcludeFn = previousCompileContext = null), compiled.apply(this, arguments)
                        }
                    }

                    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                        function addLinkFns(pre, post, attrStart, attrEnd) {
                            pre && (attrStart && (pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd)), pre.require = directive.require, pre.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (pre = cloneAndAnnotateFn(pre, {
                                isolateScope: !0
                            })), preLinkFns.push(pre)), post && (attrStart && (post = groupElementsLinkFnWrapper(post, attrStart, attrEnd)), post.require = directive.require, post.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (post = cloneAndAnnotateFn(post, {
                                isolateScope: !0
                            })), postLinkFns.push(post))
                        }

                        function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                            function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                                var transcludeControllers;
                                if (isScope(scope) || (slotName = futureParentElement, futureParentElement = cloneAttachFn, cloneAttachFn = scope, scope = void 0), hasElementTranscludeDirective && (transcludeControllers = elementControllers), futureParentElement || (futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element), !slotName) return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                                var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                                if (slotTranscludeFn) return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                                if (isUndefined(slotTranscludeFn)) throw $compileMinErr("noslot", 'No parent directive that requires a transclusion with slot name "{0}". Element: {1}', slotName, startingTag($element))
                            }
                            var i, ii, linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element, attrs, scopeBindingInfo;
                            compileNode === linkNode ? (attrs = templateAttrs, $element = templateAttrs.$$element) : ($element = jqLite(linkNode), attrs = new Attributes($element, templateAttrs)), controllerScope = scope, newIsolateScopeDirective ? isolateScope = scope.$new(!0) : newScopeDirective && (controllerScope = scope.$parent), boundTranscludeFn && (transcludeFn = controllersBoundTransclude, transcludeFn.$$boundTransclude = boundTranscludeFn, transcludeFn.isSlotFilled = function(slotName) {
                                return !!boundTranscludeFn.$$slots[slotName]
                            }), controllerDirectives && (elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective)), newIsolateScopeDirective && (compile.$$addScopeInfo($element, isolateScope, !0, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective))), compile.$$addScopeClass($element, !0), isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings, scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective), scopeBindingInfo.removeWatches && isolateScope.$on("$destroy", scopeBindingInfo.removeWatches));
                            for (var name in elementControllers) {
                                var controllerDirective = controllerDirectives[name],
                                    controller = elementControllers[name],
                                    bindings = controllerDirective.$$bindings.bindToController;
                                controller.instance = controller(), $element.data("$" + controllerDirective.name + "Controller", controller.instance), controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective)
                            }
                            for (forEach(controllerDirectives, function(controllerDirective, name) {
                                    var require = controllerDirective.require;
                                    controllerDirective.bindToController && !isArray(require) && isObject(require) && extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers))
                                }), forEach(elementControllers, function(controller) {
                                    var controllerInstance = controller.instance;
                                    if (isFunction(controllerInstance.$onChanges)) try {
                                        controllerInstance.$onChanges(controller.bindingInfo.initialChanges)
                                    } catch (e) {
                                        $exceptionHandler(e)
                                    }
                                    if (isFunction(controllerInstance.$onInit)) try {
                                        controllerInstance.$onInit()
                                    } catch (e) {
                                        $exceptionHandler(e)
                                    }
                                    isFunction(controllerInstance.$doCheck) && (controllerScope.$watch(function() {
                                        controllerInstance.$doCheck()
                                    }), controllerInstance.$doCheck()), isFunction(controllerInstance.$onDestroy) && controllerScope.$on("$destroy", function() {
                                        controllerInstance.$onDestroy()
                                    })
                                }), i = 0, ii = preLinkFns.length; i < ii; i++) linkFn = preLinkFns[i], invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                            var scopeToChild = scope;
                            for (newIsolateScopeDirective && (newIsolateScopeDirective.template || null === newIsolateScopeDirective.templateUrl) && (scopeToChild = isolateScope), childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, void 0, boundTranscludeFn), i = postLinkFns.length - 1; i >= 0; i--) linkFn = postLinkFns[i], invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                            forEach(elementControllers, function(controller) {
                                var controllerInstance = controller.instance;
                                isFunction(controllerInstance.$postLink) && controllerInstance.$postLink()
                            })
                        }
                        previousCompileContext = previousCompileContext || {};
                        for (var directive, directiveName, $template, linkFn, directiveValue, terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = !1, hasTemplate = !1, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, didScanForMultipleTransclusion = !1, mightHaveMultipleTransclusionError = !1, i = 0, ii = directives.length; i < ii; i++) {
                            directive = directives[i];
                            var attrStart = directive.$$start,
                                attrEnd = directive.$$end;
                            if (attrStart && ($compileNode = groupScan(compileNode, attrStart, attrEnd)), $template = void 0, terminalPriority > directive.priority) break;
                            if (directiveValue = directive.scope, directiveValue && (directive.templateUrl || (isObject(directiveValue) ? (assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode), newIsolateScopeDirective = directive) : assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode)), newScopeDirective = newScopeDirective || directive), directiveName = directive.name, !didScanForMultipleTransclusion && (directive.replace && (directive.templateUrl || directive.template) || directive.transclude && !directive.$$tlb)) {
                                for (var candidateDirective, scanningIndex = i + 1; candidateDirective = directives[scanningIndex++];)
                                    if (candidateDirective.transclude && !candidateDirective.$$tlb || candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template)) {
                                        mightHaveMultipleTransclusionError = !0;
                                        break
                                    } didScanForMultipleTransclusion = !0
                            }
                            if (!directive.templateUrl && directive.controller && (controllerDirectives = controllerDirectives || createMap(), assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode), controllerDirectives[directiveName] = directive), directiveValue = directive.transclude)
                                if (hasTranscludeDirective = !0, directive.$$tlb || (assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode), nonTlbTranscludeDirective = directive), "element" === directiveValue) hasElementTranscludeDirective = !0, terminalPriority = directive.priority, $template = $compileNode, $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName])), compileNode = $compileNode[0], replaceWith(jqCollection, sliceArgs($template), compileNode), childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                                    nonTlbTranscludeDirective: nonTlbTranscludeDirective
                                });
                                else {
                                    var slots = createMap();
                                    if (isObject(directiveValue)) {
                                        $template = window.document.createDocumentFragment();
                                        var slotMap = createMap(),
                                            filledSlots = createMap();
                                        forEach(directiveValue, function(elementSelector, slotName) {
                                            var optional = "?" === elementSelector.charAt(0);
                                            elementSelector = optional ? elementSelector.substring(1) : elementSelector, slotMap[elementSelector] = slotName, slots[slotName] = null, filledSlots[slotName] = optional
                                        }), forEach($compileNode.contents(), function(node) {
                                            var slotName = slotMap[directiveNormalize(nodeName_(node))];
                                            slotName ? (filledSlots[slotName] = !0, slots[slotName] = slots[slotName] || window.document.createDocumentFragment(), slots[slotName].appendChild(node)) : $template.appendChild(node)
                                        }), forEach(filledSlots, function(filled, slotName) {
                                            if (!filled) throw $compileMinErr("reqslot", "Required transclusion slot `{0}` was not filled.", slotName)
                                        });
                                        for (var slotName in slots)
                                            if (slots[slotName]) {
                                                var slotCompileNodes = jqLite(slots[slotName].childNodes);
                                                slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slotCompileNodes, transcludeFn)
                                            } $template = jqLite($template.childNodes)
                                    } else $template = jqLite(jqLiteClone(compileNode)).contents();
                                    $compileNode.empty(), childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, void 0, void 0, {
                                        needsNewScope: directive.$$isolateScope || directive.$$newScope
                                    }), childTranscludeFn.$$slots = slots
                                } if (directive.template)
                                if (hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), templateDirective = directive, directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template, directiveValue = denormalizeTemplate(directiveValue), directive.replace) {
                                    if (replaceDirective = directive, $template = jqLiteIsTextNode(directiveValue) ? [] : removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue))), compileNode = $template[0], 1 !== $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                                    replaceWith(jqCollection, $compileNode, compileNode);
                                    var newTemplateAttrs = {
                                            $attr: {}
                                        },
                                        templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs),
                                        unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                                    (newIsolateScopeDirective || newScopeDirective) && markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective), directives = directives.concat(templateDirectives).concat(unprocessedDirectives), mergeTemplateAttributes(templateAttrs, newTemplateAttrs), ii = directives.length
                                } else $compileNode.html(directiveValue);
                            if (directive.templateUrl) hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), templateDirective = directive, directive.replace && (replaceDirective = directive), nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                                controllerDirectives: controllerDirectives,
                                newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                                newIsolateScopeDirective: newIsolateScopeDirective,
                                templateDirective: templateDirective,
                                nonTlbTranscludeDirective: nonTlbTranscludeDirective
                            }), ii = directives.length;
                            else if (directive.compile) try {
                                linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                                var context = directive.$$originalDirective || directive;
                                isFunction(linkFn) ? addLinkFns(null, bind(context, linkFn), attrStart, attrEnd) : linkFn && addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd)
                            } catch (e) {
                                $exceptionHandler(e, startingTag($compileNode))
                            }
                            directive.terminal && (nodeLinkFn.terminal = !0, terminalPriority = Math.max(terminalPriority, directive.priority))
                        }
                        return nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === !0, nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective, nodeLinkFn.templateOnThisElement = hasTemplate, nodeLinkFn.transclude = childTranscludeFn, previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective, nodeLinkFn
                    }

                    function getControllers(directiveName, require, $element, elementControllers) {
                        var value;
                        if (isString(require)) {
                            var match = require.match(REQUIRE_PREFIX_REGEXP),
                                name = require.substring(match[0].length),
                                inheritType = match[1] || match[3],
                                optional = "?" === match[2];
                            if ("^^" === inheritType ? $element = $element.parent() : (value = elementControllers && elementControllers[name], value = value && value.instance), !value) {
                                var dataName = "$" + name + "Controller";
                                value = "^^" === inheritType && $element[0] && $element[0].nodeType === NODE_TYPE_DOCUMENT ? null : inheritType ? $element.inheritedData(dataName) : $element.data(dataName);
                            }
                            if (!value && !optional) throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName)
                        } else if (isArray(require)) {
                            value = [];
                            for (var i = 0, ii = require.length; i < ii; i++) value[i] = getControllers(directiveName, require[i], $element, elementControllers)
                        } else isObject(require) && (value = {}, forEach(require, function(controller, property) {
                            value[property] = getControllers(directiveName, controller, $element, elementControllers)
                        }));
                        return value || null
                    }

                    function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
                        var elementControllers = createMap();
                        for (var controllerKey in controllerDirectives) {
                            var directive = controllerDirectives[controllerKey],
                                locals = {
                                    $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                                    $element: $element,
                                    $attrs: attrs,
                                    $transclude: transcludeFn
                                },
                                controller = directive.controller;
                            "@" === controller && (controller = attrs[directive.name]);
                            var controllerInstance = $controller(controller, locals, !0, directive.controllerAs);
                            elementControllers[directive.name] = controllerInstance, $element.data("$" + directive.name + "Controller", controllerInstance.instance)
                        }
                        return elementControllers
                    }

                    function markDirectiveScope(directives, isolateScope, newScope) {
                        for (var j = 0, jj = directives.length; j < jj; j++) directives[j] = inherit(directives[j], {
                            $$isolateScope: isolateScope,
                            $$newScope: newScope
                        })
                    }

                    function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                        if (name === ignoreDirective) return null;
                        var match = null;
                        if (hasDirectives.hasOwnProperty(name))
                            for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++)
                                if (directive = directives[i], (isUndefined(maxPriority) || maxPriority > directive.priority) && directive.restrict.indexOf(location) !== -1) {
                                    if (startAttrName && (directive = inherit(directive, {
                                            $$start: startAttrName,
                                            $$end: endAttrName
                                        })), !directive.$$bindings) {
                                        var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                                        isObject(bindings.isolateScope) && (directive.$$isolateBindings = bindings.isolateScope)
                                    }
                                    tDirectives.push(directive), match = directive
                                } return match
                    }

                    function directiveIsMultiElement(name) {
                        if (hasDirectives.hasOwnProperty(name))
                            for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; i < ii; i++)
                                if (directive = directives[i], directive.multiElement) return !0;
                        return !1
                    }

                    function mergeTemplateAttributes(dst, src) {
                        var srcAttr = src.$attr,
                            dstAttr = dst.$attr;
                        forEach(dst, function(value, key) {
                            "$" !== key.charAt(0) && (src[key] && src[key] !== value && (value.length ? value += ("style" === key ? ";" : " ") + src[key] : value = src[key]), dst.$set(key, value, !0, srcAttr[key]))
                        }), forEach(src, function(value, key) {
                            dst.hasOwnProperty(key) || "$" === key.charAt(0) || (dst[key] = value, "class" !== key && "style" !== key && (dstAttr[key] = srcAttr[key]))
                        })
                    }

                    function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                        var afterTemplateNodeLinkFn, afterTemplateChildLinkFn, linkQueue = [],
                            beforeTemplateCompileNode = $compileNode[0],
                            origAsyncDirective = directives.shift(),
                            derivedSyncDirective = inherit(origAsyncDirective, {
                                templateUrl: null,
                                transclude: null,
                                replace: null,
                                $$originalDirective: origAsyncDirective
                            }),
                            templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl,
                            templateNamespace = origAsyncDirective.templateNamespace;
                        return $compileNode.empty(), $templateRequest(templateUrl).then(function(content) {
                                var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                                if (content = denormalizeTemplate(content), origAsyncDirective.replace) {
                                    if ($template = jqLiteIsTextNode(content) ? [] : removeComments(wrapTemplate(templateNamespace, trim(content))), compileNode = $template[0], 1 !== $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                                    tempTemplateAttrs = {
                                        $attr: {}
                                    }, replaceWith($rootElement, $compileNode, compileNode);
                                    var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                                    isObject(origAsyncDirective.scope) && markDirectiveScope(templateDirectives, !0), directives = templateDirectives.concat(directives), mergeTemplateAttributes(tAttrs, tempTemplateAttrs)
                                } else compileNode = beforeTemplateCompileNode, $compileNode.html(content);
                                for (directives.unshift(derivedSyncDirective), afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext), forEach($rootElement, function(node, i) {
                                        node === compileNode && ($rootElement[i] = $compileNode[0])
                                    }), afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn); linkQueue.length;) {
                                    var scope = linkQueue.shift(),
                                        beforeTemplateLinkNode = linkQueue.shift(),
                                        linkRootElement = linkQueue.shift(),
                                        boundTranscludeFn = linkQueue.shift(),
                                        linkNode = $compileNode[0];
                                    if (!scope.$$destroyed) {
                                        if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                                            var oldClasses = beforeTemplateLinkNode.className;
                                            previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace || (linkNode = jqLiteClone(compileNode)), replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode), safeAddClass(jqLite(linkNode), oldClasses)
                                        }
                                        childBoundTranscludeFn = afterTemplateNodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn) : boundTranscludeFn, afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn)
                                    }
                                }
                                linkQueue = null
                            }).catch(function(error) {
                                isError(error) && $exceptionHandler(error)
                            }),
                            function(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                                var childBoundTranscludeFn = boundTranscludeFn;
                                scope.$$destroyed || (linkQueue ? linkQueue.push(scope, node, rootElement, childBoundTranscludeFn) : (afterTemplateNodeLinkFn.transcludeOnThisElement && (childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn)), afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn)))
                            }
                    }

                    function byPriority(a, b) {
                        var diff = b.priority - a.priority;
                        return 0 !== diff ? diff : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index
                    }

                    function assertNoDuplicate(what, previousDirective, directive, element) {
                        function wrapModuleNameIfDefined(moduleName) {
                            return moduleName ? " (module: " + moduleName + ")" : ""
                        }
                        if (previousDirective) throw $compileMinErr("multidir", "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}", previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element))
                    }

                    function addTextInterpolateDirective(directives, text) {
                        var interpolateFn = $interpolate(text, !0);
                        interpolateFn && directives.push({
                            priority: 0,
                            compile: function(templateNode) {
                                var templateNodeParent = templateNode.parent(),
                                    hasCompileParent = !!templateNodeParent.length;
                                return hasCompileParent && compile.$$addBindingClass(templateNodeParent),
                                    function(scope, node) {
                                        var parent = node.parent();
                                        hasCompileParent || compile.$$addBindingClass(parent), compile.$$addBindingInfo(parent, interpolateFn.expressions), scope.$watch(interpolateFn, function(value) {
                                            node[0].nodeValue = value
                                        })
                                    }
                            }
                        })
                    }

                    function wrapTemplate(type, template) {
                        switch (type = lowercase(type || "html")) {
                            case "svg":
                            case "math":
                                var wrapper = window.document.createElement("div");
                                return wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">", wrapper.childNodes[0].childNodes;
                            default:
                                return template
                        }
                    }

                    function getTrustedAttrContext(nodeName, attrNormalizedName) {
                        return "srcdoc" === attrNormalizedName ? $sce.HTML : "src" === attrNormalizedName || "ngSrc" === attrNormalizedName ? ["img", "video", "audio", "source", "track"].indexOf(nodeName) === -1 ? $sce.RESOURCE_URL : $sce.MEDIA_URL : "xlinkHref" === attrNormalizedName ? "image" === nodeName ? $sce.MEDIA_URL : "a" === nodeName ? $sce.URL : $sce.RESOURCE_URL : "form" === nodeName && "action" === attrNormalizedName || "base" === nodeName && "href" === attrNormalizedName || "link" === nodeName && "href" === attrNormalizedName ? $sce.RESOURCE_URL : "a" !== nodeName || "href" !== attrNormalizedName && "ngHref" !== attrNormalizedName ? void 0 : $sce.URL
                    }

                    function getTrustedPropContext(nodeName, propNormalizedName) {
                        var prop = propNormalizedName.toLowerCase();
                        return PROP_CONTEXTS[nodeName + "|" + prop] || PROP_CONTEXTS["*|" + prop]
                    }

                    function sanitizeSrcsetPropertyValue(value) {
                        return sanitizeSrcset($sce.valueOf(value), "ng-prop-srcset")
                    }

                    function addPropertyDirective(node, directives, attrName, propName) {
                        if (EVENT_HANDLER_ATTR_REGEXP.test(propName)) throw $compileMinErr("nodomevents", "Property bindings for HTML DOM event properties are disallowed");
                        var nodeName = nodeName_(node),
                            trustedContext = getTrustedPropContext(nodeName, propName),
                            sanitizer = identity;
                        "srcset" !== propName || "img" !== nodeName && "source" !== nodeName ? trustedContext && (sanitizer = $sce.getTrusted.bind($sce, trustedContext)) : sanitizer = sanitizeSrcsetPropertyValue, directives.push({
                            priority: 100,
                            compile: function(_, attr) {
                                var ngPropGetter = $parse(attr[attrName]),
                                    ngPropWatch = $parse(attr[attrName], function(val) {
                                        return $sce.valueOf(val)
                                    });
                                return {
                                    pre: function(scope, $element) {
                                        function applyPropValue() {
                                            var propValue = ngPropGetter(scope);
                                            $element[0][propName] = sanitizer(propValue)
                                        }
                                        applyPropValue(), scope.$watch(ngPropWatch, applyPropValue)
                                    }
                                }
                            }
                        })
                    }

                    function addEventDirective(directives, attrName, eventName) {
                        directives.push(createEventDirective($parse, $rootScope, $exceptionHandler, attrName, eventName, !1))
                    }

                    function addAttrInterpolateDirective(node, directives, value, name, isNgAttr) {
                        var nodeName = nodeName_(node),
                            trustedContext = getTrustedAttrContext(nodeName, name),
                            mustHaveExpression = !isNgAttr,
                            allOrNothing = ALL_OR_NOTHING_ATTRS[name] || isNgAttr,
                            interpolateFn = $interpolate(value, mustHaveExpression, trustedContext, allOrNothing);
                        if (interpolateFn) {
                            if ("multiple" === name && "select" === nodeName) throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                            if (EVENT_HANDLER_ATTR_REGEXP.test(name)) throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed");
                            directives.push({
                                priority: 100,
                                compile: function() {
                                    return {
                                        pre: function(scope, element, attr) {
                                            var $$observers = attr.$$observers || (attr.$$observers = createMap()),
                                                newValue = attr[name];
                                            newValue !== value && (interpolateFn = newValue && $interpolate(newValue, !0, trustedContext, allOrNothing), value = newValue), interpolateFn && (attr[name] = interpolateFn(scope), ($$observers[name] || ($$observers[name] = [])).$$inter = !0, (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function(newValue, oldValue) {
                                                "class" === name && newValue !== oldValue ? attr.$updateClass(newValue, oldValue) : attr.$set(name, newValue)
                                            }))
                                        }
                                    }
                                }
                            })
                        }
                    }

                    function replaceWith($rootElement, elementsToRemove, newNode) {
                        var i, ii, firstElementToRemove = elementsToRemove[0],
                            removeCount = elementsToRemove.length,
                            parent = firstElementToRemove.parentNode;
                        if ($rootElement)
                            for (i = 0, ii = $rootElement.length; i < ii; i++)
                                if ($rootElement[i] === firstElementToRemove) {
                                    $rootElement[i++] = newNode;
                                    for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, j2++) j2 < jj ? $rootElement[j] = $rootElement[j2] : delete $rootElement[j];
                                    $rootElement.length -= removeCount - 1, $rootElement.context === firstElementToRemove && ($rootElement.context = newNode);
                                    break
                                } parent && parent.replaceChild(newNode, firstElementToRemove);
                        var fragment = window.document.createDocumentFragment();
                        for (i = 0; i < removeCount; i++) fragment.appendChild(elementsToRemove[i]);
                        for (jqLite.hasData(firstElementToRemove) && (jqLite.data(newNode, jqLite.data(firstElementToRemove)), jqLite(firstElementToRemove).off("$destroy")), jqLite.cleanData(fragment.querySelectorAll("*")), i = 1; i < removeCount; i++) delete elementsToRemove[i];
                        elementsToRemove[0] = newNode, elementsToRemove.length = 1
                    }

                    function cloneAndAnnotateFn(fn, annotation) {
                        return extend(function() {
                            return fn.apply(null, arguments)
                        }, fn, annotation)
                    }

                    function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                        try {
                            linkFn(scope, $element, attrs, controllers, transcludeFn)
                        } catch (e) {
                            $exceptionHandler(e, startingTag($element))
                        }
                    }

                    function strictBindingsCheck(attrName, directiveName) {
                        if (strictComponentBindingsEnabled) throw $compileMinErr("missingattr", "Attribute '{0}' of '{1}' is non-optional and must be set!", attrName, directiveName)
                    }

                    function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
                        function recordChanges(key, currentValue, previousValue) {
                            isFunction(destination.$onChanges) && !simpleCompare(currentValue, previousValue) && (onChangesQueue || (scope.$$postDigest(flushOnChangesQueue), onChangesQueue = []), changes || (changes = {}, onChangesQueue.push(triggerOnChangesHook)), changes[key] && (previousValue = changes[key].previousValue), changes[key] = new SimpleChange(previousValue, currentValue))
                        }

                        function triggerOnChangesHook() {
                            destination.$onChanges(changes), changes = void 0
                        }
                        var changes, removeWatchCollection = [],
                            initialChanges = {};
                        return forEach(bindings, function(definition, scopeName) {
                            var lastValue, parentGet, parentSet, compare, removeWatch, attrName = definition.attrName,
                                optional = definition.optional,
                                mode = definition.mode;
                            switch (mode) {
                                case "@":
                                    optional || hasOwnProperty.call(attrs, attrName) || (strictBindingsCheck(attrName, directive.name), destination[scopeName] = attrs[attrName] = void 0), removeWatch = attrs.$observe(attrName, function(value) {
                                        if (isString(value) || isBoolean(value)) {
                                            var oldValue = destination[scopeName];
                                            recordChanges(scopeName, value, oldValue), destination[scopeName] = value
                                        }
                                    }), attrs.$$observers[attrName].$$scope = scope, lastValue = attrs[attrName], isString(lastValue) ? destination[scopeName] = $interpolate(lastValue)(scope) : isBoolean(lastValue) && (destination[scopeName] = lastValue), initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]), removeWatchCollection.push(removeWatch);
                                    break;
                                case "=":
                                    if (!hasOwnProperty.call(attrs, attrName)) {
                                        if (optional) break;
                                        strictBindingsCheck(attrName, directive.name), attrs[attrName] = void 0
                                    }
                                    if (optional && !attrs[attrName]) break;
                                    parentGet = $parse(attrs[attrName]), compare = parentGet.literal ? equals : simpleCompare, parentSet = parentGet.assign || function() {
                                        throw lastValue = destination[scopeName] = parentGet(scope), $compileMinErr("nonassign", "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name)
                                    }, lastValue = destination[scopeName] = parentGet(scope);
                                    var parentValueWatch = function(parentValue) {
                                        return compare(parentValue, destination[scopeName]) || (compare(parentValue, lastValue) ? parentSet(scope, parentValue = destination[scopeName]) : destination[scopeName] = parentValue), lastValue = parentValue
                                    };
                                    parentValueWatch.$stateful = !0, removeWatch = definition.collection ? scope.$watchCollection(attrs[attrName], parentValueWatch) : scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal), removeWatchCollection.push(removeWatch);
                                    break;
                                case "<":
                                    if (!hasOwnProperty.call(attrs, attrName)) {
                                        if (optional) break;
                                        strictBindingsCheck(attrName, directive.name), attrs[attrName] = void 0
                                    }
                                    if (optional && !attrs[attrName]) break;
                                    parentGet = $parse(attrs[attrName]);
                                    var isLiteral = parentGet.literal,
                                        initialValue = destination[scopeName] = parentGet(scope);
                                    initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]), removeWatch = scope[definition.collection ? "$watchCollection" : "$watch"](parentGet, function(newValue, oldValue) {
                                        if (oldValue === newValue) {
                                            if (oldValue === initialValue || isLiteral && equals(oldValue, initialValue)) return;
                                            oldValue = initialValue
                                        }
                                        recordChanges(scopeName, newValue, oldValue), destination[scopeName] = newValue
                                    }), removeWatchCollection.push(removeWatch);
                                    break;
                                case "&":
                                    if (optional || hasOwnProperty.call(attrs, attrName) || strictBindingsCheck(attrName, directive.name), parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop, parentGet === noop && optional) break;
                                    destination[scopeName] = function(locals) {
                                        return parentGet(scope, locals)
                                    }
                            }
                        }), {
                            initialChanges: initialChanges,
                            removeWatches: removeWatchCollection.length && function() {
                                for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) removeWatchCollection[i]()
                            }
                        }
                    }
                    var onChangesQueue, SIMPLE_ATTR_NAME = /^\w/,
                        specialAttrHolder = window.document.createElement("div"),
                        commentDirectivesEnabled = commentDirectivesEnabledConfig,
                        cssClassDirectivesEnabled = cssClassDirectivesEnabledConfig,
                        onChangesTtl = TTL;
                    Attributes.prototype = {
                        $normalize: directiveNormalize,
                        $addClass: function(classVal) {
                            classVal && classVal.length > 0 && $animate.addClass(this.$$element, classVal)
                        },
                        $removeClass: function(classVal) {
                            classVal && classVal.length > 0 && $animate.removeClass(this.$$element, classVal)
                        },
                        $updateClass: function(newClasses, oldClasses) {
                            var toAdd = tokenDifference(newClasses, oldClasses);
                            toAdd && toAdd.length && $animate.addClass(this.$$element, toAdd);
                            var toRemove = tokenDifference(oldClasses, newClasses);
                            toRemove && toRemove.length && $animate.removeClass(this.$$element, toRemove)
                        },
                        $set: function(key, value, writeAttr, attrName) {
                            var nodeName, node = this.$$element[0],
                                booleanKey = getBooleanAttrName(node, key),
                                aliasedKey = getAliasedAttrName(key),
                                observer = key;
                            booleanKey ? (this.$$element.prop(key, value), attrName = booleanKey) : aliasedKey && (this[aliasedKey] = value, observer = aliasedKey), this[key] = value, attrName ? this.$attr[key] = attrName : (attrName = this.$attr[key], attrName || (this.$attr[key] = attrName = snake_case(key, "-"))), nodeName = nodeName_(this.$$element), "img" === nodeName && "srcset" === key && (this[key] = value = sanitizeSrcset(value, "$set('srcset', value)")), writeAttr !== !1 && (null === value || isUndefined(value) ? this.$$element.removeAttr(attrName) : SIMPLE_ATTR_NAME.test(attrName) ? booleanKey && value === !1 ? this.$$element.removeAttr(attrName) : this.$$element.attr(attrName, value) : setSpecialAttr(this.$$element[0], attrName, value));
                            var $$observers = this.$$observers;
                            $$observers && forEach($$observers[observer], function(fn) {
                                try {
                                    fn(value)
                                } catch (e) {
                                    $exceptionHandler(e)
                                }
                            })
                        },
                        $observe: function(key, fn) {
                            var attrs = this,
                                $$observers = attrs.$$observers || (attrs.$$observers = createMap()),
                                listeners = $$observers[key] || ($$observers[key] = []);
                            return listeners.push(fn), $rootScope.$evalAsync(function() {
                                    listeners.$$inter || !attrs.hasOwnProperty(key) || isUndefined(attrs[key]) || fn(attrs[key])
                                }),
                                function() {
                                    arrayRemove(listeners, fn)
                                }
                        }
                    };
                    var startSymbol = $interpolate.startSymbol(),
                        endSymbol = $interpolate.endSymbol(),
                        denormalizeTemplate = "{{" === startSymbol && "}}" === endSymbol ? identity : function(template) {
                            return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol)
                        },
                        NG_PREFIX_BINDING = /^ng(Attr|Prop|On)([A-Z].*)$/,
                        MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
                    return compile.$$addBindingInfo = debugInfoEnabled ? function($element, binding) {
                        var bindings = $element.data("$binding") || [];
                        isArray(binding) ? bindings = bindings.concat(binding) : bindings.push(binding), $element.data("$binding", bindings)
                    } : noop, compile.$$addBindingClass = debugInfoEnabled ? function($element) {
                        safeAddClass($element, "ng-binding")
                    } : noop, compile.$$addScopeInfo = debugInfoEnabled ? function($element, scope, isolated, noTemplate) {
                        var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                        $element.data(dataName, scope)
                    } : noop, compile.$$addScopeClass = debugInfoEnabled ? function($element, isolated) {
                        safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope")
                    } : noop, compile.$$createComment = function(directiveName, comment) {
                        var content = "";
                        return debugInfoEnabled && (content = " " + (directiveName || "") + ": ", comment && (content += comment + " ")), window.document.createComment(content)
                    }, compile
                }]
        }

        function SimpleChange(previous, current) {
            this.previousValue = previous, this.currentValue = current
        }

        function directiveNormalize(name) {
            return name.replace(PREFIX_REGEXP, "").replace(SPECIAL_CHARS_REGEXP, function(_, letter, offset) {
                return offset ? letter.toUpperCase() : letter
            })
        }

        function tokenDifference(str1, str2) {
            var values = "",
                tokens1 = str1.split(/\s+/),
                tokens2 = str2.split(/\s+/);
            outer: for (var i = 0; i < tokens1.length; i++) {
                for (var token = tokens1[i], j = 0; j < tokens2.length; j++)
                    if (token === tokens2[j]) continue outer;
                values += (values.length > 0 ? " " : "") + token
            }
            return values
        }

        function removeComments(jqNodes) {
            jqNodes = jqLite(jqNodes);
            var i = jqNodes.length;
            if (i <= 1) return jqNodes;
            for (; i--;) {
                var node = jqNodes[i];
                (node.nodeType === NODE_TYPE_COMMENT || node.nodeType === NODE_TYPE_TEXT && "" === node.nodeValue.trim()) && splice.call(jqNodes, i, 1)
            }
            return jqNodes
        }

        function identifierForController(controller, ident) {
            if (ident && isString(ident)) return ident;
            if (isString(controller)) {
                var match = CNTRL_REG.exec(controller);
                if (match) return match[3]
            }
        }

        function $ControllerProvider() {
            var controllers = {};
            this.has = function(name) {
                return controllers.hasOwnProperty(name)
            }, this.register = function(name, constructor) {
                assertNotHasOwnProperty(name, "controller"), isObject(name) ? extend(controllers, name) : controllers[name] = constructor
            }, this.$get = ["$injector", function($injector) {
                function addIdentifier(locals, identifier, instance, name) {
                    if (!locals || !isObject(locals.$scope)) throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                    locals.$scope[identifier] = instance
                }
                return function(expression, locals, later, ident) {
                    var instance, match, constructor, identifier;
                    if (later = later === !0, ident && isString(ident) && (identifier = ident), isString(expression)) {
                        if (match = expression.match(CNTRL_REG), !match) throw $controllerMinErr("ctrlfmt", "Badly formed controller string '{0}'. Must match `__name__ as __id__` or `__name__`.", expression);
                        if (constructor = match[1], identifier = identifier || match[3], expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, !0), !expression) throw $controllerMinErr("ctrlreg", "The controller with the name '{0}' is not registered.", constructor);
                        assertArgFn(expression, constructor, !0)
                    }
                    if (later) {
                        var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                        return instance = Object.create(controllerPrototype || null), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), extend(function() {
                            var result = $injector.invoke(expression, instance, locals, constructor);
                            return result !== instance && (isObject(result) || isFunction(result)) && (instance = result, identifier && addIdentifier(locals, identifier, instance, constructor || expression.name)), instance
                        }, {
                            instance: instance,
                            identifier: identifier
                        })
                    }
                    return instance = $injector.instantiate(expression, locals, constructor), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), instance
                }
            }]
        }

        function $DocumentProvider() {
            this.$get = ["$window", function(window) {
                return jqLite(window.document)
            }]
        }

        function $$IsDocumentHiddenProvider() {
            this.$get = ["$document", "$rootScope", function($document, $rootScope) {
                function changeListener() {
                    hidden = doc.hidden
                }
                var doc = $document[0],
                    hidden = doc && doc.hidden;
                return $document.on("visibilitychange", changeListener), $rootScope.$on("$destroy", function() {
                        $document.off("visibilitychange", changeListener)
                    }),
                    function() {
                        return hidden
                    }
            }]
        }

        function $ExceptionHandlerProvider() {
            this.$get = ["$log", function($log) {
                return function(exception, cause) {
                    $log.error.apply($log, arguments)
                }
            }]
        }

        function serializeValue(v) {
            return isObject(v) ? isDate(v) ? v.toISOString() : toJson(v) : v
        }

        function $HttpParamSerializerProvider() {
            this.$get = function() {
                return function(params) {
                    if (!params) return "";
                    var parts = [];
                    return forEachSorted(params, function(value, key) {
                        null === value || isUndefined(value) || isFunction(value) || (isArray(value) ? forEach(value, function(v) {
                            parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(v)))
                        }) : parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(value))))
                    }), parts.join("&")
                }
            }
        }

        function $HttpParamSerializerJQLikeProvider() {
            this.$get = function() {
                return function(params) {
                    function serialize(toSerialize, prefix, topLevel) {
                        isArray(toSerialize) ? forEach(toSerialize, function(value, index) {
                            serialize(value, prefix + "[" + (isObject(value) ? index : "") + "]")
                        }) : isObject(toSerialize) && !isDate(toSerialize) ? forEachSorted(toSerialize, function(value, key) {
                            serialize(value, prefix + (topLevel ? "" : "[") + key + (topLevel ? "" : "]"))
                        }) : (isFunction(toSerialize) && (toSerialize = toSerialize()), parts.push(encodeUriQuery(prefix) + "=" + (null == toSerialize ? "" : encodeUriQuery(serializeValue(toSerialize)))))
                    }
                    if (!params) return "";
                    var parts = [];
                    return serialize(params, "", !0), parts.join("&")
                }
            }
        }

        function defaultHttpResponseTransform(data, headers) {
            if (isString(data)) {
                var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
                if (tempData) {
                    var contentType = headers("Content-Type"),
                        hasJsonContentType = contentType && 0 === contentType.indexOf(APPLICATION_JSON);
                    if (hasJsonContentType || isJsonLike(tempData)) try {
                        data = fromJson(tempData)
                    } catch (e) {
                        if (!hasJsonContentType) return data;
                        throw $httpMinErr("baddata", 'Data must be a valid JSON object. Received: "{0}". Parse error: "{1}"', data, e)
                    }
                }
            }
            return data
        }

        function isJsonLike(str) {
            var jsonStart = str.match(JSON_START);
            return jsonStart && JSON_ENDS[jsonStart[0]].test(str)
        }

        function parseHeaders(headers) {
            function fillInParsed(key, val) {
                key && (parsed[key] = parsed[key] ? parsed[key] + ", " + val : val)
            }
            var i, parsed = createMap();
            return isString(headers) ? forEach(headers.split("\n"), function(line) {
                i = line.indexOf(":"), fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)))
            }) : isObject(headers) && forEach(headers, function(headerVal, headerKey) {
                fillInParsed(lowercase(headerKey), trim(headerVal))
            }), parsed
        }

        function headersGetter(headers) {
            var headersObj;
            return function(name) {
                if (headersObj || (headersObj = parseHeaders(headers)), name) {
                    var value = headersObj[lowercase(name)];
                    return void 0 === value && (value = null), value
                }
                return headersObj
            }
        }

        function transformData(data, headers, status, fns) {
            return isFunction(fns) ? fns(data, headers, status) : (forEach(fns, function(fn) {
                data = fn(data, headers, status)
            }), data)
        }

        function isSuccess(status) {
            return 200 <= status && status < 300
        }

        function $HttpProvider() {
            var defaults = this.defaults = {
                    transformResponse: [defaultHttpResponseTransform],
                    transformRequest: [function(d) {
                        return !isObject(d) || isFile(d) || isBlob(d) || isFormData(d) ? d : toJson(d)
                    }],
                    headers: {
                        common: {
                            Accept: "application/json, text/plain, */*"
                        },
                        post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                        put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                        patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
                    },
                    xsrfCookieName: "XSRF-TOKEN",
                    xsrfHeaderName: "X-XSRF-TOKEN",
                    paramSerializer: "$httpParamSerializer",
                    jsonpCallbackParam: "callback"
                },
                useApplyAsync = !1;
            this.useApplyAsync = function(value) {
                return isDefined(value) ? (useApplyAsync = !!value, this) : useApplyAsync
            };
            var interceptorFactories = this.interceptors = [],
                xsrfWhitelistedOrigins = this.xsrfWhitelistedOrigins = [];
            this.$get = ["$browser", "$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", "$sce", function($browser, $httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector, $sce) {
                function $http(requestConfig) {
                    function chainInterceptors(promise, interceptors) {
                        for (var i = 0, ii = interceptors.length; i < ii;) {
                            var thenFn = interceptors[i++],
                                rejectFn = interceptors[i++];
                            promise = promise.then(thenFn, rejectFn)
                        }
                        return interceptors.length = 0, promise
                    }

                    function completeOutstandingRequest() {
                        $browser.$$completeOutstandingRequest(noop, "$http")
                    }

                    function executeHeaderFns(headers, config) {
                        var headerContent, processedHeaders = {};
                        return forEach(headers, function(headerFn, header) {
                            isFunction(headerFn) ? (headerContent = headerFn(config), null != headerContent && (processedHeaders[header] = headerContent)) : processedHeaders[header] = headerFn
                        }), processedHeaders
                    }

                    function mergeHeaders(config) {
                        var defHeaderName, lowercaseDefHeaderName, reqHeaderName, defHeaders = defaults.headers,
                            reqHeaders = extend({}, config.headers);
                        defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                        defaultHeadersIteration: for (defHeaderName in defHeaders) {
                            lowercaseDefHeaderName = lowercase(defHeaderName);
                            for (reqHeaderName in reqHeaders)
                                if (lowercase(reqHeaderName) === lowercaseDefHeaderName) continue defaultHeadersIteration;
                            reqHeaders[defHeaderName] = defHeaders[defHeaderName]
                        }
                        return executeHeaderFns(reqHeaders, shallowCopy(config))
                    }

                    function serverRequest(config) {
                        var headers = config.headers,
                            reqData = transformData(config.data, headersGetter(headers), void 0, config.transformRequest);
                        return isUndefined(reqData) && forEach(headers, function(value, header) {
                            "content-type" === lowercase(header) && delete headers[header]
                        }), isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials) && (config.withCredentials = defaults.withCredentials), sendReq(config, reqData).then(transformResponse, transformResponse)
                    }

                    function transformResponse(response) {
                        var resp = extend({}, response);
                        return resp.data = transformData(response.data, response.headers, response.status, config.transformResponse), isSuccess(response.status) ? resp : $q.reject(resp)
                    }
                    if (!isObject(requestConfig)) throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                    if (!isString($sce.valueOf(requestConfig.url))) throw minErr("$http")("badreq", "Http request configuration url must be a string or a $sce trusted object.  Received: {0}", requestConfig.url);
                    var config = extend({
                        method: "get",
                        transformRequest: defaults.transformRequest,
                        transformResponse: defaults.transformResponse,
                        paramSerializer: defaults.paramSerializer,
                        jsonpCallbackParam: defaults.jsonpCallbackParam
                    }, requestConfig);
                    config.headers = mergeHeaders(requestConfig), config.method = uppercase(config.method), config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer, $browser.$$incOutstandingRequestCount("$http");
                    var requestInterceptors = [],
                        responseInterceptors = [],
                        promise = $q.resolve(config);
                    return forEach(reversedInterceptors, function(interceptor) {
                        (interceptor.request || interceptor.requestError) && requestInterceptors.unshift(interceptor.request, interceptor.requestError), (interceptor.response || interceptor.responseError) && responseInterceptors.push(interceptor.response, interceptor.responseError)
                    }), promise = chainInterceptors(promise, requestInterceptors), promise = promise.then(serverRequest), promise = chainInterceptors(promise, responseInterceptors), promise = promise.finally(completeOutstandingRequest)
                }

                function createShortMethods(names) {
                    forEach(arguments, function(name) {
                        $http[name] = function(url, config) {
                            return $http(extend({}, config || {}, {
                                method: name,
                                url: url
                            }))
                        }
                    })
                }

                function createShortMethodsWithData(name) {
                    forEach(arguments, function(name) {
                        $http[name] = function(url, data, config) {
                            return $http(extend({}, config || {}, {
                                method: name,
                                url: url,
                                data: data
                            }))
                        }
                    })
                }

                function sendReq(config, reqData) {
                    function createApplyHandlers(eventHandlers) {
                        if (eventHandlers) {
                            var applyHandlers = {};
                            return forEach(eventHandlers, function(eventHandler, key) {
                                applyHandlers[key] = function(event) {
                                    function callEventHandler() {
                                        eventHandler(event)
                                    }
                                    useApplyAsync ? $rootScope.$applyAsync(callEventHandler) : $rootScope.$$phase ? callEventHandler() : $rootScope.$apply(callEventHandler)
                                }
                            }), applyHandlers
                        }
                    }

                    function done(status, response, headersString, statusText, xhrStatus) {
                        function resolveHttpPromise() {
                            resolvePromise(response, status, headersString, statusText, xhrStatus)
                        }
                        cache && (isSuccess(status) ? cache.put(url, [status, response, parseHeaders(headersString), statusText, xhrStatus]) : cache.remove(url)), useApplyAsync ? $rootScope.$applyAsync(resolveHttpPromise) : (resolveHttpPromise(), $rootScope.$$phase || $rootScope.$apply())
                    }

                    function resolvePromise(response, status, headers, statusText, xhrStatus) {
                        status = status >= -1 ? status : 0, (isSuccess(status) ? deferred.resolve : deferred.reject)({
                            data: response,
                            status: status,
                            headers: headersGetter(headers),
                            config: config,
                            statusText: statusText,
                            xhrStatus: xhrStatus
                        })
                    }

                    function resolvePromiseWithResult(result) {
                        resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText, result.xhrStatus)
                    }

                    function removePendingReq() {
                        var idx = $http.pendingRequests.indexOf(config);
                        idx !== -1 && $http.pendingRequests.splice(idx, 1)
                    }
                    var cache, cachedResp, deferred = $q.defer(),
                        promise = deferred.promise,
                        reqHeaders = config.headers,
                        isJsonp = "jsonp" === lowercase(config.method),
                        url = config.url;
                    if (isJsonp ? url = $sce.getTrustedResourceUrl(url) : isString(url) || (url = $sce.valueOf(url)), url = buildUrl(url, config.paramSerializer(config.params)), isJsonp && (url = sanitizeJsonpCallbackParam(url, config.jsonpCallbackParam)), $http.pendingRequests.push(config), promise.then(removePendingReq, removePendingReq), !config.cache && !defaults.cache || config.cache === !1 || "GET" !== config.method && "JSONP" !== config.method || (cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache), cache && (cachedResp = cache.get(url), isDefined(cachedResp) ? isPromiseLike(cachedResp) ? cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult) : isArray(cachedResp) ? resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3], cachedResp[4]) : resolvePromise(cachedResp, 200, {}, "OK", "complete") : cache.put(url, promise)),
                        isUndefined(cachedResp)) {
                        var xsrfValue = urlIsAllowedOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : void 0;
                        xsrfValue && (reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue), $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers))
                    }
                    return promise
                }

                function buildUrl(url, serializedParams) {
                    return serializedParams.length > 0 && (url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams), url
                }

                function sanitizeJsonpCallbackParam(url, cbKey) {
                    var parts = url.split("?");
                    if (parts.length > 2) throw $httpMinErr("badjsonp", 'Illegal use more than one "?", in url, "{1}"', url);
                    var params = parseKeyValue(parts[1]);
                    return forEach(params, function(value, key) {
                        if ("JSON_CALLBACK" === value) throw $httpMinErr("badjsonp", 'Illegal use of JSON_CALLBACK in url, "{0}"', url);
                        if (key === cbKey) throw $httpMinErr("badjsonp", 'Illegal use of callback param, "{0}", in url, "{1}"', cbKey, url)
                    }), url += (url.indexOf("?") === -1 ? "?" : "&") + cbKey + "=JSON_CALLBACK"
                }
                var defaultCache = $cacheFactory("$http");
                defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
                var reversedInterceptors = [];
                forEach(interceptorFactories, function(interceptorFactory) {
                    reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory))
                });
                var urlIsAllowedOrigin = urlIsAllowedOriginFactory(xsrfWhitelistedOrigins);
                return $http.pendingRequests = [], createShortMethods("get", "delete", "head", "jsonp"), createShortMethodsWithData("post", "put", "patch"), $http.defaults = defaults, $http
            }]
        }

        function $xhrFactoryProvider() {
            this.$get = function() {
                return function() {
                    return new window.XMLHttpRequest
                }
            }
        }

        function $HttpBackendProvider() {
            this.$get = ["$browser", "$jsonpCallbacks", "$document", "$xhrFactory", function($browser, $jsonpCallbacks, $document, $xhrFactory) {
                return createHttpBackend($browser, $xhrFactory, $browser.defer, $jsonpCallbacks, $document[0])
            }]
        }

        function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
            function jsonpReq(url, callbackPath, done) {
                url = url.replace("JSON_CALLBACK", callbackPath);
                var script = rawDocument.createElement("script"),
                    _callback2 = null;
                return script.type = "text/javascript", script.src = url, script.async = !0, _callback2 = function(event) {
                    script.removeEventListener("load", _callback2), script.removeEventListener("error", _callback2), rawDocument.body.removeChild(script), script = null;
                    var status = -1,
                        text = "unknown";
                    event && ("load" !== event.type || callbacks.wasCalled(callbackPath) || (event = {
                        type: "error"
                    }), text = event.type, status = "error" === event.type ? 404 : 200), done && done(status, text)
                }, script.addEventListener("load", _callback2), script.addEventListener("error", _callback2), rawDocument.body.appendChild(script), _callback2
            }
            return function(method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
                function timeoutRequest(reason) {
                    abortedByTimeout = "timeout" === reason, jsonpDone && jsonpDone(), xhr && xhr.abort()
                }

                function completeRequest(callback, status, response, headersString, statusText, xhrStatus) {
                    isDefined(timeoutId) && $browserDefer.cancel(timeoutId), jsonpDone = xhr = null, callback(status, response, headersString, statusText, xhrStatus)
                }
                if (url = url || $browser.url(), "jsonp" === lowercase(method)) var callbackPath = callbacks.createCallback(url),
                    jsonpDone = jsonpReq(url, callbackPath, function(status, text) {
                        var response = 200 === status && callbacks.getResponse(callbackPath);
                        completeRequest(callback, status, response, "", text, "complete"), callbacks.removeCallback(callbackPath)
                    });
                else {
                    var xhr = createXhr(method, url),
                        abortedByTimeout = !1;
                    xhr.open(method, url, !0), forEach(headers, function(value, key) {
                        isDefined(value) && xhr.setRequestHeader(key, value)
                    }), xhr.onload = function() {
                        var statusText = xhr.statusText || "",
                            response = "response" in xhr ? xhr.response : xhr.responseText,
                            status = 1223 === xhr.status ? 204 : xhr.status;
                        0 === status && (status = response ? 200 : "file" === urlResolve(url).protocol ? 404 : 0), completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText, "complete")
                    };
                    var requestError = function() {
                            completeRequest(callback, -1, null, null, "", "error")
                        },
                        requestAborted = function() {
                            completeRequest(callback, -1, null, null, "", abortedByTimeout ? "timeout" : "abort")
                        },
                        requestTimeout = function() {
                            completeRequest(callback, -1, null, null, "", "timeout")
                        };
                    if (xhr.onerror = requestError, xhr.ontimeout = requestTimeout, xhr.onabort = requestAborted, forEach(eventHandlers, function(value, key) {
                            xhr.addEventListener(key, value)
                        }), forEach(uploadEventHandlers, function(value, key) {
                            xhr.upload.addEventListener(key, value)
                        }), withCredentials && (xhr.withCredentials = !0), responseType) try {
                        xhr.responseType = responseType
                    } catch (e) {
                        if ("json" !== responseType) throw e
                    }
                    xhr.send(isUndefined(post) ? null : post)
                }
                if (timeout > 0) var timeoutId = $browserDefer(function() {
                    timeoutRequest("timeout")
                }, timeout);
                else isPromiseLike(timeout) && timeout.then(function() {
                    timeoutRequest(isDefined(timeout.$$timeoutId) ? "timeout" : "abort")
                })
            }
        }

        function $InterpolateProvider() {
            var startSymbol = "{{",
                endSymbol = "}}";
            this.startSymbol = function(value) {
                return value ? (startSymbol = value, this) : startSymbol
            }, this.endSymbol = function(value) {
                return value ? (endSymbol = value, this) : endSymbol
            }, this.$get = ["$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
                function escape(ch) {
                    return "\\\\\\" + ch
                }

                function unescapeText(text) {
                    return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol)
                }

                function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
                    var unwatch = scope.$watch(function(scope) {
                        return unwatch(), constantInterp(scope)
                    }, listener, objectEquality);
                    return unwatch
                }

                function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                    function parseStringifyInterceptor(value) {
                        try {
                            return value = trustedContext && !contextAllowsConcatenation ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value), allOrNothing && !isDefined(value) ? value : stringify(value)
                        } catch (err) {
                            $exceptionHandler($interpolateMinErr.interr(text, err))
                        }
                    }
                    var contextAllowsConcatenation = trustedContext === $sce.URL || trustedContext === $sce.MEDIA_URL;
                    if (!text.length || text.indexOf(startSymbol) === -1) {
                        if (mustHaveExpression) return;
                        var unescapedText = unescapeText(text);
                        contextAllowsConcatenation && (unescapedText = $sce.getTrusted(trustedContext, unescapedText));
                        var constantInterp = valueFn(unescapedText);
                        return constantInterp.exp = text, constantInterp.expressions = [], constantInterp.$$watchDelegate = constantWatchDelegate, constantInterp
                    }
                    allOrNothing = !!allOrNothing;
                    for (var startIndex, endIndex, parseFns, exp, singleExpression, index = 0, expressions = [], textLength = text.length, concat = [], expressionPositions = []; index < textLength;) {
                        if ((startIndex = text.indexOf(startSymbol, index)) === -1 || (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) === -1) {
                            index !== textLength && concat.push(unescapeText(text.substring(index)));
                            break
                        }
                        index !== startIndex && concat.push(unescapeText(text.substring(index, startIndex))), exp = text.substring(startIndex + startSymbolLength, endIndex), expressions.push(exp), index = endIndex + endSymbolLength, expressionPositions.push(concat.length), concat.push("")
                    }
                    singleExpression = 1 === concat.length && 1 === expressionPositions.length;
                    var interceptor = contextAllowsConcatenation && singleExpression ? void 0 : parseStringifyInterceptor;
                    if (parseFns = expressions.map(function(exp) {
                            return $parse(exp, interceptor)
                        }), !mustHaveExpression || expressions.length) {
                        var compute = function(values) {
                            for (var i = 0, ii = expressions.length; i < ii; i++) {
                                if (allOrNothing && isUndefined(values[i])) return;
                                concat[expressionPositions[i]] = values[i]
                            }
                            return contextAllowsConcatenation ? $sce.getTrusted(trustedContext, singleExpression ? concat[0] : concat.join("")) : (trustedContext && concat.length > 1 && $interpolateMinErr.throwNoconcat(text), concat.join(""))
                        };
                        return extend(function(context) {
                            var i = 0,
                                ii = expressions.length,
                                values = new Array(ii);
                            try {
                                for (; i < ii; i++) values[i] = parseFns[i](context);
                                return compute(values)
                            } catch (err) {
                                $exceptionHandler($interpolateMinErr.interr(text, err))
                            }
                        }, {
                            exp: text,
                            expressions: expressions,
                            $$watchDelegate: function(scope, listener) {
                                var lastValue;
                                return scope.$watchGroup(parseFns, function(values, oldValues) {
                                    var currValue = compute(values);
                                    listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope), lastValue = currValue
                                })
                            }
                        })
                    }
                }
                var startSymbolLength = startSymbol.length,
                    endSymbolLength = endSymbol.length,
                    escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"),
                    escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
                return $interpolate.startSymbol = function() {
                    return startSymbol
                }, $interpolate.endSymbol = function() {
                    return endSymbol
                }, $interpolate
            }]
        }

        function $IntervalProvider() {
            this.$get = ["$$intervalFactory", "$window", function($$intervalFactory, $window) {
                var intervals = {},
                    setIntervalFn = function(tick, delay, deferred) {
                        var id = $window.setInterval(tick, delay);
                        return intervals[id] = deferred, id
                    },
                    clearIntervalFn = function(id) {
                        $window.clearInterval(id), delete intervals[id]
                    },
                    interval = $$intervalFactory(setIntervalFn, clearIntervalFn);
                return interval.cancel = function(promise) {
                    if (!promise) return !1;
                    if (!promise.hasOwnProperty("$$intervalId")) throw $intervalMinErr("badprom", "`$interval.cancel()` called with a promise that was not generated by `$interval()`.");
                    if (!intervals.hasOwnProperty(promise.$$intervalId)) return !1;
                    var id = promise.$$intervalId,
                        deferred = intervals[id];
                    return markQExceptionHandled(deferred.promise), deferred.reject("canceled"), clearIntervalFn(id), !0
                }, interval
            }]
        }

        function $$IntervalFactoryProvider() {
            this.$get = ["$browser", "$q", "$$q", "$rootScope", function($browser, $q, $$q, $rootScope) {
                return function(setIntervalFn, clearIntervalFn) {
                    return function(fn, delay, count, invokeApply) {
                        function callback() {
                            hasParams ? fn.apply(null, args) : fn(iteration)
                        }

                        function tick() {
                            skipApply ? $browser.defer(callback) : $rootScope.$evalAsync(callback), deferred.notify(iteration++), count > 0 && iteration >= count && (deferred.resolve(iteration), clearIntervalFn(promise.$$intervalId)), skipApply || $rootScope.$apply()
                        }
                        var hasParams = arguments.length > 4,
                            args = hasParams ? sliceArgs(arguments, 4) : [],
                            iteration = 0,
                            skipApply = isDefined(invokeApply) && !invokeApply,
                            deferred = (skipApply ? $$q : $q).defer(),
                            promise = deferred.promise;
                        return count = isDefined(count) ? count : 0, promise.$$intervalId = setIntervalFn(tick, delay, deferred, skipApply), promise
                    }
                }
            }]
        }

        function encodePath(path) {
            for (var segments = path.split("/"), i = segments.length; i--;) segments[i] = encodeUriSegment(segments[i].replace(/%2F/g, "/"));
            return segments.join("/")
        }

        function decodePath(path, html5Mode) {
            for (var segments = path.split("/"), i = segments.length; i--;) segments[i] = decodeURIComponent(segments[i]), html5Mode && (segments[i] = segments[i].replace(/\//g, "%2F"));
            return segments.join("/")
        }

        function normalizePath(pathValue, searchValue, hashValue) {
            var search = toKeyValue(searchValue),
                hash = hashValue ? "#" + encodeUriSegment(hashValue) : "",
                path = encodePath(pathValue);
            return path + (search ? "?" + search : "") + hash
        }

        function parseAbsoluteUrl(absoluteUrl, locationObj) {
            var parsedUrl = urlResolve(absoluteUrl);
            locationObj.$$protocol = parsedUrl.protocol, locationObj.$$host = parsedUrl.hostname, locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null
        }

        function parseAppUrl(url, locationObj, html5Mode) {
            if (DOUBLE_SLASH_REGEX.test(url)) throw $locationMinErr("badpath", 'Invalid url "{0}".', url);
            var prefixed = "/" !== url.charAt(0);
            prefixed && (url = "/" + url);
            var match = urlResolve(url),
                path = prefixed && "/" === match.pathname.charAt(0) ? match.pathname.substring(1) : match.pathname;
            locationObj.$$path = decodePath(path, html5Mode), locationObj.$$search = parseKeyValue(match.search), locationObj.$$hash = decodeURIComponent(match.hash), locationObj.$$path && "/" !== locationObj.$$path.charAt(0) && (locationObj.$$path = "/" + locationObj.$$path)
        }

        function startsWith(str, search) {
            return str.slice(0, search.length) === search
        }

        function stripBaseUrl(base, url) {
            if (startsWith(url, base)) return url.substr(base.length)
        }

        function stripHash(url) {
            var index = url.indexOf("#");
            return index === -1 ? url : url.substr(0, index)
        }

        function stripFile(url) {
            return url.substr(0, stripHash(url).lastIndexOf("/") + 1)
        }

        function serverBase(url) {
            return url.substring(0, url.indexOf("/", url.indexOf("//") + 2))
        }

        function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
            this.$$html5 = !0, basePrefix = basePrefix || "", parseAbsoluteUrl(appBase, this), this.$$parse = function(url) {
                var pathUrl = stripBaseUrl(appBaseNoFile, url);
                if (!isString(pathUrl)) throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
                parseAppUrl(pathUrl, this, !0), this.$$path || (this.$$path = "/"), this.$$compose()
            }, this.$$normalizeUrl = function(url) {
                return appBaseNoFile + url.substr(1)
            }, this.$$parseLinkUrl = function(url, relHref) {
                if (relHref && "#" === relHref[0]) return this.hash(relHref.slice(1)), !0;
                var appUrl, prevAppUrl, rewrittenUrl;
                return isDefined(appUrl = stripBaseUrl(appBase, url)) ? (prevAppUrl = appUrl, rewrittenUrl = basePrefix && isDefined(appUrl = stripBaseUrl(basePrefix, appUrl)) ? appBaseNoFile + (stripBaseUrl("/", appUrl) || appUrl) : appBase + prevAppUrl) : isDefined(appUrl = stripBaseUrl(appBaseNoFile, url)) ? rewrittenUrl = appBaseNoFile + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile), rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl
            }
        }

        function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
            parseAbsoluteUrl(appBase, this), this.$$parse = function(url) {
                function removeWindowsDriveName(path, url, base) {
                    var firstPathSegmentMatch, windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                    return startsWith(url, base) && (url = url.replace(base, "")), windowsFilePathExp.exec(url) ? path : (firstPathSegmentMatch = windowsFilePathExp.exec(path), firstPathSegmentMatch ? firstPathSegmentMatch[1] : path)
                }
                var withoutHashUrl, withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
                isUndefined(withoutBaseUrl) || "#" !== withoutBaseUrl.charAt(0) ? this.$$html5 ? withoutHashUrl = withoutBaseUrl : (withoutHashUrl = "", isUndefined(withoutBaseUrl) && (appBase = url, this.replace())) : (withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl), isUndefined(withoutHashUrl) && (withoutHashUrl = withoutBaseUrl)), parseAppUrl(withoutHashUrl, this, !1), this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase), this.$$compose()
            }, this.$$normalizeUrl = function(url) {
                return appBase + (url ? hashPrefix + url : "")
            }, this.$$parseLinkUrl = function(url, relHref) {
                return stripHash(appBase) === stripHash(url) && (this.$$parse(url), !0)
            }
        }

        function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
            this.$$html5 = !0, LocationHashbangUrl.apply(this, arguments), this.$$parseLinkUrl = function(url, relHref) {
                if (relHref && "#" === relHref[0]) return this.hash(relHref.slice(1)), !0;
                var rewrittenUrl, appUrl;
                return appBase === stripHash(url) ? rewrittenUrl = url : (appUrl = stripBaseUrl(appBaseNoFile, url)) ? rewrittenUrl = appBase + hashPrefix + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile), rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl
            }, this.$$normalizeUrl = function(url) {
                return appBase + hashPrefix + url
            }
        }

        function locationGetter(property) {
            return function() {
                return this[property]
            }
        }

        function locationGetterSetter(property, preprocess) {
            return function(value) {
                return isUndefined(value) ? this[property] : (this[property] = preprocess(value), this.$$compose(), this)
            }
        }

        function $LocationProvider() {
            var hashPrefix = "!",
                html5Mode = {
                    enabled: !1,
                    requireBase: !0,
                    rewriteLinks: !0
                };
            this.hashPrefix = function(prefix) {
                return isDefined(prefix) ? (hashPrefix = prefix, this) : hashPrefix
            }, this.html5Mode = function(mode) {
                return isBoolean(mode) ? (html5Mode.enabled = mode, this) : isObject(mode) ? (isBoolean(mode.enabled) && (html5Mode.enabled = mode.enabled), isBoolean(mode.requireBase) && (html5Mode.requireBase = mode.requireBase), (isBoolean(mode.rewriteLinks) || isString(mode.rewriteLinks)) && (html5Mode.rewriteLinks = mode.rewriteLinks), this) : html5Mode
            }, this.$get = ["$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function($rootScope, $browser, $sniffer, $rootElement, $window) {
                function urlsEqual(a, b) {
                    return a === b || urlResolve(a).href === urlResolve(b).href
                }

                function setBrowserUrlWithFallback(url, replace, state) {
                    var oldUrl = $location.url(),
                        oldState = $location.$$state;
                    try {
                        $browser.url(url, replace, state), $location.$$state = $browser.state()
                    } catch (e) {
                        throw $location.url(oldUrl), $location.$$state = oldState, e
                    }
                }

                function afterLocationChange(oldUrl, oldState) {
                    $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState)
                }
                var $location, LocationMode, appBase, baseHref = $browser.baseHref(),
                    initialUrl = $browser.url();
                if (html5Mode.enabled) {
                    if (!baseHref && html5Mode.requireBase) throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                    appBase = serverBase(initialUrl) + (baseHref || "/"), LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url
                } else appBase = stripHash(initialUrl), LocationMode = LocationHashbangUrl;
                var appBaseNoFile = stripFile(appBase);
                $location = new LocationMode(appBase, appBaseNoFile, "#" + hashPrefix), $location.$$parseLinkUrl(initialUrl, initialUrl), $location.$$state = $browser.state();
                var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
                $rootElement.on("click", function(event) {
                    var rewriteLinks = html5Mode.rewriteLinks;
                    if (rewriteLinks && !event.ctrlKey && !event.metaKey && !event.shiftKey && 2 !== event.which && 2 !== event.button) {
                        for (var elm = jqLite(event.target);
                            "a" !== nodeName_(elm[0]);)
                            if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                        if (!isString(rewriteLinks) || !isUndefined(elm.attr(rewriteLinks))) {
                            var absHref = elm.prop("href"),
                                relHref = elm.attr("href") || elm.attr("xlink:href");
                            isObject(absHref) && "[object SVGAnimatedString]" === absHref.toString() && (absHref = urlResolve(absHref.animVal).href), IGNORE_URI_REGEXP.test(absHref) || !absHref || elm.attr("target") || event.isDefaultPrevented() || $location.$$parseLinkUrl(absHref, relHref) && (event.preventDefault(), $location.absUrl() !== $browser.url() && $rootScope.$apply())
                        }
                    }
                }), $location.absUrl() !== initialUrl && $browser.url($location.absUrl(), !0);
                var initializing = !0;
                return $browser.onUrlChange(function(newUrl, newState) {
                    return startsWith(newUrl, appBaseNoFile) ? ($rootScope.$evalAsync(function() {
                        var defaultPrevented, oldUrl = $location.absUrl(),
                            oldState = $location.$$state;
                        $location.$$parse(newUrl), $location.$$state = newState, defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented, $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), $location.$$state = oldState, setBrowserUrlWithFallback(oldUrl, !1, oldState)) : (initializing = !1, afterLocationChange(oldUrl, oldState)))
                    }), void($rootScope.$$phase || $rootScope.$digest())) : void($window.location.href = newUrl)
                }), $rootScope.$watch(function() {
                    if (initializing || $location.$$urlUpdatedByLocation) {
                        $location.$$urlUpdatedByLocation = !1;
                        var oldUrl = $browser.url(),
                            newUrl = $location.absUrl(),
                            oldState = $browser.state(),
                            currentReplace = $location.$$replace,
                            urlOrStateChanged = !urlsEqual(oldUrl, newUrl) || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                        (initializing || urlOrStateChanged) && (initializing = !1, $rootScope.$evalAsync(function() {
                            var newUrl = $location.absUrl(),
                                defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                            $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), $location.$$state = oldState) : (urlOrStateChanged && setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state), afterLocationChange(oldUrl, oldState)))
                        }))
                    }
                    $location.$$replace = !1
                }), $location
            }]
        }

        function $LogProvider() {
            var debug = !0,
                self = this;
            this.debugEnabled = function(flag) {
                return isDefined(flag) ? (debug = flag, this) : debug
            }, this.$get = ["$window", function($window) {
                function formatError(arg) {
                    return isError(arg) && (arg.stack && formatStackTrace ? arg = arg.message && arg.stack.indexOf(arg.message) === -1 ? "Error: " + arg.message + "\n" + arg.stack : arg.stack : arg.sourceURL && (arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line)), arg
                }

                function consoleLog(type) {
                    var console = $window.console || {},
                        logFn = console[type] || console.log || noop;
                    return function() {
                        var args = [];
                        return forEach(arguments, function(arg) {
                            args.push(formatError(arg))
                        }), Function.prototype.apply.call(logFn, console, args)
                    }
                }
                var formatStackTrace = msie || /\bEdge\//.test($window.navigator && $window.navigator.userAgent);
                return {
                    log: consoleLog("log"),
                    info: consoleLog("info"),
                    warn: consoleLog("warn"),
                    error: consoleLog("error"),
                    debug: function() {
                        var fn = consoleLog("debug");
                        return function() {
                            debug && fn.apply(self, arguments)
                        }
                    }()
                }
            }]
        }

        function getStringValue(name) {
            return name + ""
        }

        function ifDefined(v, d) {
            return "undefined" != typeof v ? v : d
        }

        function plusFn(l, r) {
            return "undefined" == typeof l ? r : "undefined" == typeof r ? l : l + r
        }

        function isStateless($filter, filterName) {
            var fn = $filter(filterName);
            return !fn.$stateful
        }

        function isPure(node, parentIsPure) {
            switch (node.type) {
                case AST.MemberExpression:
                    if (node.computed) return !1;
                    break;
                case AST.UnaryExpression:
                    return PURITY_ABSOLUTE;
                case AST.BinaryExpression:
                    return "+" !== node.operator && PURITY_ABSOLUTE;
                case AST.CallExpression:
                    return !1
            }
            return void 0 === parentIsPure ? PURITY_RELATIVE : parentIsPure
        }

        function findConstantAndWatchExpressions(ast, $filter, parentIsPure) {
            var allConstants, argsToWatch, isStatelessFilter, astIsPure = ast.isPure = isPure(ast, parentIsPure);
            switch (ast.type) {
                case AST.Program:
                    allConstants = !0, forEach(ast.body, function(expr) {
                        findConstantAndWatchExpressions(expr.expression, $filter, astIsPure), allConstants = allConstants && expr.expression.constant
                    }), ast.constant = allConstants;
                    break;
                case AST.Literal:
                    ast.constant = !0, ast.toWatch = [];
                    break;
                case AST.UnaryExpression:
                    findConstantAndWatchExpressions(ast.argument, $filter, astIsPure), ast.constant = ast.argument.constant, ast.toWatch = ast.argument.toWatch;
                    break;
                case AST.BinaryExpression:
                    findConstantAndWatchExpressions(ast.left, $filter, astIsPure), findConstantAndWatchExpressions(ast.right, $filter, astIsPure), ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
                    break;
                case AST.LogicalExpression:
                    findConstantAndWatchExpressions(ast.left, $filter, astIsPure), findConstantAndWatchExpressions(ast.right, $filter, astIsPure), ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.constant ? [] : [ast];
                    break;
                case AST.ConditionalExpression:
                    findConstantAndWatchExpressions(ast.test, $filter, astIsPure), findConstantAndWatchExpressions(ast.alternate, $filter, astIsPure), findConstantAndWatchExpressions(ast.consequent, $filter, astIsPure), ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant, ast.toWatch = ast.constant ? [] : [ast];
                    break;
                case AST.Identifier:
                    ast.constant = !1, ast.toWatch = [ast];
                    break;
                case AST.MemberExpression:
                    findConstantAndWatchExpressions(ast.object, $filter, astIsPure), ast.computed && findConstantAndWatchExpressions(ast.property, $filter, astIsPure), ast.constant = ast.object.constant && (!ast.computed || ast.property.constant), ast.toWatch = ast.constant ? [] : [ast];
                    break;
                case AST.CallExpression:
                    isStatelessFilter = !!ast.filter && isStateless($filter, ast.callee.name), allConstants = isStatelessFilter, argsToWatch = [], forEach(ast.arguments, function(expr) {
                        findConstantAndWatchExpressions(expr, $filter, astIsPure), allConstants = allConstants && expr.constant, argsToWatch.push.apply(argsToWatch, expr.toWatch)
                    }), ast.constant = allConstants, ast.toWatch = isStatelessFilter ? argsToWatch : [ast];
                    break;
                case AST.AssignmentExpression:
                    findConstantAndWatchExpressions(ast.left, $filter, astIsPure), findConstantAndWatchExpressions(ast.right, $filter, astIsPure), ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = [ast];
                    break;
                case AST.ArrayExpression:
                    allConstants = !0, argsToWatch = [], forEach(ast.elements, function(expr) {
                        findConstantAndWatchExpressions(expr, $filter, astIsPure), allConstants = allConstants && expr.constant, argsToWatch.push.apply(argsToWatch, expr.toWatch)
                    }), ast.constant = allConstants, ast.toWatch = argsToWatch;
                    break;
                case AST.ObjectExpression:
                    allConstants = !0, argsToWatch = [], forEach(ast.properties, function(property) {
                        findConstantAndWatchExpressions(property.value, $filter, astIsPure), allConstants = allConstants && property.value.constant, argsToWatch.push.apply(argsToWatch, property.value.toWatch), property.computed && (findConstantAndWatchExpressions(property.key, $filter, !1), allConstants = allConstants && property.key.constant, argsToWatch.push.apply(argsToWatch, property.key.toWatch))
                    }), ast.constant = allConstants, ast.toWatch = argsToWatch;
                    break;
                case AST.ThisExpression:
                    ast.constant = !1, ast.toWatch = [];
                    break;
                case AST.LocalsExpression:
                    ast.constant = !1, ast.toWatch = []
            }
        }

        function getInputs(body) {
            if (1 === body.length) {
                var lastExpression = body[0].expression,
                    candidate = lastExpression.toWatch;
                return 1 !== candidate.length ? candidate : candidate[0] !== lastExpression ? candidate : void 0
            }
        }

        function isAssignable(ast) {
            return ast.type === AST.Identifier || ast.type === AST.MemberExpression
        }

        function assignableAST(ast) {
            if (1 === ast.body.length && isAssignable(ast.body[0].expression)) return {
                type: AST.AssignmentExpression,
                left: ast.body[0].expression,
                right: {
                    type: AST.NGValueParameter
                },
                operator: "="
            }
        }

        function isLiteral(ast) {
            return 0 === ast.body.length || 1 === ast.body.length && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression)
        }

        function isConstant(ast) {
            return ast.constant
        }

        function ASTCompiler($filter) {
            this.$filter = $filter
        }

        function ASTInterpreter($filter) {
            this.$filter = $filter
        }

        function Parser(lexer, $filter, options) {
            this.ast = new AST(lexer, options), this.astCompiler = options.csp ? new ASTInterpreter($filter) : new ASTCompiler($filter)
        }

        function getValueOf(value) {
            return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value)
        }

        function $ParseProvider() {
            var identStart, identContinue, cache = createMap(),
                literals = {
                    true: !0,
                    false: !1,
                    null: null,
                    undefined: void 0
                };
            this.addLiteral = function(literalName, literalValue) {
                literals[literalName] = literalValue
            }, this.setIdentifierFns = function(identifierStart, identifierContinue) {
                return identStart = identifierStart, identContinue = identifierContinue, this
            }, this.$get = ["$filter", function($filter) {
                function $parse(exp, interceptorFn) {
                    var parsedExpression, cacheKey;
                    switch (_typeof2(exp)) {
                        case "string":
                            if (exp = exp.trim(), cacheKey = exp, parsedExpression = cache[cacheKey], !parsedExpression) {
                                var lexer = new Lexer($parseOptions),
                                    parser = new Parser(lexer, $filter, $parseOptions);
                                parsedExpression = parser.parse(exp), cache[cacheKey] = addWatchDelegate(parsedExpression)
                            }
                            return addInterceptor(parsedExpression, interceptorFn);
                        case "function":
                            return addInterceptor(exp, interceptorFn);
                        default:
                            return addInterceptor(noop, interceptorFn)
                    }
                }

                function $$getAst(exp) {
                    var lexer = new Lexer($parseOptions),
                        parser = new Parser(lexer, $filter, $parseOptions);
                    return parser.getAst(exp).ast
                }

                function expressionInputDirtyCheck(newValue, oldValueOfValue, compareObjectIdentity) {
                    return null == newValue || null == oldValueOfValue ? newValue === oldValueOfValue : !("object" === _typeof2(newValue) && (newValue = getValueOf(newValue), "object" === _typeof2(newValue) && !compareObjectIdentity)) && (newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue)
                }

                function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                    var lastResult, inputExpressions = parsedExpression.inputs;
                    if (1 === inputExpressions.length) {
                        var oldInputValueOf = expressionInputDirtyCheck;
                        return inputExpressions = inputExpressions[0], scope.$watch(function(scope) {
                            var newInputValue = inputExpressions(scope);
                            return expressionInputDirtyCheck(newInputValue, oldInputValueOf, inputExpressions.isPure) || (lastResult = parsedExpression(scope, void 0, void 0, [newInputValue]), oldInputValueOf = newInputValue && getValueOf(newInputValue)), lastResult
                        }, listener, objectEquality, prettyPrintExpression)
                    }
                    for (var oldInputValueOfValues = [], oldInputValues = [], i = 0, ii = inputExpressions.length; i < ii; i++) oldInputValueOfValues[i] = expressionInputDirtyCheck, oldInputValues[i] = null;
                    return scope.$watch(function(scope) {
                        for (var changed = !1, i = 0, ii = inputExpressions.length; i < ii; i++) {
                            var newInputValue = inputExpressions[i](scope);
                            (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i], inputExpressions[i].isPure))) && (oldInputValues[i] = newInputValue, oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue))
                        }
                        return changed && (lastResult = parsedExpression(scope, void 0, void 0, oldInputValues)), lastResult
                    }, listener, objectEquality, prettyPrintExpression)
                }

                function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                    function unwatchIfDone() {
                        isDone(lastValue) && unwatch()
                    }

                    function oneTimeWatch(scope, locals, assign, inputs) {
                        return lastValue = useInputs && inputs ? inputs[0] : exp(scope, locals, assign, inputs), isDone(lastValue) && scope.$$postDigest(unwatchIfDone), post(lastValue)
                    }
                    var unwatch, lastValue, isDone = parsedExpression.literal ? isAllDefined : isDefined,
                        exp = parsedExpression.$$intercepted || parsedExpression,
                        post = parsedExpression.$$interceptor || identity,
                        useInputs = parsedExpression.inputs && !exp.inputs;
                    return oneTimeWatch.literal = parsedExpression.literal, oneTimeWatch.constant = parsedExpression.constant, oneTimeWatch.inputs = parsedExpression.inputs, addWatchDelegate(oneTimeWatch), unwatch = scope.$watch(oneTimeWatch, listener, objectEquality, prettyPrintExpression)
                }

                function isAllDefined(value) {
                    var allDefined = !0;
                    return forEach(value, function(val) {
                        isDefined(val) || (allDefined = !1)
                    }), allDefined
                }

                function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                    var unwatch = scope.$watch(function(scope) {
                        return unwatch(), parsedExpression(scope)
                    }, listener, objectEquality);
                    return unwatch
                }

                function addWatchDelegate(parsedExpression) {
                    return parsedExpression.constant ? parsedExpression.$$watchDelegate = constantWatchDelegate : parsedExpression.oneTime ? parsedExpression.$$watchDelegate = oneTimeWatchDelegate : parsedExpression.inputs && (parsedExpression.$$watchDelegate = inputsWatchDelegate), parsedExpression
                }

                function chainInterceptors(first, second) {
                    function chainedInterceptor(value) {
                        return second(first(value))
                    }
                    return chainedInterceptor.$stateful = first.$stateful || second.$stateful, chainedInterceptor.$$pure = first.$$pure && second.$$pure, chainedInterceptor
                }

                function addInterceptor(parsedExpression, interceptorFn) {
                    if (!interceptorFn) return parsedExpression;
                    parsedExpression.$$interceptor && (interceptorFn = chainInterceptors(parsedExpression.$$interceptor, interceptorFn), parsedExpression = parsedExpression.$$intercepted);
                    var useInputs = !1,
                        fn = function(scope, locals, assign, inputs) {
                            var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
                            return interceptorFn(value)
                        };
                    return fn.$$intercepted = parsedExpression, fn.$$interceptor = interceptorFn, fn.literal = parsedExpression.literal, fn.oneTime = parsedExpression.oneTime, fn.constant = parsedExpression.constant, interceptorFn.$stateful || (useInputs = !parsedExpression.inputs, fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression], interceptorFn.$$pure || (fn.inputs = fn.inputs.map(function(e) {
                        return e.isPure === PURITY_RELATIVE ? function(s) {
                            return e(s)
                        } : e
                    }))), addWatchDelegate(fn)
                }
                var noUnsafeEval = csp().noUnsafeEval,
                    $parseOptions = {
                        csp: noUnsafeEval,
                        literals: copy(literals),
                        isIdentifierStart: isFunction(identStart) && identStart,
                        isIdentifierContinue: isFunction(identContinue) && identContinue
                    };
                return $parse.$$getAst = $$getAst, $parse
            }]
        }

        function $QProvider() {
            var errorOnUnhandledRejections = !0;
            this.$get = ["$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
                return qFactory(function(callback) {
                    $rootScope.$evalAsync(callback)
                }, $exceptionHandler, errorOnUnhandledRejections)
            }], this.errorOnUnhandledRejections = function(value) {
                return isDefined(value) ? (errorOnUnhandledRejections = value, this) : errorOnUnhandledRejections
            }
        }

        function $$QProvider() {
            var errorOnUnhandledRejections = !0;
            this.$get = ["$browser", "$exceptionHandler", function($browser, $exceptionHandler) {
                return qFactory(function(callback) {
                    $browser.defer(callback)
                }, $exceptionHandler, errorOnUnhandledRejections)
            }], this.errorOnUnhandledRejections = function(value) {
                return isDefined(value) ? (errorOnUnhandledRejections = value, this) : errorOnUnhandledRejections
            }
        }

        function qFactory(nextTick, exceptionHandler, errorOnUnhandledRejections) {
            function defer() {
                return new Deferred
            }

            function Deferred() {
                var promise = this.promise = new Promise;
                this.resolve = function(val) {
                    resolvePromise(promise, val)
                }, this.reject = function(reason) {
                    rejectPromise(promise, reason)
                }, this.notify = function(progress) {
                    notifyPromise(promise, progress)
                }
            }

            function Promise() {
                this.$$state = {
                    status: 0
                }
            }

            function processQueue(state) {
                var fn, promise, pending;
                pending = state.pending, state.processScheduled = !1, state.pending = void 0;
                try {
                    for (var i = 0, ii = pending.length; i < ii; ++i) {
                        markQStateExceptionHandled(state), promise = pending[i][0], fn = pending[i][state.status];
                        try {
                            isFunction(fn) ? resolvePromise(promise, fn(state.value)) : 1 === state.status ? resolvePromise(promise, state.value) : rejectPromise(promise, state.value)
                        } catch (e) {
                            rejectPromise(promise, e), e && e.$$passToExceptionHandler === !0 && exceptionHandler(e)
                        }
                    }
                } finally {
                    --queueSize, errorOnUnhandledRejections && 0 === queueSize && nextTick(processChecks)
                }
            }

            function processChecks() {
                for (; !queueSize && checkQueue.length;) {
                    var toCheck = checkQueue.shift();
                    if (!isStateExceptionHandled(toCheck)) {
                        markQStateExceptionHandled(toCheck);
                        var errorMessage = "Possibly unhandled rejection: " + toDebugString(toCheck.value);
                        isError(toCheck.value) ? exceptionHandler(toCheck.value, errorMessage) : exceptionHandler(errorMessage)
                    }
                }
            }

            function scheduleProcessQueue(state) {
                !errorOnUnhandledRejections || state.pending || 2 !== state.status || isStateExceptionHandled(state) || (0 === queueSize && 0 === checkQueue.length && nextTick(processChecks), checkQueue.push(state)), !state.processScheduled && state.pending && (state.processScheduled = !0, ++queueSize, nextTick(function() {
                    processQueue(state)
                }))
            }

            function resolvePromise(promise, val) {
                promise.$$state.status || (val === promise ? $$reject(promise, $qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val)) : $$resolve(promise, val))
            }

            function $$resolve(promise, val) {
                function doResolve(val) {
                    done || (done = !0, $$resolve(promise, val))
                }

                function doReject(val) {
                    done || (done = !0, $$reject(promise, val))
                }

                function doNotify(progress) {
                    notifyPromise(promise, progress)
                }
                var then, done = !1;
                try {
                    (isObject(val) || isFunction(val)) && (then = val.then), isFunction(then) ? (promise.$$state.status = -1, then.call(val, doResolve, doReject, doNotify)) : (promise.$$state.value = val, promise.$$state.status = 1, scheduleProcessQueue(promise.$$state))
                } catch (e) {
                    doReject(e)
                }
            }

            function rejectPromise(promise, reason) {
                promise.$$state.status || $$reject(promise, reason)
            }

            function $$reject(promise, reason) {
                promise.$$state.value = reason, promise.$$state.status = 2, scheduleProcessQueue(promise.$$state)
            }

            function notifyPromise(promise, progress) {
                var callbacks = promise.$$state.pending;
                promise.$$state.status <= 0 && callbacks && callbacks.length && nextTick(function() {
                    for (var callback, result, i = 0, ii = callbacks.length; i < ii; i++) {
                        result = callbacks[i][0], callback = callbacks[i][3];
                        try {
                            notifyPromise(result, isFunction(callback) ? callback(progress) : progress)
                        } catch (e) {
                            exceptionHandler(e)
                        }
                    }
                })
            }

            function reject(reason) {
                var result = new Promise;
                return rejectPromise(result, reason), result
            }

            function handleCallback(value, resolver, callback) {
                var callbackOutput = null;
                try {
                    isFunction(callback) && (callbackOutput = callback())
                } catch (e) {
                    return reject(e)
                }
                return isPromiseLike(callbackOutput) ? callbackOutput.then(function() {
                    return resolver(value)
                }, reject) : resolver(value)
            }

            function when(value, callback, errback, progressBack) {
                var result = new Promise;
                return resolvePromise(result, value), result.then(callback, errback, progressBack)
            }

            function all(promises) {
                var result = new Promise,
                    counter = 0,
                    results = isArray(promises) ? [] : {};
                return forEach(promises, function(promise, key) {
                    counter++, when(promise).then(function(value) {
                        results[key] = value, --counter || resolvePromise(result, results)
                    }, function(reason) {
                        rejectPromise(result, reason)
                    })
                }), 0 === counter && resolvePromise(result, results), result
            }

            function race(promises) {
                var deferred = defer();
                return forEach(promises, function(promise) {
                    when(promise).then(deferred.resolve, deferred.reject)
                }), deferred.promise
            }

            function $Q(resolver) {
                function resolveFn(value) {
                    resolvePromise(promise, value)
                }

                function rejectFn(reason) {
                    rejectPromise(promise, reason)
                }
                if (!isFunction(resolver)) throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
                var promise = new Promise;
                return resolver(resolveFn, rejectFn), promise
            }
            var $qMinErr = minErr("$q", TypeError),
                queueSize = 0,
                checkQueue = [];
            extend(Promise.prototype, {
                then: function(onFulfilled, onRejected, progressBack) {
                    if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) return this;
                    var result = new Promise;
                    return this.$$state.pending = this.$$state.pending || [], this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]), this.$$state.status > 0 && scheduleProcessQueue(this.$$state), result
                },
                catch: function(callback) {
                    return this.then(null, callback)
                },
                finally: function(callback, progressBack) {
                    return this.then(function(value) {
                        return handleCallback(value, resolve, callback)
                    }, function(error) {
                        return handleCallback(error, reject, callback)
                    }, progressBack)
                }
            });
            var resolve = when;
            return $Q.prototype = Promise.prototype, $Q.defer = defer, $Q.reject = reject, $Q.when = when, $Q.resolve = resolve, $Q.all = all, $Q.race = race, $Q
        }

        function isStateExceptionHandled(state) {
            return !!state.pur
        }

        function markQStateExceptionHandled(state) {
            state.pur = !0
        }

        function markQExceptionHandled(q) {
            q.$$state && markQStateExceptionHandled(q.$$state)
        }

        function $$RAFProvider() {
            this.$get = ["$window", "$timeout", function($window, $timeout) {
                var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame,
                    cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame,
                    rafSupported = !!requestAnimationFrame,
                    raf = rafSupported ? function(fn) {
                        var id = requestAnimationFrame(fn);
                        return function() {
                            cancelAnimationFrame(id)
                        }
                    } : function(fn) {
                        var timer = $timeout(fn, 16.66, !1);
                        return function() {
                            $timeout.cancel(timer)
                        }
                    };
                return raf.supported = rafSupported, raf
            }]
        }

        function $RootScopeProvider() {
            function createChildScopeClass(parent) {
                function ChildScope() {
                    this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null, this.$$listeners = {}, this.$$listenerCount = {}, this.$$watchersCount = 0, this.$id = nextUid(), this.$$ChildScope = null, this.$$suspended = !1
                }
                return ChildScope.prototype = parent, ChildScope
            }
            var TTL = 10,
                $rootScopeMinErr = minErr("$rootScope"),
                lastDirtyWatch = null,
                applyAsyncId = null;
            this.digestTtl = function(value) {
                return arguments.length && (TTL = value), TTL
            }, this.$get = ["$exceptionHandler", "$parse", "$browser", function($exceptionHandler, $parse, $browser) {
                function destroyChildScope($event) {
                    $event.currentScope.$$destroyed = !0
                }

                function cleanUpScope($scope) {
                    9 === msie && ($scope.$$childHead && cleanUpScope($scope.$$childHead), $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling)), $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null
                }

                function Scope() {
                    this.$id = nextUid(), this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null, this.$root = this, this.$$destroyed = !1, this.$$suspended = !1, this.$$listeners = {}, this.$$listenerCount = {}, this.$$watchersCount = 0, this.$$isolateBindings = null
                }

                function beginPhase(phase) {
                    if ($rootScope.$$phase) throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                    $rootScope.$$phase = phase
                }

                function clearPhase() {
                    $rootScope.$$phase = null
                }

                function incrementWatchersCount(current, count) {
                    do current.$$watchersCount += count; while (current = current.$parent)
                }

                function decrementListenerCount(current, count, name) {
                    do current.$$listenerCount[name] -= count, 0 === current.$$listenerCount[name] && delete current.$$listenerCount[name]; while (current = current.$parent)
                }

                function initWatchVal() {}

                function flushApplyAsync() {
                    for (; applyAsyncQueue.length;) try {
                        applyAsyncQueue.shift()()
                    } catch (e) {
                        $exceptionHandler(e)
                    }
                    applyAsyncId = null
                }

                function scheduleApplyAsync() {
                    null === applyAsyncId && (applyAsyncId = $browser.defer(function() {
                        $rootScope.$apply(flushApplyAsync)
                    }, null, "$applyAsync"))
                }
                Scope.prototype = {
                    constructor: Scope,
                    $new: function(isolate, parent) {
                        var child;
                        return parent = parent || this, isolate ? (child = new Scope, child.$root = this.$root) : (this.$$ChildScope || (this.$$ChildScope = createChildScopeClass(this)), child = new this.$$ChildScope), child.$parent = parent, child.$$prevSibling = parent.$$childTail, parent.$$childHead ? (parent.$$childTail.$$nextSibling = child, parent.$$childTail = child) : parent.$$childHead = parent.$$childTail = child, (isolate || parent !== this) && child.$on("$destroy", destroyChildScope), child
                    },
                    $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
                        var get = $parse(watchExp),
                            fn = isFunction(listener) ? listener : noop;
                        if (get.$$watchDelegate) return get.$$watchDelegate(this, fn, objectEquality, get, watchExp);
                        var scope = this,
                            array = scope.$$watchers,
                            watcher = {
                                fn: fn,
                                last: initWatchVal,
                                get: get,
                                exp: prettyPrintExpression || watchExp,
                                eq: !!objectEquality
                            };
                        return lastDirtyWatch = null, array || (array = scope.$$watchers = [], array.$$digestWatchIndex = -1), array.unshift(watcher), array.$$digestWatchIndex++, incrementWatchersCount(this, 1),
                            function() {
                                var index = arrayRemove(array, watcher);
                                index >= 0 && (incrementWatchersCount(scope, -1), index < array.$$digestWatchIndex && array.$$digestWatchIndex--), lastDirtyWatch = null
                            }
                    },
                    $watchGroup: function(watchExpressions, listener) {
                        function watchGroupAction() {
                            changeReactionScheduled = !1;
                            try {
                                firstRun ? (firstRun = !1, listener(newValues, newValues, self)) : listener(newValues, oldValues, self)
                            } finally {
                                for (var i = 0; i < watchExpressions.length; i++) oldValues[i] = newValues[i]
                            }
                        }
                        var oldValues = new Array(watchExpressions.length),
                            newValues = new Array(watchExpressions.length),
                            deregisterFns = [],
                            self = this,
                            changeReactionScheduled = !1,
                            firstRun = !0;
                        if (!watchExpressions.length) {
                            var shouldCall = !0;
                            return self.$evalAsync(function() {
                                    shouldCall && listener(newValues, newValues, self)
                                }),
                                function() {
                                    shouldCall = !1
                                }
                        }
                        return 1 === watchExpressions.length ? this.$watch(watchExpressions[0], function(value, oldValue, scope) {
                            newValues[0] = value, oldValues[0] = oldValue, listener(newValues, value === oldValue ? newValues : oldValues, scope)
                        }) : (forEach(watchExpressions, function(expr, i) {
                            var unwatchFn = self.$watch(expr, function(value) {
                                newValues[i] = value, changeReactionScheduled || (changeReactionScheduled = !0, self.$evalAsync(watchGroupAction))
                            });
                            deregisterFns.push(unwatchFn)
                        }), function() {
                            for (; deregisterFns.length;) deregisterFns.shift()()
                        })
                    },
                    $watchCollection: function(obj, listener) {
                        function $watchCollectionInterceptor(_value) {
                            newValue = _value;
                            var newLength, key, bothNaN, newItem, oldItem;
                            if (!isUndefined(newValue)) {
                                if (isObject(newValue))
                                    if (isArrayLike(newValue)) {
                                        oldValue !== internalArray && (oldValue = internalArray, oldLength = oldValue.length = 0, changeDetected++), newLength = newValue.length, oldLength !== newLength && (changeDetected++, oldValue.length = oldLength = newLength);
                                        for (var i = 0; i < newLength; i++) oldItem = oldValue[i], newItem = newValue[i], bothNaN = oldItem !== oldItem && newItem !== newItem, bothNaN || oldItem === newItem || (changeDetected++, oldValue[i] = newItem)
                                    } else {
                                        oldValue !== internalObject && (oldValue = internalObject = {}, oldLength = 0, changeDetected++), newLength = 0;
                                        for (key in newValue) hasOwnProperty.call(newValue, key) && (newLength++, newItem = newValue[key], oldItem = oldValue[key], key in oldValue ? (bothNaN = oldItem !== oldItem && newItem !== newItem, bothNaN || oldItem === newItem || (changeDetected++, oldValue[key] = newItem)) : (oldLength++, oldValue[key] = newItem, changeDetected++));
                                        if (oldLength > newLength) {
                                            changeDetected++;
                                            for (key in oldValue) hasOwnProperty.call(newValue, key) || (oldLength--, delete oldValue[key])
                                        }
                                    }
                                else oldValue !== newValue && (oldValue = newValue, changeDetected++);
                                return changeDetected
                            }
                        }

                        function $watchCollectionAction() {
                            if (initRun ? (initRun = !1, listener(newValue, newValue, self)) : listener(newValue, veryOldValue, self), trackVeryOldValue)
                                if (isObject(newValue))
                                    if (isArrayLike(newValue)) {
                                        veryOldValue = new Array(newValue.length);
                                        for (var i = 0; i < newValue.length; i++) veryOldValue[i] = newValue[i]
                                    } else {
                                        veryOldValue = {};
                                        for (var key in newValue) hasOwnProperty.call(newValue, key) && (veryOldValue[key] = newValue[key])
                                    }
                            else veryOldValue = newValue
                        }
                        $watchCollectionInterceptor.$$pure = $parse(obj).literal, $watchCollectionInterceptor.$stateful = !$watchCollectionInterceptor.$$pure;
                        var newValue, oldValue, veryOldValue, self = this,
                            trackVeryOldValue = listener.length > 1,
                            changeDetected = 0,
                            changeDetector = $parse(obj, $watchCollectionInterceptor),
                            internalArray = [],
                            internalObject = {},
                            initRun = !0,
                            oldLength = 0;
                        return this.$watch(changeDetector, $watchCollectionAction)
                    },
                    $digest: function() {
                        var watch, value, last, fn, get, watchers, dirty, next, current, logIdx, asyncTask, ttl = TTL,
                            target = asyncQueue.length ? $rootScope : this,
                            watchLog = [];
                        beginPhase("$digest"), $browser.$$checkUrlChange(), this === $rootScope && null !== applyAsyncId && ($browser.defer.cancel(applyAsyncId), flushApplyAsync()), lastDirtyWatch = null;
                        do {
                            dirty = !1, current = target;
                            for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                                try {
                                    asyncTask = asyncQueue[asyncQueuePosition], fn = asyncTask.fn, fn(asyncTask.scope, asyncTask.locals)
                                } catch (e) {
                                    $exceptionHandler(e)
                                }
                                lastDirtyWatch = null
                            }
                            asyncQueue.length = 0;
                            traverseScopesLoop: do {
                                if (watchers = !current.$$suspended && current.$$watchers)
                                    for (watchers.$$digestWatchIndex = watchers.length; watchers.$$digestWatchIndex--;) try {
                                        if (watch = watchers[watchers.$$digestWatchIndex])
                                            if (get = watch.get, (value = get(current)) === (last = watch.last) || (watch.eq ? equals(value, last) : isNumberNaN(value) && isNumberNaN(last))) {
                                                if (watch === lastDirtyWatch) {
                                                    dirty = !1;
                                                    break traverseScopesLoop
                                                }
                                            } else dirty = !0, lastDirtyWatch = watch, watch.last = watch.eq ? copy(value, null) : value, fn = watch.fn, fn(value, last === initWatchVal ? value : last, current), ttl < 5 && (logIdx = 4 - ttl, watchLog[logIdx] || (watchLog[logIdx] = []), watchLog[logIdx].push({
                                                msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                                newVal: value,
                                                oldVal: last
                                            }))
                                    } catch (e) {
                                        $exceptionHandler(e)
                                    }
                                if (!(next = !current.$$suspended && current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling))
                                    for (; current !== target && !(next = current.$$nextSibling);) current = current.$parent
                            } while (current = next);
                            if ((dirty || asyncQueue.length) && !ttl--) throw clearPhase(), $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}", TTL, watchLog)
                        } while (dirty || asyncQueue.length);
                        for (clearPhase(); postDigestQueuePosition < postDigestQueue.length;) try {
                            postDigestQueue[postDigestQueuePosition++]()
                        } catch (e) {
                            $exceptionHandler(e)
                        }
                        postDigestQueue.length = postDigestQueuePosition = 0, $browser.$$checkUrlChange()
                    },
                    $suspend: function() {
                        this.$$suspended = !0
                    },
                    $isSuspended: function() {
                        return this.$$suspended
                    },
                    $resume: function() {
                        this.$$suspended = !1
                    },
                    $destroy: function() {
                        if (!this.$$destroyed) {
                            var parent = this.$parent;
                            this.$broadcast("$destroy"), this.$$destroyed = !0, this === $rootScope && $browser.$$applicationDestroyed(), incrementWatchersCount(this, -this.$$watchersCount);
                            for (var eventName in this.$$listenerCount) decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                            parent && parent.$$childHead === this && (parent.$$childHead = this.$$nextSibling), parent && parent.$$childTail === this && (parent.$$childTail = this.$$prevSibling), this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling), this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling), this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop, this.$on = this.$watch = this.$watchGroup = function() {
                                return noop
                            }, this.$$listeners = {}, this.$$nextSibling = null, cleanUpScope(this)
                        }
                    },
                    $eval: function(expr, locals) {
                        return $parse(expr)(this, locals)
                    },
                    $evalAsync: function(expr, locals) {
                        $rootScope.$$phase || asyncQueue.length || $browser.defer(function() {
                            asyncQueue.length && $rootScope.$digest()
                        }, null, "$evalAsync"), asyncQueue.push({
                            scope: this,
                            fn: $parse(expr),
                            locals: locals
                        })
                    },
                    $$postDigest: function(fn) {
                        postDigestQueue.push(fn)
                    },
                    $apply: function(expr) {
                        try {
                            beginPhase("$apply");
                            try {
                                return this.$eval(expr)
                            } finally {
                                clearPhase()
                            }
                        } catch (e) {
                            $exceptionHandler(e)
                        } finally {
                            try {
                                $rootScope.$digest()
                            } catch (e) {
                                throw $exceptionHandler(e), e
                            }
                        }
                    },
                    $applyAsync: function(expr) {
                        function $applyAsyncExpression() {
                            scope.$eval(expr)
                        }
                        var scope = this;
                        expr && applyAsyncQueue.push($applyAsyncExpression), expr = $parse(expr), scheduleApplyAsync()
                    },
                    $on: function(name, listener) {
                        var namedListeners = this.$$listeners[name];
                        namedListeners || (this.$$listeners[name] = namedListeners = []), namedListeners.push(listener);
                        var current = this;
                        do current.$$listenerCount[name] || (current.$$listenerCount[name] = 0), current.$$listenerCount[name]++; while (current = current.$parent);
                        var self = this;
                        return function() {
                            var indexOfListener = namedListeners.indexOf(listener);
                            indexOfListener !== -1 && (delete namedListeners[indexOfListener], decrementListenerCount(self, 1, name))
                        }
                    },
                    $emit: function(name, args) {
                        var namedListeners, i, length, empty = [],
                            scope = this,
                            _stopPropagation2 = !1,
                            event = {
                                name: name,
                                targetScope: scope,
                                stopPropagation: function() {
                                    _stopPropagation2 = !0
                                },
                                preventDefault: function() {
                                    event.defaultPrevented = !0
                                },
                                defaultPrevented: !1
                            },
                            listenerArgs = concat([event], arguments, 1);
                        do {
                            for (namedListeners = scope.$$listeners[name] || empty, event.currentScope = scope, i = 0, length = namedListeners.length; i < length; i++)
                                if (namedListeners[i]) try {
                                    namedListeners[i].apply(null, listenerArgs)
                                } catch (e) {
                                    $exceptionHandler(e)
                                } else namedListeners.splice(i, 1), i--, length--;
                            if (_stopPropagation2) break;
                            scope = scope.$parent
                        } while (scope);
                        return event.currentScope = null, event
                    },
                    $broadcast: function(name, args) {
                        var target = this,
                            current = target,
                            next = target,
                            event = {
                                name: name,
                                targetScope: target,
                                preventDefault: function() {
                                    event.defaultPrevented = !0
                                },
                                defaultPrevented: !1
                            };
                        if (!target.$$listenerCount[name]) return event;
                        for (var listeners, i, length, listenerArgs = concat([event], arguments, 1); current = next;) {
                            for (event.currentScope = current, listeners = current.$$listeners[name] || [], i = 0, length = listeners.length; i < length; i++)
                                if (listeners[i]) try {
                                    listeners[i].apply(null, listenerArgs)
                                } catch (e) {
                                    $exceptionHandler(e)
                                } else listeners.splice(i, 1), i--, length--;
                            if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling))
                                for (; current !== target && !(next = current.$$nextSibling);) current = current.$parent
                        }
                        return event.currentScope = null, event
                    }
                };
                var $rootScope = new Scope,
                    asyncQueue = $rootScope.$$asyncQueue = [],
                    postDigestQueue = $rootScope.$$postDigestQueue = [],
                    applyAsyncQueue = $rootScope.$$applyAsyncQueue = [],
                    postDigestQueuePosition = 0;
                return $rootScope
            }]
        }

        function $$SanitizeUriProvider() {
            var aHrefSanitizationWhitelist = /^\s*(https?|s?ftp|mailto|tel|file):/,
                imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
            this.aHrefSanitizationWhitelist = function(regexp) {
                return isDefined(regexp) ? (aHrefSanitizationWhitelist = regexp, this) : aHrefSanitizationWhitelist
            }, this.imgSrcSanitizationWhitelist = function(regexp) {
                return isDefined(regexp) ? (imgSrcSanitizationWhitelist = regexp, this) : imgSrcSanitizationWhitelist
            }, this.$get = function() {
                return function(uri, isMediaUrl) {
                    var regex = isMediaUrl ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist,
                        normalizedVal = urlResolve(uri && uri.trim()).href;
                    return "" === normalizedVal || normalizedVal.match(regex) ? uri : "unsafe:" + normalizedVal
                }
            }
        }

        function snakeToCamel(name) {
            return name.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace)
        }

        function adjustMatcher(matcher) {
            if ("self" === matcher) return matcher;
            if (isString(matcher)) {
                if (matcher.indexOf("***") > -1) throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
                return matcher = escapeForRegexp(matcher).replace(/\\\*\\\*/g, ".*").replace(/\\\*/g, "[^:/.?&;]*"), new RegExp("^" + matcher + "$")
            }
            if (isRegExp(matcher)) return new RegExp("^" + matcher.source + "$");
            throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects')
        }

        function adjustMatchers(matchers) {
            var adjustedMatchers = [];
            return isDefined(matchers) && forEach(matchers, function(matcher) {
                adjustedMatchers.push(adjustMatcher(matcher))
            }), adjustedMatchers
        }

        function $SceDelegateProvider() {
            this.SCE_CONTEXTS = SCE_CONTEXTS;
            var resourceUrlWhitelist = ["self"],
                resourceUrlBlacklist = [];
            this.resourceUrlWhitelist = function(value) {
                return arguments.length && (resourceUrlWhitelist = adjustMatchers(value)), resourceUrlWhitelist
            }, this.resourceUrlBlacklist = function(value) {
                return arguments.length && (resourceUrlBlacklist = adjustMatchers(value)), resourceUrlBlacklist
            }, this.$get = ["$injector", "$$sanitizeUri", function($injector, $$sanitizeUri) {
                function matchUrl(matcher, parsedUrl) {
                    return "self" === matcher ? urlIsSameOrigin(parsedUrl) || urlIsSameOriginAsBaseUrl(parsedUrl) : !!matcher.exec(parsedUrl.href)
                }

                function isResourceUrlAllowedByPolicy(url) {
                    var i, n, parsedUrl = urlResolve(url.toString()),
                        allowed = !1;
                    for (i = 0, n = resourceUrlWhitelist.length; i < n; i++)
                        if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                            allowed = !0;
                            break
                        } if (allowed)
                        for (i = 0, n = resourceUrlBlacklist.length; i < n; i++)
                            if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                                allowed = !1;
                                break
                            } return allowed
                }

                function generateHolderType(Base) {
                    var holderType = function(trustedValue) {
                        this.$$unwrapTrustedValue = function() {
                            return trustedValue
                        }
                    };
                    return Base && (holderType.prototype = new Base), holderType.prototype.valueOf = function() {
                        return this.$$unwrapTrustedValue()
                    }, holderType.prototype.toString = function() {
                        return this.$$unwrapTrustedValue().toString()
                    }, holderType
                }

                function trustAs(type, trustedValue) {
                    var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                    if (!Constructor) throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                    if (null === trustedValue || isUndefined(trustedValue) || "" === trustedValue) return trustedValue;
                    if ("string" != typeof trustedValue) throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                    return new Constructor(trustedValue)
                }

                function valueOf(maybeTrusted) {
                    return maybeTrusted instanceof trustedValueHolderBase ? maybeTrusted.$$unwrapTrustedValue() : maybeTrusted
                }

                function getTrusted(type, maybeTrusted) {
                    if (null === maybeTrusted || isUndefined(maybeTrusted) || "" === maybeTrusted) return maybeTrusted;
                    var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                    if (constructor && maybeTrusted instanceof constructor) return maybeTrusted.$$unwrapTrustedValue();
                    if (isFunction(maybeTrusted.$$unwrapTrustedValue) && (maybeTrusted = maybeTrusted.$$unwrapTrustedValue()), type === SCE_CONTEXTS.MEDIA_URL || type === SCE_CONTEXTS.URL) return $$sanitizeUri(maybeTrusted.toString(), type === SCE_CONTEXTS.MEDIA_URL);
                    if (type === SCE_CONTEXTS.RESOURCE_URL) {
                        if (isResourceUrlAllowedByPolicy(maybeTrusted)) return maybeTrusted;
                        throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString())
                    }
                    if (type === SCE_CONTEXTS.HTML) return htmlSanitizer(maybeTrusted);
                    throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.")
                }
                var htmlSanitizer = function(html) {
                    throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.")
                };
                $injector.has("$sanitize") && (htmlSanitizer = $injector.get("$sanitize"));
                var trustedValueHolderBase = generateHolderType(),
                    byType = {};
                return byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.MEDIA_URL] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.URL] = generateHolderType(byType[SCE_CONTEXTS.MEDIA_URL]), byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]), {
                    trustAs: trustAs,
                    getTrusted: getTrusted,
                    valueOf: valueOf
                }
            }]
        }

        function $SceProvider() {
            var enabled = !0;
            this.enabled = function(value) {
                return arguments.length && (enabled = !!value), enabled
            }, this.$get = ["$parse", "$sceDelegate", function($parse, $sceDelegate) {
                if (enabled && msie < 8) throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
                var sce = shallowCopy(SCE_CONTEXTS);
                sce.isEnabled = function() {
                    return enabled
                }, sce.trustAs = $sceDelegate.trustAs, sce.getTrusted = $sceDelegate.getTrusted, sce.valueOf = $sceDelegate.valueOf, enabled || (sce.trustAs = sce.getTrusted = function(type, value) {
                    return value
                }, sce.valueOf = identity), sce.parseAs = function(type, expr) {
                    var parsed = $parse(expr);
                    return parsed.literal && parsed.constant ? parsed : $parse(expr, function(value) {
                        return sce.getTrusted(type, value)
                    })
                };
                var parse = sce.parseAs,
                    getTrusted = sce.getTrusted,
                    trustAs = sce.trustAs;
                return forEach(SCE_CONTEXTS, function(enumValue, name) {
                    var lName = lowercase(name);
                    sce[snakeToCamel("parse_as_" + lName)] = function(expr) {
                        return parse(enumValue, expr)
                    }, sce[snakeToCamel("get_trusted_" + lName)] = function(value) {
                        return getTrusted(enumValue, value)
                    }, sce[snakeToCamel("trust_as_" + lName)] = function(value) {
                        return trustAs(enumValue, value)
                    }
                }), sce
            }]
        }

        function $SnifferProvider() {
            this.$get = ["$window", "$document", function($window, $document) {
                var eventSupport = {},
                    isNw = $window.nw && $window.nw.process,
                    isChromePackagedApp = !isNw && $window.chrome && ($window.chrome.app && $window.chrome.app.runtime || !$window.chrome.app && $window.chrome.runtime && $window.chrome.runtime.id),
                    hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState,
                    android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
                    boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
                    document = $document[0] || {},
                    bodyStyle = document.body && document.body.style,
                    transitions = !1,
                    animations = !1;
                return bodyStyle && (transitions = !!("transition" in bodyStyle || "webkitTransition" in bodyStyle), animations = !!("animation" in bodyStyle || "webkitAnimation" in bodyStyle)), {
                    history: !(!hasHistoryPushState || android < 4 || boxee),
                    hasEvent: function(event) {
                        if ("input" === event && msie) return !1;
                        if (isUndefined(eventSupport[event])) {
                            var divElm = document.createElement("div");
                            eventSupport[event] = "on" + event in divElm
                        }
                        return eventSupport[event]
                    },
                    csp: csp(),
                    transitions: transitions,
                    animations: animations,
                    android: android
                }
            }]
        }

        function $$TaskTrackerFactoryProvider() {
            this.$get = valueFn(function(log) {
                return new TaskTracker(log)
            })
        }

        function TaskTracker(log) {
            function completeTask(fn, taskType) {
                taskType = taskType || DEFAULT_TASK_TYPE;
                try {
                    fn()
                } finally {
                    decTaskCount(taskType);
                    var countForType = taskCounts[taskType],
                        countForAll = taskCounts[ALL_TASKS_TYPE];
                    if (!countForAll || !countForType)
                        for (var nextCb, getNextCallback = countForAll ? getLastCallbackForType : getLastCallback; nextCb = getNextCallback(taskType);) try {
                            nextCb()
                        } catch (e) {
                            log.error(e)
                        }
                }
            }

            function decTaskCount(taskType) {
                taskType = taskType || DEFAULT_TASK_TYPE, taskCounts[taskType] && (taskCounts[taskType]--, taskCounts[ALL_TASKS_TYPE]--)
            }

            function getLastCallback() {
                var cbInfo = taskCallbacks.pop();
                return cbInfo && cbInfo.cb
            }

            function getLastCallbackForType(taskType) {
                for (var i = taskCallbacks.length - 1; i >= 0; --i) {
                    var cbInfo = taskCallbacks[i];
                    if (cbInfo.type === taskType) return taskCallbacks.splice(i, 1), cbInfo.cb
                }
            }

            function incTaskCount(taskType) {
                taskType = taskType || DEFAULT_TASK_TYPE, taskCounts[taskType] = (taskCounts[taskType] || 0) + 1, taskCounts[ALL_TASKS_TYPE] = (taskCounts[ALL_TASKS_TYPE] || 0) + 1
            }

            function notifyWhenNoPendingTasks(callback, taskType) {
                taskType = taskType || ALL_TASKS_TYPE, taskCounts[taskType] ? taskCallbacks.push({
                    type: taskType,
                    cb: callback
                }) : callback()
            }
            var self = this,
                taskCounts = {},
                taskCallbacks = [],
                ALL_TASKS_TYPE = self.ALL_TASKS_TYPE = "$$all$$",
                DEFAULT_TASK_TYPE = self.DEFAULT_TASK_TYPE = "$$default$$";
            self.completeTask = completeTask, self.incTaskCount = incTaskCount, self.notifyWhenNoPendingTasks = notifyWhenNoPendingTasks
        }

        function $TemplateRequestProvider() {
            var httpOptions;
            this.httpOptions = function(val) {
                return val ? (httpOptions = val, this) : httpOptions
            }, this.$get = ["$exceptionHandler", "$templateCache", "$http", "$q", "$sce", function($exceptionHandler, $templateCache, $http, $q, $sce) {
                function handleRequestFn(tpl, ignoreRequestError) {
                    function handleError(resp) {
                        return ignoreRequestError || (resp = $templateRequestMinErr("tpload", "Failed to load template: {0} (HTTP status: {1} {2})", tpl, resp.status, resp.statusText), $exceptionHandler(resp)), $q.reject(resp)
                    }
                    handleRequestFn.totalPendingRequests++, isString(tpl) && !isUndefined($templateCache.get(tpl)) || (tpl = $sce.getTrustedResourceUrl(tpl));
                    var transformResponse = $http.defaults && $http.defaults.transformResponse;
                    return isArray(transformResponse) ? transformResponse = transformResponse.filter(function(transformer) {
                        return transformer !== defaultHttpResponseTransform
                    }) : transformResponse === defaultHttpResponseTransform && (transformResponse = null), $http.get(tpl, extend({
                        cache: $templateCache,
                        transformResponse: transformResponse
                    }, httpOptions)).finally(function() {
                        handleRequestFn.totalPendingRequests--
                    }).then(function(response) {
                        return $templateCache.put(tpl, response.data)
                    }, handleError)
                }
                return handleRequestFn.totalPendingRequests = 0, handleRequestFn
            }]
        }

        function $$TestabilityProvider() {
            this.$get = ["$rootScope", "$browser", "$location", function($rootScope, $browser, $location) {
                var testability = {};
                return testability.findBindings = function(element, expression, opt_exactMatch) {
                    var bindings = element.getElementsByClassName("ng-binding"),
                        matches = [];
                    return forEach(bindings, function(binding) {
                        var dataBinding = angular.element(binding).data("$binding");
                        dataBinding && forEach(dataBinding, function(bindingName) {
                            if (opt_exactMatch) {
                                var matcher = new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)");
                                matcher.test(bindingName) && matches.push(binding)
                            } else bindingName.indexOf(expression) !== -1 && matches.push(binding)
                        })
                    }), matches
                }, testability.findModels = function(element, expression, opt_exactMatch) {
                    for (var prefixes = ["ng-", "data-ng-", "ng\\:"], p = 0; p < prefixes.length; ++p) {
                        var attributeEquals = opt_exactMatch ? "=" : "*=",
                            selector = "[" + prefixes[p] + "model" + attributeEquals + '"' + expression + '"]',
                            elements = element.querySelectorAll(selector);
                        if (elements.length) return elements
                    }
                }, testability.getLocation = function() {
                    return $location.url()
                }, testability.setLocation = function(url) {
                    url !== $location.url() && ($location.url(url), $rootScope.$digest())
                }, testability.whenStable = function(callback) {
                    $browser.notifyWhenNoOutstandingRequests(callback)
                }, testability
            }]
        }

        function $TimeoutProvider() {
            this.$get = ["$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function($rootScope, $browser, $q, $$q, $exceptionHandler) {
                function timeout(fn, delay, invokeApply) {
                    isFunction(fn) || (invokeApply = delay, delay = fn, fn = noop);
                    var timeoutId, args = sliceArgs(arguments, 3),
                        skipApply = isDefined(invokeApply) && !invokeApply,
                        deferred = (skipApply ? $$q : $q).defer(),
                        promise = deferred.promise;
                    return timeoutId = $browser.defer(function() {
                        try {
                            deferred.resolve(fn.apply(null, args))
                        } catch (e) {
                            deferred.reject(e), $exceptionHandler(e)
                        } finally {
                            delete deferreds[promise.$$timeoutId]
                        }
                        skipApply || $rootScope.$apply()
                    }, delay, "$timeout"), promise.$$timeoutId = timeoutId, deferreds[timeoutId] = deferred, promise
                }
                var deferreds = {};
                return timeout.cancel = function(promise) {
                    if (!promise) return !1;
                    if (!promise.hasOwnProperty("$$timeoutId")) throw $timeoutMinErr("badprom", "`$timeout.cancel()` called with a promise that was not generated by `$timeout()`.");
                    if (!deferreds.hasOwnProperty(promise.$$timeoutId)) return !1;
                    var id = promise.$$timeoutId,
                        deferred = deferreds[id];
                    return markQExceptionHandled(deferred.promise), deferred.reject("canceled"), delete deferreds[id], $browser.defer.cancel(id)
                }, timeout
            }]
        }

        function urlResolve(url) {
            if (!isString(url)) return url;
            var href = url;
            msie && (urlParsingNode.setAttribute("href", href), href = urlParsingNode.href), urlParsingNode.setAttribute("href", href);
            var hostname = urlParsingNode.hostname;
            return !ipv6InBrackets && hostname.indexOf(":") > -1 && (hostname = "[" + hostname + "]"), {
                href: urlParsingNode.href,
                protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
                host: urlParsingNode.host,
                search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
                hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
                hostname: hostname,
                port: urlParsingNode.port,
                pathname: "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
            }
        }

        function urlIsSameOrigin(requestUrl) {
            return urlsAreSameOrigin(requestUrl, originUrl)
        }

        function urlIsSameOriginAsBaseUrl(requestUrl) {
            return urlsAreSameOrigin(requestUrl, getBaseUrl())
        }

        function urlIsAllowedOriginFactory(whitelistedOriginUrls) {
            var parsedAllowedOriginUrls = [originUrl].concat(whitelistedOriginUrls.map(urlResolve));
            return function(requestUrl) {
                var parsedUrl = urlResolve(requestUrl);
                return parsedAllowedOriginUrls.some(urlsAreSameOrigin.bind(null, parsedUrl))
            }
        }

        function urlsAreSameOrigin(url1, url2) {
            return url1 = urlResolve(url1), url2 = urlResolve(url2), url1.protocol === url2.protocol && url1.host === url2.host
        }

        function getBaseUrl() {
            return window.document.baseURI ? window.document.baseURI : (baseUrlParsingNode || (baseUrlParsingNode = window.document.createElement("a"), baseUrlParsingNode.href = ".", baseUrlParsingNode = baseUrlParsingNode.cloneNode(!1)),
                baseUrlParsingNode.href)
        }

        function $WindowProvider() {
            this.$get = valueFn(window)
        }

        function $$CookieReader($document) {
            function safeGetCookie(rawDocument) {
                try {
                    return rawDocument.cookie || ""
                } catch (e) {
                    return ""
                }
            }

            function safeDecodeURIComponent(str) {
                try {
                    return decodeURIComponent(str)
                } catch (e) {
                    return str
                }
            }
            var rawDocument = $document[0] || {},
                lastCookies = {},
                lastCookieString = "";
            return function() {
                var cookieArray, cookie, i, index, name, currentCookieString = safeGetCookie(rawDocument);
                if (currentCookieString !== lastCookieString)
                    for (lastCookieString = currentCookieString, cookieArray = lastCookieString.split("; "), lastCookies = {}, i = 0; i < cookieArray.length; i++) cookie = cookieArray[i], index = cookie.indexOf("="), index > 0 && (name = safeDecodeURIComponent(cookie.substring(0, index)), isUndefined(lastCookies[name]) && (lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1))));
                return lastCookies
            }
        }

        function $$CookieReaderProvider() {
            this.$get = $$CookieReader
        }

        function $FilterProvider($provide) {
            function register(name, factory) {
                if (isObject(name)) {
                    var filters = {};
                    return forEach(name, function(filter, key) {
                        filters[key] = register(key, filter)
                    }), filters
                }
                return $provide.factory(name + suffix, factory)
            }
            var suffix = "Filter";
            this.register = register, this.$get = ["$injector", function($injector) {
                return function(name) {
                    return $injector.get(name + suffix)
                }
            }], register("currency", currencyFilter), register("date", dateFilter), register("filter", filterFilter), register("json", jsonFilter), register("limitTo", limitToFilter), register("lowercase", lowercaseFilter), register("number", numberFilter), register("orderBy", orderByFilter), register("uppercase", uppercaseFilter)
        }

        function filterFilter() {
            return function(array, expression, comparator, anyPropertyKey) {
                if (!isArrayLike(array)) {
                    if (null == array) return array;
                    throw minErr("filter")("notarray", "Expected array but received: {0}", array)
                }
                anyPropertyKey = anyPropertyKey || "$";
                var predicateFn, matchAgainstAnyProp, expressionType = getTypeForFilter(expression);
                switch (expressionType) {
                    case "function":
                        predicateFn = expression;
                        break;
                    case "boolean":
                    case "null":
                    case "number":
                    case "string":
                        matchAgainstAnyProp = !0;
                    case "object":
                        predicateFn = createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp);
                        break;
                    default:
                        return array
                }
                return Array.prototype.filter.call(array, predicateFn)
            }
        }

        function createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp) {
            var predicateFn, shouldMatchPrimitives = isObject(expression) && anyPropertyKey in expression;
            return comparator === !0 ? comparator = equals : isFunction(comparator) || (comparator = function(actual, expected) {
                return !isUndefined(actual) && (null === actual || null === expected ? actual === expected : !(isObject(expected) || isObject(actual) && !hasCustomToString(actual)) && (actual = lowercase("" + actual), expected = lowercase("" + expected), actual.indexOf(expected) !== -1))
            }), predicateFn = function(item) {
                return shouldMatchPrimitives && !isObject(item) ? deepCompare(item, expression[anyPropertyKey], comparator, anyPropertyKey, !1) : deepCompare(item, expression, comparator, anyPropertyKey, matchAgainstAnyProp)
            }
        }

        function deepCompare(actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {
            var actualType = getTypeForFilter(actual),
                expectedType = getTypeForFilter(expected);
            if ("string" === expectedType && "!" === expected.charAt(0)) return !deepCompare(actual, expected.substring(1), comparator, anyPropertyKey, matchAgainstAnyProp);
            if (isArray(actual)) return actual.some(function(item) {
                return deepCompare(item, expected, comparator, anyPropertyKey, matchAgainstAnyProp)
            });
            switch (actualType) {
                case "object":
                    var key;
                    if (matchAgainstAnyProp) {
                        for (key in actual)
                            if (key.charAt && "$" !== key.charAt(0) && deepCompare(actual[key], expected, comparator, anyPropertyKey, !0)) return !0;
                        return !dontMatchWholeObject && deepCompare(actual, expected, comparator, anyPropertyKey, !1)
                    }
                    if ("object" === expectedType) {
                        for (key in expected) {
                            var expectedVal = expected[key];
                            if (!isFunction(expectedVal) && !isUndefined(expectedVal)) {
                                var matchAnyProperty = key === anyPropertyKey,
                                    actualVal = matchAnyProperty ? actual : actual[key];
                                if (!deepCompare(actualVal, expectedVal, comparator, anyPropertyKey, matchAnyProperty, matchAnyProperty)) return !1
                            }
                        }
                        return !0
                    }
                    return comparator(actual, expected);
                case "function":
                    return !1;
                default:
                    return comparator(actual, expected)
            }
        }

        function getTypeForFilter(val) {
            return null === val ? "null" : _typeof2(val)
        }

        function currencyFilter($locale) {
            var formats = $locale.NUMBER_FORMATS;
            return function(amount, currencySymbol, fractionSize) {
                isUndefined(currencySymbol) && (currencySymbol = formats.CURRENCY_SYM), isUndefined(fractionSize) && (fractionSize = formats.PATTERNS[1].maxFrac);
                var currencySymbolRe = currencySymbol ? /\u00A4/g : /\s*\u00A4\s*/g;
                return null == amount ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(currencySymbolRe, currencySymbol)
            }
        }

        function numberFilter($locale) {
            var formats = $locale.NUMBER_FORMATS;
            return function(number, fractionSize) {
                return null == number ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize)
            }
        }

        function parse(numStr) {
            var digits, numberOfIntegerDigits, i, j, zeros, exponent = 0;
            for ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1 && (numStr = numStr.replace(DECIMAL_SEP, "")), (i = numStr.search(/e/i)) > 0 ? (numberOfIntegerDigits < 0 && (numberOfIntegerDigits = i), numberOfIntegerDigits += +numStr.slice(i + 1), numStr = numStr.substring(0, i)) : numberOfIntegerDigits < 0 && (numberOfIntegerDigits = numStr.length), i = 0; numStr.charAt(i) === ZERO_CHAR; i++);
            if (i === (zeros = numStr.length)) digits = [0], numberOfIntegerDigits = 1;
            else {
                for (zeros--; numStr.charAt(zeros) === ZERO_CHAR;) zeros--;
                for (numberOfIntegerDigits -= i, digits = [], j = 0; i <= zeros; i++, j++) digits[j] = +numStr.charAt(i)
            }
            return numberOfIntegerDigits > MAX_DIGITS && (digits = digits.splice(0, MAX_DIGITS - 1), exponent = numberOfIntegerDigits - 1, numberOfIntegerDigits = 1), {
                d: digits,
                e: exponent,
                i: numberOfIntegerDigits
            }
        }

        function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
            var digits = parsedNumber.d,
                fractionLen = digits.length - parsedNumber.i;
            fractionSize = isUndefined(fractionSize) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
            var roundAt = fractionSize + parsedNumber.i,
                digit = digits[roundAt];
            if (roundAt > 0) {
                digits.splice(Math.max(parsedNumber.i, roundAt));
                for (var j = roundAt; j < digits.length; j++) digits[j] = 0
            } else {
                fractionLen = Math.max(0, fractionLen), parsedNumber.i = 1, digits.length = Math.max(1, roundAt = fractionSize + 1), digits[0] = 0;
                for (var i = 1; i < roundAt; i++) digits[i] = 0
            }
            if (digit >= 5)
                if (roundAt - 1 < 0) {
                    for (var k = 0; k > roundAt; k--) digits.unshift(0), parsedNumber.i++;
                    digits.unshift(1), parsedNumber.i++
                } else digits[roundAt - 1]++;
            for (; fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
            var carry = digits.reduceRight(function(carry, d, i, digits) {
                return d += carry, digits[i] = d % 10, Math.floor(d / 10)
            }, 0);
            carry && (digits.unshift(carry), parsedNumber.i++)
        }

        function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
            if (!isString(number) && !isNumber(number) || isNaN(number)) return "";
            var parsedNumber, isInfinity = !isFinite(number),
                isZero = !1,
                numStr = Math.abs(number) + "",
                formattedText = "";
            if (isInfinity) formattedText = "";
            else {
                parsedNumber = parse(numStr), roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
                var digits = parsedNumber.d,
                    integerLen = parsedNumber.i,
                    exponent = parsedNumber.e,
                    decimals = [];
                for (isZero = digits.reduce(function(isZero, d) {
                        return isZero && !d
                    }, !0); integerLen < 0;) digits.unshift(0), integerLen++;
                integerLen > 0 ? decimals = digits.splice(integerLen, digits.length) : (decimals = digits, digits = [0]);
                var groups = [];
                for (digits.length >= pattern.lgSize && groups.unshift(digits.splice(-pattern.lgSize, digits.length).join("")); digits.length > pattern.gSize;) groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
                digits.length && groups.unshift(digits.join("")), formattedText = groups.join(groupSep), decimals.length && (formattedText += decimalSep + decimals.join("")), exponent && (formattedText += "e+" + exponent)
            }
            return number < 0 && !isZero ? pattern.negPre + formattedText + pattern.negSuf : pattern.posPre + formattedText + pattern.posSuf
        }

        function padNumber(num, digits, trim, negWrap) {
            var neg = "";
            for ((num < 0 || negWrap && num <= 0) && (negWrap ? num = -num + 1 : (num = -num, neg = "-")), num = "" + num; num.length < digits;) num = ZERO_CHAR + num;
            return trim && (num = num.substr(num.length - digits)), neg + num
        }

        function dateGetter(name, size, offset, trim, negWrap) {
            return offset = offset || 0,
                function(date) {
                    var value = date["get" + name]();
                    return (offset > 0 || value > -offset) && (value += offset), 0 === value && offset === -12 && (value = 12), padNumber(value, size, trim, negWrap)
                }
        }

        function dateStrGetter(name, shortForm, standAlone) {
            return function(date, formats) {
                var value = date["get" + name](),
                    propPrefix = (standAlone ? "STANDALONE" : "") + (shortForm ? "SHORT" : ""),
                    get = uppercase(propPrefix + name);
                return formats[get][value]
            }
        }

        function timeZoneGetter(date, formats, offset) {
            var zone = -1 * offset,
                paddedZone = zone >= 0 ? "+" : "";
            return paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2)
        }

        function getFirstThursdayOfYear(year) {
            var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
            return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst)
        }

        function getThursdayThisWeek(datetime) {
            return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()))
        }

        function weekGetter(size) {
            return function(date) {
                var firstThurs = getFirstThursdayOfYear(date.getFullYear()),
                    thisThurs = getThursdayThisWeek(date),
                    diff = +thisThurs - +firstThurs,
                    result = 1 + Math.round(diff / 6048e5);
                return padNumber(result, size)
            }
        }

        function ampmGetter(date, formats) {
            return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1]
        }

        function eraGetter(date, formats) {
            return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1]
        }

        function longEraGetter(date, formats) {
            return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1]
        }

        function dateFilter($locale) {
            function jsonStringToDate(string) {
                var match;
                if (match = string.match(R_ISO8601_STR)) {
                    var date = new Date(0),
                        tzHour = 0,
                        tzMin = 0,
                        dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                        timeSetter = match[8] ? date.setUTCHours : date.setHours;
                    match[9] && (tzHour = toInt(match[9] + match[10]), tzMin = toInt(match[9] + match[11])), dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
                    var h = toInt(match[4] || 0) - tzHour,
                        m = toInt(match[5] || 0) - tzMin,
                        s = toInt(match[6] || 0),
                        ms = Math.round(1e3 * parseFloat("0." + (match[7] || 0)));
                    return timeSetter.call(date, h, m, s, ms), date
                }
                return string
            }
            var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
            return function(date, format, timezone) {
                var fn, match, text = "",
                    parts = [];
                if (format = format || "mediumDate", format = $locale.DATETIME_FORMATS[format] || format, isString(date) && (date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date)), isNumber(date) && (date = new Date(date)), !isDate(date) || !isFinite(date.getTime())) return date;
                for (; format;) match = DATE_FORMATS_SPLIT.exec(format), match ? (parts = concat(parts, match, 1), format = parts.pop()) : (parts.push(format), format = null);
                var dateTimezoneOffset = date.getTimezoneOffset();
                return timezone && (dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset), date = convertTimezoneToLocal(date, timezone, !0)), forEach(parts, function(value) {
                    fn = DATE_FORMATS[value], text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : "''" === value ? "'" : value.replace(/(^'|'$)/g, "").replace(/''/g, "'")
                }), text
            }
        }

        function jsonFilter() {
            return function(object, spacing) {
                return isUndefined(spacing) && (spacing = 2), toJson(object, spacing)
            }
        }

        function limitToFilter() {
            return function(input, limit, begin) {
                return limit = Math.abs(Number(limit)) === 1 / 0 ? Number(limit) : toInt(limit), isNumberNaN(limit) ? input : (isNumber(input) && (input = input.toString()), isArrayLike(input) ? (begin = !begin || isNaN(begin) ? 0 : toInt(begin), begin = begin < 0 ? Math.max(0, input.length + begin) : begin, limit >= 0 ? sliceFn(input, begin, begin + limit) : 0 === begin ? sliceFn(input, limit, input.length) : sliceFn(input, Math.max(0, begin + limit), begin)) : input)
            }
        }

        function sliceFn(input, begin, end) {
            return isString(input) ? input.slice(begin, end) : slice.call(input, begin, end)
        }

        function orderByFilter($parse) {
            function processPredicates(sortPredicates) {
                return sortPredicates.map(function(predicate) {
                    var descending = 1,
                        get = identity;
                    if (isFunction(predicate)) get = predicate;
                    else if (isString(predicate) && ("+" !== predicate.charAt(0) && "-" !== predicate.charAt(0) || (descending = "-" === predicate.charAt(0) ? -1 : 1, predicate = predicate.substring(1)), "" !== predicate && (get = $parse(predicate), get.constant))) {
                        var key = get();
                        get = function(value) {
                            return value[key]
                        }
                    }
                    return {
                        get: get,
                        descending: descending
                    }
                })
            }

            function isPrimitive(value) {
                switch (_typeof2(value)) {
                    case "number":
                    case "boolean":
                    case "string":
                        return !0;
                    default:
                        return !1
                }
            }

            function objectValue(value) {
                return isFunction(value.valueOf) && (value = value.valueOf(), isPrimitive(value)) ? value : hasCustomToString(value) && (value = value.toString(), isPrimitive(value)) ? value : value
            }

            function getPredicateValue(value, index) {
                var type = _typeof2(value);
                return null === value ? type = "null" : "object" === type && (value = objectValue(value)), {
                    value: value,
                    type: type,
                    index: index
                }
            }

            function defaultCompare(v1, v2) {
                var result = 0,
                    type1 = v1.type,
                    type2 = v2.type;
                if (type1 === type2) {
                    var value1 = v1.value,
                        value2 = v2.value;
                    "string" === type1 ? (value1 = value1.toLowerCase(), value2 = value2.toLowerCase()) : "object" === type1 && (isObject(value1) && (value1 = v1.index), isObject(value2) && (value2 = v2.index)), value1 !== value2 && (result = value1 < value2 ? -1 : 1)
                } else result = "undefined" === type1 ? 1 : "undefined" === type2 ? -1 : "null" === type1 ? 1 : "null" === type2 ? -1 : type1 < type2 ? -1 : 1;
                return result
            }
            return function(array, sortPredicate, reverseOrder, compareFn) {
                function getComparisonObject(value, index) {
                    return {
                        value: value,
                        tieBreaker: {
                            value: index,
                            type: "number",
                            index: index
                        },
                        predicateValues: predicates.map(function(predicate) {
                            return getPredicateValue(predicate.get(value), index)
                        })
                    }
                }

                function doComparison(v1, v2) {
                    for (var i = 0, ii = predicates.length; i < ii; i++) {
                        var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
                        if (result) return result * predicates[i].descending * descending
                    }
                    return (compare(v1.tieBreaker, v2.tieBreaker) || defaultCompare(v1.tieBreaker, v2.tieBreaker)) * descending
                }
                if (null == array) return array;
                if (!isArrayLike(array)) throw minErr("orderBy")("notarray", "Expected array but received: {0}", array);
                isArray(sortPredicate) || (sortPredicate = [sortPredicate]), 0 === sortPredicate.length && (sortPredicate = ["+"]);
                var predicates = processPredicates(sortPredicate),
                    descending = reverseOrder ? -1 : 1,
                    compare = isFunction(compareFn) ? compareFn : defaultCompare,
                    compareValues = Array.prototype.map.call(array, getComparisonObject);
                return compareValues.sort(doComparison), array = compareValues.map(function(item) {
                    return item.value
                })
            }
        }

        function ngDirective(directive) {
            return isFunction(directive) && (directive = {
                link: directive
            }), directive.restrict = directive.restrict || "AC", valueFn(directive)
        }

        function nullFormRenameControl(control, name) {
            control.$name = name
        }

        function FormController($element, $attrs, $scope, $animate, $interpolate) {
            this.$$controls = [], this.$error = {}, this.$$success = {}, this.$pending = void 0, this.$name = $interpolate($attrs.name || $attrs.ngForm || "")($scope), this.$dirty = !1, this.$pristine = !0, this.$valid = !0, this.$invalid = !1, this.$submitted = !1, this.$$parentForm = nullFormCtrl, this.$$element = $element, this.$$animate = $animate, setupValidity(this)
        }

        function setupValidity(instance) {
            instance.$$classCache = {}, instance.$$classCache[INVALID_CLASS] = !(instance.$$classCache[VALID_CLASS] = instance.$$element.hasClass(VALID_CLASS))
        }

        function addSetValidityMethod(context) {
            function createAndSet(ctrl, name, value, controller) {
                ctrl[name] || (ctrl[name] = {}), set(ctrl[name], value, controller)
            }

            function unsetAndCleanup(ctrl, name, value, controller) {
                ctrl[name] && unset(ctrl[name], value, controller), isObjectEmpty(ctrl[name]) && (ctrl[name] = void 0)
            }

            function cachedToggleClass(ctrl, className, switchValue) {
                switchValue && !ctrl.$$classCache[className] ? (ctrl.$$animate.addClass(ctrl.$$element, className), ctrl.$$classCache[className] = !0) : !switchValue && ctrl.$$classCache[className] && (ctrl.$$animate.removeClass(ctrl.$$element, className), ctrl.$$classCache[className] = !1)
            }

            function toggleValidationCss(ctrl, validationErrorKey, isValid) {
                validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "", cachedToggleClass(ctrl, VALID_CLASS + validationErrorKey, isValid === !0), cachedToggleClass(ctrl, INVALID_CLASS + validationErrorKey, isValid === !1)
            }
            var clazz = context.clazz,
                set = context.set,
                unset = context.unset;
            clazz.prototype.$setValidity = function(validationErrorKey, state, controller) {
                isUndefined(state) ? createAndSet(this, "$pending", validationErrorKey, controller) : unsetAndCleanup(this, "$pending", validationErrorKey, controller), isBoolean(state) ? state ? (unset(this.$error, validationErrorKey, controller), set(this.$$success, validationErrorKey, controller)) : (set(this.$error, validationErrorKey, controller), unset(this.$$success, validationErrorKey, controller)) : (unset(this.$error, validationErrorKey, controller), unset(this.$$success, validationErrorKey, controller)), this.$pending ? (cachedToggleClass(this, PENDING_CLASS, !0), this.$valid = this.$invalid = void 0, toggleValidationCss(this, "", null)) : (cachedToggleClass(this, PENDING_CLASS, !1), this.$valid = isObjectEmpty(this.$error), this.$invalid = !this.$valid, toggleValidationCss(this, "", this.$valid));
                var combinedState;
                combinedState = this.$pending && this.$pending[validationErrorKey] ? void 0 : !this.$error[validationErrorKey] && (!!this.$$success[validationErrorKey] || null), toggleValidationCss(this, validationErrorKey, combinedState), this.$$parentForm.$setValidity(validationErrorKey, combinedState, this)
            }
        }

        function isObjectEmpty(obj) {
            if (obj)
                for (var prop in obj)
                    if (obj.hasOwnProperty(prop)) return !1;
            return !0
        }

        function stringBasedInputType(ctrl) {
            ctrl.$formatters.push(function(value) {
                return ctrl.$isEmpty(value) ? value : value.toString()
            })
        }

        function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl)
        }

        function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            var type = lowercase(element[0].type);
            if (!$sniffer.android) {
                var composing = !1;
                element.on("compositionstart", function() {
                    composing = !0
                }), element.on("compositionupdate", function(ev) {
                    (isUndefined(ev.data) || "" === ev.data) && (composing = !1)
                }), element.on("compositionend", function() {
                    composing = !1, listener()
                })
            }
            var timeout, listener = function(ev) {
                if (timeout && ($browser.defer.cancel(timeout), timeout = null), !composing) {
                    var value = element.val(),
                        event = ev && ev.type;
                    "password" === type || attr.ngTrim && "false" === attr.ngTrim || (value = trim(value)), (ctrl.$viewValue !== value || "" === value && ctrl.$$hasNativeValidators) && ctrl.$setViewValue(value, event)
                }
            };
            if ($sniffer.hasEvent("input")) element.on("input", listener);
            else {
                var deferListener = function(ev, input, origValue) {
                    timeout || (timeout = $browser.defer(function() {
                        timeout = null, input && input.value === origValue || listener(ev)
                    }))
                };
                element.on("keydown", function(event) {
                    var key = event.keyCode;
                    91 === key || 15 < key && key < 19 || 37 <= key && key <= 40 || deferListener(event, this, this.value)
                }), $sniffer.hasEvent("paste") && element.on("paste cut drop", deferListener)
            }
            element.on("change", listener), PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type && element.on(PARTIAL_VALIDATION_EVENTS, function(ev) {
                if (!timeout) {
                    var validity = this[VALIDITY_STATE_PROPERTY],
                        origBadInput = validity.badInput,
                        origTypeMismatch = validity.typeMismatch;
                    timeout = $browser.defer(function() {
                        timeout = null, validity.badInput === origBadInput && validity.typeMismatch === origTypeMismatch || listener(ev)
                    })
                }
            }), ctrl.$render = function() {
                var value = ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue;
                element.val() !== value && element.val(value)
            }
        }

        function weekParser(isoWeek, existingDate) {
            if (isDate(isoWeek)) return isoWeek;
            if (isString(isoWeek)) {
                WEEK_REGEXP.lastIndex = 0;
                var parts = WEEK_REGEXP.exec(isoWeek);
                if (parts) {
                    var year = +parts[1],
                        week = +parts[2],
                        hours = 0,
                        minutes = 0,
                        seconds = 0,
                        milliseconds = 0,
                        firstThurs = getFirstThursdayOfYear(year),
                        addDays = 7 * (week - 1);
                    return existingDate && (hours = existingDate.getHours(), minutes = existingDate.getMinutes(), seconds = existingDate.getSeconds(), milliseconds = existingDate.getMilliseconds()), new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds)
                }
            }
            return NaN
        }

        function createDateParser(regexp, mapping) {
            return function(iso, previousDate) {
                var parts, map;
                if (isDate(iso)) return iso;
                if (isString(iso)) {
                    if ('"' === iso.charAt(0) && '"' === iso.charAt(iso.length - 1) && (iso = iso.substring(1, iso.length - 1)), ISO_DATE_REGEXP.test(iso)) return new Date(iso);
                    if (regexp.lastIndex = 0, parts = regexp.exec(iso)) {
                        parts.shift(), map = previousDate ? {
                            yyyy: previousDate.getFullYear(),
                            MM: previousDate.getMonth() + 1,
                            dd: previousDate.getDate(),
                            HH: previousDate.getHours(),
                            mm: previousDate.getMinutes(),
                            ss: previousDate.getSeconds(),
                            sss: previousDate.getMilliseconds() / 1e3
                        } : {
                            yyyy: 1970,
                            MM: 1,
                            dd: 1,
                            HH: 0,
                            mm: 0,
                            ss: 0,
                            sss: 0
                        }, forEach(parts, function(part, index) {
                            index < mapping.length && (map[mapping[index]] = +part)
                        });
                        var date = new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, 1e3 * map.sss || 0);
                        return map.yyyy < 100 && date.setFullYear(map.yyyy), date
                    }
                }
                return NaN
            }
        }

        function createDateInputType(type, regexp, parseDate, format) {
            return function(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
                function isValidDate(value) {
                    return value && !(value.getTime && value.getTime() !== value.getTime())
                }

                function parseObservedDateValue(val) {
                    return isDefined(val) && !isDate(val) ? parseDateAndConvertTimeZoneToLocal(val) || void 0 : val
                }

                function parseDateAndConvertTimeZoneToLocal(value, previousDate) {
                    var timezone = ctrl.$options.getOption("timezone");
                    previousTimezone && previousTimezone !== timezone && (previousDate = addDateMinutes(previousDate, timezoneToOffset(previousTimezone)));
                    var parsedDate = parseDate(value, previousDate);
                    return !isNaN(parsedDate) && timezone && (parsedDate = convertTimezoneToLocal(parsedDate, timezone)), parsedDate
                }

                function formatter(value, timezone) {
                    var targetFormat = format;
                    isTimeType && isString(ctrl.$options.getOption("timeSecondsFormat")) && (targetFormat = format.replace("ss.sss", ctrl.$options.getOption("timeSecondsFormat")).replace(/:$/, ""));
                    var formatted = $filter("date")(value, targetFormat, timezone);
                    return isTimeType && ctrl.$options.getOption("timeStripZeroSeconds") && (formatted = formatted.replace(/(?::00)?(?:\.000)?$/, "")), formatted
                }
                badInputChecker(scope, element, attr, ctrl, type), baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                var previousDate, previousTimezone, isTimeType = "time" === type || "datetimelocal" === type;
                if (ctrl.$parsers.push(function(value) {
                        return ctrl.$isEmpty(value) ? null : regexp.test(value) ? parseDateAndConvertTimeZoneToLocal(value, previousDate) : void(ctrl.$$parserName = type)
                    }), ctrl.$formatters.push(function(value) {
                        if (value && !isDate(value)) throw ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                        if (isValidDate(value)) {
                            previousDate = value;
                            var timezone = ctrl.$options.getOption("timezone");
                            return timezone && (previousTimezone = timezone, previousDate = convertTimezoneToLocal(previousDate, timezone, !0)), formatter(value, timezone)
                        }
                        return previousDate = null, previousTimezone = null, ""
                    }), isDefined(attr.min) || attr.ngMin) {
                    var minVal = attr.min || $parse(attr.ngMin)(scope),
                        parsedMinVal = parseObservedDateValue(minVal);
                    ctrl.$validators.min = function(value) {
                        return !isValidDate(value) || isUndefined(parsedMinVal) || parseDate(value) >= parsedMinVal
                    }, attr.$observe("min", function(val) {
                        val !== minVal && (parsedMinVal = parseObservedDateValue(val), minVal = val, ctrl.$validate())
                    })
                }
                if (isDefined(attr.max) || attr.ngMax) {
                    var maxVal = attr.max || $parse(attr.ngMax)(scope),
                        parsedMaxVal = parseObservedDateValue(maxVal);
                    ctrl.$validators.max = function(value) {
                        return !isValidDate(value) || isUndefined(parsedMaxVal) || parseDate(value) <= parsedMaxVal
                    }, attr.$observe("max", function(val) {
                        val !== maxVal && (parsedMaxVal = parseObservedDateValue(val), maxVal = val, ctrl.$validate())
                    })
                }
            }
        }

        function badInputChecker(scope, element, attr, ctrl, parserName) {
            var node = element[0],
                nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
            nativeValidation && ctrl.$parsers.push(function(value) {
                var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
                return validity.badInput || validity.typeMismatch ? void(ctrl.$$parserName = parserName) : value
            })
        }

        function numberFormatterParser(ctrl) {
            ctrl.$parsers.push(function(value) {
                return ctrl.$isEmpty(value) ? null : NUMBER_REGEXP.test(value) ? parseFloat(value) : void(ctrl.$$parserName = "number")
            }), ctrl.$formatters.push(function(value) {
                if (!ctrl.$isEmpty(value)) {
                    if (!isNumber(value)) throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                    value = value.toString()
                }
                return value
            })
        }

        function parseNumberAttrVal(val) {
            return isDefined(val) && !isNumber(val) && (val = parseFloat(val)), isNumberNaN(val) ? void 0 : val
        }

        function isNumberInteger(num) {
            return (0 | num) === num
        }

        function countDecimals(num) {
            var numString = num.toString(),
                decimalSymbolIndex = numString.indexOf(".");
            if (decimalSymbolIndex === -1) {
                if (-1 < num && num < 1) {
                    var match = /e-(\d+)$/.exec(numString);
                    if (match) return Number(match[1])
                }
                return 0
            }
            return numString.length - decimalSymbolIndex - 1
        }

        function isValidForStep(viewValue, stepBase, step) {
            var value = Number(viewValue),
                isNonIntegerValue = !isNumberInteger(value),
                isNonIntegerStepBase = !isNumberInteger(stepBase),
                isNonIntegerStep = !isNumberInteger(step);
            if (isNonIntegerValue || isNonIntegerStepBase || isNonIntegerStep) {
                var valueDecimals = isNonIntegerValue ? countDecimals(value) : 0,
                    stepBaseDecimals = isNonIntegerStepBase ? countDecimals(stepBase) : 0,
                    stepDecimals = isNonIntegerStep ? countDecimals(step) : 0,
                    decimalCount = Math.max(valueDecimals, stepBaseDecimals, stepDecimals),
                    multiplier = Math.pow(10, decimalCount);
                value *= multiplier, stepBase *= multiplier, step *= multiplier, isNonIntegerValue && (value = Math.round(value)), isNonIntegerStepBase && (stepBase = Math.round(stepBase)), isNonIntegerStep && (step = Math.round(step))
            }
            return (value - stepBase) % step === 0
        }

        function numberInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
            badInputChecker(scope, element, attr, ctrl, "number"), numberFormatterParser(ctrl), baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            var parsedMinVal;
            if (isDefined(attr.min) || attr.ngMin) {
                var minVal = attr.min || $parse(attr.ngMin)(scope);
                parsedMinVal = parseNumberAttrVal(minVal), ctrl.$validators.min = function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || isUndefined(parsedMinVal) || viewValue >= parsedMinVal
                }, attr.$observe("min", function(val) {
                    val !== minVal && (parsedMinVal = parseNumberAttrVal(val), minVal = val, ctrl.$validate())
                })
            }
            if (isDefined(attr.max) || attr.ngMax) {
                var maxVal = attr.max || $parse(attr.ngMax)(scope),
                    parsedMaxVal = parseNumberAttrVal(maxVal);
                ctrl.$validators.max = function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || isUndefined(parsedMaxVal) || viewValue <= parsedMaxVal
                }, attr.$observe("max", function(val) {
                    val !== maxVal && (parsedMaxVal = parseNumberAttrVal(val), maxVal = val, ctrl.$validate())
                })
            }
            if (isDefined(attr.step) || attr.ngStep) {
                var stepVal = attr.step || $parse(attr.ngStep)(scope),
                    parsedStepVal = parseNumberAttrVal(stepVal);
                ctrl.$validators.step = function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || isUndefined(parsedStepVal) || isValidForStep(viewValue, parsedMinVal || 0, parsedStepVal)
                }, attr.$observe("step", function(val) {
                    val !== stepVal && (parsedStepVal = parseNumberAttrVal(val), stepVal = val, ctrl.$validate())
                })
            }
        }

        function rangeInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            function setInitialValueAndObserver(htmlAttrName, changeFn) {
                element.attr(htmlAttrName, attr[htmlAttrName]);
                var oldVal = attr[htmlAttrName];
                attr.$observe(htmlAttrName, function(val) {
                    val !== oldVal && (oldVal = val, changeFn(val))
                })
            }

            function minChange(val) {
                if (minVal = parseNumberAttrVal(val), !isNumberNaN(ctrl.$modelValue))
                    if (supportsRange) {
                        var elVal = element.val();
                        minVal > elVal && (elVal = minVal, element.val(elVal)), ctrl.$setViewValue(elVal)
                    } else ctrl.$validate()
            }

            function maxChange(val) {
                if (maxVal = parseNumberAttrVal(val), !isNumberNaN(ctrl.$modelValue))
                    if (supportsRange) {
                        var elVal = element.val();
                        maxVal < elVal && (element.val(maxVal), elVal = maxVal < minVal ? minVal : maxVal), ctrl.$setViewValue(elVal)
                    } else ctrl.$validate()
            }

            function stepChange(val) {
                stepVal = parseNumberAttrVal(val), isNumberNaN(ctrl.$modelValue) || (supportsRange ? ctrl.$viewValue !== element.val() && ctrl.$setViewValue(element.val()) : ctrl.$validate())
            }
            badInputChecker(scope, element, attr, ctrl, "range"), numberFormatterParser(ctrl), baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
            var supportsRange = ctrl.$$hasNativeValidators && "range" === element[0].type,
                minVal = supportsRange ? 0 : void 0,
                maxVal = supportsRange ? 100 : void 0,
                stepVal = supportsRange ? 1 : void 0,
                validity = element[0].validity,
                hasMinAttr = isDefined(attr.min),
                hasMaxAttr = isDefined(attr.max),
                hasStepAttr = isDefined(attr.step),
                originalRender = ctrl.$render;
            ctrl.$render = supportsRange && isDefined(validity.rangeUnderflow) && isDefined(validity.rangeOverflow) ? function() {
                originalRender(), ctrl.$setViewValue(element.val())
            } : originalRender, hasMinAttr && (minVal = parseNumberAttrVal(attr.min), ctrl.$validators.min = supportsRange ? function() {
                return !0
            } : function(modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || isUndefined(minVal) || viewValue >= minVal
            }, setInitialValueAndObserver("min", minChange)), hasMaxAttr && (maxVal = parseNumberAttrVal(attr.max), ctrl.$validators.max = supportsRange ? function() {
                return !0
            } : function(modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || isUndefined(maxVal) || viewValue <= maxVal
            }, setInitialValueAndObserver("max", maxChange)), hasStepAttr && (stepVal = parseNumberAttrVal(attr.step), ctrl.$validators.step = supportsRange ? function() {
                return !validity.stepMismatch
            } : function(modelValue, viewValue) {
                return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal)
            }, setInitialValueAndObserver("step", stepChange))
        }

        function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), ctrl.$validators.url = function(modelValue, viewValue) {
                var value = modelValue || viewValue;
                return ctrl.$isEmpty(value) || URL_REGEXP.test(value)
            }
        }

        function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), ctrl.$validators.email = function(modelValue, viewValue) {
                var value = modelValue || viewValue;
                return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value)
            }
        }

        function radioInputType(scope, element, attr, ctrl) {
            var doTrim = !attr.ngTrim || "false" !== trim(attr.ngTrim);
            isUndefined(attr.name) && element.attr("name", nextUid());
            var listener = function(ev) {
                var value;
                element[0].checked && (value = attr.value, doTrim && (value = trim(value)), ctrl.$setViewValue(value, ev && ev.type))
            };
            element.on("change", listener), ctrl.$render = function() {
                var value = attr.value;
                doTrim && (value = trim(value)), element[0].checked = value === ctrl.$viewValue
            }, attr.$observe("value", ctrl.$render)
        }

        function parseConstantExpr($parse, context, name, expression, fallback) {
            var parseFn;
            if (isDefined(expression)) {
                if (parseFn = $parse(expression), !parseFn.constant) throw ngModelMinErr("constexpr", "Expected constant expression for `{0}`, but saw `{1}`.", name, expression);
                return parseFn(context)
            }
            return fallback
        }

        function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
            var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, !0),
                falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, !1),
                listener = function(ev) {
                    ctrl.$setViewValue(element[0].checked, ev && ev.type)
                };
            element.on("change", listener), ctrl.$render = function() {
                element[0].checked = ctrl.$viewValue
            }, ctrl.$isEmpty = function(value) {
                return value === !1
            }, ctrl.$formatters.push(function(value) {
                return equals(value, trueValue)
            }), ctrl.$parsers.push(function(value) {
                return value ? trueValue : falseValue
            })
        }

        function classDirective(name, selector) {
            function arrayDifference(tokens1, tokens2) {
                if (!tokens1 || !tokens1.length) return [];
                if (!tokens2 || !tokens2.length) return tokens1;
                var values = [];
                outer: for (var i = 0; i < tokens1.length; i++) {
                    for (var token = tokens1[i], j = 0; j < tokens2.length; j++)
                        if (token === tokens2[j]) continue outer;
                    values.push(token)
                }
                return values
            }

            function split(classString) {
                return classString && classString.split(" ")
            }

            function toClassString(classValue) {
                if (!classValue) return classValue;
                var classString = classValue;
                return isArray(classValue) ? classString = classValue.map(toClassString).join(" ") : isObject(classValue) ? classString = Object.keys(classValue).filter(function(key) {
                    return classValue[key]
                }).join(" ") : isString(classValue) || (classString = classValue + ""), classString
            }
            name = "ngClass" + name;
            var indexWatchExpression;
            return ["$parse", function($parse) {
                return {
                    restrict: "AC",
                    link: function(scope, element, attr) {
                        function addClasses(classString) {
                            classString = digestClassCounts(split(classString), 1),
                                attr.$addClass(classString)
                        }

                        function removeClasses(classString) {
                            classString = digestClassCounts(split(classString), -1), attr.$removeClass(classString)
                        }

                        function updateClasses(oldClassString, newClassString) {
                            var oldClassArray = split(oldClassString),
                                newClassArray = split(newClassString),
                                toRemoveArray = arrayDifference(oldClassArray, newClassArray),
                                toAddArray = arrayDifference(newClassArray, oldClassArray),
                                toRemoveString = digestClassCounts(toRemoveArray, -1),
                                toAddString = digestClassCounts(toAddArray, 1);
                            attr.$addClass(toAddString), attr.$removeClass(toRemoveString)
                        }

                        function digestClassCounts(classArray, count) {
                            var classesToUpdate = [];
                            return forEach(classArray, function(className) {
                                (count > 0 || classCounts[className]) && (classCounts[className] = (classCounts[className] || 0) + count, classCounts[className] === +(count > 0) && classesToUpdate.push(className))
                            }), classesToUpdate.join(" ")
                        }

                        function ngClassIndexWatchAction(newModulo) {
                            newModulo === selector ? addClasses(oldClassString) : removeClasses(oldClassString), oldModulo = newModulo
                        }

                        function ngClassWatchAction(newClassString) {
                            oldModulo === selector && updateClasses(oldClassString, newClassString), oldClassString = newClassString
                        }
                        var oldClassString, classCounts = element.data("$classCounts"),
                            oldModulo = !0;
                        classCounts || (classCounts = createMap(), element.data("$classCounts", classCounts)), "ngClass" !== name && (indexWatchExpression || (indexWatchExpression = $parse("$index", function($index) {
                            return 1 & $index
                        })), scope.$watch(indexWatchExpression, ngClassIndexWatchAction)), scope.$watch($parse(attr[name], toClassString), ngClassWatchAction)
                    }
                }
            }]
        }

        function createEventDirective($parse, $rootScope, $exceptionHandler, directiveName, eventName, forceAsync) {
            return {
                restrict: "A",
                compile: function($element, attr) {
                    var fn = $parse(attr[directiveName]);
                    return function(scope, element) {
                        element.on(eventName, function(event) {
                            var callback = function() {
                                fn(scope, {
                                    $event: event
                                })
                            };
                            if ($rootScope.$$phase)
                                if (forceAsync) scope.$evalAsync(callback);
                                else try {
                                    callback()
                                } catch (error) {
                                    $exceptionHandler(error)
                                } else scope.$apply(callback)
                        })
                    }
                }
            }
        }

        function NgModelController($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $q, $interpolate) {
            this.$viewValue = Number.NaN, this.$modelValue = Number.NaN, this.$$rawModelValue = void 0, this.$validators = {}, this.$asyncValidators = {}, this.$parsers = [], this.$formatters = [], this.$viewChangeListeners = [], this.$untouched = !0, this.$touched = !1, this.$pristine = !0, this.$dirty = !1, this.$valid = !0, this.$invalid = !1, this.$error = {}, this.$$success = {}, this.$pending = void 0, this.$name = $interpolate($attr.name || "", !1)($scope), this.$$parentForm = nullFormCtrl, this.$options = defaultModelOptions, this.$$updateEvents = "", this.$$updateEventHandler = this.$$updateEventHandler.bind(this), this.$$parsedNgModel = $parse($attr.ngModel), this.$$parsedNgModelAssign = this.$$parsedNgModel.assign, this.$$ngModelGet = this.$$parsedNgModel, this.$$ngModelSet = this.$$parsedNgModelAssign, this.$$pendingDebounce = null, this.$$parserValid = void 0, this.$$parserName = "parse", this.$$currentValidationRunId = 0, this.$$scope = $scope, this.$$rootScope = $scope.$root, this.$$attr = $attr, this.$$element = $element, this.$$animate = $animate, this.$$timeout = $timeout, this.$$parse = $parse, this.$$q = $q, this.$$exceptionHandler = $exceptionHandler, setupValidity(this), setupModelWatcher(this)
        }

        function setupModelWatcher(ctrl) {
            ctrl.$$scope.$watch(function(scope) {
                var modelValue = ctrl.$$ngModelGet(scope);
                return modelValue === ctrl.$modelValue || ctrl.$modelValue !== ctrl.$modelValue && modelValue !== modelValue || ctrl.$$setModelValue(modelValue), modelValue
            })
        }

        function ModelOptions(options) {
            this.$$options = options
        }

        function defaults(dst, src) {
            forEach(src, function(value, key) {
                isDefined(dst[key]) || (dst[key] = value)
            })
        }

        function setOptionSelectedStatus(optionEl, value) {
            optionEl.prop("selected", value), optionEl.attr("selected", value)
        }

        function parsePatternAttr(regex, patternExp, elm) {
            if (regex) {
                if (isString(regex) && (regex = new RegExp("^" + regex + "$")), !regex.test) throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
                return regex
            }
        }

        function parseLength(val) {
            var intVal = toInt(val);
            return isNumberNaN(intVal) ? -1 : intVal
        }
        var msie, jqLite, jQuery, angularModule, minErrConfig = {
                objectMaxDepth: 5,
                urlErrorParamsEnabled: !0
            },
            REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/,
            VALIDITY_STATE_PROPERTY = "validity",
            hasOwnProperty = Object.prototype.hasOwnProperty,
            lowercase = function(string) {
                return isString(string) ? string.toLowerCase() : string
            },
            uppercase = function(string) {
                return isString(string) ? string.toUpperCase() : string
            },
            slice = [].slice,
            splice = [].splice,
            push = [].push,
            toString = Object.prototype.toString,
            getPrototypeOf = Object.getPrototypeOf,
            ngMinErr = minErr("ng"),
            angular = window.angular || (window.angular = {}),
            uid = 0;
        msie = window.document.documentMode;
        var isNumberNaN = Number.isNaN || function(num) {
            return num !== num
        };
        noop.$inject = [], identity.$inject = [];
        var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/,
            trim = function(value) {
                return isString(value) ? value.trim() : value
            },
            escapeForRegexp = function(s) {
                return s.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08")
            },
            csp = function csp() {
                function noUnsafeEval() {
                    try {
                        return new Function(""), !1
                    } catch (e) {
                        return !0
                    }
                }
                if (!isDefined(csp.rules)) {
                    var ngCspElement = window.document.querySelector("[ng-csp]") || window.document.querySelector("[data-ng-csp]");
                    if (ngCspElement) {
                        var ngCspAttribute = ngCspElement.getAttribute("ng-csp") || ngCspElement.getAttribute("data-ng-csp");
                        csp.rules = {
                            noUnsafeEval: !ngCspAttribute || ngCspAttribute.indexOf("no-unsafe-eval") !== -1,
                            noInlineStyle: !ngCspAttribute || ngCspAttribute.indexOf("no-inline-style") !== -1
                        }
                    } else csp.rules = {
                        noUnsafeEval: noUnsafeEval(),
                        noInlineStyle: !1
                    }
                }
                return csp.rules
            },
            jq = function jq() {
                if (isDefined(jq.name_)) return jq.name_;
                var el, i, prefix, name, ii = ngAttrPrefixes.length;
                for (i = 0; i < ii; ++i)
                    if (prefix = ngAttrPrefixes[i], el = window.document.querySelector("[" + prefix.replace(":", "\\:") + "jq]")) {
                        name = el.getAttribute(prefix + "jq");
                        break
                    } return jq.name_ = name
            },
            ALL_COLONS = /:/g,
            ngAttrPrefixes = ["ng-", "data-ng-", "ng:", "x-ng-"],
            isAutoBootstrapAllowed = allowAutoBootstrap(window.document),
            SNAKE_CASE_REGEXP = /[A-Z]/g,
            bindJQueryFired = !1,
            NODE_TYPE_ELEMENT = 1,
            NODE_TYPE_ATTRIBUTE = 2,
            NODE_TYPE_TEXT = 3,
            NODE_TYPE_COMMENT = 8,
            NODE_TYPE_DOCUMENT = 9,
            NODE_TYPE_DOCUMENT_FRAGMENT = 11,
            version = {
                full: "1.8.0",
                major: 1,
                minor: 8,
                dot: 0,
                codeName: "nested-vaccination"
            };
        JQLite.expando = "ng339";
        var jqCache = JQLite.cache = {},
            jqId = 1;
        JQLite._data = function(node) {
            return this.cache[node[this.expando]] || {}
        };
        var DASH_LOWERCASE_REGEXP = /-([a-z])/g,
            MS_HACK_REGEXP = /^-ms-/,
            MOUSE_EVENT_MAP = {
                mouseleave: "mouseout",
                mouseenter: "mouseover"
            },
            jqLiteMinErr = minErr("jqLite"),
            SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/,
            HTML_REGEXP = /<|&#?\w+;/,
            TAG_NAME_REGEXP = /<([\w:-]+)/,
            XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
            wrapMap = {
                thead: ["table"],
                col: ["colgroup", "table"],
                tr: ["tbody", "table"],
                td: ["tr", "tbody", "table"]
            };
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, wrapMap.th = wrapMap.td;
        var wrapMapIE9 = {
            option: [1, '<select multiple="multiple">', "</select>"],
            _default: [0, "", ""]
        };
        for (var key in wrapMap) {
            var wrapMapValueClosing = wrapMap[key],
                wrapMapValue = wrapMapValueClosing.slice().reverse();
            wrapMapIE9[key] = [wrapMapValue.length, "<" + wrapMapValue.join("><") + ">", "</" + wrapMapValueClosing.join("></") + ">"]
        }
        wrapMapIE9.optgroup = wrapMapIE9.option;
        var jqLiteContains = window.Node.prototype.contains || function(arg) {
                return !!(16 & this.compareDocumentPosition(arg))
            },
            JQLitePrototype = JQLite.prototype = {
                ready: jqLiteReady,
                toString: function() {
                    var value = [];
                    return forEach(this, function(e) {
                        value.push("" + e)
                    }), "[" + value.join(", ") + "]"
                },
                eq: function(index) {
                    return jqLite(index >= 0 ? this[index] : this[this.length + index])
                },
                length: 0,
                push: push,
                sort: [].sort,
                splice: [].splice
            },
            BOOLEAN_ATTR = {};
        forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function(value) {
            BOOLEAN_ATTR[lowercase(value)] = value
        });
        var BOOLEAN_ELEMENTS = {};
        forEach("input,select,option,textarea,button,form,details".split(","), function(value) {
            BOOLEAN_ELEMENTS[value] = !0
        });
        var ALIASED_ATTR = {
            ngMinlength: "minlength",
            ngMaxlength: "maxlength",
            ngMin: "min",
            ngMax: "max",
            ngPattern: "pattern",
            ngStep: "step"
        };
        forEach({
            data: jqLiteData,
            removeData: jqLiteRemoveData,
            hasData: jqLiteHasData,
            cleanData: function(nodes) {
                for (var i = 0, ii = nodes.length; i < ii; i++) jqLiteRemoveData(nodes[i]), jqLiteOff(nodes[i])
            }
        }, function(fn, name) {
            JQLite[name] = fn
        }), forEach({
            data: jqLiteData,
            inheritedData: jqLiteInheritedData,
            scope: function(element) {
                return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, ["$isolateScope", "$scope"])
            },
            isolateScope: function(element) {
                return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate")
            },
            controller: jqLiteController,
            injector: function(element) {
                return jqLiteInheritedData(element, "$injector")
            },
            removeAttr: function(element, name) {
                element.removeAttribute(name)
            },
            hasClass: jqLiteHasClass,
            css: function(element, name, value) {
                return name = cssKebabToCamel(name), isDefined(value) ? void(element.style[name] = value) : element.style[name]
            },
            attr: function(element, name, value) {
                var ret, nodeType = element.nodeType;
                if (nodeType !== NODE_TYPE_TEXT && nodeType !== NODE_TYPE_ATTRIBUTE && nodeType !== NODE_TYPE_COMMENT && element.getAttribute) {
                    var lowercasedName = lowercase(name),
                        isBooleanAttr = BOOLEAN_ATTR[lowercasedName];
                    return isDefined(value) ? void(null === value || value === !1 && isBooleanAttr ? element.removeAttribute(name) : element.setAttribute(name, isBooleanAttr ? lowercasedName : value)) : (ret = element.getAttribute(name), isBooleanAttr && null !== ret && (ret = lowercasedName), null === ret ? void 0 : ret)
                }
            },
            prop: function(element, name, value) {
                return isDefined(value) ? void(element[name] = value) : element[name]
            },
            text: function() {
                function getText(element, value) {
                    if (isUndefined(value)) {
                        var nodeType = element.nodeType;
                        return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : ""
                    }
                    element.textContent = value
                }
                return getText.$dv = "", getText
            }(),
            val: function(element, value) {
                if (isUndefined(value)) {
                    if (element.multiple && "select" === nodeName_(element)) {
                        var result = [];
                        return forEach(element.options, function(option) {
                            option.selected && result.push(option.value || option.text)
                        }), result
                    }
                    return element.value
                }
                element.value = value
            },
            html: function(element, value) {
                return isUndefined(value) ? element.innerHTML : (jqLiteDealoc(element, !0), void(element.innerHTML = value))
            },
            empty: jqLiteEmpty
        }, function(fn, name) {
            JQLite.prototype[name] = function(arg1, arg2) {
                var i, key, nodeCount = this.length;
                if (fn !== jqLiteEmpty && isUndefined(2 === fn.length && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 : arg2)) {
                    if (isObject(arg1)) {
                        for (i = 0; i < nodeCount; i++)
                            if (fn === jqLiteData) fn(this[i], arg1);
                            else
                                for (key in arg1) fn(this[i], key, arg1[key]);
                        return this
                    }
                    for (var value = fn.$dv, jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount, j = 0; j < jj; j++) {
                        var nodeValue = fn(this[j], arg1, arg2);
                        value = value ? value + nodeValue : nodeValue
                    }
                    return value
                }
                for (i = 0; i < nodeCount; i++) fn(this[i], arg1, arg2);
                return this
            }
        }), forEach({
            removeData: jqLiteRemoveData,
            on: function(element, type, fn, unsupported) {
                if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
                if (jqLiteAcceptsData(element)) {
                    var expandoStore = jqLiteExpandoStore(element, !0),
                        events = expandoStore.events,
                        handle = expandoStore.handle;
                    handle || (handle = expandoStore.handle = createEventHandler(element, events));
                    for (var types = type.indexOf(" ") >= 0 ? type.split(" ") : [type], i = types.length, addHandler = function(type, specialHandlerWrapper, noEventListener) {
                            var eventFns = events[type];
                            eventFns || (eventFns = events[type] = [], eventFns.specialHandlerWrapper = specialHandlerWrapper, "$destroy" === type || noEventListener || element.addEventListener(type, handle)), eventFns.push(fn)
                        }; i--;) type = types[i], MOUSE_EVENT_MAP[type] ? (addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper), addHandler(type, void 0, !0)) : addHandler(type)
                }
            },
            off: jqLiteOff,
            one: function(element, type, fn) {
                element = jqLite(element), element.on(type, function onFn() {
                    element.off(type, fn), element.off(type, onFn)
                }), element.on(type, fn)
            },
            replaceWith: function(element, replaceNode) {
                var index, parent = element.parentNode;
                jqLiteDealoc(element), forEach(new JQLite(replaceNode), function(node) {
                    index ? parent.insertBefore(node, index.nextSibling) : parent.replaceChild(node, element), index = node
                })
            },
            children: function children(element) {
                var children = [];
                return forEach(element.childNodes, function(element) {
                    element.nodeType === NODE_TYPE_ELEMENT && children.push(element)
                }), children
            },
            contents: function(element) {
                return element.contentDocument || element.childNodes || []
            },
            append: function(element, node) {
                var nodeType = element.nodeType;
                if (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_DOCUMENT_FRAGMENT) {
                    node = new JQLite(node);
                    for (var i = 0, ii = node.length; i < ii; i++) {
                        var child = node[i];
                        element.appendChild(child)
                    }
                }
            },
            prepend: function(element, node) {
                if (element.nodeType === NODE_TYPE_ELEMENT) {
                    var index = element.firstChild;
                    forEach(new JQLite(node), function(child) {
                        element.insertBefore(child, index)
                    })
                }
            },
            wrap: function(element, wrapNode) {
                jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0])
            },
            remove: jqLiteRemove,
            detach: function(element) {
                jqLiteRemove(element, !0)
            },
            after: function(element, newElement) {
                var index = element,
                    parent = element.parentNode;
                if (parent) {
                    newElement = new JQLite(newElement);
                    for (var i = 0, ii = newElement.length; i < ii; i++) {
                        var node = newElement[i];
                        parent.insertBefore(node, index.nextSibling), index = node
                    }
                }
            },
            addClass: jqLiteAddClass,
            removeClass: jqLiteRemoveClass,
            toggleClass: function(element, selector, condition) {
                selector && forEach(selector.split(" "), function(className) {
                    var classCondition = condition;
                    isUndefined(classCondition) && (classCondition = !jqLiteHasClass(element, className)), (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className)
                })
            },
            parent: function parent(element) {
                var parent = element.parentNode;
                return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null
            },
            next: function(element) {
                return element.nextElementSibling
            },
            find: function(element, selector) {
                return element.getElementsByTagName ? element.getElementsByTagName(selector) : []
            },
            clone: jqLiteClone,
            triggerHandler: function(element, event, extraParameters) {
                var dummyEvent, eventFnsCopy, handlerArgs, eventName = event.type || event,
                    expandoStore = jqLiteExpandoStore(element),
                    events = expandoStore && expandoStore.events,
                    eventFns = events && events[eventName];
                eventFns && (dummyEvent = {
                    preventDefault: function() {
                        this.defaultPrevented = !0
                    },
                    isDefaultPrevented: function() {
                        return this.defaultPrevented === !0
                    },
                    stopImmediatePropagation: function() {
                        this.immediatePropagationStopped = !0
                    },
                    isImmediatePropagationStopped: function() {
                        return this.immediatePropagationStopped === !0
                    },
                    stopPropagation: noop,
                    type: eventName,
                    target: element
                }, event.type && (dummyEvent = extend(dummyEvent, event)), eventFnsCopy = shallowCopy(eventFns), handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent], forEach(eventFnsCopy, function(fn) {
                    dummyEvent.isImmediatePropagationStopped() || fn.apply(element, handlerArgs)
                }))
            }
        }, function(fn, name) {
            JQLite.prototype[name] = function(arg1, arg2, arg3) {
                for (var value, i = 0, ii = this.length; i < ii; i++) isUndefined(value) ? (value = fn(this[i], arg1, arg2, arg3), isDefined(value) && (value = jqLite(value))) : jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
                return isDefined(value) ? value : this
            }
        }), JQLite.prototype.bind = JQLite.prototype.on, JQLite.prototype.unbind = JQLite.prototype.off;
        var nanKey = Object.create(null);
        NgMapShim.prototype = {
            _idx: function(key) {
                return key !== this._lastKey && (this._lastKey = key, this._lastIndex = this._keys.indexOf(key)), this._lastIndex
            },
            _transformKey: function(key) {
                return isNumberNaN(key) ? nanKey : key
            },
            get: function(key) {
                key = this._transformKey(key);
                var idx = this._idx(key);
                if (idx !== -1) return this._values[idx]
            },
            has: function(key) {
                key = this._transformKey(key);
                var idx = this._idx(key);
                return idx !== -1
            },
            set: function(key, value) {
                key = this._transformKey(key);
                var idx = this._idx(key);
                idx === -1 && (idx = this._lastIndex = this._keys.length), this._keys[idx] = key, this._values[idx] = value
            },
            delete: function(key) {
                key = this._transformKey(key);
                var idx = this._idx(key);
                return idx !== -1 && (this._keys.splice(idx, 1), this._values.splice(idx, 1), this._lastKey = NaN, this._lastIndex = -1, !0)
            }
        };
        var NgMap = NgMapShim,
            $$MapProvider = [function() {
                this.$get = [function() {
                    return NgMap
                }]
            }],
            ARROW_ARG = /^([^(]+?)=>/,
            FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m,
            FN_ARG_SPLIT = /,/,
            FN_ARG = /^\s*(_?)(\S+?)\1\s*$/,
            STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,
            $injectorMinErr = minErr("$injector");
        createInjector.$$annotate = annotate;
        var $animateMinErr = minErr("$animate"),
            ELEMENT_NODE = 1,
            NG_ANIMATE_CLASSNAME = "ng-animate",
            $$CoreAnimateJsProvider = function() {
                this.$get = noop
            },
            $$CoreAnimateQueueProvider = function() {
                var postDigestQueue = new NgMap,
                    postDigestElements = [];
                this.$get = ["$$AnimateRunner", "$rootScope", function($$AnimateRunner, $rootScope) {
                    function updateData(data, classes, value) {
                        var changed = !1;
                        return classes && (classes = isString(classes) ? classes.split(" ") : isArray(classes) ? classes : [], forEach(classes, function(className) {
                            className && (changed = !0, data[className] = value)
                        })), changed
                    }

                    function handleCSSClassChanges() {
                        forEach(postDigestElements, function(element) {
                            var data = postDigestQueue.get(element);
                            if (data) {
                                var existing = splitClasses(element.attr("class")),
                                    toAdd = "",
                                    toRemove = "";
                                forEach(data, function(status, className) {
                                    var hasClass = !!existing[className];
                                    status !== hasClass && (status ? toAdd += (toAdd.length ? " " : "") + className : toRemove += (toRemove.length ? " " : "") + className)
                                }), forEach(element, function(elm) {
                                    toAdd && jqLiteAddClass(elm, toAdd), toRemove && jqLiteRemoveClass(elm, toRemove)
                                }), postDigestQueue.delete(element)
                            }
                        }), postDigestElements.length = 0
                    }

                    function addRemoveClassesPostDigest(element, add, remove) {
                        var data = postDigestQueue.get(element) || {},
                            classesAdded = updateData(data, add, !0),
                            classesRemoved = updateData(data, remove, !1);
                        (classesAdded || classesRemoved) && (postDigestQueue.set(element, data), postDigestElements.push(element), 1 === postDigestElements.length && $rootScope.$$postDigest(handleCSSClassChanges))
                    }
                    return {
                        enabled: noop,
                        on: noop,
                        off: noop,
                        pin: noop,
                        push: function(element, event, options, domOperation) {
                            domOperation && domOperation(), options = options || {}, options.from && element.css(options.from), options.to && element.css(options.to), (options.addClass || options.removeClass) && addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
                            var runner = new $$AnimateRunner;
                            return runner.complete(), runner
                        }
                    }
                }]
            },
            $AnimateProvider = ["$provide", function($provide) {
                var provider = this,
                    classNameFilter = null,
                    customFilter = null;
                this.$$registeredAnimations = Object.create(null), this.register = function(name, factory) {
                    if (name && "." !== name.charAt(0)) throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
                    var key = name + "-animation";
                    provider.$$registeredAnimations[name.substr(1)] = key, $provide.factory(key, factory)
                }, this.customFilter = function(filterFn) {
                    return 1 === arguments.length && (customFilter = isFunction(filterFn) ? filterFn : null), customFilter
                }, this.classNameFilter = function(expression) {
                    if (1 === arguments.length && (classNameFilter = expression instanceof RegExp ? expression : null)) {
                        var reservedRegex = new RegExp("[(\\s|\\/)]" + NG_ANIMATE_CLASSNAME + "[(\\s|\\/)]");
                        if (reservedRegex.test(classNameFilter.toString())) throw classNameFilter = null, $animateMinErr("nongcls", '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME)
                    }
                    return classNameFilter
                }, this.$get = ["$$animateQueue", function($$animateQueue) {
                    function domInsert(element, parentElement, afterElement) {
                        if (afterElement) {
                            var afterNode = extractElementNode(afterElement);
                            !afterNode || afterNode.parentNode || afterNode.previousElementSibling || (afterElement = null)
                        }
                        afterElement ? afterElement.after(element) : parentElement.prepend(element)
                    }
                    return {
                        on: $$animateQueue.on,
                        off: $$animateQueue.off,
                        pin: $$animateQueue.pin,
                        enabled: $$animateQueue.enabled,
                        cancel: function(runner) {
                            runner.cancel && runner.cancel()
                        },
                        enter: function(element, parent, after, options) {
                            return parent = parent && jqLite(parent), after = after && jqLite(after), parent = parent || after.parent(), domInsert(element, parent, after), $$animateQueue.push(element, "enter", prepareAnimateOptions(options))
                        },
                        move: function(element, parent, after, options) {
                            return parent = parent && jqLite(parent), after = after && jqLite(after), parent = parent || after.parent(), domInsert(element, parent, after), $$animateQueue.push(element, "move", prepareAnimateOptions(options))
                        },
                        leave: function(element, options) {
                            return $$animateQueue.push(element, "leave", prepareAnimateOptions(options), function() {
                                element.remove()
                            })
                        },
                        addClass: function(element, className, options) {
                            return options = prepareAnimateOptions(options), options.addClass = mergeClasses(options.addclass, className), $$animateQueue.push(element, "addClass", options)
                        },
                        removeClass: function(element, className, options) {
                            return options = prepareAnimateOptions(options), options.removeClass = mergeClasses(options.removeClass, className), $$animateQueue.push(element, "removeClass", options)
                        },
                        setClass: function(element, add, remove, options) {
                            return options = prepareAnimateOptions(options), options.addClass = mergeClasses(options.addClass, add), options.removeClass = mergeClasses(options.removeClass, remove), $$animateQueue.push(element, "setClass", options)
                        },
                        animate: function(element, from, to, className, options) {
                            return options = prepareAnimateOptions(options), options.from = options.from ? extend(options.from, from) : from, options.to = options.to ? extend(options.to, to) : to, className = className || "ng-inline-animate", options.tempClasses = mergeClasses(options.tempClasses, className), $$animateQueue.push(element, "animate", options)
                        }
                    }
                }]
            }],
            $$AnimateAsyncRunFactoryProvider = function() {
                this.$get = ["$$rAF", function($$rAF) {
                    function waitForTick(fn) {
                        waitQueue.push(fn), waitQueue.length > 1 || $$rAF(function() {
                            for (var i = 0; i < waitQueue.length; i++) waitQueue[i]();
                            waitQueue = []
                        })
                    }
                    var waitQueue = [];
                    return function() {
                        var passed = !1;
                        return waitForTick(function() {
                                passed = !0
                            }),
                            function(callback) {
                                passed ? callback() : waitForTick(callback)
                            }
                    }
                }]
            },
            $$AnimateRunnerFactoryProvider = function() {
                this.$get = ["$q", "$sniffer", "$$animateAsyncRun", "$$isDocumentHidden", "$timeout", function($q, $sniffer, $$animateAsyncRun, $$isDocumentHidden, $timeout) {
                    function AnimateRunner(host) {
                        this.setHost(host);
                        var rafTick = $$animateAsyncRun(),
                            timeoutTick = function(fn) {
                                $timeout(fn, 0, !1)
                            };
                        this._doneCallbacks = [], this._tick = function(fn) {
                            $$isDocumentHidden() ? timeoutTick(fn) : rafTick(fn)
                        }, this._state = 0
                    }
                    var INITIAL_STATE = 0,
                        DONE_PENDING_STATE = 1,
                        DONE_COMPLETE_STATE = 2;
                    return AnimateRunner.chain = function(chain, callback) {
                        function next() {
                            return index === chain.length ? void callback(!0) : void chain[index](function(response) {
                                return response === !1 ? void callback(!1) : (index++, void next())
                            })
                        }
                        var index = 0;
                        next()
                    }, AnimateRunner.all = function(runners, callback) {
                        function onProgress(response) {
                            status = status && response, ++count === runners.length && callback(status)
                        }
                        var count = 0,
                            status = !0;
                        forEach(runners, function(runner) {
                            runner.done(onProgress)
                        })
                    }, AnimateRunner.prototype = {
                        setHost: function(host) {
                            this.host = host || {}
                        },
                        done: function(fn) {
                            this._state === DONE_COMPLETE_STATE ? fn() : this._doneCallbacks.push(fn)
                        },
                        progress: noop,
                        getPromise: function() {
                            if (!this.promise) {
                                var self = this;
                                this.promise = $q(function(resolve, reject) {
                                    self.done(function(status) {
                                        status === !1 ? reject() : resolve()
                                    })
                                })
                            }
                            return this.promise
                        },
                        then: function(resolveHandler, rejectHandler) {
                            return this.getPromise().then(resolveHandler, rejectHandler)
                        },
                        catch: function(handler) {
                            return this.getPromise().catch(handler)
                        },
                        finally: function(handler) {
                            return this.getPromise().finally(handler)
                        },
                        pause: function() {
                            this.host.pause && this.host.pause()
                        },
                        resume: function() {
                            this.host.resume && this.host.resume()
                        },
                        end: function() {
                            this.host.end && this.host.end(), this._resolve(!0)
                        },
                        cancel: function() {
                            this.host.cancel && this.host.cancel(), this._resolve(!1)
                        },
                        complete: function(response) {
                            var self = this;
                            self._state === INITIAL_STATE && (self._state = DONE_PENDING_STATE, self._tick(function() {
                                self._resolve(response)
                            }))
                        },
                        _resolve: function(response) {
                            this._state !== DONE_COMPLETE_STATE && (forEach(this._doneCallbacks, function(fn) {
                                fn(response)
                            }), this._doneCallbacks.length = 0, this._state = DONE_COMPLETE_STATE)
                        }
                    }, AnimateRunner
                }]
            },
            $CoreAnimateCssProvider = function() {
                this.$get = ["$$rAF", "$q", "$$AnimateRunner", function($$rAF, $q, $$AnimateRunner) {
                    return function(element, initialOptions) {
                        function run() {
                            return $$rAF(function() {
                                applyAnimationContents(), closed || runner.complete(), closed = !0
                            }), runner
                        }

                        function applyAnimationContents() {
                            options.addClass && (element.addClass(options.addClass), options.addClass = null), options.removeClass && (element.removeClass(options.removeClass), options.removeClass = null), options.to && (element.css(options.to), options.to = null)
                        }
                        var options = initialOptions || {};
                        options.$$prepared || (options = copy(options)), options.cleanupStyles && (options.from = options.to = null), options.from && (element.css(options.from), options.from = null);
                        var closed, runner = new $$AnimateRunner;
                        return {
                            start: run,
                            end: run
                        }
                    }
                }]
            },
            $compileMinErr = minErr("$compile"),
            _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE;
        $CompileProvider.$inject = ["$provide", "$$sanitizeUriProvider"], SimpleChange.prototype.isFirstChange = function() {
            return this.previousValue === _UNINITIALIZED_VALUE
        };
        var PREFIX_REGEXP = /^((?:x|data)[:\-_])/i,
            SPECIAL_CHARS_REGEXP = /[:\-_]+(.)/g,
            $controllerMinErr = minErr("$controller"),
            CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/,
            $$ForceReflowProvider = function() {
                this.$get = ["$document", function($document) {
                    return function(domNode) {
                        return domNode ? !domNode.nodeType && domNode instanceof jqLite && (domNode = domNode[0]) : domNode = $document[0].body, domNode.offsetWidth + 1
                    }
                }]
            },
            APPLICATION_JSON = "application/json",
            CONTENT_TYPE_APPLICATION_JSON = {
                "Content-Type": APPLICATION_JSON + ";charset=utf-8"
            },
            JSON_START = /^\[|^\{(?!\{)/,
            JSON_ENDS = {
                "[": /]$/,
                "{": /}$/
            },
            JSON_PROTECTION_PREFIX = /^\)]\}',?\n/,
            $httpMinErr = minErr("$http"),
            $interpolateMinErr = angular.$interpolateMinErr = minErr("$interpolate");
        $interpolateMinErr.throwNoconcat = function(text) {
            throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce", text)
        }, $interpolateMinErr.interr = function(text, err) {
            return $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString())
        };
        var $intervalMinErr = minErr("$interval"),
            $jsonpCallbacksProvider = function() {
                this.$get = function() {
                    function _createCallback(callbackId) {
                        var callback = function callback(data) {
                            callback.data = data, callback.called = !0
                        };
                        return callback.id = callbackId, callback
                    }
                    var callbacks = angular.callbacks,
                        callbackMap = {};
                    return {
                        createCallback: function(url) {
                            var callbackId = "_" + (callbacks.$$counter++).toString(36),
                                callbackPath = "angular.callbacks." + callbackId,
                                callback = _createCallback(callbackId);
                            return callbackMap[callbackPath] = callbacks[callbackId] = callback, callbackPath
                        },
                        wasCalled: function(callbackPath) {
                            return callbackMap[callbackPath].called
                        },
                        getResponse: function(callbackPath) {
                            return callbackMap[callbackPath].data
                        },
                        removeCallback: function(callbackPath) {
                            var callback = callbackMap[callbackPath];
                            delete callbacks[callback.id], delete callbackMap[callbackPath]
                        }
                    }
                }
            },
            PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/,
            DEFAULT_PORTS = {
                http: 80,
                https: 443,
                ftp: 21
            },
            $locationMinErr = minErr("$location"),
            DOUBLE_SLASH_REGEX = /^\s*[\\/]{2,}/,
            locationPrototype = {
                $$absUrl: "",
                $$html5: !1,
                $$replace: !1,
                $$compose: function() {
                    this.$$url = normalizePath(this.$$path, this.$$search, this.$$hash), this.$$absUrl = this.$$normalizeUrl(this.$$url), this.$$urlUpdatedByLocation = !0
                },
                absUrl: locationGetter("$$absUrl"),
                url: function(_url) {
                    if (isUndefined(_url)) return this.$$url;
                    var match = PATH_MATCH.exec(_url);
                    return (match[1] || "" === _url) && this.path(decodeURIComponent(match[1])), (match[2] || match[1] || "" === _url) && this.search(match[3] || ""), this.hash(match[5] || ""), this
                },
                protocol: locationGetter("$$protocol"),
                host: locationGetter("$$host"),
                port: locationGetter("$$port"),
                path: locationGetterSetter("$$path", function(path) {
                    return path = null !== path ? path.toString() : "", "/" === path.charAt(0) ? path : "/" + path
                }),
                search: function(_search, paramValue) {
                    switch (arguments.length) {
                        case 0:
                            return this.$$search;
                        case 1:
                            if (isString(_search) || isNumber(_search)) _search = _search.toString(), this.$$search = parseKeyValue(_search);
                            else {
                                if (!isObject(_search)) throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                                _search = copy(_search, {}), forEach(_search, function(value, key) {
                                    null == value && delete _search[key]
                                }), this.$$search = _search
                            }
                            break;
                        default:
                            isUndefined(paramValue) || null === paramValue ? delete this.$$search[_search] : this.$$search[_search] = paramValue
                    }
                    return this.$$compose(), this
                },
                hash: locationGetterSetter("$$hash", function(hash) {
                    return null !== hash ? hash.toString() : ""
                }),
                replace: function() {
                    return this.$$replace = !0, this
                }
            };
        forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function(Location) {
            Location.prototype = Object.create(locationPrototype), Location.prototype.state = function(state) {
                if (!arguments.length) return this.$$state;
                if (Location !== LocationHtml5Url || !this.$$html5) throw $locationMinErr("nostate", "History API state support is available only in HTML5 mode and only in browsers supporting HTML5 History API");
                return this.$$state = isUndefined(state) ? null : state, this.$$urlUpdatedByLocation = !0, this
            }
        });
        var $parseMinErr = minErr("$parse"),
            objectValueOf = {}.constructor.prototype.valueOf,
            OPERATORS = createMap();
        forEach("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function(operator) {
            OPERATORS[operator] = !0
        });
        var ESCAPE = {
                n: "\n",
                f: "\f",
                r: "\r",
                t: "\t",
                v: "\v",
                "'": "'",
                '"': '"'
            },
            Lexer = function(options) {
                this.options = options
            };
        Lexer.prototype = {
            constructor: Lexer,
            lex: function(text) {
                for (this.text = text, this.index = 0, this.tokens = []; this.index < this.text.length;) {
                    var ch = this.text.charAt(this.index);
                    if ('"' === ch || "'" === ch) this.readString(ch);
                    else if (this.isNumber(ch) || "." === ch && this.isNumber(this.peek())) this.readNumber();
                    else if (this.isIdentifierStart(this.peekMultichar())) this.readIdent();
                    else if (this.is(ch, "(){}[].,;:?")) this.tokens.push({
                        index: this.index,
                        text: ch
                    }), this.index++;
                    else if (this.isWhitespace(ch)) this.index++;
                    else {
                        var ch2 = ch + this.peek(),
                            ch3 = ch2 + this.peek(2),
                            op1 = OPERATORS[ch],
                            op2 = OPERATORS[ch2],
                            op3 = OPERATORS[ch3];
                        if (op1 || op2 || op3) {
                            var token = op3 ? ch3 : op2 ? ch2 : ch;
                            this.tokens.push({
                                index: this.index,
                                text: token,
                                operator: !0
                            }), this.index += token.length
                        } else this.throwError("Unexpected next character ", this.index, this.index + 1)
                    }
                }
                return this.tokens
            },
            is: function(ch, chars) {
                return chars.indexOf(ch) !== -1
            },
            peek: function(i) {
                var num = i || 1;
                return this.index + num < this.text.length && this.text.charAt(this.index + num)
            },
            isNumber: function(ch) {
                return "0" <= ch && ch <= "9" && "string" == typeof ch
            },
            isWhitespace: function(ch) {
                return " " === ch || "\r" === ch || "\t" === ch || "\n" === ch || "\v" === ch || "" === ch
            },
            isIdentifierStart: function(ch) {
                return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch)
            },
            isValidIdentifierStart: function(ch) {
                return "a" <= ch && ch <= "z" || "A" <= ch && ch <= "Z" || "_" === ch || "$" === ch
            },
            isIdentifierContinue: function(ch) {
                return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch)
            },
            isValidIdentifierContinue: function(ch, cp) {
                return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch)
            },
            codePointAt: function(ch) {
                return 1 === ch.length ? ch.charCodeAt(0) : (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 56613888
            },
            peekMultichar: function() {
                var ch = this.text.charAt(this.index),
                    peek = this.peek();
                if (!peek) return ch;
                var cp1 = ch.charCodeAt(0),
                    cp2 = peek.charCodeAt(0);
                return cp1 >= 55296 && cp1 <= 56319 && cp2 >= 56320 && cp2 <= 57343 ? ch + peek : ch
            },
            isExpOperator: function(ch) {
                return "-" === ch || "+" === ch || this.isNumber(ch)
            },
            throwError: function(error, start, end) {
                end = end || this.index;
                var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
                throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text)
            },
            readNumber: function() {
                for (var number = "", start = this.index; this.index < this.text.length;) {
                    var ch = lowercase(this.text.charAt(this.index));
                    if ("." === ch || this.isNumber(ch)) number += ch;
                    else {
                        var peekCh = this.peek();
                        if ("e" === ch && this.isExpOperator(peekCh)) number += ch;
                        else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && "e" === number.charAt(number.length - 1)) number += ch;
                        else {
                            if (!this.isExpOperator(ch) || peekCh && this.isNumber(peekCh) || "e" !== number.charAt(number.length - 1)) break;
                            this.throwError("Invalid exponent")
                        }
                    }
                    this.index++
                }
                this.tokens.push({
                    index: start,
                    text: number,
                    constant: !0,
                    value: Number(number)
                })
            },
            readIdent: function() {
                var start = this.index;
                for (this.index += this.peekMultichar().length; this.index < this.text.length;) {
                    var ch = this.peekMultichar();
                    if (!this.isIdentifierContinue(ch)) break;
                    this.index += ch.length
                }
                this.tokens.push({
                    index: start,
                    text: this.text.slice(start, this.index),
                    identifier: !0
                })
            },
            readString: function(quote) {
                var start = this.index;
                this.index++;
                for (var string = "", rawString = quote, escape = !1; this.index < this.text.length;) {
                    var ch = this.text.charAt(this.index);
                    if (rawString += ch, escape) {
                        if ("u" === ch) {
                            var hex = this.text.substring(this.index + 1, this.index + 5);
                            hex.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + hex + "]"), this.index += 4, string += String.fromCharCode(parseInt(hex, 16))
                        } else {
                            var rep = ESCAPE[ch];
                            string += rep || ch
                        }
                        escape = !1
                    } else if ("\\" === ch) escape = !0;
                    else {
                        if (ch === quote) return this.index++, void this.tokens.push({
                            index: start,
                            text: rawString,
                            constant: !0,
                            value: string
                        });
                        string += ch
                    }
                    this.index++
                }
                this.throwError("Unterminated quote", start)
            }
        };
        var AST = function(lexer, options) {
            this.lexer = lexer, this.options = options
        };
        AST.Program = "Program", AST.ExpressionStatement = "ExpressionStatement", AST.AssignmentExpression = "AssignmentExpression", AST.ConditionalExpression = "ConditionalExpression", AST.LogicalExpression = "LogicalExpression", AST.BinaryExpression = "BinaryExpression", AST.UnaryExpression = "UnaryExpression", AST.CallExpression = "CallExpression", AST.MemberExpression = "MemberExpression", AST.Identifier = "Identifier", AST.Literal = "Literal", AST.ArrayExpression = "ArrayExpression", AST.Property = "Property", AST.ObjectExpression = "ObjectExpression", AST.ThisExpression = "ThisExpression", AST.LocalsExpression = "LocalsExpression", AST.NGValueParameter = "NGValueParameter", AST.prototype = {
            ast: function(text) {
                this.text = text, this.tokens = this.lexer.lex(text);
                var value = this.program();
                return 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]), value
            },
            program: function() {
                for (var body = [];;)
                    if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]") && body.push(this.expressionStatement()), !this.expect(";")) return {
                        type: AST.Program,
                        body: body
                    }
            },
            expressionStatement: function() {
                return {
                    type: AST.ExpressionStatement,
                    expression: this.filterChain()
                }
            },
            filterChain: function() {
                for (var left = this.expression(); this.expect("|");) left = this.filter(left);
                return left
            },
            expression: function() {
                return this.assignment()
            },
            assignment: function() {
                var result = this.ternary();
                if (this.expect("=")) {
                    if (!isAssignable(result)) throw $parseMinErr("lval", "Trying to assign a value to a non l-value");
                    result = {
                        type: AST.AssignmentExpression,
                        left: result,
                        right: this.assignment(),
                        operator: "="
                    }
                }
                return result
            },
            ternary: function() {
                var alternate, consequent, test = this.logicalOR();
                return this.expect("?") && (alternate = this.expression(), this.consume(":")) ? (consequent = this.expression(), {
                    type: AST.ConditionalExpression,
                    test: test,
                    alternate: alternate,
                    consequent: consequent
                }) : test
            },
            logicalOR: function() {
                for (var left = this.logicalAND(); this.expect("||");) left = {
                    type: AST.LogicalExpression,
                    operator: "||",
                    left: left,
                    right: this.logicalAND()
                };
                return left
            },
            logicalAND: function() {
                for (var left = this.equality(); this.expect("&&");) left = {
                    type: AST.LogicalExpression,
                    operator: "&&",
                    left: left,
                    right: this.equality()
                };
                return left
            },
            equality: function() {
                for (var token, left = this.relational(); token = this.expect("==", "!=", "===", "!==");) left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.relational()
                };
                return left
            },
            relational: function() {
                for (var token, left = this.additive(); token = this.expect("<", ">", "<=", ">=");) left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.additive()
                };
                return left
            },
            additive: function() {
                for (var token, left = this.multiplicative(); token = this.expect("+", "-");) left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.multiplicative()
                };
                return left
            },
            multiplicative: function() {
                for (var token, left = this.unary(); token = this.expect("*", "/", "%");) left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.unary()
                };
                return left
            },
            unary: function() {
                var token;
                return (token = this.expect("+", "-", "!")) ? {
                    type: AST.UnaryExpression,
                    operator: token.text,
                    prefix: !0,
                    argument: this.unary()
                } : this.primary()
            },
            primary: function primary() {
                var primary;
                this.expect("(") ? (primary = this.filterChain(), this.consume(")")) : this.expect("[") ? primary = this.arrayDeclaration() : this.expect("{") ? primary = this.object() : this.selfReferential.hasOwnProperty(this.peek().text) ? primary = copy(this.selfReferential[this.consume().text]) : this.options.literals.hasOwnProperty(this.peek().text) ? primary = {
                    type: AST.Literal,
                    value: this.options.literals[this.consume().text]
                } : this.peek().identifier ? primary = this.identifier() : this.peek().constant ? primary = this.constant() : this.throwError("not a primary expression", this.peek());
                for (var next; next = this.expect("(", "[", ".");) "(" === next.text ? (primary = {
                    type: AST.CallExpression,
                    callee: primary,
                    arguments: this.parseArguments()
                }, this.consume(")")) : "[" === next.text ? (primary = {
                    type: AST.MemberExpression,
                    object: primary,
                    property: this.expression(),
                    computed: !0
                }, this.consume("]")) : "." === next.text ? primary = {
                    type: AST.MemberExpression,
                    object: primary,
                    property: this.identifier(),
                    computed: !1
                } : this.throwError("IMPOSSIBLE");
                return primary
            },
            filter: function(baseExpression) {
                for (var args = [baseExpression], result = {
                        type: AST.CallExpression,
                        callee: this.identifier(),
                        arguments: args,
                        filter: !0
                    }; this.expect(":");) args.push(this.expression());
                return result
            },
            parseArguments: function() {
                var args = [];
                if (")" !== this.peekToken().text)
                    do args.push(this.filterChain()); while (this.expect(","));
                return args
            },
            identifier: function() {
                var token = this.consume();
                return token.identifier || this.throwError("is not a valid identifier", token), {
                    type: AST.Identifier,
                    name: token.text
                }
            },
            constant: function() {
                return {
                    type: AST.Literal,
                    value: this.consume().value
                }
            },
            arrayDeclaration: function() {
                var elements = [];
                if ("]" !== this.peekToken().text)
                    do {
                        if (this.peek("]")) break;
                        elements.push(this.expression())
                    } while (this.expect(","));
                return this.consume("]"), {
                    type: AST.ArrayExpression,
                    elements: elements
                }
            },
            object: function() {
                var property, properties = [];
                if ("}" !== this.peekToken().text)
                    do {
                        if (this.peek("}")) break;
                        property = {
                            type: AST.Property,
                            kind: "init"
                        }, this.peek().constant ? (property.key = this.constant(), property.computed = !1, this.consume(":"), property.value = this.expression()) : this.peek().identifier ? (property.key = this.identifier(), property.computed = !1, this.peek(":") ? (this.consume(":"), property.value = this.expression()) : property.value = property.key) : this.peek("[") ? (this.consume("["), property.key = this.expression(), this.consume("]"), property.computed = !0, this.consume(":"), property.value = this.expression()) : this.throwError("invalid key", this.peek()), properties.push(property)
                    } while (this.expect(","));
                return this.consume("}"), {
                    type: AST.ObjectExpression,
                    properties: properties
                }
            },
            throwError: function(msg, token) {
                throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index))
            },
            consume: function(e1) {
                if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
                var token = this.expect(e1);
                return token || this.throwError("is unexpected, expecting [" + e1 + "]", this.peek()), token
            },
            peekToken: function() {
                if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
                return this.tokens[0]
            },
            peek: function(e1, e2, e3, e4) {
                return this.peekAhead(0, e1, e2, e3, e4)
            },
            peekAhead: function(i, e1, e2, e3, e4) {
                if (this.tokens.length > i) {
                    var token = this.tokens[i],
                        t = token.text;
                    if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) return token
                }
                return !1
            },
            expect: function(e1, e2, e3, e4) {
                var token = this.peek(e1, e2, e3, e4);
                return !!token && (this.tokens.shift(), token)
            },
            selfReferential: {
                this: {
                    type: AST.ThisExpression
                },
                $locals: {
                    type: AST.LocalsExpression
                }
            }
        };
        var PURITY_ABSOLUTE = 1,
            PURITY_RELATIVE = 2;
        ASTCompiler.prototype = {
            compile: function(ast) {
                var self = this;
                this.state = {
                    nextId: 0,
                    filters: {},
                    fn: {
                        vars: [],
                        body: [],
                        own: {}
                    },
                    assign: {
                        vars: [],
                        body: [],
                        own: {}
                    },
                    inputs: []
                }, findConstantAndWatchExpressions(ast, self.$filter);
                var assignable, extra = "";
                if (this.stage = "assign", assignable = assignableAST(ast)) {
                    this.state.computing = "assign";
                    var result = this.nextId();
                    this.recurse(assignable, result), this.return_(result), extra = "fn.assign=" + this.generateFunction("assign", "s,v,l")
                }
                var toWatch = getInputs(ast.body);
                self.stage = "inputs", forEach(toWatch, function(watch, key) {
                    var fnKey = "fn" + key;
                    self.state[fnKey] = {
                        vars: [],
                        body: [],
                        own: {}
                    }, self.state.computing = fnKey;
                    var intoId = self.nextId();
                    self.recurse(watch, intoId), self.return_(intoId), self.state.inputs.push({
                        name: fnKey,
                        isPure: watch.isPure
                    }), watch.watchId = key
                }), this.state.computing = "fn", this.stage = "main", this.recurse(ast);
                var fnString = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + extra + this.watchFns() + "return fn;",
                    fn = new Function("$filter", "getStringValue", "ifDefined", "plus", fnString)(this.$filter, getStringValue, ifDefined, plusFn);
                return this.state = this.stage = void 0, fn
            },
            USE: "use",
            STRICT: "strict",
            watchFns: function() {
                var result = [],
                    inputs = this.state.inputs,
                    self = this;
                return forEach(inputs, function(input) {
                    result.push("var " + input.name + "=" + self.generateFunction(input.name, "s")), input.isPure && result.push(input.name, ".isPure=" + JSON.stringify(input.isPure) + ";")
                }), inputs.length && result.push("fn.inputs=[" + inputs.map(function(i) {
                    return i.name
                }).join(",") + "];"), result.join("")
            },
            generateFunction: function(name, params) {
                return "function(" + params + "){" + this.varsPrefix(name) + this.body(name) + "};"
            },
            filterPrefix: function() {
                var parts = [],
                    self = this;
                return forEach(this.state.filters, function(id, filter) {
                    parts.push(id + "=$filter(" + self.escape(filter) + ")")
                }), parts.length ? "var " + parts.join(",") + ";" : ""
            },
            varsPrefix: function(section) {
                return this.state[section].vars.length ? "var " + this.state[section].vars.join(",") + ";" : ""
            },
            body: function(section) {
                return this.state[section].body.join("")
            },
            recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
                var left, right, args, expression, computed, self = this;
                if (recursionFn = recursionFn || noop, !skipWatchIdCheck && isDefined(ast.watchId)) return intoId = intoId || this.nextId(), void this.if_("i", this.lazyAssign(intoId, this.computedMember("i", ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, !0));
                switch (ast.type) {
                    case AST.Program:
                        forEach(ast.body, function(expression, pos) {
                            self.recurse(expression.expression, void 0, void 0, function(expr) {
                                right = expr
                            }), pos !== ast.body.length - 1 ? self.current().body.push(right, ";") : self.return_(right)
                        });
                        break;
                    case AST.Literal:
                        expression = this.escape(ast.value), this.assign(intoId, expression), recursionFn(intoId || expression);
                        break;
                    case AST.UnaryExpression:
                        this.recurse(ast.argument, void 0, void 0, function(expr) {
                            right = expr
                        }), expression = ast.operator + "(" + this.ifDefined(right, 0) + ")", this.assign(intoId, expression), recursionFn(expression);
                        break;
                    case AST.BinaryExpression:
                        this.recurse(ast.left, void 0, void 0, function(expr) {
                            left = expr
                        }), this.recurse(ast.right, void 0, void 0, function(expr) {
                            right = expr
                        }), expression = "+" === ast.operator ? this.plus(left, right) : "-" === ast.operator ? this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0) : "(" + left + ")" + ast.operator + "(" + right + ")", this.assign(intoId, expression), recursionFn(expression);
                        break;
                    case AST.LogicalExpression:
                        intoId = intoId || this.nextId(), self.recurse(ast.left, intoId), self.if_("&&" === ast.operator ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId)), recursionFn(intoId);
                        break;
                    case AST.ConditionalExpression:
                        intoId = intoId || this.nextId(), self.recurse(ast.test, intoId), self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId)), recursionFn(intoId);
                        break;
                    case AST.Identifier:
                        intoId = intoId || this.nextId(), nameId && (nameId.context = "inputs" === self.stage ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", ast.name) + "?l:s"), nameId.computed = !1, nameId.name = ast.name), self.if_("inputs" === self.stage || self.not(self.getHasOwnProperty("l", ast.name)), function() {
                            self.if_("inputs" === self.stage || "s", function() {
                                create && 1 !== create && self.if_(self.isNull(self.nonComputedMember("s", ast.name)), self.lazyAssign(self.nonComputedMember("s", ast.name), "{}")), self.assign(intoId, self.nonComputedMember("s", ast.name))
                            })
                        }, intoId && self.lazyAssign(intoId, self.nonComputedMember("l", ast.name))), recursionFn(intoId);
                        break;
                    case AST.MemberExpression:
                        left = nameId && (nameId.context = this.nextId()) || this.nextId(), intoId = intoId || this.nextId(), self.recurse(ast.object, left, void 0, function() {
                            self.if_(self.notNull(left), function() {
                                ast.computed ? (right = self.nextId(), self.recurse(ast.property, right), self.getStringValue(right), create && 1 !== create && self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), "{}")), expression = self.computedMember(left, right), self.assign(intoId, expression), nameId && (nameId.computed = !0, nameId.name = right)) : (create && 1 !== create && self.if_(self.isNull(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), "{}")), expression = self.nonComputedMember(left, ast.property.name), self.assign(intoId, expression), nameId && (nameId.computed = !1, nameId.name = ast.property.name))
                            }, function() {
                                self.assign(intoId, "undefined")
                            }), recursionFn(intoId)
                        }, !!create);
                        break;
                    case AST.CallExpression:
                        intoId = intoId || this.nextId(), ast.filter ? (right = self.filter(ast.callee.name), args = [], forEach(ast.arguments, function(expr) {
                            var argument = self.nextId();
                            self.recurse(expr, argument), args.push(argument)
                        }), expression = right + "(" + args.join(",") + ")", self.assign(intoId, expression), recursionFn(intoId)) : (right = self.nextId(), left = {}, args = [], self.recurse(ast.callee, right, left, function() {
                            self.if_(self.notNull(right), function() {
                                forEach(ast.arguments, function(expr) {
                                    self.recurse(expr, ast.constant ? void 0 : self.nextId(), void 0, function(argument) {
                                        args.push(argument)
                                    })
                                }), expression = left.name ? self.member(left.context, left.name, left.computed) + "(" + args.join(",") + ")" : right + "(" + args.join(",") + ")", self.assign(intoId, expression)
                            }, function() {
                                self.assign(intoId, "undefined")
                            }), recursionFn(intoId)
                        }));
                        break;
                    case AST.AssignmentExpression:
                        right = this.nextId(), left = {}, this.recurse(ast.left, void 0, left, function() {
                            self.if_(self.notNull(left.context), function() {
                                self.recurse(ast.right, right), expression = self.member(left.context, left.name, left.computed) + ast.operator + right, self.assign(intoId, expression), recursionFn(intoId || expression)
                            })
                        }, 1);
                        break;
                    case AST.ArrayExpression:
                        args = [], forEach(ast.elements, function(expr) {
                            self.recurse(expr, ast.constant ? void 0 : self.nextId(), void 0, function(argument) {
                                args.push(argument)
                            })
                        }), expression = "[" + args.join(",") + "]", this.assign(intoId, expression), recursionFn(intoId || expression);
                        break;
                    case AST.ObjectExpression:
                        args = [], computed = !1, forEach(ast.properties, function(property) {
                            property.computed && (computed = !0)
                        }), computed ? (intoId = intoId || this.nextId(), this.assign(intoId, "{}"), forEach(ast.properties, function(property) {
                            property.computed ? (left = self.nextId(), self.recurse(property.key, left)) : left = property.key.type === AST.Identifier ? property.key.name : "" + property.key.value, right = self.nextId(), self.recurse(property.value, right), self.assign(self.member(intoId, left, property.computed), right)
                        })) : (forEach(ast.properties, function(property) {
                            self.recurse(property.value, ast.constant ? void 0 : self.nextId(), void 0, function(expr) {
                                args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : "" + property.key.value) + ":" + expr)
                            })
                        }), expression = "{" + args.join(",") + "}", this.assign(intoId, expression)), recursionFn(intoId || expression);
                        break;
                    case AST.ThisExpression:
                        this.assign(intoId, "s"), recursionFn(intoId || "s");
                        break;
                    case AST.LocalsExpression:
                        this.assign(intoId, "l"), recursionFn(intoId || "l");
                        break;
                    case AST.NGValueParameter:
                        this.assign(intoId, "v"), recursionFn(intoId || "v")
                }
            },
            getHasOwnProperty: function(element, property) {
                var key = element + "." + property,
                    own = this.current().own;
                return own.hasOwnProperty(key) || (own[key] = this.nextId(!1, element + "&&(" + this.escape(property) + " in " + element + ")")), own[key]
            },
            assign: function(id, value) {
                if (id) return this.current().body.push(id, "=", value, ";"), id
            },
            filter: function(filterName) {
                return this.state.filters.hasOwnProperty(filterName) || (this.state.filters[filterName] = this.nextId(!0)), this.state.filters[filterName]
            },
            ifDefined: function(id, defaultValue) {
                return "ifDefined(" + id + "," + this.escape(defaultValue) + ")"
            },
            plus: function(left, right) {
                return "plus(" + left + "," + right + ")"
            },
            return_: function(id) {
                this.current().body.push("return ", id, ";")
            },
            if_: function(test, alternate, consequent) {
                if (test === !0) alternate();
                else {
                    var body = this.current().body;
                    body.push("if(", test, "){"), alternate(), body.push("}"), consequent && (body.push("else{"), consequent(), body.push("}"))
                }
            },
            not: function(expression) {
                return "!(" + expression + ")"
            },
            isNull: function(expression) {
                return expression + "==null"
            },
            notNull: function(expression) {
                return expression + "!=null"
            },
            nonComputedMember: function(left, right) {
                var SAFE_IDENTIFIER = /^[$_a-zA-Z][$_a-zA-Z0-9]*$/,
                    UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
                return SAFE_IDENTIFIER.test(right) ? left + "." + right : left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]'
            },
            computedMember: function(left, right) {
                return left + "[" + right + "]"
            },
            member: function(left, right, computed) {
                return computed ? this.computedMember(left, right) : this.nonComputedMember(left, right)
            },
            getStringValue: function(item) {
                this.assign(item, "getStringValue(" + item + ")")
            },
            lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
                var self = this;
                return function() {
                    self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck)
                }
            },
            lazyAssign: function(id, value) {
                var self = this;
                return function() {
                    self.assign(id, value)
                }
            },
            stringEscapeRegex: /[^ a-zA-Z0-9]/g,
            stringEscapeFn: function(c) {
                return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4)
            },
            escape: function(value) {
                if (isString(value)) return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
                if (isNumber(value)) return value.toString();
                if (value === !0) return "true";
                if (value === !1) return "false";
                if (null === value) return "null";
                if ("undefined" == typeof value) return "undefined";
                throw $parseMinErr("esc", "IMPOSSIBLE")
            },
            nextId: function(skip, init) {
                var id = "v" + this.state.nextId++;
                return skip || this.current().vars.push(id + (init ? "=" + init : "")), id
            },
            current: function() {
                return this.state[this.state.computing]
            }
        }, ASTInterpreter.prototype = {
            compile: function(ast) {
                var self = this;
                findConstantAndWatchExpressions(ast, self.$filter);
                var assignable, assign;
                (assignable = assignableAST(ast)) && (assign = this.recurse(assignable));
                var inputs, toWatch = getInputs(ast.body);
                toWatch && (inputs = [], forEach(toWatch, function(watch, key) {
                    var input = self.recurse(watch);
                    input.isPure = watch.isPure, watch.input = input, inputs.push(input), watch.watchId = key
                }));
                var expressions = [];
                forEach(ast.body, function(expression) {
                    expressions.push(self.recurse(expression.expression))
                });
                var fn = 0 === ast.body.length ? noop : 1 === ast.body.length ? expressions[0] : function(scope, locals) {
                    var lastValue;
                    return forEach(expressions, function(exp) {
                        lastValue = exp(scope, locals)
                    }), lastValue
                };
                return assign && (fn.assign = function(scope, value, locals) {
                    return assign(scope, locals, value)
                }), inputs && (fn.inputs = inputs), fn
            },
            recurse: function(ast, context, create) {
                var left, right, args, self = this;
                if (ast.input) return this.inputs(ast.input, ast.watchId);
                switch (ast.type) {
                    case AST.Literal:
                        return this.value(ast.value, context);
                    case AST.UnaryExpression:
                        return right = this.recurse(ast.argument), this["unary" + ast.operator](right, context);
                    case AST.BinaryExpression:
                        return left = this.recurse(ast.left), right = this.recurse(ast.right), this["binary" + ast.operator](left, right, context);
                    case AST.LogicalExpression:
                        return left = this.recurse(ast.left), right = this.recurse(ast.right), this["binary" + ast.operator](left, right, context);
                    case AST.ConditionalExpression:
                        return this["ternary?:"](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
                    case AST.Identifier:
                        return self.identifier(ast.name, context, create);
                    case AST.MemberExpression:
                        return left = this.recurse(ast.object, !1, !!create), ast.computed || (right = ast.property.name), ast.computed && (right = this.recurse(ast.property)), ast.computed ? this.computedMember(left, right, context, create) : this.nonComputedMember(left, right, context, create);
                    case AST.CallExpression:
                        return args = [], forEach(ast.arguments, function(expr) {
                            args.push(self.recurse(expr))
                        }), ast.filter && (right = this.$filter(ast.callee.name)), ast.filter || (right = this.recurse(ast.callee, !0)), ast.filter ? function(scope, locals, assign, inputs) {
                            for (var values = [], i = 0; i < args.length; ++i) values.push(args[i](scope, locals, assign, inputs));
                            var value = right.apply(void 0, values, inputs);
                            return context ? {
                                context: void 0,
                                name: void 0,
                                value: value
                            } : value
                        } : function(scope, locals, assign, inputs) {
                            var value, rhs = right(scope, locals, assign, inputs);
                            if (null != rhs.value) {
                                for (var values = [], i = 0; i < args.length; ++i) values.push(args[i](scope, locals, assign, inputs));
                                value = rhs.value.apply(rhs.context, values)
                            }
                            return context ? {
                                value: value
                            } : value
                        };
                    case AST.AssignmentExpression:
                        return left = this.recurse(ast.left, !0, 1), right = this.recurse(ast.right),
                            function(scope, locals, assign, inputs) {
                                var lhs = left(scope, locals, assign, inputs),
                                    rhs = right(scope, locals, assign, inputs);
                                return lhs.context[lhs.name] = rhs, context ? {
                                    value: rhs
                                } : rhs
                            };
                    case AST.ArrayExpression:
                        return args = [], forEach(ast.elements, function(expr) {
                                args.push(self.recurse(expr))
                            }),
                            function(scope, locals, assign, inputs) {
                                for (var value = [], i = 0; i < args.length; ++i) value.push(args[i](scope, locals, assign, inputs));
                                return context ? {
                                    value: value
                                } : value
                            };
                    case AST.ObjectExpression:
                        return args = [], forEach(ast.properties, function(property) {
                                property.computed ? args.push({
                                    key: self.recurse(property.key),
                                    computed: !0,
                                    value: self.recurse(property.value)
                                }) : args.push({
                                    key: property.key.type === AST.Identifier ? property.key.name : "" + property.key.value,
                                    computed: !1,
                                    value: self.recurse(property.value)
                                })
                            }),
                            function(scope, locals, assign, inputs) {
                                for (var value = {}, i = 0; i < args.length; ++i) args[i].computed ? value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs) : value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                                return context ? {
                                    value: value
                                } : value
                            };
                    case AST.ThisExpression:
                        return function(scope) {
                            return context ? {
                                value: scope
                            } : scope
                        };
                    case AST.LocalsExpression:
                        return function(scope, locals) {
                            return context ? {
                                value: locals
                            } : locals
                        };
                    case AST.NGValueParameter:
                        return function(scope, locals, assign) {
                            return context ? {
                                value: assign
                            } : assign
                        }
                }
            },
            "unary+": function(argument, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = argument(scope, locals, assign, inputs);
                    return arg = isDefined(arg) ? +arg : 0, context ? {
                        value: arg
                    } : arg
                }
            },
            "unary-": function(argument, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = argument(scope, locals, assign, inputs);
                    return arg = isDefined(arg) ? -arg : -0, context ? {
                        value: arg
                    } : arg
                }
            },
            "unary!": function(argument, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = !argument(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary+": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs),
                        rhs = right(scope, locals, assign, inputs),
                        arg = plusFn(lhs, rhs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary-": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs),
                        rhs = right(scope, locals, assign, inputs),
                        arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary*": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary/": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary%": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary===": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary!==": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary==": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary!=": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary<": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary>": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary<=": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary>=": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary&&": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary||": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "ternary?:": function(test, alternate, consequent, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            value: function(_value2, context) {
                return function() {
                    return context ? {
                        context: void 0,
                        name: void 0,
                        value: _value2
                    } : _value2
                }
            },
            identifier: function(name, context, create) {
                return function(scope, locals, assign, inputs) {
                    var base = locals && name in locals ? locals : scope;
                    create && 1 !== create && base && null == base[name] && (base[name] = {});
                    var value = base ? base[name] : void 0;
                    return context ? {
                        context: base,
                        name: name,
                        value: value
                    } : value
                }
            },
            computedMember: function(left, right, context, create) {
                return function(scope, locals, assign, inputs) {
                    var rhs, value, lhs = left(scope, locals, assign, inputs);
                    return null != lhs && (rhs = right(scope, locals, assign, inputs), rhs = getStringValue(rhs), create && 1 !== create && lhs && !lhs[rhs] && (lhs[rhs] = {}), value = lhs[rhs]), context ? {
                        context: lhs,
                        name: rhs,
                        value: value
                    } : value
                }
            },
            nonComputedMember: function(left, right, context, create) {
                return function(scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs);
                    create && 1 !== create && lhs && null == lhs[right] && (lhs[right] = {});
                    var value = null != lhs ? lhs[right] : void 0;
                    return context ? {
                        context: lhs,
                        name: right,
                        value: value
                    } : value
                }
            },
            inputs: function(input, watchId) {
                return function(scope, value, locals, inputs) {
                    return inputs ? inputs[watchId] : input(scope, value, locals)
                }
            }
        }, Parser.prototype = {
            constructor: Parser,
            parse: function(text) {
                var ast = this.getAst(text),
                    fn = this.astCompiler.compile(ast.ast);
                return fn.literal = isLiteral(ast.ast), fn.constant = isConstant(ast.ast), fn.oneTime = ast.oneTime, fn
            },
            getAst: function(exp) {
                var oneTime = !1;
                return exp = exp.trim(), ":" === exp.charAt(0) && ":" === exp.charAt(1) && (oneTime = !0, exp = exp.substring(2)), {
                    ast: this.ast.ast(exp),
                    oneTime: oneTime
                }
            }
        };
        var baseUrlParsingNode, $sceMinErr = minErr("$sce"),
            SCE_CONTEXTS = {
                HTML: "html",
                CSS: "css",
                MEDIA_URL: "mediaUrl",
                URL: "url",
                RESOURCE_URL: "resourceUrl",
                JS: "js"
            },
            UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g,
            $templateRequestMinErr = minErr("$templateRequest"),
            $timeoutMinErr = minErr("$timeout"),
            urlParsingNode = window.document.createElement("a"),
            originUrl = urlResolve(window.location.href);
        urlParsingNode.href = "http://[::1]";
        var ipv6InBrackets = "[::1]" === urlParsingNode.hostname;
        $$CookieReader.$inject = ["$document"], $FilterProvider.$inject = ["$provide"];
        var MAX_DIGITS = 22,
            DECIMAL_SEP = ".",
            ZERO_CHAR = "0";
        currencyFilter.$inject = ["$locale"], numberFilter.$inject = ["$locale"];
        var DATE_FORMATS = {
                yyyy: dateGetter("FullYear", 4, 0, !1, !0),
                yy: dateGetter("FullYear", 2, 0, !0, !0),
                y: dateGetter("FullYear", 1, 0, !1, !0),
                MMMM: dateStrGetter("Month"),
                MMM: dateStrGetter("Month", !0),
                MM: dateGetter("Month", 2, 1),
                M: dateGetter("Month", 1, 1),
                LLLL: dateStrGetter("Month", !1, !0),
                dd: dateGetter("Date", 2),
                d: dateGetter("Date", 1),
                HH: dateGetter("Hours", 2),
                H: dateGetter("Hours", 1),
                hh: dateGetter("Hours", 2, -12),
                h: dateGetter("Hours", 1, -12),
                mm: dateGetter("Minutes", 2),
                m: dateGetter("Minutes", 1),
                ss: dateGetter("Seconds", 2),
                s: dateGetter("Seconds", 1),
                sss: dateGetter("Milliseconds", 3),
                EEEE: dateStrGetter("Day"),
                EEE: dateStrGetter("Day", !0),
                a: ampmGetter,
                Z: timeZoneGetter,
                ww: weekGetter(2),
                w: weekGetter(1),
                G: eraGetter,
                GG: eraGetter,
                GGG: eraGetter,
                GGGG: longEraGetter
            },
            DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))([\s\S]*)/,
            NUMBER_STRING = /^-?\d+$/;
        dateFilter.$inject = ["$locale"];
        var lowercaseFilter = valueFn(lowercase),
            uppercaseFilter = valueFn(uppercase);
        orderByFilter.$inject = ["$parse"];
        var htmlAnchorDirective = valueFn({
                restrict: "E",
                compile: function(element, attr) {
                    if (!attr.href && !attr.xlinkHref) return function(scope, element) {
                        if ("a" === element[0].nodeName.toLowerCase()) {
                            var href = "[object SVGAnimatedString]" === toString.call(element.prop("href")) ? "xlink:href" : "href";
                            element.on("click", function(event) {
                                element.attr(href) || event.preventDefault()
                            })
                        }
                    }
                }
            }),
            ngAttributeAliasDirectives = {};
        forEach(BOOLEAN_ATTR, function(propName, attrName) {
            function defaultLinkFn(scope, element, attr) {
                scope.$watch(attr[normalized], function(value) {
                    attr.$set(attrName, !!value)
                })
            }
            if ("multiple" !== propName) {
                var normalized = directiveNormalize("ng-" + attrName),
                    linkFn = defaultLinkFn;
                "checked" === propName && (linkFn = function(scope, element, attr) {
                    attr.ngModel !== attr[normalized] && defaultLinkFn(scope, element, attr)
                }), ngAttributeAliasDirectives[normalized] = function() {
                    return {
                        restrict: "A",
                        priority: 100,
                        link: linkFn
                    }
                }
            }
        }), forEach(ALIASED_ATTR, function(htmlAttr, ngAttr) {
            ngAttributeAliasDirectives[ngAttr] = function() {
                return {
                    priority: 100,
                    link: function(scope, element, attr) {
                        if ("ngPattern" === ngAttr && "/" === attr.ngPattern.charAt(0)) {
                            var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                            if (match) return void attr.$set("ngPattern", new RegExp(match[1], match[2]))
                        }
                        scope.$watch(attr[ngAttr], function(value) {
                            attr.$set(ngAttr, value)
                        })
                    }
                }
            }
        }), forEach(["src", "srcset", "href"], function(attrName) {
            var normalized = directiveNormalize("ng-" + attrName);
            ngAttributeAliasDirectives[normalized] = ["$sce", function($sce) {
                return {
                    priority: 99,
                    link: function(scope, element, attr) {
                        var propName = attrName,
                            name = attrName;
                        "href" === attrName && "[object SVGAnimatedString]" === toString.call(element.prop("href")) && (name = "xlinkHref", attr.$attr[name] = "xlink:href", propName = null), attr.$set(normalized, $sce.getTrustedMediaUrl(attr[normalized])), attr.$observe(normalized, function(value) {
                            return value ? (attr.$set(name, value), void(msie && propName && element.prop(propName, attr[name]))) : void("href" === attrName && attr.$set(name, null))
                        })
                    }
                }
            }]
        });
        var nullFormCtrl = {
                $addControl: noop,
                $getControls: valueFn([]),
                $$renameControl: nullFormRenameControl,
                $removeControl: noop,
                $setValidity: noop,
                $setDirty: noop,
                $setPristine: noop,
                $setSubmitted: noop,
                $$setSubmitted: noop
            },
            PENDING_CLASS = "ng-pending",
            SUBMITTED_CLASS = "ng-submitted";
        FormController.$inject = ["$element", "$attrs", "$scope", "$animate", "$interpolate"], FormController.prototype = {
            $rollbackViewValue: function() {
                forEach(this.$$controls, function(control) {
                    control.$rollbackViewValue()
                })
            },
            $commitViewValue: function() {
                forEach(this.$$controls, function(control) {
                    control.$commitViewValue()
                })
            },
            $addControl: function(control) {
                assertNotHasOwnProperty(control.$name, "input"), this.$$controls.push(control), control.$name && (this[control.$name] = control), control.$$parentForm = this
            },
            $getControls: function() {
                return shallowCopy(this.$$controls);
            },
            $$renameControl: function(control, newName) {
                var oldName = control.$name;
                this[oldName] === control && delete this[oldName], this[newName] = control, control.$name = newName
            },
            $removeControl: function(control) {
                control.$name && this[control.$name] === control && delete this[control.$name], forEach(this.$pending, function(value, name) {
                    this.$setValidity(name, null, control)
                }, this), forEach(this.$error, function(value, name) {
                    this.$setValidity(name, null, control)
                }, this), forEach(this.$$success, function(value, name) {
                    this.$setValidity(name, null, control)
                }, this), arrayRemove(this.$$controls, control), control.$$parentForm = nullFormCtrl
            },
            $setDirty: function() {
                this.$$animate.removeClass(this.$$element, PRISTINE_CLASS), this.$$animate.addClass(this.$$element, DIRTY_CLASS), this.$dirty = !0, this.$pristine = !1, this.$$parentForm.$setDirty()
            },
            $setPristine: function() {
                this.$$animate.setClass(this.$$element, PRISTINE_CLASS, DIRTY_CLASS + " " + SUBMITTED_CLASS), this.$dirty = !1, this.$pristine = !0, this.$submitted = !1, forEach(this.$$controls, function(control) {
                    control.$setPristine()
                })
            },
            $setUntouched: function() {
                forEach(this.$$controls, function(control) {
                    control.$setUntouched()
                })
            },
            $setSubmitted: function() {
                for (var rootForm = this; rootForm.$$parentForm && rootForm.$$parentForm !== nullFormCtrl;) rootForm = rootForm.$$parentForm;
                rootForm.$$setSubmitted()
            },
            $$setSubmitted: function() {
                this.$$animate.addClass(this.$$element, SUBMITTED_CLASS), this.$submitted = !0, forEach(this.$$controls, function(control) {
                    control.$$setSubmitted && control.$$setSubmitted()
                })
            }
        }, addSetValidityMethod({
            clazz: FormController,
            set: function(object, property, controller) {
                var list = object[property];
                if (list) {
                    var index = list.indexOf(controller);
                    index === -1 && list.push(controller)
                } else object[property] = [controller]
            },
            unset: function(object, property, controller) {
                var list = object[property];
                list && (arrayRemove(list, controller), 0 === list.length && delete object[property])
            }
        });
        var formDirectiveFactory = function(isNgForm) {
                return ["$timeout", "$parse", function($timeout, $parse) {
                    function getSetter(expression) {
                        return "" === expression ? $parse('this[""]').assign : $parse(expression).assign || noop
                    }
                    var formDirective = {
                        name: "form",
                        restrict: isNgForm ? "EAC" : "E",
                        require: ["form", "^^?form"],
                        controller: FormController,
                        compile: function(formElement, attr) {
                            formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                            var nameAttr = attr.name ? "name" : !(!isNgForm || !attr.ngForm) && "ngForm";
                            return {
                                pre: function(scope, formElement, attr, ctrls) {
                                    var controller = ctrls[0];
                                    if (!("action" in attr)) {
                                        var handleFormSubmission = function(event) {
                                            scope.$apply(function() {
                                                controller.$commitViewValue(), controller.$setSubmitted()
                                            }), event.preventDefault()
                                        };
                                        formElement[0].addEventListener("submit", handleFormSubmission), formElement.on("$destroy", function() {
                                            $timeout(function() {
                                                formElement[0].removeEventListener("submit", handleFormSubmission)
                                            }, 0, !1)
                                        })
                                    }
                                    var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                                    parentFormCtrl.$addControl(controller);
                                    var setter = nameAttr ? getSetter(controller.$name) : noop;
                                    nameAttr && (setter(scope, controller), attr.$observe(nameAttr, function(newValue) {
                                        controller.$name !== newValue && (setter(scope, void 0), controller.$$parentForm.$$renameControl(controller, newValue), (setter = getSetter(controller.$name))(scope, controller))
                                    })), formElement.on("$destroy", function() {
                                        controller.$$parentForm.$removeControl(controller), setter(scope, void 0), extend(controller, nullFormCtrl)
                                    })
                                }
                            }
                        }
                    };
                    return formDirective
                }]
            },
            formDirective = formDirectiveFactory(),
            ngFormDirective = formDirectiveFactory(!0),
            ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/,
            URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i,
            EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/,
            NUMBER_REGEXP = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/,
            DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/,
            DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/,
            WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/,
            MONTH_REGEXP = /^(\d{4,})-(\d\d)$/,
            TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/,
            PARTIAL_VALIDATION_EVENTS = "keydown wheel mousedown",
            PARTIAL_VALIDATION_TYPES = createMap();
        forEach("date,datetime-local,month,time,week".split(","), function(type) {
            PARTIAL_VALIDATION_TYPES[type] = !0
        });
        var inputType = {
                text: textInputType,
                date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, ["yyyy", "MM", "dd"]), "yyyy-MM-dd"),
                "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ["yyyy", "MM", "dd", "HH", "mm", "ss", "sss"]), "yyyy-MM-ddTHH:mm:ss.sss"),
                time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, ["HH", "mm", "ss", "sss"]), "HH:mm:ss.sss"),
                week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
                month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, ["yyyy", "MM"]), "yyyy-MM"),
                number: numberInputType,
                url: urlInputType,
                email: emailInputType,
                radio: radioInputType,
                range: rangeInputType,
                checkbox: checkboxInputType,
                hidden: noop,
                button: noop,
                submit: noop,
                reset: noop,
                file: noop
            },
            inputDirective = ["$browser", "$sniffer", "$filter", "$parse", function($browser, $sniffer, $filter, $parse) {
                return {
                    restrict: "E",
                    require: ["?ngModel"],
                    link: {
                        pre: function(scope, element, attr, ctrls) {
                            ctrls[0] && (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse)
                        }
                    }
                }
            }],
            hiddenInputBrowserCacheDirective = function() {
                var valueProperty = {
                    configurable: !0,
                    enumerable: !1,
                    get: function() {
                        return this.getAttribute("value") || ""
                    },
                    set: function(val) {
                        this.setAttribute("value", val)
                    }
                };
                return {
                    restrict: "E",
                    priority: 200,
                    compile: function(_, attr) {
                        if ("hidden" === lowercase(attr.type)) return {
                            pre: function(scope, element, attr, ctrls) {
                                var node = element[0];
                                node.parentNode && node.parentNode.insertBefore(node, node.nextSibling), Object.defineProperty && Object.defineProperty(node, "value", valueProperty)
                            }
                        }
                    }
                }
            },
            CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/,
            ngValueDirective = function() {
                function updateElementValue(element, attr, value) {
                    var propValue = isDefined(value) ? value : 9 === msie ? "" : null;
                    element.prop("value", propValue), attr.$set("value", value)
                }
                return {
                    restrict: "A",
                    priority: 100,
                    compile: function(tpl, tplAttr) {
                        return CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue) ? function(scope, elm, attr) {
                            var value = scope.$eval(attr.ngValue);
                            updateElementValue(elm, attr, value)
                        } : function(scope, elm, attr) {
                            scope.$watch(attr.ngValue, function(value) {
                                updateElementValue(elm, attr, value)
                            })
                        }
                    }
                }
            },
            ngBindDirective = ["$compile", function($compile) {
                return {
                    restrict: "AC",
                    compile: function(templateElement) {
                        return $compile.$$addBindingClass(templateElement),
                            function(scope, element, attr) {
                                $compile.$$addBindingInfo(element, attr.ngBind), element = element[0], scope.$watch(attr.ngBind, function(value) {
                                    element.textContent = stringify(value)
                                })
                            }
                    }
                }
            }],
            ngBindTemplateDirective = ["$interpolate", "$compile", function($interpolate, $compile) {
                return {
                    compile: function(templateElement) {
                        return $compile.$$addBindingClass(templateElement),
                            function(scope, element, attr) {
                                var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                                $compile.$$addBindingInfo(element, interpolateFn.expressions), element = element[0], attr.$observe("ngBindTemplate", function(value) {
                                    element.textContent = isUndefined(value) ? "" : value
                                })
                            }
                    }
                }
            }],
            ngBindHtmlDirective = ["$sce", "$parse", "$compile", function($sce, $parse, $compile) {
                return {
                    restrict: "A",
                    compile: function(tElement, tAttrs) {
                        var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml),
                            ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function(val) {
                                return $sce.valueOf(val)
                            });
                        return $compile.$$addBindingClass(tElement),
                            function(scope, element, attr) {
                                $compile.$$addBindingInfo(element, attr.ngBindHtml), scope.$watch(ngBindHtmlWatch, function() {
                                    var value = ngBindHtmlGetter(scope);
                                    element.html($sce.getTrustedHtml(value) || "")
                                })
                            }
                    }
                }
            }],
            ngChangeDirective = valueFn({
                restrict: "A",
                require: "ngModel",
                link: function(scope, element, attr, ctrl) {
                    ctrl.$viewChangeListeners.push(function() {
                        scope.$eval(attr.ngChange)
                    })
                }
            }),
            ngClassDirective = classDirective("", !0),
            ngClassOddDirective = classDirective("Odd", 0),
            ngClassEvenDirective = classDirective("Even", 1),
            ngCloakDirective = ngDirective({
                compile: function(element, attr) {
                    attr.$set("ngCloak", void 0), element.removeClass("ng-cloak")
                }
            }),
            ngControllerDirective = [function() {
                return {
                    restrict: "A",
                    scope: !0,
                    controller: "@",
                    priority: 500
                }
            }],
            ngEventDirectives = {},
            forceAsyncEvents = {
                blur: !0,
                focus: !0
            };
        forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function(eventName) {
            var directiveName = directiveNormalize("ng-" + eventName);
            ngEventDirectives[directiveName] = ["$parse", "$rootScope", "$exceptionHandler", function($parse, $rootScope, $exceptionHandler) {
                return createEventDirective($parse, $rootScope, $exceptionHandler, directiveName, eventName, forceAsyncEvents[eventName])
            }]
        });
        var ngIfDirective = ["$animate", "$compile", function($animate, $compile) {
                return {
                    multiElement: !0,
                    transclude: "element",
                    priority: 600,
                    terminal: !0,
                    restrict: "A",
                    $$tlb: !0,
                    link: function($scope, $element, $attr, ctrl, $transclude) {
                        var block, childScope, previousElements;
                        $scope.$watch($attr.ngIf, function(value) {
                            value ? childScope || $transclude(function(clone, newScope) {
                                childScope = newScope, clone[clone.length++] = $compile.$$createComment("end ngIf", $attr.ngIf), block = {
                                    clone: clone
                                }, $animate.enter(clone, $element.parent(), $element)
                            }) : (previousElements && (previousElements.remove(), previousElements = null), childScope && (childScope.$destroy(), childScope = null), block && (previousElements = getBlockNodes(block.clone), $animate.leave(previousElements).done(function(response) {
                                response !== !1 && (previousElements = null)
                            }), block = null))
                        })
                    }
                }
            }],
            ngIncludeDirective = ["$templateRequest", "$anchorScroll", "$animate", function($templateRequest, $anchorScroll, $animate) {
                return {
                    restrict: "ECA",
                    priority: 400,
                    terminal: !0,
                    transclude: "element",
                    controller: angular.noop,
                    compile: function(element, attr) {
                        var srcExp = attr.ngInclude || attr.src,
                            onloadExp = attr.onload || "",
                            autoScrollExp = attr.autoscroll;
                        return function(scope, $element, $attr, ctrl, $transclude) {
                            var currentScope, previousElement, currentElement, changeCounter = 0,
                                cleanupLastIncludeContent = function() {
                                    previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), currentScope = null), currentElement && ($animate.leave(currentElement).done(function(response) {
                                        response !== !1 && (previousElement = null)
                                    }), previousElement = currentElement, currentElement = null)
                                };
                            scope.$watch(srcExp, function(src) {
                                var afterAnimation = function(response) {
                                        response === !1 || !isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll()
                                    },
                                    thisChangeId = ++changeCounter;
                                src ? ($templateRequest(src, !0).then(function(response) {
                                    if (!scope.$$destroyed && thisChangeId === changeCounter) {
                                        var newScope = scope.$new();
                                        ctrl.template = response;
                                        var clone = $transclude(newScope, function(clone) {
                                            cleanupLastIncludeContent(), $animate.enter(clone, null, $element).done(afterAnimation)
                                        });
                                        currentScope = newScope, currentElement = clone, currentScope.$emit("$includeContentLoaded", src), scope.$eval(onloadExp)
                                    }
                                }, function() {
                                    scope.$$destroyed || thisChangeId === changeCounter && (cleanupLastIncludeContent(), scope.$emit("$includeContentError", src))
                                }), scope.$emit("$includeContentRequested", src)) : (cleanupLastIncludeContent(), ctrl.template = null)
                            })
                        }
                    }
                }
            }],
            ngIncludeFillContentDirective = ["$compile", function($compile) {
                return {
                    restrict: "ECA",
                    priority: -400,
                    require: "ngInclude",
                    link: function(scope, $element, $attr, ctrl) {
                        return toString.call($element[0]).match(/SVG/) ? ($element.empty(), void $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, function(clone) {
                            $element.append(clone)
                        }, {
                            futureParentElement: $element
                        })) : ($element.html(ctrl.template), void $compile($element.contents())(scope))
                    }
                }
            }],
            ngInitDirective = ngDirective({
                priority: 450,
                compile: function() {
                    return {
                        pre: function(scope, element, attrs) {
                            scope.$eval(attrs.ngInit)
                        }
                    }
                }
            }),
            ngListDirective = function() {
                return {
                    restrict: "A",
                    priority: 100,
                    require: "ngModel",
                    link: function(scope, element, attr, ctrl) {
                        var ngList = attr.ngList || ", ",
                            trimValues = "false" !== attr.ngTrim,
                            separator = trimValues ? trim(ngList) : ngList,
                            parse = function(viewValue) {
                                if (!isUndefined(viewValue)) {
                                    var list = [];
                                    return viewValue && forEach(viewValue.split(separator), function(value) {
                                        value && list.push(trimValues ? trim(value) : value)
                                    }), list
                                }
                            };
                        ctrl.$parsers.push(parse), ctrl.$formatters.push(function(value) {
                            if (isArray(value)) return value.join(ngList)
                        }), ctrl.$isEmpty = function(value) {
                            return !value || !value.length
                        }
                    }
                }
            },
            VALID_CLASS = "ng-valid",
            INVALID_CLASS = "ng-invalid",
            PRISTINE_CLASS = "ng-pristine",
            DIRTY_CLASS = "ng-dirty",
            UNTOUCHED_CLASS = "ng-untouched",
            TOUCHED_CLASS = "ng-touched",
            EMPTY_CLASS = "ng-empty",
            NOT_EMPTY_CLASS = "ng-not-empty",
            ngModelMinErr = minErr("ngModel");
        NgModelController.$inject = ["$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$q", "$interpolate"], NgModelController.prototype = {
            $$initGetterSetters: function() {
                if (this.$options.getOption("getterSetter")) {
                    var invokeModelGetter = this.$$parse(this.$$attr.ngModel + "()"),
                        invokeModelSetter = this.$$parse(this.$$attr.ngModel + "($$$p)");
                    this.$$ngModelGet = function($scope) {
                        var modelValue = this.$$parsedNgModel($scope);
                        return isFunction(modelValue) && (modelValue = invokeModelGetter($scope)), modelValue
                    }, this.$$ngModelSet = function($scope, newValue) {
                        isFunction(this.$$parsedNgModel($scope)) ? invokeModelSetter($scope, {
                            $$$p: newValue
                        }) : this.$$parsedNgModelAssign($scope, newValue)
                    }
                } else if (!this.$$parsedNgModel.assign) throw ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", this.$$attr.ngModel, startingTag(this.$$element))
            },
            $render: noop,
            $isEmpty: function(value) {
                return isUndefined(value) || "" === value || null === value || value !== value
            },
            $$updateEmptyClasses: function(value) {
                this.$isEmpty(value) ? (this.$$animate.removeClass(this.$$element, NOT_EMPTY_CLASS), this.$$animate.addClass(this.$$element, EMPTY_CLASS)) : (this.$$animate.removeClass(this.$$element, EMPTY_CLASS), this.$$animate.addClass(this.$$element, NOT_EMPTY_CLASS))
            },
            $setPristine: function() {
                this.$dirty = !1, this.$pristine = !0, this.$$animate.removeClass(this.$$element, DIRTY_CLASS), this.$$animate.addClass(this.$$element, PRISTINE_CLASS)
            },
            $setDirty: function() {
                this.$dirty = !0, this.$pristine = !1, this.$$animate.removeClass(this.$$element, PRISTINE_CLASS), this.$$animate.addClass(this.$$element, DIRTY_CLASS), this.$$parentForm.$setDirty()
            },
            $setUntouched: function() {
                this.$touched = !1, this.$untouched = !0, this.$$animate.setClass(this.$$element, UNTOUCHED_CLASS, TOUCHED_CLASS)
            },
            $setTouched: function() {
                this.$touched = !0, this.$untouched = !1, this.$$animate.setClass(this.$$element, TOUCHED_CLASS, UNTOUCHED_CLASS)
            },
            $rollbackViewValue: function() {
                this.$$timeout.cancel(this.$$pendingDebounce), this.$viewValue = this.$$lastCommittedViewValue, this.$render()
            },
            $validate: function() {
                if (!isNumberNaN(this.$modelValue)) {
                    var viewValue = this.$$lastCommittedViewValue,
                        modelValue = this.$$rawModelValue,
                        prevValid = this.$valid,
                        prevModelValue = this.$modelValue,
                        allowInvalid = this.$options.getOption("allowInvalid"),
                        that = this;
                    this.$$runValidators(modelValue, viewValue, function(allValid) {
                        allowInvalid || prevValid === allValid || (that.$modelValue = allValid ? modelValue : void 0, that.$modelValue !== prevModelValue && that.$$writeModelToScope())
                    })
                }
            },
            $$runValidators: function(modelValue, viewValue, doneCallback) {
                function processParseErrors() {
                    var errorKey = that.$$parserName;
                    return isUndefined(that.$$parserValid) ? (setValidity(errorKey, null), !0) : (that.$$parserValid || (forEach(that.$validators, function(v, name) {
                        setValidity(name, null)
                    }), forEach(that.$asyncValidators, function(v, name) {
                        setValidity(name, null)
                    })), setValidity(errorKey, that.$$parserValid), that.$$parserValid)
                }

                function processSyncValidators() {
                    var syncValidatorsValid = !0;
                    return forEach(that.$validators, function(validator, name) {
                        var result = Boolean(validator(modelValue, viewValue));
                        syncValidatorsValid = syncValidatorsValid && result, setValidity(name, result)
                    }), !!syncValidatorsValid || (forEach(that.$asyncValidators, function(v, name) {
                        setValidity(name, null)
                    }), !1)
                }

                function processAsyncValidators() {
                    var validatorPromises = [],
                        allValid = !0;
                    forEach(that.$asyncValidators, function(validator, name) {
                        var promise = validator(modelValue, viewValue);
                        if (!isPromiseLike(promise)) throw ngModelMinErr("nopromise", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                        setValidity(name, void 0), validatorPromises.push(promise.then(function() {
                            setValidity(name, !0)
                        }, function() {
                            allValid = !1, setValidity(name, !1)
                        }))
                    }), validatorPromises.length ? that.$$q.all(validatorPromises).then(function() {
                        validationDone(allValid)
                    }, noop) : validationDone(!0)
                }

                function setValidity(name, isValid) {
                    localValidationRunId === that.$$currentValidationRunId && that.$setValidity(name, isValid)
                }

                function validationDone(allValid) {
                    localValidationRunId === that.$$currentValidationRunId && doneCallback(allValid)
                }
                this.$$currentValidationRunId++;
                var localValidationRunId = this.$$currentValidationRunId,
                    that = this;
                return processParseErrors() && processSyncValidators() ? void processAsyncValidators() : void validationDone(!1)
            },
            $commitViewValue: function() {
                var viewValue = this.$viewValue;
                this.$$timeout.cancel(this.$$pendingDebounce), (this.$$lastCommittedViewValue !== viewValue || "" === viewValue && this.$$hasNativeValidators) && (this.$$updateEmptyClasses(viewValue), this.$$lastCommittedViewValue = viewValue, this.$pristine && this.$setDirty(), this.$$parseAndValidate())
            },
            $$parseAndValidate: function() {
                function writeToModelIfNeeded() {
                    that.$modelValue !== prevModelValue && that.$$writeModelToScope()
                }
                var viewValue = this.$$lastCommittedViewValue,
                    modelValue = viewValue,
                    that = this;
                if (this.$$parserValid = !isUndefined(modelValue) || void 0, this.$setValidity(this.$$parserName, null), this.$$parserName = "parse", this.$$parserValid)
                    for (var i = 0; i < this.$parsers.length; i++)
                        if (modelValue = this.$parsers[i](modelValue), isUndefined(modelValue)) {
                            this.$$parserValid = !1;
                            break
                        } isNumberNaN(this.$modelValue) && (this.$modelValue = this.$$ngModelGet(this.$$scope));
                var prevModelValue = this.$modelValue,
                    allowInvalid = this.$options.getOption("allowInvalid");
                this.$$rawModelValue = modelValue, allowInvalid && (this.$modelValue = modelValue, writeToModelIfNeeded()), this.$$runValidators(modelValue, this.$$lastCommittedViewValue, function(allValid) {
                    allowInvalid || (that.$modelValue = allValid ? modelValue : void 0, writeToModelIfNeeded())
                })
            },
            $$writeModelToScope: function() {
                this.$$ngModelSet(this.$$scope, this.$modelValue), forEach(this.$viewChangeListeners, function(listener) {
                    try {
                        listener()
                    } catch (e) {
                        this.$$exceptionHandler(e)
                    }
                }, this)
            },
            $setViewValue: function(value, trigger) {
                this.$viewValue = value, this.$options.getOption("updateOnDefault") && this.$$debounceViewValueCommit(trigger)
            },
            $$debounceViewValueCommit: function(trigger) {
                var debounceDelay = this.$options.getOption("debounce");
                isNumber(debounceDelay[trigger]) ? debounceDelay = debounceDelay[trigger] : isNumber(debounceDelay.default) && this.$options.getOption("updateOn").indexOf(trigger) === -1 ? debounceDelay = debounceDelay.default : isNumber(debounceDelay["*"]) && (debounceDelay = debounceDelay["*"]), this.$$timeout.cancel(this.$$pendingDebounce);
                var that = this;
                debounceDelay > 0 ? this.$$pendingDebounce = this.$$timeout(function() {
                    that.$commitViewValue()
                }, debounceDelay) : this.$$rootScope.$$phase ? this.$commitViewValue() : this.$$scope.$apply(function() {
                    that.$commitViewValue()
                })
            },
            $overrideModelOptions: function(options) {
                this.$options = this.$options.createChild(options), this.$$setUpdateOnEvents()
            },
            $processModelValue: function() {
                var viewValue = this.$$format();
                this.$viewValue !== viewValue && (this.$$updateEmptyClasses(viewValue), this.$viewValue = this.$$lastCommittedViewValue = viewValue, this.$render(), this.$$runValidators(this.$modelValue, this.$viewValue, noop))
            },
            $$format: function() {
                for (var formatters = this.$formatters, idx = formatters.length, viewValue = this.$modelValue; idx--;) viewValue = formatters[idx](viewValue);
                return viewValue
            },
            $$setModelValue: function(modelValue) {
                this.$modelValue = this.$$rawModelValue = modelValue, this.$$parserValid = void 0, this.$processModelValue()
            },
            $$setUpdateOnEvents: function() {
                this.$$updateEvents && this.$$element.off(this.$$updateEvents, this.$$updateEventHandler), this.$$updateEvents = this.$options.getOption("updateOn"), this.$$updateEvents && this.$$element.on(this.$$updateEvents, this.$$updateEventHandler)
            },
            $$updateEventHandler: function(ev) {
                this.$$debounceViewValueCommit(ev && ev.type)
            }
        }, addSetValidityMethod({
            clazz: NgModelController,
            set: function(object, property) {
                object[property] = !0
            },
            unset: function(object, property) {
                delete object[property]
            }
        });
        var defaultModelOptions, ngModelDirective = ["$rootScope", function($rootScope) {
                return {
                    restrict: "A",
                    require: ["ngModel", "^?form", "^?ngModelOptions"],
                    controller: NgModelController,
                    priority: 1,
                    compile: function(element) {
                        return element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS), {
                            pre: function(scope, element, attr, ctrls) {
                                var modelCtrl = ctrls[0],
                                    formCtrl = ctrls[1] || modelCtrl.$$parentForm,
                                    optionsCtrl = ctrls[2];
                                optionsCtrl && (modelCtrl.$options = optionsCtrl.$options), modelCtrl.$$initGetterSetters(), formCtrl.$addControl(modelCtrl), attr.$observe("name", function(newValue) {
                                    modelCtrl.$name !== newValue && modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue)
                                }), scope.$on("$destroy", function() {
                                    modelCtrl.$$parentForm.$removeControl(modelCtrl)
                                })
                            },
                            post: function(scope, element, attr, ctrls) {
                                function setTouched() {
                                    modelCtrl.$setTouched()
                                }
                                var modelCtrl = ctrls[0];
                                modelCtrl.$$setUpdateOnEvents(), element.on("blur", function() {
                                    modelCtrl.$touched || ($rootScope.$$phase ? scope.$evalAsync(setTouched) : scope.$apply(setTouched))
                                })
                            }
                        }
                    }
                }
            }],
            DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;
        ModelOptions.prototype = {
            getOption: function(name) {
                return this.$$options[name]
            },
            createChild: function(options) {
                var inheritAll = !1;
                return options = extend({}, options), forEach(options, function(option, key) {
                    "$inherit" === option ? "*" === key ? inheritAll = !0 : (options[key] = this.$$options[key], "updateOn" === key && (options.updateOnDefault = this.$$options.updateOnDefault)) : "updateOn" === key && (options.updateOnDefault = !1, options[key] = trim(option.replace(DEFAULT_REGEXP, function() {
                        return options.updateOnDefault = !0, " "
                    })))
                }, this), inheritAll && (delete options["*"], defaults(options, this.$$options)), defaults(options, defaultModelOptions.$$options), new ModelOptions(options)
            }
        }, defaultModelOptions = new ModelOptions({
            updateOn: "",
            updateOnDefault: !0,
            debounce: 0,
            getterSetter: !1,
            allowInvalid: !1,
            timezone: null
        });
        var ngModelOptionsDirective = function() {
                function NgModelOptionsController($attrs, $scope) {
                    this.$$attrs = $attrs, this.$$scope = $scope
                }
                return NgModelOptionsController.$inject = ["$attrs", "$scope"], NgModelOptionsController.prototype = {
                    $onInit: function() {
                        var parentOptions = this.parentCtrl ? this.parentCtrl.$options : defaultModelOptions,
                            modelOptionsDefinition = this.$$scope.$eval(this.$$attrs.ngModelOptions);
                        this.$options = parentOptions.createChild(modelOptionsDefinition)
                    }
                }, {
                    restrict: "A",
                    priority: 10,
                    require: {
                        parentCtrl: "?^^ngModelOptions"
                    },
                    bindToController: !0,
                    controller: NgModelOptionsController
                }
            },
            ngNonBindableDirective = ngDirective({
                terminal: !0,
                priority: 1e3
            }),
            ngOptionsMinErr = minErr("ngOptions"),
            NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/,
            ngOptionsDirective = ["$compile", "$document", "$parse", function($compile, $document, $parse) {
                function parseOptionsExpression(optionsExp, selectElement, scope) {
                    function Option(selectValue, viewValue, label, group, disabled) {
                        this.selectValue = selectValue, this.viewValue = viewValue, this.label = label, this.group = group, this.disabled = disabled
                    }

                    function getOptionValuesKeys(optionValues) {
                        var optionValuesKeys;
                        if (!keyName && isArrayLike(optionValues)) optionValuesKeys = optionValues;
                        else {
                            optionValuesKeys = [];
                            for (var itemKey in optionValues) optionValues.hasOwnProperty(itemKey) && "$" !== itemKey.charAt(0) && optionValuesKeys.push(itemKey)
                        }
                        return optionValuesKeys
                    }
                    var match = optionsExp.match(NG_OPTIONS_REGEXP);
                    if (!match) throw ngOptionsMinErr("iexp", "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
                    var valueName = match[5] || match[7],
                        keyName = match[6],
                        selectAs = / as /.test(match[0]) && match[1],
                        trackBy = match[9],
                        valueFn = $parse(match[2] ? match[1] : valueName),
                        selectAsFn = selectAs && $parse(selectAs),
                        viewValueFn = selectAsFn || valueFn,
                        trackByFn = trackBy && $parse(trackBy),
                        getTrackByValueFn = trackBy ? function(value, locals) {
                            return trackByFn(scope, locals)
                        } : function(value) {
                            return hashKey(value)
                        },
                        getTrackByValue = function(value, key) {
                            return getTrackByValueFn(value, getLocals(value, key))
                        },
                        displayFn = $parse(match[2] || match[1]),
                        groupByFn = $parse(match[3] || ""),
                        disableWhenFn = $parse(match[4] || ""),
                        valuesFn = $parse(match[8]),
                        locals = {},
                        getLocals = keyName ? function(value, key) {
                            return locals[keyName] = key, locals[valueName] = value, locals
                        } : function(value) {
                            return locals[valueName] = value, locals
                        };
                    return {
                        trackBy: trackBy,
                        getTrackByValue: getTrackByValue,
                        getWatchables: $parse(valuesFn, function(optionValues) {
                            var watchedArray = [];
                            optionValues = optionValues || [];
                            for (var optionValuesKeys = getOptionValuesKeys(optionValues), optionValuesLength = optionValuesKeys.length, index = 0; index < optionValuesLength; index++) {
                                var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index],
                                    value = optionValues[key],
                                    locals = getLocals(value, key),
                                    selectValue = getTrackByValueFn(value, locals);
                                if (watchedArray.push(selectValue), match[2] || match[1]) {
                                    var label = displayFn(scope, locals);
                                    watchedArray.push(label)
                                }
                                if (match[4]) {
                                    var disableWhen = disableWhenFn(scope, locals);
                                    watchedArray.push(disableWhen)
                                }
                            }
                            return watchedArray
                        }),
                        getOptions: function() {
                            for (var optionItems = [], selectValueMap = {}, optionValues = valuesFn(scope) || [], optionValuesKeys = getOptionValuesKeys(optionValues), optionValuesLength = optionValuesKeys.length, index = 0; index < optionValuesLength; index++) {
                                var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index],
                                    value = optionValues[key],
                                    locals = getLocals(value, key),
                                    viewValue = viewValueFn(scope, locals),
                                    selectValue = getTrackByValueFn(viewValue, locals),
                                    label = displayFn(scope, locals),
                                    group = groupByFn(scope, locals),
                                    disabled = disableWhenFn(scope, locals),
                                    optionItem = new Option(selectValue, viewValue, label, group, disabled);
                                optionItems.push(optionItem), selectValueMap[selectValue] = optionItem
                            }
                            return {
                                items: optionItems,
                                selectValueMap: selectValueMap,
                                getOptionFromViewValue: function(value) {
                                    return selectValueMap[getTrackByValue(value)]
                                },
                                getViewValueFromOption: function(option) {
                                    return trackBy ? copy(option.viewValue) : option.viewValue
                                }
                            }
                        }
                    }
                }

                function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
                    function addOptionElement(option, parent) {
                        var optionElement = optionTemplate.cloneNode(!1);
                        parent.appendChild(optionElement), updateOptionElement(option, optionElement)
                    }

                    function getAndUpdateSelectedOption(viewValue) {
                        var option = options.getOptionFromViewValue(viewValue),
                            element = option && option.element;
                        return element && !element.selected && (element.selected = !0), option
                    }

                    function updateOptionElement(option, element) {
                        option.element = element, element.disabled = option.disabled, option.label !== element.label && (element.label = option.label, element.textContent = option.label), element.value = option.selectValue
                    }

                    function updateOptions() {
                        var previousValue = options && selectCtrl.readValue();
                        if (options)
                            for (var i = options.items.length - 1; i >= 0; i--) {
                                var option = options.items[i];
                                jqLiteRemove(isDefined(option.group) ? option.element.parentNode : option.element)
                            }
                        options = ngOptions.getOptions();
                        var groupElementMap = {};
                        if (options.items.forEach(function(option) {
                                var groupElement;
                                isDefined(option.group) ? (groupElement = groupElementMap[option.group], groupElement || (groupElement = optGroupTemplate.cloneNode(!1), listFragment.appendChild(groupElement), groupElement.label = null === option.group ? "null" : option.group, groupElementMap[option.group] = groupElement), addOptionElement(option, groupElement)) : addOptionElement(option, listFragment)
                            }), selectElement[0].appendChild(listFragment), ngModelCtrl.$render(), !ngModelCtrl.$isEmpty(previousValue)) {
                            var nextValue = selectCtrl.readValue(),
                                isNotPrimitive = ngOptions.trackBy || multiple;
                            (isNotPrimitive ? equals(previousValue, nextValue) : previousValue === nextValue) || (ngModelCtrl.$setViewValue(nextValue), ngModelCtrl.$render())
                        }
                    }
                    for (var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, i = 0, children = selectElement.children(), ii = children.length; i < ii; i++)
                        if ("" === children[i].value) {
                            selectCtrl.hasEmptyOption = !0, selectCtrl.emptyOption = children.eq(i);
                            break
                        } selectElement.empty();
                    var providedEmptyOption = !!selectCtrl.emptyOption,
                        unknownOption = jqLite(optionTemplate.cloneNode(!1));
                    unknownOption.val("?");
                    var options, ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope),
                        listFragment = $document[0].createDocumentFragment();
                    selectCtrl.generateUnknownOptionValue = function(val) {
                        return "?"
                    }, multiple ? (selectCtrl.writeValue = function(values) {
                        if (options) {
                            var selectedOptions = values && values.map(getAndUpdateSelectedOption) || [];
                            options.items.forEach(function(option) {
                                option.element.selected && !includes(selectedOptions, option) && (option.element.selected = !1)
                            })
                        }
                    }, selectCtrl.readValue = function() {
                        var selectedValues = selectElement.val() || [],
                            selections = [];
                        return forEach(selectedValues, function(value) {
                            var option = options.selectValueMap[value];
                            option && !option.disabled && selections.push(options.getViewValueFromOption(option))
                        }), selections
                    }, ngOptions.trackBy && scope.$watchCollection(function() {
                        if (isArray(ngModelCtrl.$viewValue)) return ngModelCtrl.$viewValue.map(function(value) {
                            return ngOptions.getTrackByValue(value)
                        })
                    }, function() {
                        ngModelCtrl.$render()
                    })) : (selectCtrl.writeValue = function(value) {
                        if (options) {
                            var selectedOption = selectElement[0].options[selectElement[0].selectedIndex],
                                option = options.getOptionFromViewValue(value);
                            selectedOption && selectedOption.removeAttribute("selected"), option ? (selectElement[0].value !== option.selectValue && (selectCtrl.removeUnknownOption(), selectElement[0].value = option.selectValue, option.element.selected = !0), option.element.setAttribute("selected", "selected")) : selectCtrl.selectUnknownOrEmptyOption(value)
                        }
                    }, selectCtrl.readValue = function() {
                        var selectedOption = options.selectValueMap[selectElement.val()];
                        return selectedOption && !selectedOption.disabled ? (selectCtrl.unselectEmptyOption(), selectCtrl.removeUnknownOption(), options.getViewValueFromOption(selectedOption)) : null
                    }, ngOptions.trackBy && scope.$watch(function() {
                        return ngOptions.getTrackByValue(ngModelCtrl.$viewValue)
                    }, function() {
                        ngModelCtrl.$render()
                    })), providedEmptyOption && ($compile(selectCtrl.emptyOption)(scope), selectElement.prepend(selectCtrl.emptyOption), selectCtrl.emptyOption[0].nodeType === NODE_TYPE_COMMENT ? (selectCtrl.hasEmptyOption = !1, selectCtrl.registerOption = function(optionScope, optionEl) {
                        "" === optionEl.val() && (selectCtrl.hasEmptyOption = !0, selectCtrl.emptyOption = optionEl, selectCtrl.emptyOption.removeClass("ng-scope"), ngModelCtrl.$render(), optionEl.on("$destroy", function() {
                            var needsRerender = selectCtrl.$isEmptyOptionSelected();
                            selectCtrl.hasEmptyOption = !1, selectCtrl.emptyOption = void 0, needsRerender && ngModelCtrl.$render()
                        }))
                    }) : selectCtrl.emptyOption.removeClass("ng-scope")), scope.$watchCollection(ngOptions.getWatchables, updateOptions)
                }
                var optionTemplate = window.document.createElement("option"),
                    optGroupTemplate = window.document.createElement("optgroup");
                return {
                    restrict: "A",
                    terminal: !0,
                    require: ["select", "ngModel"],
                    link: {
                        pre: function(scope, selectElement, attr, ctrls) {
                            ctrls[0].registerOption = noop
                        },
                        post: ngOptionsPostLink
                    }
                }
            }],
            ngPluralizeDirective = ["$locale", "$interpolate", "$log", function($locale, $interpolate, $log) {
                var BRACE = /{}/g,
                    IS_WHEN = /^when(Minus)?(.+)$/;
                return {
                    link: function(scope, element, attr) {
                        function updateElementText(newText) {
                            element.text(newText || "")
                        }
                        var lastCount, numberExp = attr.count,
                            whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                            offset = attr.offset || 0,
                            whens = scope.$eval(whenExp) || {},
                            whensExpFns = {},
                            startSymbol = $interpolate.startSymbol(),
                            endSymbol = $interpolate.endSymbol(),
                            braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol,
                            watchRemover = angular.noop;
                        forEach(attr, function(expression, attributeName) {
                            var tmpMatch = IS_WHEN.exec(attributeName);
                            if (tmpMatch) {
                                var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                                whens[whenKey] = element.attr(attr.$attr[attributeName])
                            }
                        }), forEach(whens, function(expression, key) {
                            whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement))
                        }), scope.$watch(numberExp, function(newVal) {
                            var count = parseFloat(newVal),
                                countIsNaN = isNumberNaN(count);
                            if (countIsNaN || count in whens || (count = $locale.pluralCat(count - offset)), !(count === lastCount || countIsNaN && isNumberNaN(lastCount))) {
                                watchRemover();
                                var whenExpFn = whensExpFns[count];
                                isUndefined(whenExpFn) ? (null != newVal && $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp), watchRemover = noop, updateElementText()) : watchRemover = scope.$watch(whenExpFn, updateElementText), lastCount = count
                            }
                        })
                    }
                }
            }],
            ngRefMinErr = minErr("ngRef"),
            ngRefDirective = ["$parse", function($parse) {
                return {
                    priority: -1,
                    restrict: "A",
                    compile: function(tElement, tAttrs) {
                        var controllerName = directiveNormalize(nodeName_(tElement)),
                            getter = $parse(tAttrs.ngRef),
                            setter = getter.assign || function() {
                                throw ngRefMinErr("nonassign", 'Expression in ngRef="{0}" is non-assignable!', tAttrs.ngRef)
                            };
                        return function(scope, element, attrs) {
                            var refValue;
                            if (attrs.hasOwnProperty("ngRefRead")) {
                                if ("$element" === attrs.ngRefRead) refValue = element;
                                else if (refValue = element.data("$" + attrs.ngRefRead + "Controller"), !refValue) throw ngRefMinErr("noctrl", 'The controller for ngRefRead="{0}" could not be found on ngRef="{1}"', attrs.ngRefRead, tAttrs.ngRef)
                            } else refValue = element.data("$" + controllerName + "Controller");
                            refValue = refValue || element, setter(scope, refValue), element.on("$destroy", function() {
                                getter(scope) === refValue && setter(scope, null)
                            })
                        }
                    }
                }
            }],
            ngRepeatDirective = ["$parse", "$animate", "$compile", function($parse, $animate, $compile) {
                var NG_REMOVED = "$$NG_REMOVED",
                    ngRepeatMinErr = minErr("ngRepeat"),
                    updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
                        scope[valueIdentifier] = value, keyIdentifier && (scope[keyIdentifier] = key), scope.$index = index, scope.$first = 0 === index, scope.$last = index === arrayLength - 1, scope.$middle = !(scope.$first || scope.$last), scope.$odd = !(scope.$even = 0 === (1 & index))
                    },
                    getBlockStart = function(block) {
                        return block.clone[0]
                    },
                    getBlockEnd = function(block) {
                        return block.clone[block.clone.length - 1]
                    },
                    trackByIdArrayFn = function($scope, key, value) {
                        return hashKey(value)
                    },
                    trackByIdObjFn = function($scope, key) {
                        return key
                    };
                return {
                    restrict: "A",
                    multiElement: !0,
                    transclude: "element",
                    priority: 1e3,
                    terminal: !0,
                    $$tlb: !0,
                    compile: function($element, $attr) {
                        var expression = $attr.ngRepeat,
                            ngRepeatEndComment = $compile.$$createComment("end ngRepeat", expression),
                            match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                        if (!match) throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                        var lhs = match[1],
                            rhs = match[2],
                            aliasAs = match[3],
                            trackByExp = match[4];
                        if (match = lhs.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/), !match) throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                        var valueIdentifier = match[3] || match[1],
                            keyIdentifier = match[2];
                        if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                        var trackByIdExpFn;
                        if (trackByExp) {
                            var hashFnLocals = {
                                    $id: hashKey
                                },
                                trackByExpGetter = $parse(trackByExp);
                            trackByIdExpFn = function($scope, key, value, index) {
                                return keyIdentifier && (hashFnLocals[keyIdentifier] = key), hashFnLocals[valueIdentifier] = value, hashFnLocals.$index = index, trackByExpGetter($scope, hashFnLocals)
                            }
                        }
                        return function($scope, $element, $attr, ctrl, $transclude) {
                            var lastBlockMap = createMap();
                            $scope.$watchCollection(rhs, function(collection) {
                                var index, length, nextNode, collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove, previousNode = $element[0],
                                    nextBlockMap = createMap();
                                if (aliasAs && ($scope[aliasAs] = collection), isArrayLike(collection)) collectionKeys = collection, trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                                else {
                                    trackByIdFn = trackByIdExpFn || trackByIdObjFn, collectionKeys = [];
                                    for (var itemKey in collection) hasOwnProperty.call(collection, itemKey) && "$" !== itemKey.charAt(0) && collectionKeys.push(itemKey)
                                }
                                for (collectionLength = collectionKeys.length, nextBlockOrder = new Array(collectionLength), index = 0; index < collectionLength; index++)
                                    if (key = collection === collectionKeys ? index : collectionKeys[index], value = collection[key], trackById = trackByIdFn($scope, key, value, index), lastBlockMap[trackById]) block = lastBlockMap[trackById], delete lastBlockMap[trackById], nextBlockMap[trackById] = block, nextBlockOrder[index] = block;
                                    else {
                                        if (nextBlockMap[trackById]) throw forEach(nextBlockOrder, function(block) {
                                            block && block.scope && (lastBlockMap[block.id] = block)
                                        }), ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                                        nextBlockOrder[index] = {
                                            id: trackById,
                                            scope: void 0,
                                            clone: void 0
                                        }, nextBlockMap[trackById] = !0
                                    } hashFnLocals && (hashFnLocals[valueIdentifier] = void 0);
                                for (var blockKey in lastBlockMap) {
                                    if (block = lastBlockMap[blockKey], elementsToRemove = getBlockNodes(block.clone), $animate.leave(elementsToRemove), elementsToRemove[0].parentNode)
                                        for (index = 0, length = elementsToRemove.length; index < length; index++) elementsToRemove[index][NG_REMOVED] = !0;
                                    block.scope.$destroy()
                                }
                                for (index = 0; index < collectionLength; index++)
                                    if (key = collection === collectionKeys ? index : collectionKeys[index], value = collection[key], block = nextBlockOrder[index], block.scope) {
                                        nextNode = previousNode;
                                        do nextNode = nextNode.nextSibling; while (nextNode && nextNode[NG_REMOVED]);
                                        getBlockStart(block) !== nextNode && $animate.move(getBlockNodes(block.clone), null, previousNode), previousNode = getBlockEnd(block), updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength)
                                    } else $transclude(function(clone, scope) {
                                        block.scope = scope;
                                        var endNode = ngRepeatEndComment.cloneNode(!1);
                                        clone[clone.length++] = endNode, $animate.enter(clone, null, previousNode), previousNode = endNode, block.clone = clone, nextBlockMap[block.id] = block, updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength)
                                    });
                                lastBlockMap = nextBlockMap
                            })
                        }
                    }
                }
            }],
            NG_HIDE_CLASS = "ng-hide",
            NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate",
            ngShowDirective = ["$animate", function($animate) {
                return {
                    restrict: "A",
                    multiElement: !0,
                    link: function(scope, element, attr) {
                        scope.$watch(attr.ngShow, function(value) {
                            $animate[value ? "removeClass" : "addClass"](element, NG_HIDE_CLASS, {
                                tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                            })
                        })
                    }
                }
            }],
            ngHideDirective = ["$animate", function($animate) {
                return {
                    restrict: "A",
                    multiElement: !0,
                    link: function(scope, element, attr) {
                        scope.$watch(attr.ngHide, function(value) {
                            $animate[value ? "addClass" : "removeClass"](element, NG_HIDE_CLASS, {
                                tempClasses: NG_HIDE_IN_PROGRESS_CLASS
                            })
                        })
                    }
                }
            }],
            ngStyleDirective = ngDirective(function(scope, element, attr) {
                scope.$watchCollection(attr.ngStyle, function(newStyles, oldStyles) {
                    oldStyles && newStyles !== oldStyles && forEach(oldStyles, function(val, style) {
                        element.css(style, "")
                    }), newStyles && element.css(newStyles)
                })
            }),
            ngSwitchDirective = ["$animate", "$compile", function($animate, $compile) {
                return {
                    require: "ngSwitch",
                    controller: ["$scope", function() {
                        this.cases = {}
                    }],
                    link: function(scope, element, attr, ngSwitchController) {
                        var watchExpr = attr.ngSwitch || attr.on,
                            selectedTranscludes = [],
                            selectedElements = [],
                            previousLeaveAnimations = [],
                            selectedScopes = [],
                            spliceFactory = function(array, index) {
                                return function(response) {
                                    response !== !1 && array.splice(index, 1)
                                }
                            };
                        scope.$watch(watchExpr, function(value) {
                            for (var i, ii; previousLeaveAnimations.length;) $animate.cancel(previousLeaveAnimations.pop());
                            for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                                var selected = getBlockNodes(selectedElements[i].clone);
                                selectedScopes[i].$destroy();
                                var runner = previousLeaveAnimations[i] = $animate.leave(selected);
                                runner.done(spliceFactory(previousLeaveAnimations, i))
                            }
                            selectedElements.length = 0, selectedScopes.length = 0, (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) && forEach(selectedTranscludes, function(selectedTransclude) {
                                selectedTransclude.transclude(function(caseElement, selectedScope) {
                                    selectedScopes.push(selectedScope);
                                    var anchor = selectedTransclude.element;
                                    caseElement[caseElement.length++] = $compile.$$createComment("end ngSwitchWhen");
                                    var block = {
                                        clone: caseElement
                                    };
                                    selectedElements.push(block), $animate.enter(caseElement, anchor.parent(), anchor)
                                })
                            })
                        })
                    }
                }
            }],
            ngSwitchWhenDirective = ngDirective({
                transclude: "element",
                priority: 1200,
                require: "^ngSwitch",
                multiElement: !0,
                link: function(scope, element, attrs, ctrl, $transclude) {
                    var cases = attrs.ngSwitchWhen.split(attrs.ngSwitchWhenSeparator).sort().filter(function(element, index, array) {
                        return array[index - 1] !== element
                    });
                    forEach(cases, function(whenCase) {
                        ctrl.cases["!" + whenCase] = ctrl.cases["!" + whenCase] || [], ctrl.cases["!" + whenCase].push({
                            transclude: $transclude,
                            element: element
                        })
                    })
                }
            }),
            ngSwitchDefaultDirective = ngDirective({
                transclude: "element",
                priority: 1200,
                require: "^ngSwitch",
                multiElement: !0,
                link: function(scope, element, attr, ctrl, $transclude) {
                    ctrl.cases["?"] = ctrl.cases["?"] || [], ctrl.cases["?"].push({
                        transclude: $transclude,
                        element: element
                    })
                }
            }),
            ngTranscludeMinErr = minErr("ngTransclude"),
            ngTranscludeDirective = ["$compile", function($compile) {
                return {
                    restrict: "EAC",
                    compile: function(tElement) {
                        var fallbackLinkFn = $compile(tElement.contents());
                        return tElement.empty(),
                            function($scope, $element, $attrs, controller, $transclude) {
                                function ngTranscludeCloneAttachFn(clone, transcludedScope) {
                                    clone.length && notWhitespace(clone) ? $element.append(clone) : (useFallbackContent(), transcludedScope.$destroy())
                                }

                                function useFallbackContent() {
                                    fallbackLinkFn($scope, function(clone) {
                                        $element.append(clone)
                                    })
                                }

                                function notWhitespace(nodes) {
                                    for (var i = 0, ii = nodes.length; i < ii; i++) {
                                        var node = nodes[i];
                                        if (node.nodeType !== NODE_TYPE_TEXT || node.nodeValue.trim()) return !0
                                    }
                                }
                                if (!$transclude) throw ngTranscludeMinErr("orphan", "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}", startingTag($element));
                                $attrs.ngTransclude === $attrs.$attr.ngTransclude && ($attrs.ngTransclude = "");
                                var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
                                $transclude(ngTranscludeCloneAttachFn, null, slotName), slotName && !$transclude.isSlotFilled(slotName) && useFallbackContent()
                            }
                    }
                }
            }],
            scriptDirective = ["$templateCache", function($templateCache) {
                return {
                    restrict: "E",
                    terminal: !0,
                    compile: function(element, attr) {
                        if ("text/ng-template" === attr.type) {
                            var templateUrl = attr.id,
                                text = element[0].text;
                            $templateCache.put(templateUrl, text)
                        }
                    }
                }
            }],
            noopNgModelController = {
                $setViewValue: noop,
                $render: noop
            },
            SelectController = ["$element", "$scope", function($element, $scope) {
                function scheduleRender() {
                    renderScheduled || (renderScheduled = !0, $scope.$$postDigest(function() {
                        renderScheduled = !1, self.ngModelCtrl.$render()
                    }))
                }

                function scheduleViewValueUpdate(renderAfter) {
                    updateScheduled || (updateScheduled = !0, $scope.$$postDigest(function() {
                        $scope.$$destroyed || (updateScheduled = !1, self.ngModelCtrl.$setViewValue(self.readValue()), renderAfter && self.ngModelCtrl.$render())
                    }))
                }
                var self = this,
                    optionsMap = new NgMap;
                self.selectValueMap = {}, self.ngModelCtrl = noopNgModelController, self.multiple = !1, self.unknownOption = jqLite(window.document.createElement("option")), self.hasEmptyOption = !1, self.emptyOption = void 0, self.renderUnknownOption = function(val) {
                    var unknownVal = self.generateUnknownOptionValue(val);
                    self.unknownOption.val(unknownVal), $element.prepend(self.unknownOption), setOptionSelectedStatus(self.unknownOption, !0), $element.val(unknownVal)
                }, self.updateUnknownOption = function(val) {
                    var unknownVal = self.generateUnknownOptionValue(val);
                    self.unknownOption.val(unknownVal), setOptionSelectedStatus(self.unknownOption, !0), $element.val(unknownVal)
                }, self.generateUnknownOptionValue = function(val) {
                    return "? " + hashKey(val) + " ?"
                }, self.removeUnknownOption = function() {
                    self.unknownOption.parent() && self.unknownOption.remove()
                }, self.selectEmptyOption = function() {
                    self.emptyOption && ($element.val(""), setOptionSelectedStatus(self.emptyOption, !0))
                }, self.unselectEmptyOption = function() {
                    self.hasEmptyOption && setOptionSelectedStatus(self.emptyOption, !1)
                }, $scope.$on("$destroy", function() {
                    self.renderUnknownOption = noop
                }), self.readValue = function() {
                    var val = $element.val(),
                        realVal = val in self.selectValueMap ? self.selectValueMap[val] : val;
                    return self.hasOption(realVal) ? realVal : null
                }, self.writeValue = function(value) {
                    var currentlySelectedOption = $element[0].options[$element[0].selectedIndex];
                    if (currentlySelectedOption && setOptionSelectedStatus(jqLite(currentlySelectedOption), !1), self.hasOption(value)) {
                        self.removeUnknownOption();
                        var hashedVal = hashKey(value);
                        $element.val(hashedVal in self.selectValueMap ? hashedVal : value);
                        var selectedOption = $element[0].options[$element[0].selectedIndex];
                        setOptionSelectedStatus(jqLite(selectedOption), !0)
                    } else self.selectUnknownOrEmptyOption(value)
                }, self.addOption = function(value, element) {
                    if (element[0].nodeType !== NODE_TYPE_COMMENT) {
                        assertNotHasOwnProperty(value, '"option value"'), "" === value && (self.hasEmptyOption = !0, self.emptyOption = element);
                        var count = optionsMap.get(value) || 0;
                        optionsMap.set(value, count + 1), scheduleRender()
                    }
                }, self.removeOption = function(value) {
                    var count = optionsMap.get(value);
                    count && (1 === count ? (optionsMap.delete(value), "" === value && (self.hasEmptyOption = !1, self.emptyOption = void 0)) : optionsMap.set(value, count - 1))
                }, self.hasOption = function(value) {
                    return !!optionsMap.get(value)
                }, self.$hasEmptyOption = function() {
                    return self.hasEmptyOption
                }, self.$isUnknownOptionSelected = function() {
                    return $element[0].options[0] === self.unknownOption[0]
                }, self.$isEmptyOptionSelected = function() {
                    return self.hasEmptyOption && $element[0].options[$element[0].selectedIndex] === self.emptyOption[0]
                }, self.selectUnknownOrEmptyOption = function(value) {
                    null == value && self.emptyOption ? (self.removeUnknownOption(), self.selectEmptyOption()) : self.unknownOption.parent().length ? self.updateUnknownOption(value) : self.renderUnknownOption(value)
                };
                var renderScheduled = !1,
                    updateScheduled = !1;
                self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
                    if (optionAttrs.$attr.ngValue) {
                        var oldVal, hashedVal;
                        optionAttrs.$observe("value", function(newVal) {
                            var removal, previouslySelected = optionElement.prop("selected");
                            isDefined(hashedVal) && (self.removeOption(oldVal), delete self.selectValueMap[hashedVal], removal = !0), hashedVal = hashKey(newVal), oldVal = newVal, self.selectValueMap[hashedVal] = newVal, self.addOption(newVal, optionElement), optionElement.attr("value", hashedVal), removal && previouslySelected && scheduleViewValueUpdate()
                        })
                    } else interpolateValueFn ? optionAttrs.$observe("value", function(newVal) {
                        self.readValue();
                        var removal, previouslySelected = optionElement.prop("selected");
                        isDefined(oldVal) && (self.removeOption(oldVal), removal = !0), oldVal = newVal, self.addOption(newVal, optionElement), removal && previouslySelected && scheduleViewValueUpdate()
                    }) : interpolateTextFn ? optionScope.$watch(interpolateTextFn, function(newVal, oldVal) {
                        optionAttrs.$set("value", newVal);
                        var previouslySelected = optionElement.prop("selected");
                        oldVal !== newVal && self.removeOption(oldVal), self.addOption(newVal, optionElement), oldVal && previouslySelected && scheduleViewValueUpdate()
                    }) : self.addOption(optionAttrs.value, optionElement);
                    optionAttrs.$observe("disabled", function(newVal) {
                        ("true" === newVal || newVal && optionElement.prop("selected")) && (self.multiple ? scheduleViewValueUpdate(!0) : (self.ngModelCtrl.$setViewValue(null), self.ngModelCtrl.$render()))
                    }), optionElement.on("$destroy", function() {
                        var currentValue = self.readValue(),
                            removeValue = optionAttrs.value;
                        self.removeOption(removeValue), scheduleRender(), (self.multiple && currentValue && currentValue.indexOf(removeValue) !== -1 || currentValue === removeValue) && scheduleViewValueUpdate(!0)
                    })
                }
            }],
            selectDirective = function() {
                function selectPreLink(scope, element, attr, ctrls) {
                    var selectCtrl = ctrls[0],
                        ngModelCtrl = ctrls[1];
                    if (!ngModelCtrl) return void(selectCtrl.registerOption = noop);
                    if (selectCtrl.ngModelCtrl = ngModelCtrl, element.on("change", function() {
                            selectCtrl.removeUnknownOption(), scope.$apply(function() {
                                ngModelCtrl.$setViewValue(selectCtrl.readValue())
                            })
                        }), attr.multiple) {
                        selectCtrl.multiple = !0, selectCtrl.readValue = function() {
                            var array = [];
                            return forEach(element.find("option"), function(option) {
                                if (option.selected && !option.disabled) {
                                    var val = option.value;
                                    array.push(val in selectCtrl.selectValueMap ? selectCtrl.selectValueMap[val] : val)
                                }
                            }), array
                        }, selectCtrl.writeValue = function(value) {
                            forEach(element.find("option"), function(option) {
                                var shouldBeSelected = !!value && (includes(value, option.value) || includes(value, selectCtrl.selectValueMap[option.value])),
                                    currentlySelected = option.selected;
                                shouldBeSelected !== currentlySelected && setOptionSelectedStatus(jqLite(option), shouldBeSelected)
                            })
                        };
                        var lastView, lastViewRef = NaN;
                        scope.$watch(function() {
                            lastViewRef !== ngModelCtrl.$viewValue || equals(lastView, ngModelCtrl.$viewValue) || (lastView = shallowCopy(ngModelCtrl.$viewValue), ngModelCtrl.$render()), lastViewRef = ngModelCtrl.$viewValue
                        }), ngModelCtrl.$isEmpty = function(value) {
                            return !value || 0 === value.length
                        }
                    }
                }

                function selectPostLink(scope, element, attrs, ctrls) {
                    var ngModelCtrl = ctrls[1];
                    if (ngModelCtrl) {
                        var selectCtrl = ctrls[0];
                        ngModelCtrl.$render = function() {
                            selectCtrl.writeValue(ngModelCtrl.$viewValue)
                        }
                    }
                }
                return {
                    restrict: "E",
                    require: ["select", "?ngModel"],
                    controller: SelectController,
                    priority: 1,
                    link: {
                        pre: selectPreLink,
                        post: selectPostLink
                    }
                }
            },
            optionDirective = ["$interpolate", function($interpolate) {
                return {
                    restrict: "E",
                    priority: 100,
                    compile: function(element, attr) {
                        var interpolateValueFn, interpolateTextFn;
                        return isDefined(attr.ngValue) || (isDefined(attr.value) ? interpolateValueFn = $interpolate(attr.value, !0) : (interpolateTextFn = $interpolate(element.text(), !0), interpolateTextFn || attr.$set("value", element.text()))),
                            function(scope, element, attr) {
                                var selectCtrlName = "$selectController",
                                    parent = element.parent(),
                                    selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                                selectCtrl && selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn)
                            }
                    }
                }
            }],
            requiredDirective = ["$parse", function($parse) {
                return {
                    restrict: "A",
                    require: "?ngModel",
                    link: function(scope, elm, attr, ctrl) {
                        if (ctrl) {
                            var value = attr.hasOwnProperty("required") || $parse(attr.ngRequired)(scope);
                            attr.ngRequired || (attr.required = !0), ctrl.$validators.required = function(modelValue, viewValue) {
                                return !value || !ctrl.$isEmpty(viewValue)
                            }, attr.$observe("required", function(newVal) {
                                value !== newVal && (value = newVal, ctrl.$validate())
                            })
                        }
                    }
                }
            }],
            patternDirective = ["$parse", function($parse) {
                return {
                    restrict: "A",
                    require: "?ngModel",
                    compile: function(tElm, tAttr) {
                        var patternExp, parseFn;
                        return tAttr.ngPattern && (patternExp = tAttr.ngPattern, parseFn = "/" === tAttr.ngPattern.charAt(0) && REGEX_STRING_REGEXP.test(tAttr.ngPattern) ? function() {
                                return tAttr.ngPattern
                            } : $parse(tAttr.ngPattern)),
                            function(scope, elm, attr, ctrl) {
                                if (ctrl) {
                                    var attrVal = attr.pattern;
                                    attr.ngPattern ? attrVal = parseFn(scope) : patternExp = attr.pattern;
                                    var regexp = parsePatternAttr(attrVal, patternExp, elm);
                                    attr.$observe("pattern", function(newVal) {
                                        var oldRegexp = regexp;
                                        regexp = parsePatternAttr(newVal, patternExp, elm), (oldRegexp && oldRegexp.toString()) !== (regexp && regexp.toString()) && ctrl.$validate()
                                    }), ctrl.$validators.pattern = function(modelValue, viewValue) {
                                        return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue)
                                    }
                                }
                            }
                    }
                }
            }],
            maxlengthDirective = ["$parse", function($parse) {
                return {
                    restrict: "A",
                    require: "?ngModel",
                    link: function(scope, elm, attr, ctrl) {
                        if (ctrl) {
                            var maxlength = attr.maxlength || $parse(attr.ngMaxlength)(scope),
                                maxlengthParsed = parseLength(maxlength);
                            attr.$observe("maxlength", function(value) {
                                maxlength !== value && (maxlengthParsed = parseLength(value), maxlength = value, ctrl.$validate())
                            }), ctrl.$validators.maxlength = function(modelValue, viewValue) {
                                return maxlengthParsed < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlengthParsed
                            }
                        }
                    }
                }
            }],
            minlengthDirective = ["$parse", function($parse) {
                return {
                    restrict: "A",
                    require: "?ngModel",
                    link: function(scope, elm, attr, ctrl) {
                        if (ctrl) {
                            var minlength = attr.minlength || $parse(attr.ngMinlength)(scope),
                                minlengthParsed = parseLength(minlength) || -1;
                            attr.$observe("minlength", function(value) {
                                minlength !== value && (minlengthParsed = parseLength(value) || -1, minlength = value, ctrl.$validate())
                            }), ctrl.$validators.minlength = function(modelValue, viewValue) {
                                return ctrl.$isEmpty(viewValue) || viewValue.length >= minlengthParsed
                            }
                        }
                    }
                }
            }];
        return window.angular.bootstrap ? void(window.console && console.log("WARNING: Tried to load AngularJS more than once.")) : (bindJQuery(), publishExternalAPI(angular), angular.module("ngLocale", [], ["$provide", function($provide) {
            function getDecimals(n) {
                n += "";
                var i = n.indexOf(".");
                return i == -1 ? 0 : n.length - i - 1
            }

            function getVF(n, opt_precision) {
                var v = opt_precision;
                void 0 === v && (v = Math.min(getDecimals(n), 3));
                var base = Math.pow(10, v),
                    f = (n * base | 0) % base;
                return {
                    v: v,
                    f: f
                }
            }
            var PLURAL_CATEGORY = {
                ZERO: "zero",
                ONE: "one",
                TWO: "two",
                FEW: "few",
                MANY: "many",
                OTHER: "other"
            };
            $provide.value("$locale", {
                DATETIME_FORMATS: {
                    AMPMS: ["AM", "PM"],
                    DAY: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                    ERANAMES: ["Before Christ", "Anno Domini"],
                    ERAS: ["BC", "AD"],
                    FIRSTDAYOFWEEK: 6,
                    MONTH: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                    SHORTDAY: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                    SHORTMONTH: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                    STANDALONEMONTH: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                    WEEKENDRANGE: [5, 6],
                    fullDate: "EEEE, MMMM d, y",
                    longDate: "MMMM d, y",
                    medium: "MMM d, y h:mm:ss a",
                    mediumDate: "MMM d, y",
                    mediumTime: "h:mm:ss a",
                    short: "M/d/yy h:mm a",
                    shortDate: "M/d/yy",
                    shortTime: "h:mm a"
                },
                NUMBER_FORMATS: {
                    CURRENCY_SYM: "$",
                    DECIMAL_SEP: ".",
                    GROUP_SEP: ",",
                    PATTERNS: [{
                        gSize: 3,
                        lgSize: 3,
                        maxFrac: 3,
                        minFrac: 0,
                        minInt: 1,
                        negPre: "-",
                        negSuf: "",
                        posPre: "",
                        posSuf: ""
                    }, {
                        gSize: 3,
                        lgSize: 3,
                        maxFrac: 2,
                        minFrac: 2,
                        minInt: 1,
                        negPre: "-",
                        negSuf: "",
                        posPre: "",
                        posSuf: ""
                    }]
                },
                id: "en-us",
                localeID: "en_US",
                pluralCat: function(n, opt_precision) {
                    var i = 0 | n,
                        vf = getVF(n, opt_precision);
                    return 1 == i && 0 == vf.v ? PLURAL_CATEGORY.ONE : PLURAL_CATEGORY.OTHER
                }
            })
        }]), void jqLite(function() {
            angularInit(window.document, bootstrap)
        }))
    }(window), !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend(window.angular.element("<style>").text('@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}')),
    function(window, angular) {
        "use strict";

        function isValidDottedPath(path) {
            return null != path && "" !== path && "hasOwnProperty" !== path && MEMBER_NAME_REGEX.test("." + path)
        }

        function lookupDottedPath(obj, path) {
            if (!isValidDottedPath(path)) throw $resourceMinErr("badmember", 'Dotted member path "@{0}" is invalid.', path);
            for (var keys = path.split("."), i = 0, ii = keys.length; i < ii && angular.isDefined(obj); i++) {
                var key = keys[i];
                obj = null !== obj ? obj[key] : void 0
            }
            return obj
        }

        function shallowClearAndCopy(src, dst) {
            dst = dst || {}, angular.forEach(dst, function(value, key) {
                delete dst[key]
            });
            for (var key in src) !src.hasOwnProperty(key) || "$" === key.charAt(0) && "$" === key.charAt(1) || (dst[key] = src[key]);
            return dst
        }
        var $resourceMinErr = angular.$$minErr("$resource"),
            MEMBER_NAME_REGEX = /^(\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;
        angular.module("ngResource", ["ng"]).info({
            angularVersion: "1.7.6"
        }).provider("$resource", function() {
            var PROTOCOL_AND_IPV6_REGEX = /^https?:\/\/\[[^\]]*][^/]*/,
                provider = this;
            this.defaults = {
                stripTrailingSlashes: !0,
                cancellable: !1,
                actions: {
                    get: {
                        method: "GET"
                    },
                    save: {
                        method: "POST"
                    },
                    query: {
                        method: "GET",
                        isArray: !0
                    },
                    remove: {
                        method: "DELETE"
                    },
                    delete: {
                        method: "DELETE"
                    }
                }
            }, this.$get = ["$http", "$log", "$q", "$timeout", function($http, $log, $q, $timeout) {
                function Route(template, defaults) {
                    this.template = template, this.defaults = extend({}, provider.defaults, defaults), this.urlParams = {}
                }

                function resourceFactory(url, paramDefaults, actions, options) {
                    function extractParams(data, actionParams) {
                        var ids = {};
                        return actionParams = extend({}, paramDefaults, actionParams), forEach(actionParams, function(value, key) {
                            isFunction(value) && (value = value(data)), ids[key] = value && value.charAt && "@" === value.charAt(0) ? lookupDottedPath(data, value.substr(1)) : value
                        }), ids
                    }

                    function defaultResponseInterceptor(response) {
                        return response.resource
                    }

                    function Resource(value) {
                        shallowClearAndCopy(value || {}, this)
                    }
                    var route = new Route(url, options);
                    return actions = extend({}, provider.defaults.actions, actions), Resource.prototype.toJSON = function() {
                        var data = extend({}, this);
                        return delete data.$promise, delete data.$resolved, delete data.$cancelRequest, data
                    }, forEach(actions, function(action, name) {
                        var hasBody = action.hasBody === !0 || action.hasBody !== !1 && /^(POST|PUT|PATCH)$/i.test(action.method),
                            numericTimeout = action.timeout,
                            cancellable = isDefined(action.cancellable) ? action.cancellable : route.defaults.cancellable;
                        numericTimeout && !isNumber(numericTimeout) && ($log.debug("ngResource:\n  Only numeric values are allowed as `timeout`.\n  Promises are not supported in $resource, because the same value would be used for multiple requests. If you are looking for a way to cancel requests, you should use the `cancellable` option."), delete action.timeout, numericTimeout = null), Resource[name] = function(a1, a2, a3, a4) {
                            function cancelRequest(value) {
                                promise.catch(noop), null !== timeoutDeferred && timeoutDeferred.resolve(value)
                            }
                            var data, onSuccess, onError, params = {};
                            switch (arguments.length) {
                                case 4:
                                    onError = a4, onSuccess = a3;
                                case 3:
                                case 2:
                                    if (!isFunction(a2)) {
                                        params = a1, data = a2, onSuccess = a3;
                                        break
                                    }
                                    if (isFunction(a1)) {
                                        onSuccess = a1, onError = a2;
                                        break
                                    }
                                    onSuccess = a2, onError = a3;
                                case 1:
                                    isFunction(a1) ? onSuccess = a1 : hasBody ? data = a1 : params = a1;
                                    break;
                                case 0:
                                    break;
                                default:
                                    throw $resourceMinErr("badargs", "Expected up to 4 arguments [params, data, success, error], got {0} arguments", arguments.length)
                            }
                            var timeoutDeferred, numericTimeoutPromise, response, isInstanceCall = this instanceof Resource,
                                value = isInstanceCall ? data : action.isArray ? [] : new Resource(data),
                                httpConfig = {},
                                requestInterceptor = action.interceptor && action.interceptor.request || void 0,
                                requestErrorInterceptor = action.interceptor && action.interceptor.requestError || void 0,
                                responseInterceptor = action.interceptor && action.interceptor.response || defaultResponseInterceptor,
                                responseErrorInterceptor = action.interceptor && action.interceptor.responseError || $q.reject,
                                successCallback = onSuccess ? function(val) {
                                    onSuccess(val, response.headers, response.status, response.statusText)
                                } : void 0,
                                errorCallback = onError || void 0;
                            forEach(action, function(value, key) {
                                switch (key) {
                                    default:
                                        httpConfig[key] = copy(value);
                                        break;
                                    case "params":
                                    case "isArray":
                                    case "interceptor":
                                    case "cancellable":
                                }
                            }), !isInstanceCall && cancellable && (timeoutDeferred = $q.defer(), httpConfig.timeout = timeoutDeferred.promise, numericTimeout && (numericTimeoutPromise = $timeout(timeoutDeferred.resolve, numericTimeout))), hasBody && (httpConfig.data = data), route.setUrlParams(httpConfig, extend({}, extractParams(data, action.params || {}), params), action.url);
                            var promise = $q.resolve(httpConfig).then(requestInterceptor).catch(requestErrorInterceptor).then($http);
                            return promise = promise.then(function(resp) {
                                var data = resp.data;
                                if (data) {
                                    if (isArray(data) !== !!action.isArray) throw $resourceMinErr("badcfg", "Error in resource configuration for action `{0}`. Expected response to contain an {1} but got an {2} (Request: {3} {4})", name, action.isArray ? "array" : "object", isArray(data) ? "array" : "object", httpConfig.method, httpConfig.url);
                                    if (action.isArray) value.length = 0, forEach(data, function(item) {
                                        "object" === _typeof2(item) ? value.push(new Resource(item)) : value.push(item)
                                    });
                                    else {
                                        var promise = value.$promise;
                                        shallowClearAndCopy(data, value), value.$promise = promise
                                    }
                                }
                                return resp.resource = value, response = resp, responseInterceptor(resp)
                            }, function(rejectionOrResponse) {
                                return rejectionOrResponse.resource = value, response = rejectionOrResponse, responseErrorInterceptor(rejectionOrResponse)
                            }), promise = promise.finally(function() {
                                value.$resolved = !0, !isInstanceCall && cancellable && (value.$cancelRequest = noop, $timeout.cancel(numericTimeoutPromise), timeoutDeferred = numericTimeoutPromise = httpConfig.timeout = null)
                            }), promise.then(successCallback, errorCallback), isInstanceCall ? promise : (value.$promise = promise, value.$resolved = !1, cancellable && (value.$cancelRequest = cancelRequest), value)
                        }, Resource.prototype["$" + name] = function(params, success, error) {
                            isFunction(params) && (error = success, success = params, params = {});
                            var result = Resource[name].call(this, params, this, success, error);
                            return result.$promise || result
                        }
                    }), Resource
                }
                var noop = angular.noop,
                    forEach = angular.forEach,
                    extend = angular.extend,
                    copy = angular.copy,
                    isArray = angular.isArray,
                    isDefined = angular.isDefined,
                    isFunction = angular.isFunction,
                    isNumber = angular.isNumber,
                    encodeUriQuery = angular.$$encodeUriQuery,
                    encodeUriSegment = angular.$$encodeUriSegment;
                return Route.prototype = {
                    setUrlParams: function(config, params, actionUrl) {
                        var val, encodedVal, self = this,
                            url = actionUrl || self.template,
                            protocolAndIpv6 = "",
                            urlParams = self.urlParams = Object.create(null);
                        forEach(url.split(/\W/), function(param) {
                            if ("hasOwnProperty" === param) throw $resourceMinErr("badname", "hasOwnProperty is not a valid parameter name.");
                            !new RegExp("^\\d+$").test(param) && param && new RegExp("(^|[^\\\\]):" + param + "(\\W|$)").test(url) && (urlParams[param] = {
                                isQueryParamValue: new RegExp("\\?.*=:" + param + "(?:\\W|$)").test(url)
                            })
                        }), url = url.replace(/\\:/g, ":"), url = url.replace(PROTOCOL_AND_IPV6_REGEX, function(match) {
                            return protocolAndIpv6 = match, ""
                        }), params = params || {}, forEach(self.urlParams, function(paramInfo, urlParam) {
                            val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam], isDefined(val) && null !== val ? (encodedVal = paramInfo.isQueryParamValue ? encodeUriQuery(val, !0) : encodeUriSegment(val), url = url.replace(new RegExp(":" + urlParam + "(\\W|$)", "g"), function(match, p1) {
                                return encodedVal + p1
                            })) : url = url.replace(new RegExp("(/?):" + urlParam + "(\\W|$)", "g"), function(match, leadingSlashes, tail) {
                                return "/" === tail.charAt(0) ? tail : leadingSlashes + tail
                            })
                        }), self.defaults.stripTrailingSlashes && (url = url.replace(/\/+$/, "") || "/"), url = url.replace(/\/\.(?=\w+($|\?))/, "."), config.url = protocolAndIpv6 + url.replace(/\/(\\|%5C)\./, "/."), forEach(params, function(value, key) {
                            self.urlParams[key] || (config.params = config.params || {}, config.params[key] = value)
                        })
                    }
                }, resourceFactory
            }]
        })
    }(window, window.angular),
    function(window, angular) {
        "use strict";

        function $$CookieWriter($document, $log, $browser) {
            function buildCookieString(name, value, options) {
                var path, expires;
                options = options || {}, expires = options.expires, path = angular.isDefined(options.path) ? options.path : cookiePath, angular.isUndefined(value) && (expires = "Thu, 01 Jan 1970 00:00:00 GMT", value = ""), angular.isString(expires) && (expires = new Date(expires));
                var str = encodeURIComponent(name) + "=" + encodeURIComponent(value);
                str += path ? ";path=" + path : "", str += options.domain ? ";domain=" + options.domain : "", str += expires ? ";expires=" + expires.toUTCString() : "", str += options.secure ? ";secure" : "", str += options.samesite ? ";samesite=" + options.samesite : "";
                var cookieLength = str.length + 1;
                return cookieLength > 4096 && $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!"), str
            }
            var cookiePath = $browser.baseHref(),
                rawDocument = $document[0];
            return function(name, value, options) {
                rawDocument.cookie = buildCookieString(name, value, options)
            }
        }
        angular.module("ngCookies", ["ng"]).info({
            angularVersion: "1.7.6"
        }).provider("$cookies", [function() {
            function calcOptions(options) {
                return options ? angular.extend({}, defaults, options) : defaults
            }
            var defaults = this.defaults = {};
            this.$get = ["$$cookieReader", "$$cookieWriter", function($$cookieReader, $$cookieWriter) {
                return {
                    get: function(key) {
                        return $$cookieReader()[key]
                    },
                    getObject: function(key) {
                        var value = this.get(key);
                        return value ? angular.fromJson(value) : value
                    },
                    getAll: function() {
                        return $$cookieReader()
                    },
                    put: function(key, value, options) {
                        $$cookieWriter(key, value, calcOptions(options))
                    },
                    putObject: function(key, value, options) {
                        this.put(key, angular.toJson(value), options)
                    },
                    remove: function(key, options) {
                        $$cookieWriter(key, void 0, calcOptions(options))
                    }
                }
            }]
        }]), $$CookieWriter.$inject = ["$document", "$log", "$browser"], angular.module("ngCookies").provider("$$cookieWriter", function() {
            this.$get = $$CookieWriter;
        })
    }(window, window.angular), "undefined" != typeof module && "undefined" != typeof exports && module.exports === exports && (module.exports = "ui.router"),
    function(window, angular, undefined) {
        "use strict";

        function inherit(parent, extra) {
            return extend(new(extend(function() {}, {
                prototype: parent
            })), extra)
        }

        function merge(dst) {
            return forEach(arguments, function(obj) {
                obj !== dst && forEach(obj, function(value, key) {
                    dst.hasOwnProperty(key) || (dst[key] = value)
                })
            }), dst
        }

        function ancestors(first, second) {
            var path = [];
            for (var n in first.path) {
                if (first.path[n] !== second.path[n]) break;
                path.push(first.path[n])
            }
            return path
        }

        function objectKeys(object) {
            if (Object.keys) return Object.keys(object);
            var result = [];
            return forEach(object, function(val, key) {
                result.push(key)
            }), result
        }

        function indexOf(array, value) {
            if (Array.prototype.indexOf) return array.indexOf(value, Number(arguments[2]) || 0);
            var len = array.length >>> 0,
                from = Number(arguments[2]) || 0;
            for (from = from < 0 ? Math.ceil(from) : Math.floor(from), from < 0 && (from += len); from < len; from++)
                if (from in array && array[from] === value) return from;
            return -1
        }

        function inheritParams(currentParams, newParams, $current, $to) {
            var parentParams, parents = ancestors($current, $to),
                inherited = {},
                inheritList = [];
            for (var i in parents)
                if (parents[i] && parents[i].params && (parentParams = objectKeys(parents[i].params), parentParams.length))
                    for (var j in parentParams) indexOf(inheritList, parentParams[j]) >= 0 || (inheritList.push(parentParams[j]), inherited[parentParams[j]] = currentParams[parentParams[j]]);
            return extend({}, inherited, newParams)
        }

        function equalForKeys(a, b, keys) {
            if (!keys) {
                keys = [];
                for (var n in a) keys.push(n)
            }
            for (var i = 0; i < keys.length; i++) {
                var k = keys[i];
                if (a[k] != b[k]) return !1
            }
            return !0
        }

        function filterByKeys(keys, values) {
            var filtered = {};
            return forEach(keys, function(name) {
                filtered[name] = values[name]
            }), filtered
        }

        function pick(obj) {
            var copy = {},
                keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
            return forEach(keys, function(key) {
                key in obj && (copy[key] = obj[key])
            }), copy
        }

        function omit(obj) {
            var copy = {},
                keys = Array.prototype.concat.apply(Array.prototype, Array.prototype.slice.call(arguments, 1));
            for (var key in obj) indexOf(keys, key) == -1 && (copy[key] = obj[key]);
            return copy
        }

        function filter(collection, callback) {
            var array = isArray(collection),
                result = array ? [] : {};
            return forEach(collection, function(val, i) {
                callback(val, i) && (result[array ? result.length : i] = val)
            }), result
        }

        function map(collection, callback) {
            var result = isArray(collection) ? [] : {};
            return forEach(collection, function(val, i) {
                result[i] = callback(val, i)
            }), result
        }

        function silenceUncaughtInPromise(promise) {
            return promise.then(undefined, function() {}) && promise
        }

        function $Resolve($q, $injector) {
            var VISIT_IN_PROGRESS = 1,
                VISIT_DONE = 2,
                NOTHING = {},
                NO_DEPENDENCIES = [],
                NO_LOCALS = NOTHING,
                NO_PARENT = extend($q.when(NOTHING), {
                    $$promises: NOTHING,
                    $$values: NOTHING
                });
            this.study = function(invocables) {
                function visit(value, key) {
                    if (visited[key] !== VISIT_DONE) {
                        if (cycle.push(key), visited[key] === VISIT_IN_PROGRESS) throw cycle.splice(0, indexOf(cycle, key)), new Error("Cyclic dependency: " + cycle.join(" -> "));
                        if (visited[key] = VISIT_IN_PROGRESS, isString(value)) plan.push(key, [function() {
                            return $injector.get(value)
                        }], NO_DEPENDENCIES);
                        else {
                            var params = $injector.annotate(value);
                            forEach(params, function(param) {
                                param !== key && invocables.hasOwnProperty(param) && visit(invocables[param], param)
                            }), plan.push(key, value, params)
                        }
                        cycle.pop(), visited[key] = VISIT_DONE
                    }
                }

                function isResolve(value) {
                    return isObject(value) && value.then && value.$$promises
                }
                if (!isObject(invocables)) throw new Error("'invocables' must be an object");
                var invocableKeys = objectKeys(invocables || {}),
                    plan = [],
                    cycle = [],
                    visited = {};
                return forEach(invocables, visit), invocables = cycle = visited = null,
                    function(locals, parent, self) {
                        function done() {
                            --wait || (merged || merge(values, parent.$$values), result.$$values = values, result.$$promises = result.$$promises || !0, delete result.$$inheritedValues, resolution.resolve(values))
                        }

                        function fail(reason) {
                            result.$$failure = reason, resolution.reject(reason)
                        }

                        function invoke(key, invocable, params) {
                            function onfailure(reason) {
                                invocation.reject(reason), fail(reason)
                            }

                            function proceed() {
                                if (!isDefined(result.$$failure)) try {
                                    invocation.resolve($injector.invoke(invocable, self, values)), invocation.promise.then(function(result) {
                                        values[key] = result, done()
                                    }, onfailure)
                                } catch (e) {
                                    onfailure(e)
                                }
                            }
                            var invocation = $q.defer(),
                                waitParams = 0;
                            forEach(params, function(dep) {
                                promises.hasOwnProperty(dep) && !locals.hasOwnProperty(dep) && (waitParams++, promises[dep].then(function(result) {
                                    values[dep] = result, --waitParams || proceed()
                                }, onfailure))
                            }), waitParams || proceed(), promises[key] = silenceUncaughtInPromise(invocation.promise)
                        }
                        if (isResolve(locals) && self === undefined && (self = parent, parent = locals, locals = null), locals) {
                            if (!isObject(locals)) throw new Error("'locals' must be an object")
                        } else locals = NO_LOCALS;
                        if (parent) {
                            if (!isResolve(parent)) throw new Error("'parent' must be a promise returned by $resolve.resolve()")
                        } else parent = NO_PARENT;
                        var resolution = $q.defer(),
                            result = silenceUncaughtInPromise(resolution.promise),
                            promises = result.$$promises = {},
                            values = extend({}, locals),
                            wait = 1 + plan.length / 3,
                            merged = !1;
                        if (silenceUncaughtInPromise(result), isDefined(parent.$$failure)) return fail(parent.$$failure), result;
                        parent.$$inheritedValues && merge(values, omit(parent.$$inheritedValues, invocableKeys)), extend(promises, parent.$$promises), parent.$$values ? (merged = merge(values, omit(parent.$$values, invocableKeys)), result.$$inheritedValues = omit(parent.$$values, invocableKeys), done()) : (parent.$$inheritedValues && (result.$$inheritedValues = omit(parent.$$inheritedValues, invocableKeys)), parent.then(done, fail));
                        for (var i = 0, ii = plan.length; i < ii; i += 3) locals.hasOwnProperty(plan[i]) ? done() : invoke(plan[i], plan[i + 1], plan[i + 2]);
                        return result
                    }
            }, this.resolve = function(invocables, locals, parent, self) {
                return this.study(invocables)(locals, parent, self)
            }
        }

        function TemplateFactoryProvider() {
            var shouldUnsafelyUseHttp = angular.version.minor < 3;
            this.shouldUnsafelyUseHttp = function(value) {
                shouldUnsafelyUseHttp = !!value
            }, this.$get = ["$http", "$templateCache", "$injector", function($http, $templateCache, $injector) {
                return new TemplateFactory($http, $templateCache, $injector, shouldUnsafelyUseHttp)
            }]
        }

        function TemplateFactory($http, $templateCache, $injector, shouldUnsafelyUseHttp) {
            this.fromConfig = function(config, params, locals) {
                return isDefined(config.template) ? this.fromString(config.template, params) : isDefined(config.templateUrl) ? this.fromUrl(config.templateUrl, params) : isDefined(config.templateProvider) ? this.fromProvider(config.templateProvider, params, locals) : null
            }, this.fromString = function(template, params) {
                return isFunction(template) ? template(params) : template
            }, this.fromUrl = function(url, params) {
                return isFunction(url) && (url = url(params)), null == url ? null : shouldUnsafelyUseHttp ? $http.get(url, {
                    cache: $templateCache,
                    headers: {
                        Accept: "text/html"
                    }
                }).then(function(response) {
                    return response.data
                }) : $injector.get("$templateRequest")(url)
            }, this.fromProvider = function(provider, params, locals) {
                return $injector.invoke(provider, null, locals || {
                    params: params
                })
            }
        }

        function UrlMatcher(pattern, config, parentMatcher) {
            function addParameter(id, type, config, location) {
                if (paramNames.push(id), parentParams[id]) return parentParams[id];
                if (!/^\w+([-.]+\w+)*(?:\[\])?$/.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
                if (params[id]) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'");
                return params[id] = new $$UMFP.Param(id, type, config, location), params[id]
            }

            function quoteRegExp(string, pattern, squash, optional) {
                var surroundPattern = ["", ""],
                    result = string.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
                if (!pattern) return result;
                switch (squash) {
                    case !1:
                        surroundPattern = ["(", ")" + (optional ? "?" : "")];
                        break;
                    case !0:
                        result = result.replace(/\/$/, ""), surroundPattern = ["(?:/(", ")|/)?"];
                        break;
                    default:
                        surroundPattern = ["(" + squash + "|", ")?"]
                }
                return result + surroundPattern[0] + pattern + surroundPattern[1]
            }

            function matchDetails(m, isSearch) {
                var id, regexp, segment, type, cfg;
                return id = m[2] || m[3], cfg = config.params[id], segment = pattern.substring(last, m.index), regexp = isSearch ? m[4] : m[4] || ("*" == m[1] ? ".*" : null), regexp && (type = $$UMFP.type(regexp) || inherit($$UMFP.type("string"), {
                    pattern: new RegExp(regexp, config.caseInsensitive ? "i" : undefined)
                })), {
                    id: id,
                    regexp: regexp,
                    segment: segment,
                    type: type,
                    cfg: cfg
                }
            }
            config = extend({
                params: {}
            }, isObject(config) ? config : {});
            var m, placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
                searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g,
                compiled = "^",
                last = 0,
                segments = this.segments = [],
                parentParams = parentMatcher ? parentMatcher.params : {},
                params = this.params = parentMatcher ? parentMatcher.params.$$new() : new $$UMFP.ParamSet,
                paramNames = [];
            this.source = pattern;
            for (var p, param, segment;
                (m = placeholder.exec(pattern)) && (p = matchDetails(m, !1), !(p.segment.indexOf("?") >= 0));) param = addParameter(p.id, p.type, p.cfg, "path"), compiled += quoteRegExp(p.segment, param.type.pattern.source, param.squash, param.isOptional), segments.push(p.segment), last = placeholder.lastIndex;
            segment = pattern.substring(last);
            var i = segment.indexOf("?");
            if (i >= 0) {
                var search = this.sourceSearch = segment.substring(i);
                if (segment = segment.substring(0, i), this.sourcePath = pattern.substring(0, last + i), search.length > 0)
                    for (last = 0; m = searchPlaceholder.exec(search);) p = matchDetails(m, !0), param = addParameter(p.id, p.type, p.cfg, "search"), last = placeholder.lastIndex
            } else this.sourcePath = pattern, this.sourceSearch = "";
            compiled += quoteRegExp(segment) + (config.strict === !1 ? "/?" : "") + "$", segments.push(segment), this.regexp = new RegExp(compiled, config.caseInsensitive ? "i" : undefined), this.prefix = segments[0], this.$$paramNames = paramNames
        }

        function Type(config) {
            extend(this, config)
        }

        function $UrlMatcherFactory() {
            function valToString(val) {
                return null != val ? val.toString().replace(/(~|\/)/g, function(m) {
                    return {
                        "~": "~~",
                        "/": "~2F"
                    } [m]
                }) : val
            }

            function valFromString(val) {
                return null != val ? val.toString().replace(/(~~|~2F)/g, function(m) {
                    return {
                        "~~": "~",
                        "~2F": "/"
                    } [m]
                }) : val
            }

            function getDefaultConfig() {
                return {
                    strict: isStrictMode,
                    caseInsensitive: isCaseInsensitive
                }
            }

            function isInjectable(value) {
                return isFunction(value) || isArray(value) && isFunction(value[value.length - 1])
            }

            function flushTypeQueue() {
                for (; typeQueue.length;) {
                    var type = typeQueue.shift();
                    if (type.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
                    angular.extend($types[type.name], injector.invoke(type.def))
                }
            }

            function ParamSet(params) {
                extend(this, params || {})
            }
            $$UMFP = this;
            var injector, isCaseInsensitive = !1,
                isStrictMode = !0,
                defaultSquashPolicy = !1,
                $types = {},
                enqueue = !0,
                typeQueue = [],
                defaultTypes = {
                    string: {
                        encode: valToString,
                        decode: valFromString,
                        is: function(val) {
                            return null == val || !isDefined(val) || "string" == typeof val
                        },
                        pattern: /[^/]*/
                    },
                    int: {
                        encode: valToString,
                        decode: function(val) {
                            return parseInt(val, 10)
                        },
                        is: function(val) {
                            return val !== undefined && null !== val && this.decode(val.toString()) === val
                        },
                        pattern: /-?\d+/
                    },
                    bool: {
                        encode: function(val) {
                            return val ? 1 : 0
                        },
                        decode: function(val) {
                            return 0 !== parseInt(val, 10)
                        },
                        is: function(val) {
                            return val === !0 || val === !1
                        },
                        pattern: /0|1/
                    },
                    date: {
                        encode: function(val) {
                            return this.is(val) ? [val.getFullYear(), ("0" + (val.getMonth() + 1)).slice(-2), ("0" + val.getDate()).slice(-2)].join("-") : undefined
                        },
                        decode: function(val) {
                            if (this.is(val)) return val;
                            var match = this.capture.exec(val);
                            return match ? new Date(match[1], match[2] - 1, match[3]) : undefined
                        },
                        is: function(val) {
                            return val instanceof Date && !isNaN(val.valueOf())
                        },
                        equals: function(a, b) {
                            return this.is(a) && this.is(b) && a.toISOString() === b.toISOString()
                        },
                        pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
                        capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
                    },
                    json: {
                        encode: angular.toJson,
                        decode: angular.fromJson,
                        is: angular.isObject,
                        equals: angular.equals,
                        pattern: /[^/]*/
                    },
                    any: {
                        encode: angular.identity,
                        decode: angular.identity,
                        equals: angular.equals,
                        pattern: /.*/
                    }
                };
            $UrlMatcherFactory.$$getDefaultValue = function(config) {
                if (!isInjectable(config.value)) return config.value;
                if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
                return injector.invoke(config.value)
            }, this.caseInsensitive = function(value) {
                return isDefined(value) && (isCaseInsensitive = value), isCaseInsensitive
            }, this.strictMode = function(value) {
                return isDefined(value) && (isStrictMode = value), isStrictMode
            }, this.defaultSquashPolicy = function(value) {
                if (!isDefined(value)) return defaultSquashPolicy;
                if (value !== !0 && value !== !1 && !isString(value)) throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
                return defaultSquashPolicy = value, value
            }, this.compile = function(pattern, config) {
                return new UrlMatcher(pattern, extend(getDefaultConfig(), config))
            }, this.isMatcher = function(o) {
                if (!isObject(o)) return !1;
                var result = !0;
                return forEach(UrlMatcher.prototype, function(val, name) {
                    isFunction(val) && (result = result && isDefined(o[name]) && isFunction(o[name]))
                }), result
            }, this.type = function(name, definition, definitionFn) {
                if (!isDefined(definition)) return $types[name];
                if ($types.hasOwnProperty(name)) throw new Error("A type named '" + name + "' has already been defined.");
                return $types[name] = new Type(extend({
                    name: name
                }, definition)), definitionFn && (typeQueue.push({
                    name: name,
                    def: definitionFn
                }), enqueue || flushTypeQueue()), this
            }, forEach(defaultTypes, function(type, name) {
                $types[name] = new Type(extend({
                    name: name
                }, type))
            }), $types = inherit($types, {}), this.$get = ["$injector", function($injector) {
                return injector = $injector, enqueue = !1, flushTypeQueue(), forEach(defaultTypes, function(type, name) {
                    $types[name] || ($types[name] = new Type(type))
                }), this
            }], this.Param = function(id, type, config, location) {
                function unwrapShorthand(config) {
                    var keys = isObject(config) ? objectKeys(config) : [],
                        isShorthand = indexOf(keys, "value") === -1 && indexOf(keys, "type") === -1 && indexOf(keys, "squash") === -1 && indexOf(keys, "array") === -1;
                    return isShorthand && (config = {
                        value: config
                    }), config.$$fn = isInjectable(config.value) ? config.value : function() {
                        return config.value
                    }, config
                }

                function getType(config, urlType, location) {
                    if (config.type && urlType) throw new Error("Param '" + id + "' has two type configurations.");
                    return urlType ? urlType : config.type ? angular.isString(config.type) ? $types[config.type] : config.type instanceof Type ? config.type : new Type(config.type) : "config" === location ? $types.any : $types.string
                }

                function getArrayMode() {
                    var arrayDefaults = {
                            array: "search" === location && "auto"
                        },
                        arrayParamNomenclature = id.match(/\[\]$/) ? {
                            array: !0
                        } : {};
                    return extend(arrayDefaults, arrayParamNomenclature, config).array
                }

                function getSquashPolicy(config, isOptional) {
                    var squash = config.squash;
                    if (!isOptional || squash === !1) return !1;
                    if (!isDefined(squash) || null == squash) return defaultSquashPolicy;
                    if (squash === !0 || isString(squash)) return squash;
                    throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string")
                }

                function getReplace(config, arrayMode, isOptional, squash) {
                    var replace, configuredKeys, defaultPolicy = [{
                        from: "",
                        to: isOptional || arrayMode ? undefined : ""
                    }, {
                        from: null,
                        to: isOptional || arrayMode ? undefined : ""
                    }];
                    return replace = isArray(config.replace) ? config.replace : [], isString(squash) && replace.push({
                        from: squash,
                        to: undefined
                    }), configuredKeys = map(replace, function(item) {
                        return item.from
                    }), filter(defaultPolicy, function(item) {
                        return indexOf(configuredKeys, item.from) === -1
                    }).concat(replace)
                }

                function $$getDefaultValue() {
                    if (!injector) throw new Error("Injectable functions cannot be called at configuration time");
                    var defaultValue = injector.invoke(config.$$fn);
                    if (null !== defaultValue && defaultValue !== undefined && !self.type.is(defaultValue)) throw new Error("Default value (" + defaultValue + ") for parameter '" + self.id + "' is not an instance of Type (" + self.type.name + ")");
                    return defaultValue
                }

                function $value(value) {
                    function hasReplaceVal(val) {
                        return function(obj) {
                            return obj.from === val
                        }
                    }

                    function $replace(value) {
                        var replacement = map(filter(self.replace, hasReplaceVal(value)), function(obj) {
                            return obj.to
                        });
                        return replacement.length ? replacement[0] : value
                    }
                    return value = $replace(value), isDefined(value) ? self.type.$normalize(value) : $$getDefaultValue()
                }

                function toString() {
                    return "{Param:" + id + " " + type + " squash: '" + squash + "' optional: " + isOptional + "}"
                }
                var self = this;
                config = unwrapShorthand(config), type = getType(config, type, location);
                var arrayMode = getArrayMode();
                type = arrayMode ? type.$asArray(arrayMode, "search" === location) : type, "string" !== type.name || arrayMode || "path" !== location || config.value !== undefined || (config.value = "");
                var isOptional = config.value !== undefined,
                    squash = getSquashPolicy(config, isOptional),
                    replace = getReplace(config, arrayMode, isOptional, squash);
                extend(this, {
                    id: id,
                    type: type,
                    location: location,
                    array: arrayMode,
                    squash: squash,
                    replace: replace,
                    isOptional: isOptional,
                    value: $value,
                    dynamic: undefined,
                    config: config,
                    toString: toString
                })
            }, ParamSet.prototype = {
                $$new: function() {
                    return inherit(this, extend(new ParamSet, {
                        $$parent: this
                    }))
                },
                $$keys: function() {
                    for (var keys = [], chain = [], parent = this, ignore = objectKeys(ParamSet.prototype); parent;) chain.push(parent), parent = parent.$$parent;
                    return chain.reverse(), forEach(chain, function(paramset) {
                        forEach(objectKeys(paramset), function(key) {
                            indexOf(keys, key) === -1 && indexOf(ignore, key) === -1 && keys.push(key)
                        })
                    }), keys
                },
                $$values: function(paramValues) {
                    var values = {},
                        self = this;
                    return forEach(self.$$keys(), function(key) {
                        values[key] = self[key].value(paramValues && paramValues[key])
                    }), values
                },
                $$equals: function(paramValues1, paramValues2) {
                    var equal = !0,
                        self = this;
                    return forEach(self.$$keys(), function(key) {
                        var left = paramValues1 && paramValues1[key],
                            right = paramValues2 && paramValues2[key];
                        self[key].type.equals(left, right) || (equal = !1)
                    }), equal
                },
                $$validates: function(paramValues) {
                    var i, param, rawVal, normalized, encoded, keys = this.$$keys();
                    for (i = 0; i < keys.length && (param = this[keys[i]], rawVal = paramValues[keys[i]], rawVal !== undefined && null !== rawVal || !param.isOptional); i++) {
                        if (normalized = param.type.$normalize(rawVal), !param.type.is(normalized)) return !1;
                        if (encoded = param.type.encode(normalized), angular.isString(encoded) && !param.type.pattern.exec(encoded)) return !1
                    }
                    return !0
                },
                $$parent: undefined
            }, this.ParamSet = ParamSet
        }

        function $UrlRouterProvider($locationProvider, $urlMatcherFactory) {
            function regExpPrefix(re) {
                var prefix = /^\^((?:\\[^a-zA-Z0-9]|[^\\\[\]\^$*+?.()|{}]+)*)/.exec(re.source);
                return null != prefix ? prefix[1].replace(/\\(.)/g, "$1") : ""
            }

            function interpolate(pattern, match) {
                return pattern.replace(/\$(\$|\d{1,2})/, function(m, what) {
                    return match["$" === what ? 0 : Number(what)]
                })
            }

            function handleIfMatch($injector, handler, match) {
                if (!match) return !1;
                var result = $injector.invoke(handler, handler, {
                    $match: match
                });
                return !isDefined(result) || result
            }

            function $get($location, $rootScope, $injector, $browser, $sniffer) {
                function appendBasePath(url, isHtml5, absolute) {
                    return "/" === baseHref ? url : isHtml5 ? baseHref.slice(0, -1) + url : absolute ? baseHref.slice(1) + url : url
                }

                function update(evt) {
                    function check(rule) {
                        var handled = rule($injector, $location);
                        return !!handled && (isString(handled) && $location.replace().url(handled), !0)
                    }
                    if (!evt || !evt.defaultPrevented) {
                        lastPushedUrl && $location.url() === lastPushedUrl;
                        lastPushedUrl = undefined;
                        var i, n = rules.length;
                        for (i = 0; i < n; i++)
                            if (check(rules[i])) return;
                        otherwise && check(otherwise)
                    }
                }

                function _listen() {
                    return listener = listener || $rootScope.$on("$locationChangeSuccess", update)
                }
                var lastPushedUrl, baseHref = $browser.baseHref(),
                    location = $location.url();
                return interceptDeferred || _listen(), {
                    sync: function() {
                        update()
                    },
                    listen: function() {
                        return _listen()
                    },
                    update: function(read) {
                        return read ? void(location = $location.url()) : void($location.url() !== location && ($location.url(location), $location.replace()))
                    },
                    push: function(urlMatcher, params, options) {
                        var url = urlMatcher.format(params || {});
                        null !== url && params && params["#"] && (url += "#" + params["#"]), $location.url(url), lastPushedUrl = options && options.$$avoidResync ? $location.url() : undefined, options && options.replace && $location.replace()
                    },
                    href: function(urlMatcher, params, options) {
                        if (!urlMatcher.validates(params)) return null;
                        var isHtml5 = $locationProvider.html5Mode();
                        angular.isObject(isHtml5) && (isHtml5 = isHtml5.enabled), isHtml5 = isHtml5 && $sniffer.history;
                        var url = urlMatcher.format(params);
                        if (options = options || {}, isHtml5 || null === url || (url = "#" + $locationProvider.hashPrefix() + url), null !== url && params && params["#"] && (url += "#" + params["#"]), url = appendBasePath(url, isHtml5, options.absolute), !options.absolute || !url) return url;
                        var slash = !isHtml5 && url ? "/" : "",
                            port = $location.port();
                        return port = 80 === port || 443 === port ? "" : ":" + port, [$location.protocol(), "://", $location.host(), port, slash, url].join("")
                    }
                }
            }
            var listener, rules = [],
                otherwise = null,
                interceptDeferred = !1;
            this.rule = function(rule) {
                if (!isFunction(rule)) throw new Error("'rule' must be a function");
                return rules.push(rule), this
            }, this.otherwise = function(rule) {
                if (isString(rule)) {
                    var redirect = rule;
                    rule = function() {
                        return redirect
                    }
                } else if (!isFunction(rule)) throw new Error("'rule' must be a function");
                return otherwise = rule, this
            }, this.when = function(what, handler) {
                var redirect, handlerIsString = isString(handler);
                if (isString(what) && (what = $urlMatcherFactory.compile(what)), !handlerIsString && !isFunction(handler) && !isArray(handler)) throw new Error("invalid 'handler' in when()");
                var strategies = {
                        matcher: function(what, handler) {
                            return handlerIsString && (redirect = $urlMatcherFactory.compile(handler), handler = ["$match", function($match) {
                                return redirect.format($match)
                            }]), extend(function($injector, $location) {
                                return handleIfMatch($injector, handler, what.exec($location.path(), $location.search()))
                            }, {
                                prefix: isString(what.prefix) ? what.prefix : ""
                            })
                        },
                        regex: function(what, handler) {
                            if (what.global || what.sticky) throw new Error("when() RegExp must not be global or sticky");
                            return handlerIsString && (redirect = handler, handler = ["$match", function($match) {
                                return interpolate(redirect, $match)
                            }]), extend(function($injector, $location) {
                                return handleIfMatch($injector, handler, what.exec($location.path()))
                            }, {
                                prefix: regExpPrefix(what)
                            })
                        }
                    },
                    check = {
                        matcher: $urlMatcherFactory.isMatcher(what),
                        regex: what instanceof RegExp
                    };
                for (var n in check)
                    if (check[n]) return this.rule(strategies[n](what, handler));
                throw new Error("invalid 'what' in when()")
            }, this.deferIntercept = function(defer) {
                defer === undefined && (defer = !0), interceptDeferred = defer
            }, this.$get = $get, $get.$inject = ["$location", "$rootScope", "$injector", "$browser", "$sniffer"]
        }

        function $StateProvider($urlRouterProvider, $urlMatcherFactory) {
            function isRelative(stateName) {
                return 0 === stateName.indexOf(".") || 0 === stateName.indexOf("^")
            }

            function findState(stateOrName, base) {
                if (!stateOrName) return undefined;
                var isStr = isString(stateOrName),
                    name = isStr ? stateOrName : stateOrName.name,
                    path = isRelative(name);
                if (path) {
                    if (!base) throw new Error("No reference point given for path '" + name + "'");
                    base = findState(base);
                    for (var rel = name.split("."), i = 0, pathLength = rel.length, current = base; i < pathLength; i++)
                        if ("" !== rel[i] || 0 !== i) {
                            if ("^" !== rel[i]) break;
                            if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + base.name + "'");
                            current = current.parent
                        } else current = base;
                    rel = rel.slice(i).join("."), name = current.name + (current.name && rel ? "." : "") + rel
                }
                var state = states[name];
                return !state || !isStr && (isStr || state !== stateOrName && state.self !== stateOrName) ? undefined : state
            }

            function queueState(parentName, state) {
                queue[parentName] || (queue[parentName] = []), queue[parentName].push(state)
            }

            function flushQueuedChildren(parentName) {
                for (var queued = queue[parentName] || []; queued.length;) registerState(queued.shift())
            }

            function registerState(state) {
                state = inherit(state, {
                    self: state,
                    resolve: state.resolve || {},
                    toString: function() {
                        return this.name
                    }
                });
                var name = state.name;
                if (!isString(name) || name.indexOf("@") >= 0) throw new Error("State must have a valid name");
                if (states.hasOwnProperty(name)) throw new Error("State '" + name + "' is already defined");
                var parentName = name.indexOf(".") !== -1 ? name.substring(0, name.lastIndexOf(".")) : isString(state.parent) ? state.parent : isObject(state.parent) && isString(state.parent.name) ? state.parent.name : "";
                if (parentName && !states[parentName]) return queueState(parentName, state.self);
                for (var key in stateBuilder) isFunction(stateBuilder[key]) && (state[key] = stateBuilder[key](state, stateBuilder.$delegates[key]));
                return states[name] = state, !state[abstractKey] && state.url && $urlRouterProvider.when(state.url, ["$match", "$stateParams", function($match, $stateParams) {
                    $state.$current.navigable == state && equalForKeys($match, $stateParams) || $state.transitionTo(state, $match, {
                        inherit: !0,
                        location: !1
                    })
                }]), flushQueuedChildren(name), state
            }

            function isGlob(text) {
                return text.indexOf("*") > -1
            }

            function doesStateMatchGlob(glob) {
                for (var globSegments = glob.split("."), segments = $state.$current.name.split("."), i = 0, l = globSegments.length; i < l; i++) "*" === globSegments[i] && (segments[i] = "*");
                return "**" === globSegments[0] && (segments = segments.slice(indexOf(segments, globSegments[1])), segments.unshift("**")), "**" === globSegments[globSegments.length - 1] && (segments.splice(indexOf(segments, globSegments[globSegments.length - 2]) + 1, Number.MAX_VALUE), segments.push("**")), globSegments.length == segments.length && segments.join("") === globSegments.join("")
            }

            function decorator(name, func) {
                return isString(name) && !isDefined(func) ? stateBuilder[name] : isFunction(func) && isString(name) ? (stateBuilder[name] && !stateBuilder.$delegates[name] && (stateBuilder.$delegates[name] = stateBuilder[name]), stateBuilder[name] = func, this) : this
            }

            function state(name, definition) {
                return isObject(name) ? definition = name : definition.name = name, registerState(definition), this
            }

            function $get($rootScope, $q, $view, $injector, $resolve, $stateParams, $urlRouter, $location, $urlMatcherFactory) {
                function handleRedirect(redirect, state, params, options) {
                    var evt = $rootScope.$broadcast("$stateNotFound", redirect, state, params);
                    if (evt.defaultPrevented) return $urlRouter.update(), TransitionAborted;
                    if (!evt.retry) return null;
                    if (options.$retry) return $urlRouter.update(), TransitionFailed;
                    var retryTransition = $state.transition = $q.when(evt.retry);
                    return retryTransition.then(function() {
                        return retryTransition !== $state.transition ? ($rootScope.$broadcast("$stateChangeCancel", redirect.to, redirect.toParams, state, params), TransitionSuperseded) : (redirect.options.$retry = !0, $state.transitionTo(redirect.to, redirect.toParams, redirect.options))
                    }, function() {
                        return TransitionAborted
                    }), $urlRouter.update(), retryTransition
                }

                function resolveState(state, params, paramsAreFiltered, inherited, dst, options) {
                    function resolveViews() {
                        var viewsPromises = [];
                        return forEach(state.views, function(view, name) {
                            var injectables = view.resolve && view.resolve !== state.resolve ? view.resolve : {};
                            injectables.$template = [function() {
                                return $view.load(name, {
                                    view: view,
                                    locals: dst.globals,
                                    params: $stateParams,
                                    notify: options.notify
                                }) || ""
                            }], viewsPromises.push($resolve.resolve(injectables, dst.globals, dst.resolve, state).then(function(result) {
                                if (isFunction(view.controllerProvider) || isArray(view.controllerProvider)) {
                                    var injectLocals = angular.extend({}, injectables, dst.globals);
                                    result.$$controller = $injector.invoke(view.controllerProvider, null, injectLocals)
                                } else result.$$controller = view.controller;
                                result.$$state = state, result.$$controllerAs = view.controllerAs, result.$$resolveAs = view.resolveAs, dst[name] = result
                            }))
                        }), $q.all(viewsPromises).then(function() {
                            return dst.globals
                        })
                    }
                    var $stateParams = paramsAreFiltered ? params : filterByKeys(state.params.$$keys(), params),
                        locals = {
                            $stateParams: $stateParams
                        };
                    dst.resolve = $resolve.resolve(state.resolve, locals, dst.resolve, state);
                    var promises = [dst.resolve.then(function(globals) {
                        dst.globals = globals
                    })];
                    return inherited && promises.push(inherited), $q.all(promises).then(resolveViews).then(function(values) {
                        return dst
                    })
                }
                var TransitionSupersededError = new Error("transition superseded"),
                    TransitionSuperseded = silenceUncaughtInPromise($q.reject(TransitionSupersededError)),
                    TransitionPrevented = silenceUncaughtInPromise($q.reject(new Error("transition prevented"))),
                    TransitionAborted = silenceUncaughtInPromise($q.reject(new Error("transition aborted"))),
                    TransitionFailed = silenceUncaughtInPromise($q.reject(new Error("transition failed")));
                return root.locals = {
                    resolve: null,
                    globals: {
                        $stateParams: {}
                    }
                }, $state = {
                    params: {},
                    current: root.self,
                    $current: root,
                    transition: null
                }, $state.reload = function(state) {
                    return $state.transitionTo($state.current, $stateParams, {
                        reload: state || !0,
                        inherit: !1,
                        notify: !0
                    })
                }, $state.go = function(to, params, options) {
                    return $state.transitionTo(to, params, extend({
                        inherit: !0,
                        relative: $state.$current
                    }, options))
                }, $state.transitionTo = function(to, toParams, options) {
                    toParams = toParams || {}, options = extend({
                        location: !0,
                        inherit: !1,
                        relative: null,
                        notify: !0,
                        reload: !1,
                        $retry: !1
                    }, options || {});
                    var evt, from = $state.$current,
                        fromParams = $state.params,
                        fromPath = from.path,
                        toState = findState(to, options.relative),
                        hash = toParams["#"];
                    if (!isDefined(toState)) {
                        var redirect = {
                                to: to,
                                toParams: toParams,
                                options: options
                            },
                            redirectResult = handleRedirect(redirect, from.self, fromParams, options);
                        if (redirectResult) return redirectResult;
                        if (to = redirect.to, toParams = redirect.toParams, options = redirect.options, toState = findState(to, options.relative), !isDefined(toState)) {
                            if (!options.relative) throw new Error("No such state '" + to + "'");
                            throw new Error("Could not resolve '" + to + "' from state '" + options.relative + "'")
                        }
                    }
                    if (toState[abstractKey]) throw new Error("Cannot transition to abstract state '" + to + "'");
                    if (options.inherit && (toParams = inheritParams($stateParams, toParams || {}, $state.$current, toState)), !toState.params.$$validates(toParams)) return TransitionFailed;
                    toParams = toState.params.$$values(toParams), to = toState;
                    var toPath = to.path,
                        keep = 0,
                        state = toPath[keep],
                        locals = root.locals,
                        toLocals = [];
                    if (options.reload) {
                        if (isString(options.reload) || isObject(options.reload)) {
                            if (isObject(options.reload) && !options.reload.name) throw new Error("Invalid reload state object");
                            var reloadState = options.reload === !0 ? fromPath[0] : findState(options.reload);
                            if (options.reload && !reloadState) throw new Error("No such reload state '" + (isString(options.reload) ? options.reload : options.reload.name) + "'");
                            for (; state && state === fromPath[keep] && state !== reloadState;) locals = toLocals[keep] = state.locals, keep++, state = toPath[keep]
                        }
                    } else
                        for (; state && state === fromPath[keep] && state.ownParams.$$equals(toParams, fromParams);) locals = toLocals[keep] = state.locals, keep++, state = toPath[keep];
                    if (shouldSkipReload(to, toParams, from, fromParams, locals, options)) return hash && (toParams["#"] = hash), $state.params = toParams, copy($state.params, $stateParams), copy(filterByKeys(to.params.$$keys(), $stateParams), to.locals.globals.$stateParams), options.location && to.navigable && to.navigable.url && ($urlRouter.push(to.navigable.url, toParams, {
                        $$avoidResync: !0,
                        replace: "replace" === options.location
                    }), $urlRouter.update(!0)), $state.transition = null, $q.when($state.current);
                    if (toParams = filterByKeys(to.params.$$keys(), toParams || {}), hash && (toParams["#"] = hash), options.notify && $rootScope.$broadcast("$stateChangeStart", to.self, toParams, from.self, fromParams, options).defaultPrevented) return $rootScope.$broadcast("$stateChangeCancel", to.self, toParams, from.self, fromParams), null == $state.transition && $urlRouter.update(), TransitionPrevented;
                    for (var resolved = $q.when(locals), l = keep; l < toPath.length; l++, state = toPath[l]) locals = toLocals[l] = inherit(locals), resolved = resolveState(state, toParams, state === to, resolved, locals, options);
                    var transition = $state.transition = resolved.then(function() {
                        var l, entering, exiting;
                        if ($state.transition !== transition) return $rootScope.$broadcast("$stateChangeCancel", to.self, toParams, from.self, fromParams), TransitionSuperseded;
                        for (l = fromPath.length - 1; l >= keep; l--) exiting = fromPath[l], exiting.self.onExit && $injector.invoke(exiting.self.onExit, exiting.self, exiting.locals.globals), exiting.locals = null;
                        for (l = keep; l < toPath.length; l++) entering = toPath[l], entering.locals = toLocals[l], entering.self.onEnter && $injector.invoke(entering.self.onEnter, entering.self, entering.locals.globals);
                        return $state.transition !== transition ? ($rootScope.$broadcast("$stateChangeCancel", to.self, toParams, from.self, fromParams), TransitionSuperseded) : ($state.$current = to, $state.current = to.self, $state.params = toParams, copy($state.params, $stateParams), $state.transition = null, options.location && to.navigable && $urlRouter.push(to.navigable.url, to.navigable.locals.globals.$stateParams, {
                            $$avoidResync: !0,
                            replace: "replace" === options.location
                        }), options.notify && $rootScope.$broadcast("$stateChangeSuccess", to.self, toParams, from.self, fromParams), $urlRouter.update(!0), $state.current)
                    }).then(null, function(error) {
                        return error === TransitionSupersededError ? TransitionSuperseded : $state.transition !== transition ? ($rootScope.$broadcast("$stateChangeCancel", to.self, toParams, from.self, fromParams),
                            TransitionSuperseded) : ($state.transition = null, evt = $rootScope.$broadcast("$stateChangeError", to.self, toParams, from.self, fromParams, error), evt.defaultPrevented || $urlRouter.update(), $q.reject(error))
                    });
                    return silenceUncaughtInPromise(transition), transition
                }, $state.is = function(stateOrName, params, options) {
                    options = extend({
                        relative: $state.$current
                    }, options || {});
                    var state = findState(stateOrName, options.relative);
                    return isDefined(state) ? $state.$current === state && (!params || objectKeys(params).reduce(function(acc, key) {
                        var paramDef = state.params[key];
                        return acc && (!paramDef || paramDef.type.equals($stateParams[key], params[key]))
                    }, !0)) : undefined
                }, $state.includes = function(stateOrName, params, options) {
                    if (options = extend({
                            relative: $state.$current
                        }, options || {}), isString(stateOrName) && isGlob(stateOrName)) {
                        if (!doesStateMatchGlob(stateOrName)) return !1;
                        stateOrName = $state.$current.name
                    }
                    var state = findState(stateOrName, options.relative);
                    if (!isDefined(state)) return undefined;
                    if (!isDefined($state.$current.includes[state.name])) return !1;
                    if (!params) return !0;
                    for (var keys = objectKeys(params), i = 0; i < keys.length; i++) {
                        var key = keys[i],
                            paramDef = state.params[key];
                        if (paramDef && !paramDef.type.equals($stateParams[key], params[key])) return !1
                    }
                    return objectKeys(params).reduce(function(acc, key) {
                        var paramDef = state.params[key];
                        return acc && !paramDef || paramDef.type.equals($stateParams[key], params[key])
                    }, !0)
                }, $state.href = function(stateOrName, params, options) {
                    options = extend({
                        lossy: !0,
                        inherit: !0,
                        absolute: !1,
                        relative: $state.$current
                    }, options || {});
                    var state = findState(stateOrName, options.relative);
                    if (!isDefined(state)) return null;
                    options.inherit && (params = inheritParams($stateParams, params || {}, $state.$current, state));
                    var nav = state && options.lossy ? state.navigable : state;
                    return nav && nav.url !== undefined && null !== nav.url ? $urlRouter.href(nav.url, filterByKeys(state.params.$$keys().concat("#"), params || {}), {
                        absolute: options.absolute
                    }) : null
                }, $state.get = function(stateOrName, context) {
                    if (0 === arguments.length) return map(objectKeys(states), function(name) {
                        return states[name].self
                    });
                    var state = findState(stateOrName, context || $state.$current);
                    return state && state.self ? state.self : null
                }, $state
            }

            function shouldSkipReload(to, toParams, from, fromParams, locals, options) {
                function nonSearchParamsEqual(fromAndToState, fromParams, toParams) {
                    function notSearchParam(key) {
                        return "search" != fromAndToState.params[key].location
                    }
                    var nonQueryParamKeys = fromAndToState.params.$$keys().filter(notSearchParam),
                        nonQueryParams = pick.apply({}, [fromAndToState.params].concat(nonQueryParamKeys)),
                        nonQueryParamSet = new $$UMFP.ParamSet(nonQueryParams);
                    return nonQueryParamSet.$$equals(fromParams, toParams)
                }
                if (!options.reload && to === from && (locals === from.locals || to.self.reloadOnSearch === !1 && nonSearchParamsEqual(from, fromParams, toParams))) return !0
            }
            var root, $state, states = {},
                queue = {},
                abstractKey = "abstract",
                stateBuilder = {
                    parent: function(state) {
                        if (isDefined(state.parent) && state.parent) return findState(state.parent);
                        var compositeName = /^(.+)\.[^.]+$/.exec(state.name);
                        return compositeName ? findState(compositeName[1]) : root
                    },
                    data: function(state) {
                        return state.parent && state.parent.data && (state.data = state.self.data = inherit(state.parent.data, state.data)), state.data
                    },
                    url: function url(state) {
                        var url = state.url,
                            config = {
                                params: state.params || {}
                            };
                        if (isString(url)) return "^" == url.charAt(0) ? $urlMatcherFactory.compile(url.substring(1), config) : (state.parent.navigable || root).url.concat(url, config);
                        if (!url || $urlMatcherFactory.isMatcher(url)) return url;
                        throw new Error("Invalid url '" + url + "' in state '" + state + "'")
                    },
                    navigable: function(state) {
                        return state.url ? state : state.parent ? state.parent.navigable : null
                    },
                    ownParams: function(state) {
                        var params = state.url && state.url.params || new $$UMFP.ParamSet;
                        return forEach(state.params || {}, function(config, id) {
                            params[id] || (params[id] = new $$UMFP.Param(id, null, config, "config"))
                        }), params
                    },
                    params: function(state) {
                        var ownParams = pick(state.ownParams, state.ownParams.$$keys());
                        return state.parent && state.parent.params ? extend(state.parent.params.$$new(), ownParams) : new $$UMFP.ParamSet
                    },
                    views: function views(state) {
                        var views = {};
                        return forEach(isDefined(state.views) ? state.views : {
                            "": state
                        }, function(view, name) {
                            name.indexOf("@") < 0 && (name += "@" + state.parent.name), view.resolveAs = view.resolveAs || state.resolveAs || "$resolve", views[name] = view
                        }), views
                    },
                    path: function(state) {
                        return state.parent ? state.parent.path.concat(state) : []
                    },
                    includes: function includes(state) {
                        var includes = state.parent ? extend({}, state.parent.includes) : {};
                        return includes[state.name] = !0, includes
                    },
                    $delegates: {}
                };
            root = registerState({
                name: "",
                url: "^",
                views: null,
                abstract: !0
            }), root.navigable = null, this.decorator = decorator, this.state = state, this.$get = $get, $get.$inject = ["$rootScope", "$q", "$view", "$injector", "$resolve", "$stateParams", "$urlRouter", "$location", "$urlMatcherFactory"]
        }

        function $ViewProvider() {
            function $get($rootScope, $templateFactory) {
                return {
                    load: function(name, options) {
                        var result, defaults = {
                            template: null,
                            controller: null,
                            view: null,
                            locals: null,
                            notify: !0,
                            async: !0,
                            params: {}
                        };
                        return options = extend(defaults, options), options.view && (result = $templateFactory.fromConfig(options.view, options.params, options.locals)), result
                    }
                }
            }
            this.$get = $get, $get.$inject = ["$rootScope", "$templateFactory"]
        }

        function $ViewScrollProvider() {
            var useAnchorScroll = !1;
            this.useAnchorScroll = function() {
                useAnchorScroll = !0
            }, this.$get = ["$anchorScroll", "$timeout", function($anchorScroll, $timeout) {
                return useAnchorScroll ? $anchorScroll : function($element) {
                    return $timeout(function() {
                        $element[0].scrollIntoView()
                    }, 0, !1)
                }
            }]
        }

        function $ViewDirective($state, $injector, $uiViewScroll, $interpolate, $q) {
            function getService() {
                return $injector.has ? function(service) {
                    return $injector.has(service) ? $injector.get(service) : null
                } : function(service) {
                    try {
                        return $injector.get(service)
                    } catch (e) {
                        return null
                    }
                }
            }

            function getRenderer(attrs, scope) {
                var statics = function() {
                    return {
                        enter: function(element, target, cb) {
                            target.after(element), cb()
                        },
                        leave: function(element, cb) {
                            element.remove(), cb()
                        }
                    }
                };
                if ($animate) return {
                    enter: function(element, target, cb) {
                        angular.version.minor > 2 ? $animate.enter(element, null, target).then(cb) : $animate.enter(element, null, target, cb)
                    },
                    leave: function(element, cb) {
                        angular.version.minor > 2 ? $animate.leave(element).then(cb) : $animate.leave(element, cb)
                    }
                };
                if ($animator) {
                    var animate = $animator && $animator(scope, attrs);
                    return {
                        enter: function(element, target, cb) {
                            animate.enter(element, null, target), cb()
                        },
                        leave: function(element, cb) {
                            animate.leave(element), cb()
                        }
                    }
                }
                return statics()
            }
            var service = getService(),
                $animator = service("$animator"),
                $animate = service("$animate"),
                directive = {
                    restrict: "ECA",
                    terminal: !0,
                    priority: 400,
                    transclude: "element",
                    compile: function(tElement, tAttrs, $transclude) {
                        return function(scope, $element, attrs) {
                            function cleanupLastView() {
                                if (previousEl && (previousEl.remove(), previousEl = null), currentScope && (currentScope.$destroy(), currentScope = null), currentEl) {
                                    var $uiViewData = currentEl.data("$uiViewAnim");
                                    renderer.leave(currentEl, function() {
                                        $uiViewData.$$animLeave.resolve(), previousEl = null
                                    }), previousEl = currentEl, currentEl = null
                                }
                            }

                            function updateView(firstTime) {
                                var newScope, name = getUiViewName(scope, attrs, $element, $interpolate),
                                    previousLocals = name && $state.$current && $state.$current.locals[name];
                                if (firstTime || previousLocals !== latestLocals) {
                                    newScope = scope.$new(), latestLocals = $state.$current.locals[name], newScope.$emit("$viewContentLoading", name);
                                    var clone = $transclude(newScope, function(clone) {
                                        var animEnter = $q.defer(),
                                            animLeave = $q.defer(),
                                            viewAnimData = {
                                                $animEnter: animEnter.promise,
                                                $animLeave: animLeave.promise,
                                                $$animLeave: animLeave
                                            };
                                        clone.data("$uiViewAnim", viewAnimData), renderer.enter(clone, $element, function() {
                                            animEnter.resolve(), currentScope && currentScope.$emit("$viewContentAnimationEnded"), (angular.isDefined(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) && $uiViewScroll(clone)
                                        }), cleanupLastView()
                                    });
                                    currentEl = clone, currentScope = newScope, currentScope.$emit("$viewContentLoaded", name), currentScope.$eval(onloadExp)
                                }
                            }
                            var previousEl, currentEl, currentScope, latestLocals, onloadExp = attrs.onload || "",
                                autoScrollExp = attrs.autoscroll,
                                renderer = getRenderer(attrs, scope);
                            $element.inheritedData("$uiView");
                            scope.$on("$stateChangeSuccess", function() {
                                updateView(!1)
                            }), updateView(!0)
                        }
                    }
                };
            return directive
        }

        function $ViewDirectiveFill($compile, $controller, $state, $interpolate) {
            return {
                restrict: "ECA",
                priority: -400,
                compile: function(tElement) {
                    var initial = tElement.html();
                    return tElement.empty ? tElement.empty() : tElement[0].innerHTML = null,
                        function(scope, $element, attrs) {
                            var current = $state.$current,
                                name = getUiViewName(scope, attrs, $element, $interpolate),
                                locals = current && current.locals[name];
                            if (!locals) return $element.html(initial), void $compile($element.contents())(scope);
                            $element.data("$uiView", {
                                name: name,
                                state: locals.$$state
                            }), $element.html(locals.$template ? locals.$template : initial);
                            var resolveData = angular.extend({}, locals);
                            scope[locals.$$resolveAs] = resolveData;
                            var link = $compile($element.contents());
                            if (locals.$$controller) {
                                locals.$scope = scope, locals.$element = $element;
                                var controller = $controller(locals.$$controller, locals);
                                locals.$$controllerAs && (scope[locals.$$controllerAs] = controller, scope[locals.$$controllerAs][locals.$$resolveAs] = resolveData), isFunction(controller.$onInit) && controller.$onInit(), $element.data("$ngControllerController", controller), $element.children().data("$ngControllerController", controller)
                            }
                            link(scope)
                        }
                }
            }
        }

        function getUiViewName(scope, attrs, element, $interpolate) {
            var name = $interpolate(attrs.uiView || attrs.name || "")(scope),
                uiViewCreatedBy = element.inheritedData("$uiView");
            return name.indexOf("@") >= 0 ? name : name + "@" + (uiViewCreatedBy ? uiViewCreatedBy.state.name : "")
        }

        function parseStateRef(ref, current) {
            var parsed, preparsed = ref.match(/^\s*({[^}]*})\s*$/);
            if (preparsed && (ref = current + "(" + preparsed[1] + ")"), parsed = ref.replace(/\n/g, " ").match(/^([^(]+?)\s*(\((.*)\))?$/), !parsed || 4 !== parsed.length) throw new Error("Invalid state ref '" + ref + "'");
            return {
                state: parsed[1],
                paramExpr: parsed[3] || null
            }
        }

        function stateContext(el) {
            var stateData = el.parent().inheritedData("$uiView");
            if (stateData && stateData.state && stateData.state.name) return stateData.state
        }

        function getTypeInfo(el) {
            var isSvg = "[object SVGAnimatedString]" === Object.prototype.toString.call(el.prop("href")),
                isForm = "FORM" === el[0].nodeName;
            return {
                attr: isForm ? "action" : isSvg ? "xlink:href" : "href",
                isAnchor: "A" === el.prop("tagName").toUpperCase(),
                clickable: !isForm
            }
        }

        function clickHook(el, $state, $timeout, type, current) {
            return function(e) {
                var button = e.which || e.button,
                    target = current();
                if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || el.attr("target"))) {
                    var transition = $timeout(function() {
                        $state.go(target.state, target.params, target.options)
                    });
                    e.preventDefault();
                    var ignorePreventDefaultCount = type.isAnchor && !target.href ? 1 : 0;
                    e.preventDefault = function() {
                        ignorePreventDefaultCount-- <= 0 && $timeout.cancel(transition)
                    }
                }
            }
        }

        function defaultOpts(el, $state) {
            return {
                relative: stateContext(el) || $state.$current,
                inherit: !0
            }
        }

        function $StateRefDirective($state, $timeout) {
            return {
                restrict: "A",
                require: ["?^uiSrefActive", "?^uiSrefActiveEq"],
                link: function(scope, element, attrs, uiSrefActive) {
                    var hookFn, ref = parseStateRef(attrs.uiSref, $state.current.name),
                        def = {
                            state: ref.state,
                            href: null,
                            params: null
                        },
                        type = getTypeInfo(element),
                        active = uiSrefActive[1] || uiSrefActive[0],
                        unlinkInfoFn = null;
                    def.options = extend(defaultOpts(element, $state), attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {});
                    var update = function(val) {
                        val && (def.params = angular.copy(val)), def.href = $state.href(ref.state, def.params, def.options), unlinkInfoFn && unlinkInfoFn(), active && (unlinkInfoFn = active.$$addStateInfo(ref.state, def.params)), null !== def.href && attrs.$set(type.attr, def.href)
                    };
                    ref.paramExpr && (scope.$watch(ref.paramExpr, function(val) {
                        val !== def.params && update(val)
                    }, !0), def.params = angular.copy(scope.$eval(ref.paramExpr))), update(), type.clickable && (hookFn = clickHook(element, $state, $timeout, type, function() {
                        return def
                    }), element[element.on ? "on" : "bind"]("click", hookFn), scope.$on("$destroy", function() {
                        element[element.off ? "off" : "unbind"]("click", hookFn)
                    }))
                }
            }
        }

        function $StateRefDynamicDirective($state, $timeout) {
            return {
                restrict: "A",
                require: ["?^uiSrefActive", "?^uiSrefActiveEq"],
                link: function(scope, element, attrs, uiSrefActive) {
                    function runStateRefLink(group) {
                        def.state = group[0], def.params = group[1], def.options = group[2], def.href = $state.href(def.state, def.params, def.options), unlinkInfoFn && unlinkInfoFn(), active && (unlinkInfoFn = active.$$addStateInfo(def.state, def.params)), def.href && attrs.$set(type.attr, def.href)
                    }
                    var hookFn, type = getTypeInfo(element),
                        active = uiSrefActive[1] || uiSrefActive[0],
                        group = [attrs.uiState, attrs.uiStateParams || null, attrs.uiStateOpts || null],
                        watch = "[" + group.map(function(val) {
                            return val || "null"
                        }).join(", ") + "]",
                        def = {
                            state: null,
                            params: null,
                            options: null,
                            href: null
                        },
                        unlinkInfoFn = null;
                    scope.$watch(watch, runStateRefLink, !0), runStateRefLink(scope.$eval(watch)), type.clickable && (hookFn = clickHook(element, $state, $timeout, type, function() {
                        return def
                    }), element[element.on ? "on" : "bind"]("click", hookFn), scope.$on("$destroy", function() {
                        element[element.off ? "off" : "unbind"]("click", hookFn)
                    }))
                }
            }
        }

        function $StateRefActiveDirective($state, $stateParams, $interpolate) {
            return {
                restrict: "A",
                controller: ["$scope", "$element", "$attrs", "$timeout", function($scope, $element, $attrs, $timeout) {
                    function addState(stateName, stateParams, activeClass) {
                        var state = $state.get(stateName, stateContext($element)),
                            stateHash = createStateHash(stateName, stateParams),
                            stateInfo = {
                                state: state || {
                                    name: stateName
                                },
                                params: stateParams,
                                hash: stateHash
                            };
                        return states.push(stateInfo), activeClasses[stateHash] = activeClass,
                            function() {
                                var idx = states.indexOf(stateInfo);
                                idx !== -1 && states.splice(idx, 1)
                            }
                    }

                    function createStateHash(state, params) {
                        if (!isString(state)) throw new Error("state should be a string");
                        return isObject(params) ? state + toJson(params) : (params = $scope.$eval(params), isObject(params) ? state + toJson(params) : state)
                    }

                    function update() {
                        for (var i = 0; i < states.length; i++) anyMatch(states[i].state, states[i].params) ? addClass($element, activeClasses[states[i].hash]) : removeClass($element, activeClasses[states[i].hash]), exactMatch(states[i].state, states[i].params) ? addClass($element, activeEqClass) : removeClass($element, activeEqClass)
                    }

                    function addClass(el, className) {
                        $timeout(function() {
                            el.addClass(className)
                        })
                    }

                    function removeClass(el, className) {
                        el.removeClass(className)
                    }

                    function anyMatch(state, params) {
                        return $state.includes(state.name, params)
                    }

                    function exactMatch(state, params) {
                        return $state.is(state.name, params)
                    }
                    var activeEqClass, uiSrefActive, states = [],
                        activeClasses = {};
                    activeEqClass = $interpolate($attrs.uiSrefActiveEq || "", !1)($scope);
                    try {
                        uiSrefActive = $scope.$eval($attrs.uiSrefActive)
                    } catch (e) {}
                    uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || "", !1)($scope), isObject(uiSrefActive) && forEach(uiSrefActive, function(stateOrName, activeClass) {
                        if (isString(stateOrName)) {
                            var ref = parseStateRef(stateOrName, $state.current.name);
                            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass)
                        }
                    }), this.$$addStateInfo = function(newState, newParams) {
                        if (!(isObject(uiSrefActive) && states.length > 0)) {
                            var deregister = addState(newState, newParams, uiSrefActive);
                            return update(), deregister
                        }
                    }, $scope.$on("$stateChangeSuccess", update), update()
                }]
            }
        }

        function $IsStateFilter($state) {
            var isFilter = function(state, params) {
                return $state.is(state, params)
            };
            return isFilter.$stateful = !0, isFilter
        }

        function $IncludedByStateFilter($state) {
            var includesFilter = function(state, params, options) {
                return $state.includes(state, params, options)
            };
            return includesFilter.$stateful = !0, includesFilter
        }
        var isDefined = angular.isDefined,
            isFunction = angular.isFunction,
            isString = angular.isString,
            isObject = angular.isObject,
            isArray = angular.isArray,
            forEach = angular.forEach,
            extend = angular.extend,
            copy = angular.copy,
            toJson = angular.toJson;
        angular.module("ui.router.util", ["ng"]), angular.module("ui.router.router", ["ui.router.util"]), angular.module("ui.router.state", ["ui.router.router", "ui.router.util"]), angular.module("ui.router", ["ui.router.state"]), angular.module("ui.router.compat", ["ui.router"]), $Resolve.$inject = ["$q", "$injector"], angular.module("ui.router.util").service("$resolve", $Resolve), angular.module("ui.router.util").provider("$templateFactory", TemplateFactoryProvider);
        var $$UMFP;
        UrlMatcher.prototype.concat = function(pattern, config) {
            var defaultConfig = {
                caseInsensitive: $$UMFP.caseInsensitive(),
                strict: $$UMFP.strictMode(),
                squash: $$UMFP.defaultSquashPolicy()
            };
            return new UrlMatcher(this.sourcePath + pattern + this.sourceSearch, extend(defaultConfig, config), this)
        }, UrlMatcher.prototype.toString = function() {
            return this.source
        }, UrlMatcher.prototype.exec = function(path, searchParams) {
            function decodePathArray(string) {
                function reverseString(str) {
                    return str.split("").reverse().join("")
                }

                function unquoteDashes(str) {
                    return str.replace(/\\-/g, "-")
                }
                var split = reverseString(string).split(/-(?!\\)/),
                    allReversed = map(split, reverseString);
                return map(allReversed, unquoteDashes).reverse()
            }
            var m = this.regexp.exec(path);
            if (!m) return null;
            searchParams = searchParams || {};
            var i, j, paramName, paramNames = this.parameters(),
                nTotal = paramNames.length,
                nPath = this.segments.length - 1,
                values = {};
            if (nPath !== m.length - 1) throw new Error("Unbalanced capture group in route '" + this.source + "'");
            var param, paramVal;
            for (i = 0; i < nPath; i++) {
                for (paramName = paramNames[i], param = this.params[paramName], paramVal = m[i + 1], j = 0; j < param.replace.length; j++) param.replace[j].from === paramVal && (paramVal = param.replace[j].to);
                paramVal && param.array === !0 && (paramVal = decodePathArray(paramVal)), isDefined(paramVal) && (paramVal = param.type.decode(paramVal)), values[paramName] = param.value(paramVal)
            }
            for (; i < nTotal; i++) {
                for (paramName = paramNames[i], values[paramName] = this.params[paramName].value(searchParams[paramName]), param = this.params[paramName], paramVal = searchParams[paramName], j = 0; j < param.replace.length; j++) param.replace[j].from === paramVal && (paramVal = param.replace[j].to);
                isDefined(paramVal) && (paramVal = param.type.decode(paramVal)), values[paramName] = param.value(paramVal)
            }
            return values
        }, UrlMatcher.prototype.parameters = function(param) {
            return isDefined(param) ? this.params[param] || null : this.$$paramNames
        }, UrlMatcher.prototype.validates = function(params) {
            return this.params.$$validates(params)
        }, UrlMatcher.prototype.format = function(values) {
            function encodeDashes(str) {
                return encodeURIComponent(str).replace(/-/g, function(c) {
                    return "%5C%" + c.charCodeAt(0).toString(16).toUpperCase()
                })
            }
            values = values || {};
            var segments = this.segments,
                params = this.parameters(),
                paramset = this.params;
            if (!this.validates(values)) return null;
            var i, search = !1,
                nPath = segments.length - 1,
                nTotal = params.length,
                result = segments[0];
            for (i = 0; i < nTotal; i++) {
                var isPathParam = i < nPath,
                    name = params[i],
                    param = paramset[name],
                    value = param.value(values[name]),
                    isDefaultValue = param.isOptional && param.type.equals(param.value(), value),
                    squash = !!isDefaultValue && param.squash,
                    encoded = param.type.encode(value);
                if (isPathParam) {
                    var nextSegment = segments[i + 1],
                        isFinalPathParam = i + 1 === nPath;
                    if (squash === !1) null != encoded && (result += isArray(encoded) ? map(encoded, encodeDashes).join("-") : encodeURIComponent(encoded)), result += nextSegment;
                    else if (squash === !0) {
                        var capture = result.match(/\/$/) ? /\/?(.*)/ : /(.*)/;
                        result += nextSegment.match(capture)[1]
                    } else isString(squash) && (result += squash + nextSegment);
                    isFinalPathParam && param.squash === !0 && "/" === result.slice(-1) && (result = result.slice(0, -1))
                } else {
                    if (null == encoded || isDefaultValue && squash !== !1) continue;
                    if (isArray(encoded) || (encoded = [encoded]), 0 === encoded.length) continue;
                    encoded = map(encoded, encodeURIComponent).join("&" + name + "="), result += (search ? "&" : "?") + (name + "=" + encoded), search = !0
                }
            }
            return result
        }, Type.prototype.is = function(val, key) {
            return !0
        }, Type.prototype.encode = function(val, key) {
            return val
        }, Type.prototype.decode = function(val, key) {
            return val
        }, Type.prototype.equals = function(a, b) {
            return a == b
        }, Type.prototype.$subPattern = function() {
            var sub = this.pattern.toString();
            return sub.substr(1, sub.length - 2)
        }, Type.prototype.pattern = /.*/, Type.prototype.toString = function() {
            return "{Type:" + this.name + "}"
        }, Type.prototype.$normalize = function(val) {
            return this.is(val) ? val : this.decode(val)
        }, Type.prototype.$asArray = function(mode, isSearch) {
            function ArrayType(type, mode) {
                function bindTo(type, callbackName) {
                    return function() {
                        return type[callbackName].apply(type, arguments)
                    }
                }

                function arrayWrap(val) {
                    return isArray(val) ? val : isDefined(val) ? [val] : []
                }

                function arrayUnwrap(val) {
                    switch (val.length) {
                        case 0:
                            return undefined;
                        case 1:
                            return "auto" === mode ? val[0] : val;
                        default:
                            return val
                    }
                }

                function falsey(val) {
                    return !val
                }

                function arrayHandler(callback, allTruthyMode) {
                    return function(val) {
                        if (isArray(val) && 0 === val.length) return val;
                        val = arrayWrap(val);
                        var result = map(val, callback);
                        return allTruthyMode === !0 ? 0 === filter(result, falsey).length : arrayUnwrap(result)
                    }
                }

                function arrayEqualsHandler(callback) {
                    return function(val1, val2) {
                        var left = arrayWrap(val1),
                            right = arrayWrap(val2);
                        if (left.length !== right.length) return !1;
                        for (var i = 0; i < left.length; i++)
                            if (!callback(left[i], right[i])) return !1;
                        return !0
                    }
                }
                this.encode = arrayHandler(bindTo(type, "encode")), this.decode = arrayHandler(bindTo(type, "decode")), this.is = arrayHandler(bindTo(type, "is"), !0), this.equals = arrayEqualsHandler(bindTo(type, "equals")), this.pattern = type.pattern, this.$normalize = arrayHandler(bindTo(type, "$normalize")), this.name = type.name, this.$arrayMode = mode
            }
            if (!mode) return this;
            if ("auto" === mode && !isSearch) throw new Error("'auto' array mode is for query parameters only");
            return new ArrayType(this, mode)
        }, angular.module("ui.router.util").provider("$urlMatcherFactory", $UrlMatcherFactory), angular.module("ui.router.util").run(["$urlMatcherFactory", function($urlMatcherFactory) {}]), $UrlRouterProvider.$inject = ["$locationProvider", "$urlMatcherFactoryProvider"], angular.module("ui.router.router").provider("$urlRouter", $UrlRouterProvider), $StateProvider.$inject = ["$urlRouterProvider", "$urlMatcherFactoryProvider"], angular.module("ui.router.state").factory("$stateParams", function() {
            return {}
        }).constant("$state.runtime", {
            autoinject: !0
        }).provider("$state", $StateProvider).run(["$injector", function($injector) {
            $injector.get("$state.runtime").autoinject && $injector.get("$state")
        }]), $ViewProvider.$inject = [], angular.module("ui.router.state").provider("$view", $ViewProvider), angular.module("ui.router.state").provider("$uiViewScroll", $ViewScrollProvider), $ViewDirective.$inject = ["$state", "$injector", "$uiViewScroll", "$interpolate", "$q"], $ViewDirectiveFill.$inject = ["$compile", "$controller", "$state", "$interpolate"], angular.module("ui.router.state").directive("uiView", $ViewDirective), angular.module("ui.router.state").directive("uiView", $ViewDirectiveFill), $StateRefDirective.$inject = ["$state", "$timeout"], $StateRefDynamicDirective.$inject = ["$state", "$timeout"], $StateRefActiveDirective.$inject = ["$state", "$stateParams", "$interpolate"], angular.module("ui.router.state").directive("uiSref", $StateRefDirective).directive("uiSrefActive", $StateRefActiveDirective).directive("uiSrefActiveEq", $StateRefActiveDirective).directive("uiState", $StateRefDynamicDirective), $IsStateFilter.$inject = ["$state"], $IncludedByStateFilter.$inject = ["$state"], angular.module("ui.router.state").filter("isState", $IsStateFilter).filter("includedByState", $IncludedByStateFilter)
    }(window, window.angular),
    function(root, factory) {
        "function" == typeof define && define.amd ? define([], function() {
            return factory()
        }) : "object" === ("undefined" == typeof module ? "undefined" : _typeof2(module)) && module.exports ? module.exports = factory() : factory()
    }(this, function() {
        function runTranslate($translate) {
            "use strict";
            var key = $translate.storageKey(),
                storage = $translate.storage(),
                fallbackFromIncorrectStorageValue = function() {
                    var preferred = $translate.preferredLanguage();
                    angular.isString(preferred) ? $translate.use(preferred) : storage.put(key, $translate.use())
                };
            fallbackFromIncorrectStorageValue.displayName = "fallbackFromIncorrectStorageValue", storage ? storage.get(key) ? $translate.use(storage.get(key)).catch(fallbackFromIncorrectStorageValue) : fallbackFromIncorrectStorageValue() : angular.isString($translate.preferredLanguage()) && $translate.use($translate.preferredLanguage())
        }

        function $translateSanitizationProvider() {
            "use strict";
            var $sanitize, $sce, strategies, currentStrategy = null,
                hasConfiguredStrategy = !1,
                hasShownNoStrategyConfiguredWarning = !1;
            strategies = {
                sanitize: function(value, mode) {
                    return "text" === mode && (value = htmlSanitizeValue(value)), value
                },
                escape: function(value, mode) {
                    return "text" === mode && (value = htmlEscapeValue(value)), value
                },
                sanitizeParameters: function(value, mode) {
                    return "params" === mode && (value = mapInterpolationParameters(value, htmlSanitizeValue)), value
                },
                escapeParameters: function(value, mode) {
                    return "params" === mode && (value = mapInterpolationParameters(value, htmlEscapeValue)), value
                },
                sce: function(value, mode, context) {
                    return "text" === mode ? value = htmlTrustValue(value) : "params" === mode && "filter" !== context && (value = mapInterpolationParameters(value, htmlEscapeValue)), value
                },
                sceParameters: function(value, mode) {
                    return "params" === mode && (value = mapInterpolationParameters(value, htmlTrustValue)), value
                }
            }, strategies.escaped = strategies.escapeParameters, this.addStrategy = function(strategyName, strategyFunction) {
                return strategies[strategyName] = strategyFunction, this
            }, this.removeStrategy = function(strategyName) {
                return delete strategies[strategyName], this
            }, this.useStrategy = function(strategy) {
                return hasConfiguredStrategy = !0, currentStrategy = strategy, this
            }, this.$get = ["$injector", "$log", function($injector, $log) {
                var cachedStrategyMap = {},
                    applyStrategies = function(value, mode, context, selectedStrategies) {
                        return angular.forEach(selectedStrategies, function(selectedStrategy) {
                            if (angular.isFunction(selectedStrategy)) value = selectedStrategy(value, mode, context);
                            else if (angular.isFunction(strategies[selectedStrategy])) value = strategies[selectedStrategy](value, mode, context);
                            else {
                                if (!angular.isString(strategies[selectedStrategy])) throw new Error("pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: '" + selectedStrategy + "'");
                                if (!cachedStrategyMap[strategies[selectedStrategy]]) try {
                                    cachedStrategyMap[strategies[selectedStrategy]] = $injector.get(strategies[selectedStrategy])
                                } catch (e) {
                                    throw cachedStrategyMap[strategies[selectedStrategy]] = function() {}, new Error("pascalprecht.translate.$translateSanitization: Unknown sanitization strategy: '" + selectedStrategy + "'")
                                }
                                value = cachedStrategyMap[strategies[selectedStrategy]](value, mode, context)
                            }
                        }), value
                    },
                    showNoStrategyConfiguredWarning = function() {
                        hasConfiguredStrategy || hasShownNoStrategyConfiguredWarning || ($log.warn("pascalprecht.translate.$translateSanitization: No sanitization strategy has been configured. This can have serious security implications. See http://angular-translate.github.io/docs/#/guide/19_security for details."), hasShownNoStrategyConfiguredWarning = !0)
                    };
                return $injector.has("$sanitize") && ($sanitize = $injector.get("$sanitize")), $injector.has("$sce") && ($sce = $injector.get("$sce")), {
                    useStrategy: function(self) {
                        return function(strategy) {
                            self.useStrategy(strategy)
                        }
                    }(this),
                    sanitize: function(value, mode, strategy, context) {
                        if (currentStrategy || showNoStrategyConfiguredWarning(), strategy || null === strategy || (strategy = currentStrategy), !strategy) return value;
                        context || (context = "service");
                        var selectedStrategies = angular.isArray(strategy) ? strategy : [strategy];
                        return applyStrategies(value, mode, context, selectedStrategies)
                    }
                }
            }];
            var htmlEscapeValue = function(value) {
                    var element = angular.element("<div></div>");
                    return element.text(value), element.html()
                },
                htmlSanitizeValue = function(value) {
                    if (!$sanitize) throw new Error("pascalprecht.translate.$translateSanitization: Error cannot find $sanitize service. Either include the ngSanitize module (https://docs.angularjs.org/api/ngSanitize) or use a sanitization strategy which does not depend on $sanitize, such as 'escape'.");
                    return $sanitize(value)
                },
                htmlTrustValue = function(value) {
                    if (!$sce) throw new Error("pascalprecht.translate.$translateSanitization: Error cannot find $sce service.");
                    return $sce.trustAsHtml(value)
                },
                mapInterpolationParameters = function mapInterpolationParameters(value, iteratee, stack) {
                    if (angular.isDate(value)) return value;
                    if (angular.isObject(value)) {
                        var result = angular.isArray(value) ? [] : {};
                        if (stack) {
                            if (stack.indexOf(value) > -1) throw new Error("pascalprecht.translate.$translateSanitization: Error cannot interpolate parameter due recursive object")
                        } else stack = [];
                        return stack.push(value), angular.forEach(value, function(propertyValue, propertyKey) {
                            angular.isFunction(propertyValue) || (result[propertyKey] = mapInterpolationParameters(propertyValue, iteratee, stack))
                        }), stack.splice(-1, 1), result
                    }
                    return angular.isNumber(value) ? value : value === !0 || value === !1 ? value : angular.isUndefined(value) || null === value ? value : iteratee(value)
                }
        }

        function $translate($STORAGE_KEY, $windowProvider, $translateSanitizationProvider, pascalprechtTranslateOverrider) {
            "use strict";
            var $preferredLanguage, $languageKeyAliases, $fallbackLanguage, $fallbackWasString, $uses, $nextLang, $storageFactory, $storagePrefix, $missingTranslationHandlerFactory, $interpolationFactory, $loaderFactory, $loaderOptions, $notFoundIndicatorLeft, $notFoundIndicatorRight, loaderCache, postProcessFn, $translationTable = {},
                $availableLanguageKeys = [],
                $storageKey = $STORAGE_KEY,
                $interpolatorFactories = [],
                $cloakClassName = "translate-cloak",
                $postCompilingEnabled = !1,
                $forceAsyncReloadEnabled = !1,
                $nestedObjectDelimeter = ".",
                $isReady = !1,
                $keepContent = !1,
                directivePriority = 0,
                statefulFilter = !0,
                uniformLanguageTagResolver = "default",
                languageTagResolver = {
                    default: function(tag) {
                        return (tag || "").split("-").join("_")
                    },
                    java: function(tag) {
                        var temp = (tag || "").split("-").join("_"),
                            parts = temp.split("_");
                        return parts.length > 1 ? parts[0].toLowerCase() + "_" + parts[1].toUpperCase() : temp
                    },
                    bcp47: function(tag) {
                        var temp = (tag || "").split("_").join("-"),
                            parts = temp.split("-");
                        switch (parts.length) {
                            case 1:
                                parts[0] = parts[0].toLowerCase();
                                break;
                            case 2:
                                parts[0] = parts[0].toLowerCase(), 4 === parts[1].length ? parts[1] = parts[1].charAt(0).toUpperCase() + parts[1].slice(1).toLowerCase() : parts[1] = parts[1].toUpperCase();
                                break;
                            case 3:
                                parts[0] = parts[0].toLowerCase(), parts[1] = parts[1].charAt(0).toUpperCase() + parts[1].slice(1).toLowerCase(), parts[2] = parts[2].toUpperCase();
                                break;
                            default:
                                return temp
                        }
                        return parts.join("-")
                    },
                    "iso639-1": function(tag) {
                        var temp = (tag || "").split("_").join("-"),
                            parts = temp.split("-");
                        return parts[0].toLowerCase()
                    }
                },
                version = "2.18.1",
                getFirstBrowserLanguage = function() {
                    if (angular.isFunction(pascalprechtTranslateOverrider.getLocale)) return pascalprechtTranslateOverrider.getLocale();
                    var i, language, nav = $windowProvider.$get().navigator,
                        browserLanguagePropertyKeys = ["language", "browserLanguage", "systemLanguage", "userLanguage"];
                    if (angular.isArray(nav.languages))
                        for (i = 0; i < nav.languages.length; i++)
                            if (language = nav.languages[i], language && language.length) return language;
                    for (i = 0; i < browserLanguagePropertyKeys.length; i++)
                        if (language = nav[browserLanguagePropertyKeys[i]], language && language.length) return language;
                    return null
                };
            getFirstBrowserLanguage.displayName = "angular-translate/service: getFirstBrowserLanguage";
            var getLocale = function() {
                var locale = getFirstBrowserLanguage() || "";
                return languageTagResolver[uniformLanguageTagResolver] && (locale = languageTagResolver[uniformLanguageTagResolver](locale)), locale
            };
            getLocale.displayName = "angular-translate/service: getLocale";
            var indexOf = function(array, searchElement) {
                    for (var i = 0, len = array.length; i < len; i++)
                        if (array[i] === searchElement) return i;
                    return -1
                },
                trim = function() {
                    return this.toString().replace(/^\s+|\s+$/g, "")
                },
                lowercase = function(string) {
                    return angular.isString(string) ? string.toLowerCase() : string
                },
                negotiateLocale = function(preferred) {
                    if (preferred) {
                        for (var avail = [], locale = lowercase(preferred), i = 0, n = $availableLanguageKeys.length; i < n; i++) avail.push(lowercase($availableLanguageKeys[i]));
                        if (i = indexOf(avail, locale), i > -1) return $availableLanguageKeys[i];
                        if ($languageKeyAliases) {
                            var alias;
                            for (var langKeyAlias in $languageKeyAliases)
                                if ($languageKeyAliases.hasOwnProperty(langKeyAlias)) {
                                    var hasWildcardKey = !1,
                                        hasExactKey = Object.prototype.hasOwnProperty.call($languageKeyAliases, langKeyAlias) && lowercase(langKeyAlias) === lowercase(preferred);
                                    if ("*" === langKeyAlias.slice(-1) && (hasWildcardKey = lowercase(langKeyAlias.slice(0, -1)) === lowercase(preferred.slice(0, langKeyAlias.length - 1))), (hasExactKey || hasWildcardKey) && (alias = $languageKeyAliases[langKeyAlias], indexOf(avail, lowercase(alias)) > -1)) return alias
                                }
                        }
                        var parts = preferred.split("_");
                        return parts.length > 1 && indexOf(avail, lowercase(parts[0])) > -1 ? parts[0] : void 0;
                    }
                },
                translations = function(langKey, translationTable) {
                    if (!langKey && !translationTable) return $translationTable;
                    if (langKey && !translationTable) {
                        if (angular.isString(langKey)) return $translationTable[langKey]
                    } else angular.isObject($translationTable[langKey]) || ($translationTable[langKey] = {}), angular.extend($translationTable[langKey], flatObject(translationTable));
                    return this
                };
            this.translations = translations, this.cloakClassName = function(name) {
                return name ? ($cloakClassName = name, this) : $cloakClassName
            }, this.nestedObjectDelimeter = function(delimiter) {
                return delimiter ? ($nestedObjectDelimeter = delimiter, this) : $nestedObjectDelimeter
            };
            var flatObject = function flatObject(data, path, result, prevKey) {
                var key, keyWithPath, keyWithShortPath, val;
                path || (path = []), result || (result = {});
                for (key in data) Object.prototype.hasOwnProperty.call(data, key) && (val = data[key], angular.isObject(val) ? flatObject(val, path.concat(key), result, key) : (keyWithPath = path.length ? "" + path.join($nestedObjectDelimeter) + $nestedObjectDelimeter + key : key, path.length && key === prevKey && (keyWithShortPath = "" + path.join($nestedObjectDelimeter), result[keyWithShortPath] = "@:" + keyWithPath), result[keyWithPath] = val));
                return result
            };
            flatObject.displayName = "flatObject", this.addInterpolation = function(factory) {
                return $interpolatorFactories.push(factory), this
            }, this.useMessageFormatInterpolation = function() {
                return this.useInterpolation("$translateMessageFormatInterpolation")
            }, this.useInterpolation = function(factory) {
                return $interpolationFactory = factory, this
            }, this.useSanitizeValueStrategy = function(value) {
                return $translateSanitizationProvider.useStrategy(value), this
            }, this.preferredLanguage = function(langKey) {
                return langKey ? (setupPreferredLanguage(langKey), this) : $preferredLanguage
            };
            var setupPreferredLanguage = function(langKey) {
                return langKey && ($preferredLanguage = langKey), $preferredLanguage
            };
            this.translationNotFoundIndicator = function(indicator) {
                return this.translationNotFoundIndicatorLeft(indicator), this.translationNotFoundIndicatorRight(indicator), this
            }, this.translationNotFoundIndicatorLeft = function(indicator) {
                return indicator ? ($notFoundIndicatorLeft = indicator, this) : $notFoundIndicatorLeft
            }, this.translationNotFoundIndicatorRight = function(indicator) {
                return indicator ? ($notFoundIndicatorRight = indicator, this) : $notFoundIndicatorRight
            }, this.fallbackLanguage = function(langKey) {
                return fallbackStack(langKey), this
            };
            var fallbackStack = function(langKey) {
                return langKey ? (angular.isString(langKey) ? ($fallbackWasString = !0, $fallbackLanguage = [langKey]) : angular.isArray(langKey) && ($fallbackWasString = !1, $fallbackLanguage = langKey), angular.isString($preferredLanguage) && indexOf($fallbackLanguage, $preferredLanguage) < 0 && $fallbackLanguage.push($preferredLanguage), this) : $fallbackWasString ? $fallbackLanguage[0] : $fallbackLanguage
            };
            this.use = function(langKey) {
                if (langKey) {
                    if (!$translationTable[langKey] && !$loaderFactory) throw new Error("$translateProvider couldn't find translationTable for langKey: '" + langKey + "'");
                    return $uses = langKey, this
                }
                return $uses
            }, this.resolveClientLocale = function() {
                return getLocale()
            };
            var storageKey = function(key) {
                return key ? ($storageKey = key, this) : $storagePrefix ? $storagePrefix + $storageKey : $storageKey
            };
            this.storageKey = storageKey, this.useUrlLoader = function(url, options) {
                return this.useLoader("$translateUrlLoader", angular.extend({
                    url: url
                }, options))
            }, this.useStaticFilesLoader = function(options) {
                return this.useLoader("$translateStaticFilesLoader", options)
            }, this.useLoader = function(loaderFactory, options) {
                return $loaderFactory = loaderFactory, $loaderOptions = options || {}, this
            }, this.useLocalStorage = function() {
                return this.useStorage("$translateLocalStorage")
            }, this.useCookieStorage = function() {
                return this.useStorage("$translateCookieStorage")
            }, this.useStorage = function(storageFactory) {
                return $storageFactory = storageFactory, this
            }, this.storagePrefix = function(prefix) {
                return prefix ? ($storagePrefix = prefix, this) : prefix
            }, this.useMissingTranslationHandlerLog = function() {
                return this.useMissingTranslationHandler("$translateMissingTranslationHandlerLog")
            }, this.useMissingTranslationHandler = function(factory) {
                return $missingTranslationHandlerFactory = factory, this
            }, this.usePostCompiling = function(value) {
                return $postCompilingEnabled = !!value, this
            }, this.forceAsyncReload = function(value) {
                return $forceAsyncReloadEnabled = !!value, this
            }, this.uniformLanguageTag = function(options) {
                return options ? angular.isString(options) && (options = {
                    standard: options
                }) : options = {}, uniformLanguageTagResolver = options.standard, this
            }, this.determinePreferredLanguage = function(fn) {
                var locale = fn && angular.isFunction(fn) ? fn() : getLocale();
                return $preferredLanguage = $availableLanguageKeys.length ? negotiateLocale(locale) || locale : locale, this
            }, this.registerAvailableLanguageKeys = function(languageKeys, aliases) {
                return languageKeys ? ($availableLanguageKeys = languageKeys, aliases && ($languageKeyAliases = aliases), this) : $availableLanguageKeys
            }, this.useLoaderCache = function(cache) {
                return cache === !1 ? loaderCache = void 0 : cache === !0 ? loaderCache = !0 : "undefined" == typeof cache ? loaderCache = "$translationCache" : cache && (loaderCache = cache), this
            }, this.directivePriority = function(priority) {
                return void 0 === priority ? directivePriority : (directivePriority = priority, this)
            }, this.statefulFilter = function(state) {
                return void 0 === state ? statefulFilter : (statefulFilter = state, this)
            }, this.postProcess = function(fn) {
                return postProcessFn = fn ? fn : void 0, this
            }, this.keepContent = function(value) {
                return $keepContent = !!value, this
            }, this.$get = ["$log", "$injector", "$rootScope", "$q", function($log, $injector, $rootScope, $q) {
                var Storage, fallbackIndex, startFallbackIteration, defaultInterpolator = $injector.get($interpolationFactory || "$translateDefaultInterpolation"),
                    pendingLoader = !1,
                    interpolatorHashMap = {},
                    langPromises = {},
                    $translate = function $translate(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage, sanitizeStrategy) {
                        !$uses && $preferredLanguage && ($uses = $preferredLanguage);
                        var uses = forceLanguage && forceLanguage !== $uses ? negotiateLocale(forceLanguage) || forceLanguage : $uses;
                        if (forceLanguage && loadTranslationsIfMissing(forceLanguage), angular.isArray(translationId)) {
                            var translateAll = function(translationIds) {
                                for (var results = {}, promises = [], translate = function(translationId) {
                                        var deferred = $q.defer(),
                                            regardless = function(value) {
                                                results[translationId] = value, deferred.resolve([translationId, value])
                                            };
                                        return $translate(translationId, interpolateParams, interpolationId, defaultTranslationText, forceLanguage, sanitizeStrategy).then(regardless, regardless), deferred.promise
                                    }, i = 0, c = translationIds.length; i < c; i++) promises.push(translate(translationIds[i]));
                                return $q.all(promises).then(function() {
                                    return results
                                })
                            };
                            return translateAll(translationId)
                        }
                        var deferred = $q.defer();
                        translationId && (translationId = trim.apply(translationId));
                        var promiseToWaitFor = function() {
                            var promise = langPromises[uses] || langPromises[$preferredLanguage];
                            if (fallbackIndex = 0, $storageFactory && !promise) {
                                var langKey = Storage.get($storageKey);
                                if (promise = langPromises[langKey], $fallbackLanguage && $fallbackLanguage.length) {
                                    var index = indexOf($fallbackLanguage, langKey);
                                    fallbackIndex = 0 === index ? 1 : 0, indexOf($fallbackLanguage, $preferredLanguage) < 0 && $fallbackLanguage.push($preferredLanguage)
                                }
                            }
                            return promise
                        }();
                        if (promiseToWaitFor) {
                            var promiseResolved = function() {
                                forceLanguage || (uses = $uses), determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses, sanitizeStrategy).then(deferred.resolve, deferred.reject)
                            };
                            promiseResolved.displayName = "promiseResolved", promiseToWaitFor.finally(promiseResolved).catch(angular.noop)
                        } else determineTranslation(translationId, interpolateParams, interpolationId, defaultTranslationText, uses, sanitizeStrategy).then(deferred.resolve, deferred.reject);
                        return deferred.promise
                    },
                    applyNotFoundIndicators = function(translationId) {
                        return $notFoundIndicatorLeft && (translationId = [$notFoundIndicatorLeft, translationId].join(" ")), $notFoundIndicatorRight && (translationId = [translationId, $notFoundIndicatorRight].join(" ")), translationId
                    },
                    useLanguage = function(key) {
                        $uses = key, $storageFactory && Storage.put($translate.storageKey(), $uses), $rootScope.$emit("$translateChangeSuccess", {
                            language: key
                        }), defaultInterpolator.setLocale($uses);
                        var eachInterpolator = function(interpolator, id) {
                            interpolatorHashMap[id].setLocale($uses)
                        };
                        eachInterpolator.displayName = "eachInterpolatorLocaleSetter", angular.forEach(interpolatorHashMap, eachInterpolator), $rootScope.$emit("$translateChangeEnd", {
                            language: key
                        })
                    },
                    loadAsync = function(key) {
                        if (!key) throw "No language key specified for loading.";
                        var deferred = $q.defer();
                        $rootScope.$emit("$translateLoadingStart", {
                            language: key
                        }), pendingLoader = !0;
                        var cache = loaderCache;
                        "string" == typeof cache && (cache = $injector.get(cache));
                        var loaderOptions = angular.extend({}, $loaderOptions, {
                                key: key,
                                $http: angular.extend({}, {
                                    cache: cache
                                }, $loaderOptions.$http)
                            }),
                            onLoaderSuccess = function(data) {
                                var translationTable = {};
                                $rootScope.$emit("$translateLoadingSuccess", {
                                    language: key
                                }), angular.isArray(data) ? angular.forEach(data, function(table) {
                                    angular.extend(translationTable, flatObject(table))
                                }) : angular.extend(translationTable, flatObject(data)), pendingLoader = !1, deferred.resolve({
                                    key: key,
                                    table: translationTable
                                }), $rootScope.$emit("$translateLoadingEnd", {
                                    language: key
                                })
                            };
                        onLoaderSuccess.displayName = "onLoaderSuccess";
                        var onLoaderError = function(key) {
                            $rootScope.$emit("$translateLoadingError", {
                                language: key
                            }), deferred.reject(key), $rootScope.$emit("$translateLoadingEnd", {
                                language: key
                            })
                        };
                        return onLoaderError.displayName = "onLoaderError", $injector.get($loaderFactory)(loaderOptions).then(onLoaderSuccess, onLoaderError), deferred.promise
                    };
                if ($storageFactory && (Storage = $injector.get($storageFactory), !Storage.get || !Storage.put)) throw new Error("Couldn't use storage '" + $storageFactory + "', missing get() or put() method!");
                if ($interpolatorFactories.length) {
                    var eachInterpolationFactory = function(interpolatorFactory) {
                        var interpolator = $injector.get(interpolatorFactory);
                        interpolator.setLocale($preferredLanguage || $uses), interpolatorHashMap[interpolator.getInterpolationIdentifier()] = interpolator
                    };
                    eachInterpolationFactory.displayName = "interpolationFactoryAdder", angular.forEach($interpolatorFactories, eachInterpolationFactory)
                }
                var getTranslationTable = function(langKey) {
                        var deferred = $q.defer();
                        if (Object.prototype.hasOwnProperty.call($translationTable, langKey)) deferred.resolve($translationTable[langKey]);
                        else if (langPromises[langKey]) {
                            var onResolve = function(data) {
                                translations(data.key, data.table), deferred.resolve(data.table)
                            };
                            onResolve.displayName = "translationTableResolver", langPromises[langKey].then(onResolve, deferred.reject)
                        } else deferred.reject();
                        return deferred.promise
                    },
                    getFallbackTranslation = function getFallbackTranslation(langKey, translationId, interpolateParams, Interpolator, sanitizeStrategy) {
                        var deferred = $q.defer(),
                            onResolve = function(translationTable) {
                                if (Object.prototype.hasOwnProperty.call(translationTable, translationId) && null !== translationTable[translationId]) {
                                    Interpolator.setLocale(langKey);
                                    var translation = translationTable[translationId];
                                    if ("@:" === translation.substr(0, 2)) getFallbackTranslation(langKey, translation.substr(2), interpolateParams, Interpolator, sanitizeStrategy).then(deferred.resolve, deferred.reject);
                                    else {
                                        var interpolatedValue = Interpolator.interpolate(translationTable[translationId], interpolateParams, "service", sanitizeStrategy, translationId);
                                        interpolatedValue = applyPostProcessing(translationId, translationTable[translationId], interpolatedValue, interpolateParams, langKey), deferred.resolve(interpolatedValue)
                                    }
                                    Interpolator.setLocale($uses)
                                } else deferred.reject()
                            };
                        return onResolve.displayName = "fallbackTranslationResolver", getTranslationTable(langKey).then(onResolve, deferred.reject), deferred.promise
                    },
                    getFallbackTranslationInstant = function getFallbackTranslationInstant(langKey, translationId, interpolateParams, Interpolator, sanitizeStrategy) {
                        var result, translationTable = $translationTable[langKey];
                        if (translationTable && Object.prototype.hasOwnProperty.call(translationTable, translationId) && null !== translationTable[translationId]) {
                            if (Interpolator.setLocale(langKey), result = Interpolator.interpolate(translationTable[translationId], interpolateParams, "filter", sanitizeStrategy, translationId), result = applyPostProcessing(translationId, translationTable[translationId], result, interpolateParams, langKey, sanitizeStrategy), !angular.isString(result) && angular.isFunction(result.$$unwrapTrustedValue)) {
                                var result2 = result.$$unwrapTrustedValue();
                                if ("@:" === result2.substr(0, 2)) return getFallbackTranslationInstant(langKey, result2.substr(2), interpolateParams, Interpolator, sanitizeStrategy)
                            } else if ("@:" === result.substr(0, 2)) return getFallbackTranslationInstant(langKey, result.substr(2), interpolateParams, Interpolator, sanitizeStrategy);
                            Interpolator.setLocale($uses)
                        }
                        return result
                    },
                    translateByHandler = function(translationId, interpolateParams, defaultTranslationText, sanitizeStrategy) {
                        return $missingTranslationHandlerFactory ? $injector.get($missingTranslationHandlerFactory)(translationId, $uses, interpolateParams, defaultTranslationText, sanitizeStrategy) : translationId
                    },
                    resolveForFallbackLanguage = function resolveForFallbackLanguage(fallbackLanguageIndex, translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy) {
                        var deferred = $q.defer();
                        if (fallbackLanguageIndex < $fallbackLanguage.length) {
                            var langKey = $fallbackLanguage[fallbackLanguageIndex];
                            getFallbackTranslation(langKey, translationId, interpolateParams, Interpolator, sanitizeStrategy).then(function(data) {
                                deferred.resolve(data)
                            }, function() {
                                return resolveForFallbackLanguage(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy).then(deferred.resolve, deferred.reject)
                            })
                        } else if (defaultTranslationText) deferred.resolve(defaultTranslationText);
                        else {
                            var missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, defaultTranslationText);
                            $missingTranslationHandlerFactory && missingTranslationHandlerTranslation ? deferred.resolve(missingTranslationHandlerTranslation) : deferred.reject(applyNotFoundIndicators(translationId))
                        }
                        return deferred.promise
                    },
                    resolveForFallbackLanguageInstant = function resolveForFallbackLanguageInstant(fallbackLanguageIndex, translationId, interpolateParams, Interpolator, sanitizeStrategy) {
                        var result;
                        if (fallbackLanguageIndex < $fallbackLanguage.length) {
                            var langKey = $fallbackLanguage[fallbackLanguageIndex];
                            result = getFallbackTranslationInstant(langKey, translationId, interpolateParams, Interpolator, sanitizeStrategy), result || "" === result || (result = resolveForFallbackLanguageInstant(fallbackLanguageIndex + 1, translationId, interpolateParams, Interpolator))
                        }
                        return result
                    },
                    fallbackTranslation = function(translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy) {
                        return resolveForFallbackLanguage(startFallbackIteration > 0 ? startFallbackIteration : fallbackIndex, translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy)
                    },
                    fallbackTranslationInstant = function(translationId, interpolateParams, Interpolator, sanitizeStrategy) {
                        return resolveForFallbackLanguageInstant(startFallbackIteration > 0 ? startFallbackIteration : fallbackIndex, translationId, interpolateParams, Interpolator, sanitizeStrategy)
                    },
                    determineTranslation = function(translationId, interpolateParams, interpolationId, defaultTranslationText, uses, sanitizeStrategy) {
                        var deferred = $q.defer(),
                            table = uses ? $translationTable[uses] : $translationTable,
                            Interpolator = interpolationId ? interpolatorHashMap[interpolationId] : defaultInterpolator;
                        if (table && Object.prototype.hasOwnProperty.call(table, translationId) && null !== table[translationId]) {
                            var translation = table[translationId];
                            if ("@:" === translation.substr(0, 2)) $translate(translation.substr(2), interpolateParams, interpolationId, defaultTranslationText, uses, sanitizeStrategy).then(deferred.resolve, deferred.reject);
                            else {
                                var resolvedTranslation = Interpolator.interpolate(translation, interpolateParams, "service", sanitizeStrategy, translationId);
                                resolvedTranslation = applyPostProcessing(translationId, translation, resolvedTranslation, interpolateParams, uses), deferred.resolve(resolvedTranslation)
                            }
                        } else {
                            var missingTranslationHandlerTranslation;
                            $missingTranslationHandlerFactory && !pendingLoader && (missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, defaultTranslationText)), uses && $fallbackLanguage && $fallbackLanguage.length ? fallbackTranslation(translationId, interpolateParams, Interpolator, defaultTranslationText, sanitizeStrategy).then(function(translation) {
                                deferred.resolve(translation)
                            }, function(_translationId) {
                                deferred.reject(applyNotFoundIndicators(_translationId))
                            }) : $missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation ? defaultTranslationText ? deferred.resolve(defaultTranslationText) : deferred.resolve(missingTranslationHandlerTranslation) : defaultTranslationText ? deferred.resolve(defaultTranslationText) : deferred.reject(applyNotFoundIndicators(translationId))
                        }
                        return deferred.promise
                    },
                    determineTranslationInstant = function determineTranslationInstant(translationId, interpolateParams, interpolationId, uses, sanitizeStrategy) {
                        var result, table = uses ? $translationTable[uses] : $translationTable,
                            Interpolator = defaultInterpolator;
                        if (interpolatorHashMap && Object.prototype.hasOwnProperty.call(interpolatorHashMap, interpolationId) && (Interpolator = interpolatorHashMap[interpolationId]), table && Object.prototype.hasOwnProperty.call(table, translationId) && null !== table[translationId]) {
                            var translation = table[translationId];
                            "@:" === translation.substr(0, 2) ? result = determineTranslationInstant(translation.substr(2), interpolateParams, interpolationId, uses, sanitizeStrategy) : (result = Interpolator.interpolate(translation, interpolateParams, "filter", sanitizeStrategy, translationId), result = applyPostProcessing(translationId, translation, result, interpolateParams, uses, sanitizeStrategy))
                        } else {
                            var missingTranslationHandlerTranslation;
                            $missingTranslationHandlerFactory && !pendingLoader && (missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, sanitizeStrategy)), uses && $fallbackLanguage && $fallbackLanguage.length ? (fallbackIndex = 0, result = fallbackTranslationInstant(translationId, interpolateParams, Interpolator, sanitizeStrategy)) : result = $missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation ? missingTranslationHandlerTranslation : applyNotFoundIndicators(translationId)
                        }
                        return result
                    },
                    clearNextLangAndPromise = function(key) {
                        $nextLang === key && ($nextLang = void 0), langPromises[key] = void 0
                    },
                    applyPostProcessing = function(translationId, translation, resolvedTranslation, interpolateParams, uses, sanitizeStrategy) {
                        var fn = postProcessFn;
                        return fn && ("string" == typeof fn && (fn = $injector.get(fn)), fn) ? fn(translationId, translation, resolvedTranslation, interpolateParams, uses, sanitizeStrategy) : resolvedTranslation
                    },
                    loadTranslationsIfMissing = function(key) {
                        $translationTable[key] || !$loaderFactory || langPromises[key] || (langPromises[key] = loadAsync(key).then(function(translation) {
                            return translations(translation.key, translation.table), translation
                        }))
                    };
                $translate.preferredLanguage = function(langKey) {
                    return langKey && setupPreferredLanguage(langKey), $preferredLanguage
                }, $translate.cloakClassName = function() {
                    return $cloakClassName
                }, $translate.nestedObjectDelimeter = function() {
                    return $nestedObjectDelimeter
                }, $translate.fallbackLanguage = function(langKey) {
                    if (void 0 !== langKey && null !== langKey) {
                        if (fallbackStack(langKey), $loaderFactory && $fallbackLanguage && $fallbackLanguage.length)
                            for (var i = 0, len = $fallbackLanguage.length; i < len; i++) langPromises[$fallbackLanguage[i]] || (langPromises[$fallbackLanguage[i]] = loadAsync($fallbackLanguage[i]));
                        $translate.use($translate.use())
                    }
                    return $fallbackWasString ? $fallbackLanguage[0] : $fallbackLanguage
                }, $translate.useFallbackLanguage = function(langKey) {
                    if (void 0 !== langKey && null !== langKey)
                        if (langKey) {
                            var langKeyPosition = indexOf($fallbackLanguage, langKey);
                            langKeyPosition > -1 && (startFallbackIteration = langKeyPosition)
                        } else startFallbackIteration = 0
                }, $translate.proposedLanguage = function() {
                    return $nextLang
                }, $translate.storage = function() {
                    return Storage
                }, $translate.negotiateLocale = negotiateLocale, $translate.use = function(key) {
                    if (!key) return $uses;
                    var deferred = $q.defer();
                    deferred.promise.then(null, angular.noop), $rootScope.$emit("$translateChangeStart", {
                        language: key
                    });
                    var aliasedKey = negotiateLocale(key);
                    return $availableLanguageKeys.length > 0 && !aliasedKey ? $q.reject(key) : (aliasedKey && (key = aliasedKey), $nextLang = key, !$forceAsyncReloadEnabled && $translationTable[key] || !$loaderFactory || langPromises[key] ? langPromises[key] ? langPromises[key].then(function(translation) {
                        return $nextLang === translation.key && useLanguage(translation.key), deferred.resolve(translation.key), translation
                    }, function(key) {
                        return !$uses && $fallbackLanguage && $fallbackLanguage.length > 0 && $fallbackLanguage[0] !== key ? $translate.use($fallbackLanguage[0]).then(deferred.resolve, deferred.reject) : deferred.reject(key)
                    }) : (deferred.resolve(key), useLanguage(key)) : (langPromises[key] = loadAsync(key).then(function(translation) {
                        return translations(translation.key, translation.table), deferred.resolve(translation.key), $nextLang === key && useLanguage(translation.key), translation
                    }, function(key) {
                        return $rootScope.$emit("$translateChangeError", {
                            language: key
                        }), deferred.reject(key), $rootScope.$emit("$translateChangeEnd", {
                            language: key
                        }), $q.reject(key)
                    }), langPromises[key].finally(function() {
                        clearNextLangAndPromise(key)
                    }).catch(angular.noop)), deferred.promise)
                }, $translate.resolveClientLocale = function() {
                    return getLocale()
                }, $translate.storageKey = function() {
                    return storageKey()
                }, $translate.isPostCompilingEnabled = function() {
                    return $postCompilingEnabled
                }, $translate.isForceAsyncReloadEnabled = function() {
                    return $forceAsyncReloadEnabled
                }, $translate.isKeepContent = function() {
                    return $keepContent
                }, $translate.refresh = function(langKey) {
                    function loadNewData(languageKey) {
                        var promise = loadAsync(languageKey);
                        return langPromises[languageKey] = promise, promise.then(function(data) {
                            $translationTable[languageKey] = {}, translations(languageKey, data.table), updatedLanguages[languageKey] = !0
                        }, angular.noop), promise
                    }
                    if (!$loaderFactory) throw new Error("Couldn't refresh translation table, no loader registered!");
                    $rootScope.$emit("$translateRefreshStart", {
                        language: langKey
                    });
                    var deferred = $q.defer(),
                        updatedLanguages = {};
                    if (deferred.promise.then(function() {
                            for (var key in $translationTable) $translationTable.hasOwnProperty(key) && (key in updatedLanguages || delete $translationTable[key]);
                            $uses && useLanguage($uses)
                        }, angular.noop).finally(function() {
                            $rootScope.$emit("$translateRefreshEnd", {
                                language: langKey
                            })
                        }), langKey) $translationTable[langKey] ? loadNewData(langKey).then(deferred.resolve, deferred.reject) : deferred.reject();
                    else {
                        var languagesToReload = $fallbackLanguage && $fallbackLanguage.slice() || [];
                        $uses && languagesToReload.indexOf($uses) === -1 && languagesToReload.push($uses), $q.all(languagesToReload.map(loadNewData)).then(deferred.resolve, deferred.reject)
                    }
                    return deferred.promise
                }, $translate.instant = function(translationId, interpolateParams, interpolationId, forceLanguage, sanitizeStrategy) {
                    var uses = forceLanguage && forceLanguage !== $uses ? negotiateLocale(forceLanguage) || forceLanguage : $uses;
                    if (null === translationId || angular.isUndefined(translationId)) return translationId;
                    if (forceLanguage && loadTranslationsIfMissing(forceLanguage), angular.isArray(translationId)) {
                        for (var results = {}, i = 0, c = translationId.length; i < c; i++) results[translationId[i]] = $translate.instant(translationId[i], interpolateParams, interpolationId, forceLanguage, sanitizeStrategy);
                        return results
                    }
                    if (angular.isString(translationId) && translationId.length < 1) return translationId;
                    translationId && (translationId = trim.apply(translationId));
                    var result, possibleLangKeys = [];
                    $preferredLanguage && possibleLangKeys.push($preferredLanguage), uses && possibleLangKeys.push(uses), $fallbackLanguage && $fallbackLanguage.length && (possibleLangKeys = possibleLangKeys.concat($fallbackLanguage));
                    for (var j = 0, d = possibleLangKeys.length; j < d; j++) {
                        var possibleLangKey = possibleLangKeys[j];
                        if ($translationTable[possibleLangKey] && "undefined" != typeof $translationTable[possibleLangKey][translationId] && (result = determineTranslationInstant(translationId, interpolateParams, interpolationId, uses, sanitizeStrategy)), "undefined" != typeof result) break
                    }
                    if (!result && "" !== result)
                        if ($notFoundIndicatorLeft || $notFoundIndicatorRight) result = applyNotFoundIndicators(translationId);
                        else {
                            result = defaultInterpolator.interpolate(translationId, interpolateParams, "filter", sanitizeStrategy);
                            var missingTranslationHandlerTranslation;
                            $missingTranslationHandlerFactory && !pendingLoader && (missingTranslationHandlerTranslation = translateByHandler(translationId, interpolateParams, sanitizeStrategy)), $missingTranslationHandlerFactory && !pendingLoader && missingTranslationHandlerTranslation && (result = missingTranslationHandlerTranslation)
                        } return result
                }, $translate.versionInfo = function() {
                    return version
                }, $translate.loaderCache = function() {
                    return loaderCache
                }, $translate.directivePriority = function() {
                    return directivePriority
                }, $translate.statefulFilter = function() {
                    return statefulFilter
                }, $translate.isReady = function() {
                    return $isReady
                };
                var $onReadyDeferred = $q.defer();
                $onReadyDeferred.promise.then(function() {
                    $isReady = !0
                }), $translate.onReady = function(fn) {
                    var deferred = $q.defer();
                    return angular.isFunction(fn) && deferred.promise.then(fn), $isReady ? deferred.resolve() : $onReadyDeferred.promise.then(deferred.resolve), deferred.promise
                }, $translate.getAvailableLanguageKeys = function() {
                    return $availableLanguageKeys.length > 0 ? $availableLanguageKeys : null
                }, $translate.getTranslationTable = function(langKey) {
                    return langKey = langKey || $translate.use(), langKey && $translationTable[langKey] ? angular.copy($translationTable[langKey]) : null
                };
                var globalOnReadyListener = $rootScope.$on("$translateReady", function() {
                        $onReadyDeferred.resolve(), globalOnReadyListener(), globalOnReadyListener = null
                    }),
                    globalOnChangeListener = $rootScope.$on("$translateChangeEnd", function() {
                        $onReadyDeferred.resolve(), globalOnChangeListener(), globalOnChangeListener = null
                    });
                if ($loaderFactory) {
                    if (angular.equals($translationTable, {}) && $translate.use() && $translate.use($translate.use()), $fallbackLanguage && $fallbackLanguage.length)
                        for (var processAsyncResult = function(translation) {
                                return translations(translation.key, translation.table), $rootScope.$emit("$translateChangeEnd", {
                                    language: translation.key
                                }), translation
                            }, i = 0, len = $fallbackLanguage.length; i < len; i++) {
                            var fallbackLanguageId = $fallbackLanguage[i];
                            !$forceAsyncReloadEnabled && $translationTable[fallbackLanguageId] || (langPromises[fallbackLanguageId] = loadAsync(fallbackLanguageId).then(processAsyncResult))
                        }
                } else $rootScope.$emit("$translateReady", {
                    language: $translate.use()
                });
                return $translate
            }]
        }

        function $translateDefaultInterpolation($interpolate, $translateSanitization) {
            "use strict";
            var $locale, $translateInterpolator = {},
                $identifier = "default";
            return $translateInterpolator.setLocale = function(locale) {
                $locale = locale
            }, $translateInterpolator.getInterpolationIdentifier = function() {
                return $identifier
            }, $translateInterpolator.useSanitizeValueStrategy = function(value) {
                return $translateSanitization.useStrategy(value), this
            }, $translateInterpolator.interpolate = function(value, interpolationParams, context, sanitizeStrategy, translationId) {
                interpolationParams = interpolationParams || {}, interpolationParams = $translateSanitization.sanitize(interpolationParams, "params", sanitizeStrategy, context);
                var interpolatedText;
                return angular.isNumber(value) ? interpolatedText = "" + value : angular.isString(value) ? (interpolatedText = $interpolate(value)(interpolationParams), interpolatedText = $translateSanitization.sanitize(interpolatedText, "text", sanitizeStrategy, context)) : interpolatedText = "", interpolatedText
            }, $translateInterpolator
        }

        function translateDirective($translate, $interpolate, $compile, $parse, $rootScope) {
            "use strict";
            var trim = function() {
                    return this.toString().replace(/^\s+|\s+$/g, "")
                },
                lowercase = function(string) {
                    return angular.isString(string) ? string.toLowerCase() : string
                };
            return {
                restrict: "AE",
                scope: !0,
                priority: $translate.directivePriority(),
                compile: function(tElement, tAttr) {
                    var translateValuesExist = tAttr.translateValues ? tAttr.translateValues : void 0,
                        translateInterpolation = tAttr.translateInterpolation ? tAttr.translateInterpolation : void 0,
                        translateSanitizeStrategyExist = tAttr.translateSanitizeStrategy ? tAttr.translateSanitizeStrategy : void 0,
                        translateValueExist = tElement[0].outerHTML.match(/translate-value-+/i),
                        interpolateRegExp = "^(.*)(" + $interpolate.startSymbol() + ".*" + $interpolate.endSymbol() + ")(.*)",
                        watcherRegExp = "^(.*)" + $interpolate.startSymbol() + "(.*)" + $interpolate.endSymbol() + "(.*)";
                    return function(scope, iElement, iAttr) {
                        scope.interpolateParams = {}, scope.preText = "", scope.postText = "", scope.translateNamespace = getTranslateNamespace(scope);
                        var translationIds = {},
                            initInterpolationParams = function(interpolateParams, iAttr, tAttr) {
                                if (iAttr.translateValues && angular.extend(interpolateParams, $parse(iAttr.translateValues)(scope.$parent)), translateValueExist)
                                    for (var attr in tAttr)
                                        if (Object.prototype.hasOwnProperty.call(iAttr, attr) && "translateValue" === attr.substr(0, 14) && "translateValues" !== attr) {
                                            var attributeName = lowercase(attr.substr(14, 1)) + attr.substr(15);
                                            interpolateParams[attributeName] = tAttr[attr]
                                        }
                            },
                            observeElementTranslation = function observeElementTranslation(translationId) {
                                if (angular.isFunction(observeElementTranslation._unwatchOld) && (observeElementTranslation._unwatchOld(), observeElementTranslation._unwatchOld = void 0), angular.equals(translationId, "") || !angular.isDefined(translationId)) {
                                    var iElementText = trim.apply(iElement.text()),
                                        interpolateMatches = iElementText.match(interpolateRegExp);
                                    if (angular.isArray(interpolateMatches)) {
                                        scope.preText = interpolateMatches[1], scope.postText = interpolateMatches[3], translationIds.translate = $interpolate(interpolateMatches[2])(scope.$parent);
                                        var watcherMatches = iElementText.match(watcherRegExp);
                                        angular.isArray(watcherMatches) && watcherMatches[2] && watcherMatches[2].length && (observeElementTranslation._unwatchOld = scope.$watch(watcherMatches[2], function(newValue) {
                                            translationIds.translate = newValue, updateTranslations()
                                        }))
                                    } else translationIds.translate = iElementText ? iElementText : void 0
                                } else translationIds.translate = translationId;
                                updateTranslations()
                            },
                            observeAttributeTranslation = function(translateAttr) {
                                iAttr.$observe(translateAttr, function(translationId) {
                                    translationIds[translateAttr] = translationId, updateTranslations()
                                })
                            };
                        initInterpolationParams(scope.interpolateParams, iAttr, tAttr);
                        var firstAttributeChangedEvent = !0;
                        iAttr.$observe("translate", function(translationId) {
                            "undefined" == typeof translationId ? observeElementTranslation("") : "" === translationId && firstAttributeChangedEvent || (translationIds.translate = translationId, updateTranslations()), firstAttributeChangedEvent = !1
                        });
                        for (var translateAttr in iAttr) iAttr.hasOwnProperty(translateAttr) && "translateAttr" === translateAttr.substr(0, 13) && translateAttr.length > 13 && observeAttributeTranslation(translateAttr);
                        if (iAttr.$observe("translateDefault", function(value) {
                                scope.defaultText = value, updateTranslations()
                            }), translateSanitizeStrategyExist && iAttr.$observe("translateSanitizeStrategy", function(value) {
                                scope.sanitizeStrategy = $parse(value)(scope.$parent), updateTranslations()
                            }), translateValuesExist && iAttr.$observe("translateValues", function(interpolateParams) {
                                interpolateParams && scope.$parent.$watch(function() {
                                    angular.extend(scope.interpolateParams, $parse(interpolateParams)(scope.$parent))
                                })
                            }), translateValueExist) {
                            var observeValueAttribute = function(attrName) {
                                iAttr.$observe(attrName, function(value) {
                                    var attributeName = lowercase(attrName.substr(14, 1)) + attrName.substr(15);
                                    scope.interpolateParams[attributeName] = value
                                })
                            };
                            for (var attr in iAttr) Object.prototype.hasOwnProperty.call(iAttr, attr) && "translateValue" === attr.substr(0, 14) && "translateValues" !== attr && observeValueAttribute(attr)
                        }
                        var updateTranslations = function() {
                                for (var key in translationIds) translationIds.hasOwnProperty(key) && void 0 !== translationIds[key] && updateTranslation(key, translationIds[key], scope, scope.interpolateParams, scope.defaultText, scope.translateNamespace)
                            },
                            updateTranslation = function(translateAttr, translationId, scope, interpolateParams, defaultTranslationText, translateNamespace) {
                                translationId ? (translateNamespace && "." === translationId.charAt(0) && (translationId = translateNamespace + translationId), $translate(translationId, interpolateParams, translateInterpolation, defaultTranslationText, scope.translateLanguage, scope.sanitizeStrategy).then(function(translation) {
                                    applyTranslation(translation, scope, !0, translateAttr)
                                }, function(translationId) {
                                    applyTranslation(translationId, scope, !1, translateAttr)
                                })) : applyTranslation(translationId, scope, !1, translateAttr)
                            },
                            applyTranslation = function(value, scope, successful, translateAttr) {
                                if (successful || "undefined" != typeof scope.defaultText && (value = scope.defaultText), "translate" === translateAttr) {
                                    (successful || !successful && !$translate.isKeepContent() && "undefined" == typeof iAttr.translateKeepContent) && iElement.empty().append(scope.preText + value + scope.postText);
                                    var globallyEnabled = $translate.isPostCompilingEnabled(),
                                        locallyDefined = "undefined" != typeof tAttr.translateCompile,
                                        locallyEnabled = locallyDefined && "false" !== tAttr.translateCompile;
                                    (globallyEnabled && !locallyDefined || locallyEnabled) && $compile(iElement.contents())(scope)
                                } else {
                                    var attributeName = iAttr.$attr[translateAttr];
                                    "data-" === attributeName.substr(0, 5) && (attributeName = attributeName.substr(5)), attributeName = attributeName.substr(15), iElement.attr(attributeName, value)
                                }
                            };
                        (translateValuesExist || translateValueExist || iAttr.translateDefault) && scope.$watch("interpolateParams", updateTranslations, !0), scope.$on("translateLanguageChanged", updateTranslations);
                        var unbind = $rootScope.$on("$translateChangeSuccess", updateTranslations);
                        iElement.text().length ? observeElementTranslation(iAttr.translate ? iAttr.translate : "") : iAttr.translate && observeElementTranslation(iAttr.translate), updateTranslations(), scope.$on("$destroy", unbind)
                    }
                }
            }
        }

        function getTranslateNamespace(scope) {
            "use strict";
            return scope.translateNamespace ? scope.translateNamespace : scope.$parent ? getTranslateNamespace(scope.$parent) : void 0
        }

        function translateAttrDirective($translate, $rootScope) {
            "use strict";
            return {
                restrict: "A",
                priority: $translate.directivePriority(),
                link: function(scope, element, attr) {
                    var translateAttr, translateValues, translateSanitizeStrategy, previousAttributes = {},
                        updateTranslations = function() {
                            angular.forEach(translateAttr, function(translationId, attributeName) {
                                translationId && (previousAttributes[attributeName] = !0, scope.translateNamespace && "." === translationId.charAt(0) && (translationId = scope.translateNamespace + translationId), $translate(translationId, translateValues, attr.translateInterpolation, void 0, scope.translateLanguage, translateSanitizeStrategy).then(function(translation) {
                                    element.attr(attributeName, translation)
                                }, function(translationId) {
                                    element.attr(attributeName, translationId)
                                }))
                            }), angular.forEach(previousAttributes, function(flag, attributeName) {
                                translateAttr[attributeName] || (element.removeAttr(attributeName), delete previousAttributes[attributeName])
                            })
                        };
                    watchAttribute(scope, attr.translateAttr, function(newValue) {
                        translateAttr = newValue
                    }, updateTranslations), watchAttribute(scope, attr.translateValues, function(newValue) {
                        translateValues = newValue
                    }, updateTranslations), watchAttribute(scope, attr.translateSanitizeStrategy, function(newValue) {
                        translateSanitizeStrategy = newValue
                    }, updateTranslations), attr.translateValues && scope.$watch(attr.translateValues, updateTranslations, !0), scope.$on("translateLanguageChanged", updateTranslations);
                    var unbind = $rootScope.$on("$translateChangeSuccess", updateTranslations);
                    updateTranslations(), scope.$on("$destroy", unbind)
                }
            }
        }

        function watchAttribute(scope, attribute, valueCallback, changeCallback) {
            "use strict";
            attribute && ("::" === attribute.substr(0, 2) ? attribute = attribute.substr(2) : scope.$watch(attribute, function(newValue) {
                valueCallback(newValue), changeCallback()
            }, !0), valueCallback(scope.$eval(attribute)))
        }

        function translateCloakDirective($translate, $rootScope) {
            "use strict";
            return {
                compile: function(tElement) {
                    var applyCloak = function(element) {
                            element.addClass($translate.cloakClassName())
                        },
                        removeCloak = function(element) {
                            element.removeClass($translate.cloakClassName())
                        };
                    return applyCloak(tElement),
                        function(scope, iElement, iAttr) {
                            var iRemoveCloak = removeCloak.bind(this, iElement),
                                iApplyCloak = applyCloak.bind(this, iElement);
                            iAttr.translateCloak && iAttr.translateCloak.length ? (iAttr.$observe("translateCloak", function(translationId) {
                                $translate(translationId).then(iRemoveCloak, iApplyCloak)
                            }), $rootScope.$on("$translateChangeSuccess", function() {
                                $translate(iAttr.translateCloak).then(iRemoveCloak, iApplyCloak)
                            })) : $translate.onReady(iRemoveCloak)
                        }
                }
            }
        }

        function translateNamespaceDirective() {
            "use strict";
            return {
                restrict: "A",
                scope: !0,
                compile: function() {
                    return {
                        pre: function(scope, iElement, iAttrs) {
                            scope.translateNamespace = _getTranslateNamespace(scope), scope.translateNamespace && "." === iAttrs.translateNamespace.charAt(0) ? scope.translateNamespace += iAttrs.translateNamespace : scope.translateNamespace = iAttrs.translateNamespace
                        }
                    }
                }
            }
        }

        function _getTranslateNamespace(scope) {
            "use strict";
            return scope.translateNamespace ? scope.translateNamespace : scope.$parent ? _getTranslateNamespace(scope.$parent) : void 0
        }

        function translateLanguageDirective() {
            "use strict";
            return {
                restrict: "A",
                scope: !0,
                compile: function() {
                    return function(scope, iElement, iAttrs) {
                        iAttrs.$observe("translateLanguage", function(newTranslateLanguage) {
                            scope.translateLanguage = newTranslateLanguage
                        }), scope.$watch("translateLanguage", function() {
                            scope.$broadcast("translateLanguageChanged")
                        })
                    }
                }
            }
        }

        function translateFilterFactory($parse, $translate) {
            "use strict";
            var translateFilter = function(translationId, interpolateParams, interpolation, forceLanguage) {
                if (!angular.isObject(interpolateParams)) {
                    var ctx = this || {
                        __SCOPE_IS_NOT_AVAILABLE: "More info at https://github.com/angular/angular.js/commit/8863b9d04c722b278fa93c5d66ad1e578ad6eb1f"
                    };
                    interpolateParams = $parse(interpolateParams)(ctx)
                }
                return $translate.instant(translationId, interpolateParams, interpolation, forceLanguage)
            };
            return $translate.statefulFilter() && (translateFilter.$stateful = !0), translateFilter
        }

        function $translationCache($cacheFactory) {
            "use strict";
            return $cacheFactory("translations")
        }
        return runTranslate.$inject = ["$translate"], $translate.$inject = ["$STORAGE_KEY", "$windowProvider", "$translateSanitizationProvider", "pascalprechtTranslateOverrider"], $translateDefaultInterpolation.$inject = ["$interpolate", "$translateSanitization"], translateDirective.$inject = ["$translate", "$interpolate", "$compile", "$parse", "$rootScope"], translateAttrDirective.$inject = ["$translate", "$rootScope"], translateCloakDirective.$inject = ["$translate", "$rootScope"], translateFilterFactory.$inject = ["$parse", "$translate"], $translationCache.$inject = ["$cacheFactory"], angular.module("pascalprecht.translate", ["ng"]).run(runTranslate), runTranslate.displayName = "runTranslate", angular.module("pascalprecht.translate").provider("$translateSanitization", $translateSanitizationProvider), angular.module("pascalprecht.translate").constant("pascalprechtTranslateOverrider", {}).provider("$translate", $translate), $translate.displayName = "displayName", angular.module("pascalprecht.translate").factory("$translateDefaultInterpolation", $translateDefaultInterpolation), $translateDefaultInterpolation.displayName = "$translateDefaultInterpolation", angular.module("pascalprecht.translate").constant("$STORAGE_KEY", "NG_TRANSLATE_LANG_KEY"), angular.module("pascalprecht.translate").directive("translate", translateDirective), translateDirective.displayName = "translateDirective", angular.module("pascalprecht.translate").directive("translateAttr", translateAttrDirective), translateAttrDirective.displayName = "translateAttrDirective", angular.module("pascalprecht.translate").directive("translateCloak", translateCloakDirective), translateCloakDirective.displayName = "translateCloakDirective", angular.module("pascalprecht.translate").directive("translateNamespace", translateNamespaceDirective), translateNamespaceDirective.displayName = "translateNamespaceDirective", angular.module("pascalprecht.translate").directive("translateLanguage", translateLanguageDirective), translateLanguageDirective.displayName = "translateLanguageDirective", angular.module("pascalprecht.translate").filter("translate", translateFilterFactory), translateFilterFactory.displayName = "translateFilterFactory", angular.module("pascalprecht.translate").factory("$translationCache", $translationCache), $translationCache.displayName = "$translationCache", "pascalprecht.translate"
    }),
    function(root, factory) {
        "function" == typeof define && define.amd ? define([], function() {
            return factory()
        }) : "object" === ("undefined" == typeof module ? "undefined" : _typeof2(module)) && module.exports ? module.exports = factory() : factory()
    }(this, function() {
        function $translateStaticFilesLoader($q, $http) {
            "use strict";
            return function(options) {
                if (!(options && (angular.isArray(options.files) || angular.isString(options.prefix) && angular.isString(options.suffix)))) throw new Error("Couldn't load static files, no files and prefix or suffix specified!");
                options.files || (options.files = [{
                    prefix: options.prefix,
                    suffix: options.suffix
                }]);
                for (var load = function(file) {
                        if (!file || !angular.isString(file.prefix) || !angular.isString(file.suffix)) throw new Error("Couldn't load static file, no prefix or suffix specified!");
                        var fileUrl = [file.prefix, options.key, file.suffix].join("");
                        return angular.isObject(options.fileMap) && options.fileMap[fileUrl] && (fileUrl = options.fileMap[fileUrl]), $http(angular.extend({
                            url: fileUrl,
                            method: "GET"
                        }, options.$http)).then(function(result) {
                            return result.data
                        }, function() {
                            return $q.reject(options.key)
                        })
                    }, promises = [], length = options.files.length, i = 0; i < length; i++) promises.push(load({
                    prefix: options.files[i].prefix,
                    key: options.key,
                    suffix: options.files[i].suffix
                }));
                return $q.all(promises).then(function(data) {
                    for (var length = data.length, mergedData = {}, i = 0; i < length; i++)
                        for (var key in data[i]) mergedData[key] = data[i][key];
                    return mergedData
                })
            }
        }
        return $translateStaticFilesLoader.$inject = ["$q", "$http"], angular.module("pascalprecht.translate").factory("$translateStaticFilesLoader", $translateStaticFilesLoader), $translateStaticFilesLoader.displayName = "$translateStaticFilesLoader", "pascalprecht.translate"
    }),
    function() {
        function apply(func, thisArg, args) {
            switch (args.length) {
                case 0:
                    return func.call(thisArg);
                case 1:
                    return func.call(thisArg, args[0]);
                case 2:
                    return func.call(thisArg, args[0], args[1]);
                case 3:
                    return func.call(thisArg, args[0], args[1], args[2])
            }
            return func.apply(thisArg, args)
        }

        function arrayAggregator(array, setter, iteratee, accumulator) {
            for (var index = -1, length = null == array ? 0 : array.length; ++index < length;) {
                var value = array[index];
                setter(accumulator, value, iteratee(value), array)
            }
            return accumulator
        }

        function arrayEach(array, iteratee) {
            for (var index = -1, length = null == array ? 0 : array.length; ++index < length && iteratee(array[index], index, array) !== !1;);
            return array
        }

        function arrayEachRight(array, iteratee) {
            for (var length = null == array ? 0 : array.length; length-- && iteratee(array[length], length, array) !== !1;);
            return array
        }

        function arrayEvery(array, predicate) {
            for (var index = -1, length = null == array ? 0 : array.length; ++index < length;)
                if (!predicate(array[index], index, array)) return !1;
            return !0
        }

        function arrayFilter(array, predicate) {
            for (var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = []; ++index < length;) {
                var value = array[index];
                predicate(value, index, array) && (result[resIndex++] = value)
            }
            return result
        }

        function arrayIncludes(array, value) {
            var length = null == array ? 0 : array.length;
            return !!length && baseIndexOf(array, value, 0) > -1
        }

        function arrayIncludesWith(array, value, comparator) {
            for (var index = -1, length = null == array ? 0 : array.length; ++index < length;)
                if (comparator(value, array[index])) return !0;
            return !1
        }

        function arrayMap(array, iteratee) {
            for (var index = -1, length = null == array ? 0 : array.length, result = Array(length); ++index < length;) result[index] = iteratee(array[index], index, array);
            return result
        }

        function arrayPush(array, values) {
            for (var index = -1, length = values.length, offset = array.length; ++index < length;) array[offset + index] = values[index];
            return array
        }

        function arrayReduce(array, iteratee, accumulator, initAccum) {
            var index = -1,
                length = null == array ? 0 : array.length;
            for (initAccum && length && (accumulator = array[++index]); ++index < length;) accumulator = iteratee(accumulator, array[index], index, array);
            return accumulator
        }

        function arrayReduceRight(array, iteratee, accumulator, initAccum) {
            var length = null == array ? 0 : array.length;
            for (initAccum && length && (accumulator = array[--length]); length--;) accumulator = iteratee(accumulator, array[length], length, array);
            return accumulator
        }

        function arraySome(array, predicate) {
            for (var index = -1, length = null == array ? 0 : array.length; ++index < length;)
                if (predicate(array[index], index, array)) return !0;
            return !1
        }

        function asciiToArray(string) {
            return string.split("")
        }

        function asciiWords(string) {
            return string.match(reAsciiWord) || []
        }

        function baseFindKey(collection, predicate, eachFunc) {
            var result;
            return eachFunc(collection, function(value, key, collection) {
                if (predicate(value, key, collection)) return result = key, !1
            }), result
        }

        function baseFindIndex(array, predicate, fromIndex, fromRight) {
            for (var length = array.length, index = fromIndex + (fromRight ? 1 : -1); fromRight ? index-- : ++index < length;)
                if (predicate(array[index], index, array)) return index;
            return -1
        }

        function baseIndexOf(array, value, fromIndex) {
            return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex)
        }

        function baseIndexOfWith(array, value, fromIndex, comparator) {
            for (var index = fromIndex - 1, length = array.length; ++index < length;)
                if (comparator(array[index], value)) return index;
            return -1
        }

        function baseIsNaN(value) {
            return value !== value
        }

        function baseMean(array, iteratee) {
            var length = null == array ? 0 : array.length;
            return length ? baseSum(array, iteratee) / length : NAN
        }

        function baseProperty(key) {
            return function(object) {
                return null == object ? undefined : object[key]
            }
        }

        function basePropertyOf(object) {
            return function(key) {
                return null == object ? undefined : object[key]
            }
        }

        function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
            return eachFunc(collection, function(value, index, collection) {
                accumulator = initAccum ? (initAccum = !1, value) : iteratee(accumulator, value, index, collection)
            }), accumulator
        }

        function baseSortBy(array, comparer) {
            var length = array.length;
            for (array.sort(comparer); length--;) array[length] = array[length].value;
            return array
        }

        function baseSum(array, iteratee) {
            for (var result, index = -1, length = array.length; ++index < length;) {
                var current = iteratee(array[index]);
                current !== undefined && (result = result === undefined ? current : result + current)
            }
            return result
        }

        function baseTimes(n, iteratee) {
            for (var index = -1, result = Array(n); ++index < n;) result[index] = iteratee(index);
            return result
        }

        function baseToPairs(object, props) {
            return arrayMap(props, function(key) {
                return [key, object[key]]
            })
        }

        function baseUnary(func) {
            return function(value) {
                return func(value)
            }
        }

        function baseValues(object, props) {
            return arrayMap(props, function(key) {
                return object[key]
            })
        }

        function cacheHas(cache, key) {
            return cache.has(key)
        }

        function charsStartIndex(strSymbols, chrSymbols) {
            for (var index = -1, length = strSymbols.length; ++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1;);
            return index
        }

        function charsEndIndex(strSymbols, chrSymbols) {
            for (var index = strSymbols.length; index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1;);
            return index
        }

        function countHolders(array, placeholder) {
            for (var length = array.length, result = 0; length--;) array[length] === placeholder && ++result;
            return result
        }

        function escapeStringChar(chr) {
            return "\\" + stringEscapes[chr]
        }

        function getValue(object, key) {
            return null == object ? undefined : object[key]
        }

        function hasUnicode(string) {
            return reHasUnicode.test(string)
        }

        function hasUnicodeWord(string) {
            return reHasUnicodeWord.test(string)
        }

        function iteratorToArray(iterator) {
            for (var data, result = []; !(data = iterator.next()).done;) result.push(data.value);
            return result
        }

        function mapToArray(map) {
            var index = -1,
                result = Array(map.size);
            return map.forEach(function(value, key) {
                result[++index] = [key, value]
            }), result
        }

        function overArg(func, transform) {
            return function(arg) {
                return func(transform(arg))
            }
        }

        function replaceHolders(array, placeholder) {
            for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length;) {
                var value = array[index];
                value !== placeholder && value !== PLACEHOLDER || (array[index] = PLACEHOLDER, result[resIndex++] = index)
            }
            return result
        }

        function setToArray(set) {
            var index = -1,
                result = Array(set.size);
            return set.forEach(function(value) {
                result[++index] = value
            }), result
        }

        function setToPairs(set) {
            var index = -1,
                result = Array(set.size);
            return set.forEach(function(value) {
                result[++index] = [value, value]
            }), result
        }

        function strictIndexOf(array, value, fromIndex) {
            for (var index = fromIndex - 1, length = array.length; ++index < length;)
                if (array[index] === value) return index;
            return -1
        }

        function strictLastIndexOf(array, value, fromIndex) {
            for (var index = fromIndex + 1; index--;)
                if (array[index] === value) return index;
            return index
        }

        function stringSize(string) {
            return hasUnicode(string) ? unicodeSize(string) : asciiSize(string)
        }

        function stringToArray(string) {
            return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string)
        }

        function unicodeSize(string) {
            for (var result = reUnicode.lastIndex = 0; reUnicode.test(string);) ++result;
            return result
        }

        function unicodeToArray(string) {
            return string.match(reUnicode) || []
        }

        function unicodeWords(string) {
            return string.match(reUnicodeWord) || []
        }
        var undefined, VERSION = "4.17.13",
            LARGE_ARRAY_SIZE = 200,
            CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.",
            FUNC_ERROR_TEXT = "Expected a function",
            HASH_UNDEFINED = "__lodash_hash_undefined__",
            MAX_MEMOIZE_SIZE = 500,
            PLACEHOLDER = "__lodash_placeholder__",
            CLONE_DEEP_FLAG = 1,
            CLONE_FLAT_FLAG = 2,
            CLONE_SYMBOLS_FLAG = 4,
            COMPARE_PARTIAL_FLAG = 1,
            COMPARE_UNORDERED_FLAG = 2,
            WRAP_BIND_FLAG = 1,
            WRAP_BIND_KEY_FLAG = 2,
            WRAP_CURRY_BOUND_FLAG = 4,
            WRAP_CURRY_FLAG = 8,
            WRAP_CURRY_RIGHT_FLAG = 16,
            WRAP_PARTIAL_FLAG = 32,
            WRAP_PARTIAL_RIGHT_FLAG = 64,
            WRAP_ARY_FLAG = 128,
            WRAP_REARG_FLAG = 256,
            WRAP_FLIP_FLAG = 512,
            DEFAULT_TRUNC_LENGTH = 30,
            DEFAULT_TRUNC_OMISSION = "...",
            HOT_COUNT = 800,
            HOT_SPAN = 16,
            LAZY_FILTER_FLAG = 1,
            LAZY_MAP_FLAG = 2,
            LAZY_WHILE_FLAG = 3,
            INFINITY = 1 / 0,
            MAX_SAFE_INTEGER = 9007199254740991,
            MAX_INTEGER = 1.7976931348623157e308,
            NAN = NaN,
            MAX_ARRAY_LENGTH = 4294967295,
            MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
            HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1,
            wrapFlags = [
                ["ary", WRAP_ARY_FLAG],
                ["bind", WRAP_BIND_FLAG],
                ["bindKey", WRAP_BIND_KEY_FLAG],
                ["curry", WRAP_CURRY_FLAG],
                ["curryRight", WRAP_CURRY_RIGHT_FLAG],
                ["flip", WRAP_FLIP_FLAG],
                ["partial", WRAP_PARTIAL_FLAG],
                ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
                ["rearg", WRAP_REARG_FLAG]
            ],
            argsTag = "[object Arguments]",
            arrayTag = "[object Array]",
            asyncTag = "[object AsyncFunction]",
            boolTag = "[object Boolean]",
            dateTag = "[object Date]",
            domExcTag = "[object DOMException]",
            errorTag = "[object Error]",
            funcTag = "[object Function]",
            genTag = "[object GeneratorFunction]",
            mapTag = "[object Map]",
            numberTag = "[object Number]",
            nullTag = "[object Null]",
            objectTag = "[object Object]",
            promiseTag = "[object Promise]",
            proxyTag = "[object Proxy]",
            regexpTag = "[object RegExp]",
            setTag = "[object Set]",
            stringTag = "[object String]",
            symbolTag = "[object Symbol]",
            undefinedTag = "[object Undefined]",
            weakMapTag = "[object WeakMap]",
            weakSetTag = "[object WeakSet]",
            arrayBufferTag = "[object ArrayBuffer]",
            dataViewTag = "[object DataView]",
            float32Tag = "[object Float32Array]",
            float64Tag = "[object Float64Array]",
            int8Tag = "[object Int8Array]",
            int16Tag = "[object Int16Array]",
            int32Tag = "[object Int32Array]",
            uint8Tag = "[object Uint8Array]",
            uint8ClampedTag = "[object Uint8ClampedArray]",
            uint16Tag = "[object Uint16Array]",
            uint32Tag = "[object Uint32Array]",
            reEmptyStringLeading = /\b__p \+= '';/g,
            reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
            reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g,
            reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
            reUnescapedHtml = /[&<>"']/g,
            reHasEscapedHtml = RegExp(reEscapedHtml.source),
            reHasUnescapedHtml = RegExp(reUnescapedHtml.source),
            reEscape = /<%-([\s\S]+?)%>/g,
            reEvaluate = /<%([\s\S]+?)%>/g,
            reInterpolate = /<%=([\s\S]+?)%>/g,
            reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
            reIsPlainProp = /^\w*$/,
            rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
            reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
            reHasRegExpChar = RegExp(reRegExpChar.source),
            reTrim = /^\s+|\s+$/g,
            reTrimStart = /^\s+/,
            reTrimEnd = /\s+$/,
            reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
            reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
            reSplitDetails = /,? & /,
            reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g,
            reEscapeChar = /\\(\\)?/g,
            reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,
            reFlags = /\w*$/,
            reIsBadHex = /^[-+]0x[0-9a-f]+$/i,
            reIsBinary = /^0b[01]+$/i,
            reIsHostCtor = /^\[object .+?Constructor\]$/,
            reIsOctal = /^0o[0-7]+$/i,
            reIsUint = /^(?:0|[1-9]\d*)$/,
            reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g,
            reNoMatch = /($^)/,
            reUnescapedString = /['\n\r\u2028\u2029\\]/g,
            rsAstralRange = "\\ud800-\\udfff",
            rsComboMarksRange = "\\u0300-\\u036f",
            reComboHalfMarksRange = "\\ufe20-\\ufe2f",
            rsComboSymbolsRange = "\\u20d0-\\u20ff",
            rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
            rsDingbatRange = "\\u2700-\\u27bf",
            rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff",
            rsMathOpRange = "\\xac\\xb1\\xd7\\xf7",
            rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf",
            rsPunctuationRange = "\\u2000-\\u206f",
            rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000",
            rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde",
            rsVarRange = "\\ufe0e\\ufe0f",
            rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange,
            rsApos = "[']",
            rsAstral = "[" + rsAstralRange + "]",
            rsBreak = "[" + rsBreakRange + "]",
            rsCombo = "[" + rsComboRange + "]",
            rsDigits = "\\d+",
            rsDingbat = "[" + rsDingbatRange + "]",
            rsLower = "[" + rsLowerRange + "]",
            rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]",
            rsFitz = "\\ud83c[\\udffb-\\udfff]",
            rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")",
            rsNonAstral = "[^" + rsAstralRange + "]",
            rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
            rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
            rsUpper = "[" + rsUpperRange + "]",
            rsZWJ = "\\u200d",
            rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")",
            rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")",
            rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?",
            rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?",
            reOptMod = rsModifier + "?",
            rsOptVar = "[" + rsVarRange + "]?",
            rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*",
            rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])",
            rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])",
            rsSeq = rsOptVar + reOptMod + rsOptJoin,
            rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq,
            rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")",
            reApos = RegExp(rsApos, "g"),
            reComboMark = RegExp(rsCombo, "g"),
            reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g"),
            reUnicodeWord = RegExp([rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")", rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")", rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower, rsUpper + "+" + rsOptContrUpper, rsOrdUpper, rsOrdLower, rsDigits, rsEmoji].join("|"), "g"),
            reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]"),
            reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/,
            contextProps = ["Array", "Buffer", "DataView", "Date", "Error", "Float32Array", "Float64Array", "Function", "Int8Array", "Int16Array", "Int32Array", "Map", "Math", "Object", "Promise", "RegExp", "Set", "String", "Symbol", "TypeError", "Uint8Array", "Uint8ClampedArray", "Uint16Array", "Uint32Array", "WeakMap", "_", "clearTimeout", "isFinite", "parseInt", "setTimeout"],
            templateCounter = -1,
            typedArrayTags = {};
        typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0, typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1;
        var cloneableTags = {};
        cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0, cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1;
        var deburredLetters = {
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "A",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "a",
                "": "C",
                "": "c",
                "": "D",
                "": "d",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "N",
                "": "n",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "O",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "o",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "Y",
                "": "y",
                "": "y",
                "": "Ae",
                "": "ae",
                "": "Th",
                "": "th",
                "": "ss",
                "": "A",
                "": "A",
                "": "A",
                "": "a",
                "": "a",
                "": "a",
                "": "C",
                "": "C",
                "": "C",
                "": "C",
                "": "c",
                "": "c",
                "": "c",
                "": "c",
                "": "D",
                "": "D",
                "": "d",
                "": "d",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "E",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "e",
                "": "G",
                "": "G",
                "": "G",
                "": "G",
                "": "g",
                "": "g",
                "": "g",
                "": "g",
                "": "H",
                "": "H",
                "": "h",
                "": "h",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "I",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "i",
                "": "J",
                "": "j",
                "": "K",
                "": "k",
                "": "k",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "L",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "l",
                "": "N",
                "": "N",
                "": "N",
                "": "N",
                "": "n",
                "": "n",
                "": "n",
                "": "n",
                "": "O",
                "": "O",
                "": "O",
                "": "o",
                "": "o",
                "": "o",
                "": "R",
                "": "R",
                "": "R",
                "": "r",
                "": "r",
                "": "r",
                "": "S",
                "": "S",
                "": "S",
                "": "S",
                "": "s",
                "": "s",
                "": "s",
                "": "s",
                "": "T",
                "": "T",
                "": "T",
                "": "t",
                "": "t",
                "": "t",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "U",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "u",
                "": "W",
                "": "w",
                "": "Y",
                "": "y",
                "": "Y",
                "": "Z",
                "": "Z",
                "": "Z",
                "": "z",
                "": "z",
                "": "z",
                "": "IJ",
                "": "ij",
                "": "Oe",
                "": "oe",
                "": "'n",
                "": "s"
            },
            htmlEscapes = {
                "&": "&amp;",
                "<": "&lt;",
                ">": "&gt;",
                '"': "&quot;",
                "'": "&#39;"
            },
            htmlUnescapes = {
                "&amp;": "&",
                "&lt;": "<",
                "&gt;": ">",
                "&quot;": '"',
                "&#39;": "'"
            },
            stringEscapes = {
                "\\": "\\",
                "'": "'",
                "\n": "n",
                "\r": "r",
                "\u2028": "u2028",
                "\u2029": "u2029"
            },
            freeParseFloat = parseFloat,
            freeParseInt = parseInt,
            freeGlobal = "object" == ("undefined" == typeof global ? "undefined" : _typeof2(global)) && global && global.Object === Object && global,
            freeSelf = "object" == ("undefined" == typeof self ? "undefined" : _typeof2(self)) && self && self.Object === Object && self,
            root = freeGlobal || freeSelf || Function("return this")(),
            freeExports = "object" == ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && exports && !exports.nodeType && exports,
            freeModule = freeExports && "object" == ("undefined" == typeof module ? "undefined" : _typeof2(module)) && module && !module.nodeType && module,
            moduleExports = freeModule && freeModule.exports === freeExports,
            freeProcess = moduleExports && freeGlobal.process,
            nodeUtil = function() {
                try {
                    var types = freeModule && freeModule.require && freeModule.require("util").types;
                    return types ? types : freeProcess && freeProcess.binding && freeProcess.binding("util")
                } catch (e) {}
            }(),
            nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
            nodeIsDate = nodeUtil && nodeUtil.isDate,
            nodeIsMap = nodeUtil && nodeUtil.isMap,
            nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
            nodeIsSet = nodeUtil && nodeUtil.isSet,
            nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray,
            asciiSize = baseProperty("length"),
            deburrLetter = basePropertyOf(deburredLetters),
            escapeHtmlChar = basePropertyOf(htmlEscapes),
            unescapeHtmlChar = basePropertyOf(htmlUnescapes),
            runInContext = function runInContext(context) {
                function lodash(value) {
                    if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
                        if (value instanceof LodashWrapper) return value;
                        if (hasOwnProperty.call(value, "__wrapped__")) return wrapperClone(value)
                    }
                    return new LodashWrapper(value)
                }

                function baseLodash() {}

                function LodashWrapper(value, chainAll) {
                    this.__wrapped__ = value, this.__actions__ = [], this.__chain__ = !!chainAll, this.__index__ = 0, this.__values__ = undefined
                }

                function LazyWrapper(value) {
                    this.__wrapped__ = value, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = MAX_ARRAY_LENGTH, this.__views__ = []
                }

                function lazyClone() {
                    var result = new LazyWrapper(this.__wrapped__);
                    return result.__actions__ = copyArray(this.__actions__), result.__dir__ = this.__dir__, result.__filtered__ = this.__filtered__, result.__iteratees__ = copyArray(this.__iteratees__), result.__takeCount__ = this.__takeCount__, result.__views__ = copyArray(this.__views__), result
                }

                function lazyReverse() {
                    if (this.__filtered__) {
                        var result = new LazyWrapper(this);
                        result.__dir__ = -1, result.__filtered__ = !0
                    } else result = this.clone(), result.__dir__ *= -1;
                    return result
                }

                function lazyValue() {
                    var array = this.__wrapped__.value(),
                        dir = this.__dir__,
                        isArr = isArray(array),
                        isRight = dir < 0,
                        arrLength = isArr ? array.length : 0,
                        view = getView(0, arrLength, this.__views__),
                        start = view.start,
                        end = view.end,
                        length = end - start,
                        index = isRight ? end : start - 1,
                        iteratees = this.__iteratees__,
                        iterLength = iteratees.length,
                        resIndex = 0,
                        takeCount = nativeMin(length, this.__takeCount__);
                    if (!isArr || !isRight && arrLength == length && takeCount == length) return baseWrapperValue(array, this.__actions__);
                    var result = [];
                    outer: for (; length-- && resIndex < takeCount;) {
                        index += dir;
                        for (var iterIndex = -1, value = array[index]; ++iterIndex < iterLength;) {
                            var data = iteratees[iterIndex],
                                iteratee = data.iteratee,
                                type = data.type,
                                computed = iteratee(value);
                            if (type == LAZY_MAP_FLAG) value = computed;
                            else if (!computed) {
                                if (type == LAZY_FILTER_FLAG) continue outer;
                                break outer
                            }
                        }
                        result[resIndex++] = value
                    }
                    return result
                }

                function Hash(entries) {
                    var index = -1,
                        length = null == entries ? 0 : entries.length;
                    for (this.clear(); ++index < length;) {
                        var entry = entries[index];
                        this.set(entry[0], entry[1])
                    }
                }

                function hashClear() {
                    this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0
                }

                function hashDelete(key) {
                    var result = this.has(key) && delete this.__data__[key];
                    return this.size -= result ? 1 : 0, result
                }

                function hashGet(key) {
                    var data = this.__data__;
                    if (nativeCreate) {
                        var result = data[key];
                        return result === HASH_UNDEFINED ? undefined : result
                    }
                    return hasOwnProperty.call(data, key) ? data[key] : undefined
                }

                function hashHas(key) {
                    var data = this.__data__;
                    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key)
                }

                function hashSet(key, value) {
                    var data = this.__data__;
                    return this.size += this.has(key) ? 0 : 1, data[key] = nativeCreate && value === undefined ? HASH_UNDEFINED : value, this
                }

                function ListCache(entries) {
                    var index = -1,
                        length = null == entries ? 0 : entries.length;
                    for (this.clear(); ++index < length;) {
                        var entry = entries[index];
                        this.set(entry[0], entry[1])
                    }
                }

                function listCacheClear() {
                    this.__data__ = [], this.size = 0
                }

                function listCacheDelete(key) {
                    var data = this.__data__,
                        index = assocIndexOf(data, key);
                    if (index < 0) return !1;
                    var lastIndex = data.length - 1;
                    return index == lastIndex ? data.pop() : splice.call(data, index, 1), --this.size, !0
                }

                function listCacheGet(key) {
                    var data = this.__data__,
                        index = assocIndexOf(data, key);
                    return index < 0 ? undefined : data[index][1]
                }

                function listCacheHas(key) {
                    return assocIndexOf(this.__data__, key) > -1
                }

                function listCacheSet(key, value) {
                    var data = this.__data__,
                        index = assocIndexOf(data, key);
                    return index < 0 ? (++this.size, data.push([key, value])) : data[index][1] = value, this
                }

                function MapCache(entries) {
                    var index = -1,
                        length = null == entries ? 0 : entries.length;
                    for (this.clear(); ++index < length;) {
                        var entry = entries[index];
                        this.set(entry[0], entry[1])
                    }
                }

                function mapCacheClear() {
                    this.size = 0, this.__data__ = {
                        hash: new Hash,
                        map: new(Map || ListCache),
                        string: new Hash
                    }
                }

                function mapCacheDelete(key) {
                    var result = getMapData(this, key).delete(key);
                    return this.size -= result ? 1 : 0, result
                }

                function mapCacheGet(key) {
                    return getMapData(this, key).get(key)
                }

                function mapCacheHas(key) {
                    return getMapData(this, key).has(key)
                }

                function mapCacheSet(key, value) {
                    var data = getMapData(this, key),
                        size = data.size;
                    return data.set(key, value), this.size += data.size == size ? 0 : 1, this
                }

                function SetCache(values) {
                    var index = -1,
                        length = null == values ? 0 : values.length;
                    for (this.__data__ = new MapCache; ++index < length;) this.add(values[index])
                }

                function setCacheAdd(value) {
                    return this.__data__.set(value, HASH_UNDEFINED), this
                }

                function setCacheHas(value) {
                    return this.__data__.has(value)
                }

                function Stack(entries) {
                    var data = this.__data__ = new ListCache(entries);
                    this.size = data.size
                }

                function stackClear() {
                    this.__data__ = new ListCache, this.size = 0
                }

                function stackDelete(key) {
                    var data = this.__data__,
                        result = data.delete(key);
                    return this.size = data.size, result
                }

                function stackGet(key) {
                    return this.__data__.get(key)
                }

                function stackHas(key) {
                    return this.__data__.has(key)
                }

                function stackSet(key, value) {
                    var data = this.__data__;
                    if (data instanceof ListCache) {
                        var pairs = data.__data__;
                        if (!Map || pairs.length < LARGE_ARRAY_SIZE - 1) return pairs.push([key, value]), this.size = ++data.size, this;
                        data = this.__data__ = new MapCache(pairs)
                    }
                    return data.set(key, value), this.size = data.size, this
                }

                function arrayLikeKeys(value, inherited) {
                    var isArr = isArray(value),
                        isArg = !isArr && isArguments(value),
                        isBuff = !isArr && !isArg && isBuffer(value),
                        isType = !isArr && !isArg && !isBuff && isTypedArray(value),
                        skipIndexes = isArr || isArg || isBuff || isType,
                        result = skipIndexes ? baseTimes(value.length, String) : [],
                        length = result.length;
                    for (var key in value) !inherited && !hasOwnProperty.call(value, key) || skipIndexes && ("length" == key || isBuff && ("offset" == key || "parent" == key) || isType && ("buffer" == key || "byteLength" == key || "byteOffset" == key) || isIndex(key, length)) || result.push(key);
                    return result
                }

                function arraySample(array) {
                    var length = array.length;
                    return length ? array[baseRandom(0, length - 1)] : undefined
                }

                function arraySampleSize(array, n) {
                    return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length))
                }

                function arrayShuffle(array) {
                    return shuffleSelf(copyArray(array))
                }

                function assignMergeValue(object, key, value) {
                    (value === undefined || eq(object[key], value)) && (value !== undefined || key in object) || baseAssignValue(object, key, value)
                }

                function assignValue(object, key, value) {
                    var objValue = object[key];
                    hasOwnProperty.call(object, key) && eq(objValue, value) && (value !== undefined || key in object) || baseAssignValue(object, key, value)
                }

                function assocIndexOf(array, key) {
                    for (var length = array.length; length--;)
                        if (eq(array[length][0], key)) return length;
                    return -1
                }

                function baseAggregator(collection, setter, iteratee, accumulator) {
                    return baseEach(collection, function(value, key, collection) {
                        setter(accumulator, value, iteratee(value), collection)
                    }), accumulator
                }

                function baseAssign(object, source) {
                    return object && copyObject(source, keys(source), object)
                }

                function baseAssignIn(object, source) {
                    return object && copyObject(source, keysIn(source), object)
                }

                function baseAssignValue(object, key, value) {
                    "__proto__" == key && defineProperty ? defineProperty(object, key, {
                        configurable: !0,
                        enumerable: !0,
                        value: value,
                        writable: !0
                    }) : object[key] = value
                }

                function baseAt(object, paths) {
                    for (var index = -1, length = paths.length, result = Array(length), skip = null == object; ++index < length;) result[index] = skip ? undefined : get(object, paths[index]);
                    return result
                }

                function baseClamp(number, lower, upper) {
                    return number === number && (upper !== undefined && (number = number <= upper ? number : upper), lower !== undefined && (number = number >= lower ? number : lower)), number
                }

                function baseClone(value, bitmask, customizer, key, object, stack) {
                    var result, isDeep = bitmask & CLONE_DEEP_FLAG,
                        isFlat = bitmask & CLONE_FLAT_FLAG,
                        isFull = bitmask & CLONE_SYMBOLS_FLAG;
                    if (customizer && (result = object ? customizer(value, key, object, stack) : customizer(value)), result !== undefined) return result;
                    if (!isObject(value)) return value;
                    var isArr = isArray(value);
                    if (isArr) {
                        if (result = initCloneArray(value), !isDeep) return copyArray(value, result)
                    } else {
                        var tag = getTag(value),
                            isFunc = tag == funcTag || tag == genTag;
                        if (isBuffer(value)) return cloneBuffer(value, isDeep);
                        if (tag == objectTag || tag == argsTag || isFunc && !object) {
                            if (result = isFlat || isFunc ? {} : initCloneObject(value), !isDeep) return isFlat ? copySymbolsIn(value, baseAssignIn(result, value)) : copySymbols(value, baseAssign(result, value))
                        } else {
                            if (!cloneableTags[tag]) return object ? value : {};
                            result = initCloneByTag(value, tag, isDeep)
                        }
                    }
                    stack || (stack = new Stack);
                    var stacked = stack.get(value);
                    if (stacked) return stacked;
                    stack.set(value, result), isSet(value) ? value.forEach(function(subValue) {
                        result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack))
                    }) : isMap(value) && value.forEach(function(subValue, key) {
                        result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack))
                    });
                    var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys,
                        props = isArr ? undefined : keysFunc(value);
                    return arrayEach(props || value, function(subValue, key) {
                        props && (key = subValue, subValue = value[key]), assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack))
                    }), result
                }

                function baseConforms(source) {
                    var props = keys(source);
                    return function(object) {
                        return baseConformsTo(object, source, props)
                    }
                }

                function baseConformsTo(object, source, props) {
                    var length = props.length;
                    if (null == object) return !length;
                    for (object = Object(object); length--;) {
                        var key = props[length],
                            predicate = source[key],
                            value = object[key];
                        if (value === undefined && !(key in object) || !predicate(value)) return !1
                    }
                    return !0
                }

                function baseDelay(func, wait, args) {
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    return setTimeout(function() {
                        func.apply(undefined, args)
                    }, wait)
                }

                function baseDifference(array, values, iteratee, comparator) {
                    var index = -1,
                        includes = arrayIncludes,
                        isCommon = !0,
                        length = array.length,
                        result = [],
                        valuesLength = values.length;
                    if (!length) return result;
                    iteratee && (values = arrayMap(values, baseUnary(iteratee))), comparator ? (includes = arrayIncludesWith, isCommon = !1) : values.length >= LARGE_ARRAY_SIZE && (includes = cacheHas, isCommon = !1, values = new SetCache(values));
                    outer: for (; ++index < length;) {
                        var value = array[index],
                            computed = null == iteratee ? value : iteratee(value);
                        if (value = comparator || 0 !== value ? value : 0, isCommon && computed === computed) {
                            for (var valuesIndex = valuesLength; valuesIndex--;)
                                if (values[valuesIndex] === computed) continue outer;
                            result.push(value)
                        } else includes(values, computed, comparator) || result.push(value)
                    }
                    return result
                }

                function baseEvery(collection, predicate) {
                    var result = !0;
                    return baseEach(collection, function(value, index, collection) {
                        return result = !!predicate(value, index, collection)
                    }), result
                }

                function baseExtremum(array, iteratee, comparator) {
                    for (var index = -1, length = array.length; ++index < length;) {
                        var value = array[index],
                            current = iteratee(value);
                        if (null != current && (computed === undefined ? current === current && !isSymbol(current) : comparator(current, computed))) var computed = current,
                            result = value
                    }
                    return result
                }

                function baseFill(array, value, start, end) {
                    var length = array.length;
                    for (start = toInteger(start), start < 0 && (start = -start > length ? 0 : length + start), end = end === undefined || end > length ? length : toInteger(end), end < 0 && (end += length), end = start > end ? 0 : toLength(end); start < end;) array[start++] = value;
                    return array
                }

                function baseFilter(collection, predicate) {
                    var result = [];
                    return baseEach(collection, function(value, index, collection) {
                        predicate(value, index, collection) && result.push(value)
                    }), result
                }

                function baseFlatten(array, depth, predicate, isStrict, result) {
                    var index = -1,
                        length = array.length;
                    for (predicate || (predicate = isFlattenable), result || (result = []); ++index < length;) {
                        var value = array[index];
                        depth > 0 && predicate(value) ? depth > 1 ? baseFlatten(value, depth - 1, predicate, isStrict, result) : arrayPush(result, value) : isStrict || (result[result.length] = value)
                    }
                    return result
                }

                function baseForOwn(object, iteratee) {
                    return object && baseFor(object, iteratee, keys)
                }

                function baseForOwnRight(object, iteratee) {
                    return object && baseForRight(object, iteratee, keys)
                }

                function baseFunctions(object, props) {
                    return arrayFilter(props, function(key) {
                        return isFunction(object[key])
                    })
                }

                function baseGet(object, path) {
                    path = castPath(path, object);
                    for (var index = 0, length = path.length; null != object && index < length;) object = object[toKey(path[index++])];
                    return index && index == length ? object : undefined
                }

                function baseGetAllKeys(object, keysFunc, symbolsFunc) {
                    var result = keysFunc(object);
                    return isArray(object) ? result : arrayPush(result, symbolsFunc(object))
                }

                function baseGetTag(value) {
                    return null == value ? value === undefined ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value)
                }

                function baseGt(value, other) {
                    return value > other
                }

                function baseHas(object, key) {
                    return null != object && hasOwnProperty.call(object, key)
                }

                function baseHasIn(object, key) {
                    return null != object && key in Object(object)
                }

                function baseInRange(number, start, end) {
                    return number >= nativeMin(start, end) && number < nativeMax(start, end)
                }

                function baseIntersection(arrays, iteratee, comparator) {
                    for (var includes = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array(othLength), maxLength = 1 / 0, result = []; othIndex--;) {
                        var array = arrays[othIndex];
                        othIndex && iteratee && (array = arrayMap(array, baseUnary(iteratee))), maxLength = nativeMin(array.length, maxLength), caches[othIndex] = !comparator && (iteratee || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined
                    }
                    array = arrays[0];
                    var index = -1,
                        seen = caches[0];
                    outer: for (; ++index < length && result.length < maxLength;) {
                        var value = array[index],
                            computed = iteratee ? iteratee(value) : value;
                        if (value = comparator || 0 !== value ? value : 0, !(seen ? cacheHas(seen, computed) : includes(result, computed, comparator))) {
                            for (othIndex = othLength; --othIndex;) {
                                var cache = caches[othIndex];
                                if (!(cache ? cacheHas(cache, computed) : includes(arrays[othIndex], computed, comparator))) continue outer
                            }
                            seen && seen.push(computed), result.push(value)
                        }
                    }
                    return result
                }

                function baseInverter(object, setter, iteratee, accumulator) {
                    return baseForOwn(object, function(value, key, object) {
                        setter(accumulator, iteratee(value), key, object)
                    }), accumulator
                }

                function baseInvoke(object, path, args) {
                    path = castPath(path, object), object = parent(object, path);
                    var func = null == object ? object : object[toKey(last(path))];
                    return null == func ? undefined : apply(func, object, args)
                }

                function baseIsArguments(value) {
                    return isObjectLike(value) && baseGetTag(value) == argsTag
                }

                function baseIsArrayBuffer(value) {
                    return isObjectLike(value) && baseGetTag(value) == arrayBufferTag
                }

                function baseIsDate(value) {
                    return isObjectLike(value) && baseGetTag(value) == dateTag
                }

                function baseIsEqual(value, other, bitmask, customizer, stack) {
                    return value === other || (null == value || null == other || !isObjectLike(value) && !isObjectLike(other) ? value !== value && other !== other : baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack))
                }

                function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
                    var objIsArr = isArray(object),
                        othIsArr = isArray(other),
                        objTag = objIsArr ? arrayTag : getTag(object),
                        othTag = othIsArr ? arrayTag : getTag(other);
                    objTag = objTag == argsTag ? objectTag : objTag, othTag = othTag == argsTag ? objectTag : othTag;
                    var objIsObj = objTag == objectTag,
                        othIsObj = othTag == objectTag,
                        isSameTag = objTag == othTag;
                    if (isSameTag && isBuffer(object)) {
                        if (!isBuffer(other)) return !1;
                        objIsArr = !0, objIsObj = !1
                    }
                    if (isSameTag && !objIsObj) return stack || (stack = new Stack), objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
                    if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
                        var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"),
                            othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
                        if (objIsWrapped || othIsWrapped) {
                            var objUnwrapped = objIsWrapped ? object.value() : object,
                                othUnwrapped = othIsWrapped ? other.value() : other;
                            return stack || (stack = new Stack), equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack)
                        }
                    }
                    return !!isSameTag && (stack || (stack = new Stack), equalObjects(object, other, bitmask, customizer, equalFunc, stack))
                }

                function baseIsMap(value) {
                    return isObjectLike(value) && getTag(value) == mapTag
                }

                function baseIsMatch(object, source, matchData, customizer) {
                    var index = matchData.length,
                        length = index,
                        noCustomizer = !customizer;
                    if (null == object) return !length;
                    for (object = Object(object); index--;) {
                        var data = matchData[index];
                        if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) return !1
                    }
                    for (; ++index < length;) {
                        data = matchData[index];
                        var key = data[0],
                            objValue = object[key],
                            srcValue = data[1];
                        if (noCustomizer && data[2]) {
                            if (objValue === undefined && !(key in object)) return !1
                        } else {
                            var stack = new Stack;
                            if (customizer) var result = customizer(objValue, srcValue, key, object, source, stack);
                            if (!(result === undefined ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result)) return !1
                        }
                    }
                    return !0
                }

                function baseIsNative(value) {
                    if (!isObject(value) || isMasked(value)) return !1;
                    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
                    return pattern.test(toSource(value))
                }

                function baseIsRegExp(value) {
                    return isObjectLike(value) && baseGetTag(value) == regexpTag
                }

                function baseIsSet(value) {
                    return isObjectLike(value) && getTag(value) == setTag
                }

                function baseIsTypedArray(value) {
                    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)]
                }

                function baseIteratee(value) {
                    return "function" == typeof value ? value : null == value ? identity : "object" == _typeof2(value) ? isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value) : property(value)
                }

                function baseKeys(object) {
                    if (!isPrototype(object)) return nativeKeys(object);
                    var result = [];
                    for (var key in Object(object)) hasOwnProperty.call(object, key) && "constructor" != key && result.push(key);
                    return result
                }

                function baseKeysIn(object) {
                    if (!isObject(object)) return nativeKeysIn(object);
                    var isProto = isPrototype(object),
                        result = [];
                    for (var key in object)("constructor" != key || !isProto && hasOwnProperty.call(object, key)) && result.push(key);
                    return result
                }

                function baseLt(value, other) {
                    return value < other
                }

                function baseMap(collection, iteratee) {
                    var index = -1,
                        result = isArrayLike(collection) ? Array(collection.length) : [];
                    return baseEach(collection, function(value, key, collection) {
                        result[++index] = iteratee(value, key, collection)
                    }), result
                }

                function baseMatches(source) {
                    var matchData = getMatchData(source);
                    return 1 == matchData.length && matchData[0][2] ? matchesStrictComparable(matchData[0][0], matchData[0][1]) : function(object) {
                        return object === source || baseIsMatch(object, source, matchData)
                    }
                }

                function baseMatchesProperty(path, srcValue) {
                    return isKey(path) && isStrictComparable(srcValue) ? matchesStrictComparable(toKey(path), srcValue) : function(object) {
                        var objValue = get(object, path);
                        return objValue === undefined && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG)
                    }
                }

                function baseMerge(object, source, srcIndex, customizer, stack) {
                    object !== source && baseFor(source, function(srcValue, key) {
                        if (stack || (stack = new Stack), isObject(srcValue)) baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
                        else {
                            var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined;
                            newValue === undefined && (newValue = srcValue), assignMergeValue(object, key, newValue)
                        }
                    }, keysIn)
                }

                function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
                    var objValue = safeGet(object, key),
                        srcValue = safeGet(source, key),
                        stacked = stack.get(srcValue);
                    if (stacked) return void assignMergeValue(object, key, stacked);
                    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined,
                        isCommon = newValue === undefined;
                    if (isCommon) {
                        var isArr = isArray(srcValue),
                            isBuff = !isArr && isBuffer(srcValue),
                            isTyped = !isArr && !isBuff && isTypedArray(srcValue);
                        newValue = srcValue, isArr || isBuff || isTyped ? isArray(objValue) ? newValue = objValue : isArrayLikeObject(objValue) ? newValue = copyArray(objValue) : isBuff ? (isCommon = !1, newValue = cloneBuffer(srcValue, !0)) : isTyped ? (isCommon = !1, newValue = cloneTypedArray(srcValue, !0)) : newValue = [] : isPlainObject(srcValue) || isArguments(srcValue) ? (newValue = objValue, isArguments(objValue) ? newValue = toPlainObject(objValue) : isObject(objValue) && !isFunction(objValue) || (newValue = initCloneObject(srcValue))) : isCommon = !1
                    }
                    isCommon && (stack.set(srcValue, newValue), mergeFunc(newValue, srcValue, srcIndex, customizer, stack), stack.delete(srcValue)), assignMergeValue(object, key, newValue)
                }

                function baseNth(array, n) {
                    var length = array.length;
                    if (length) return n += n < 0 ? length : 0, isIndex(n, length) ? array[n] : undefined
                }

                function baseOrderBy(collection, iteratees, orders) {
                    var index = -1;
                    iteratees = arrayMap(iteratees.length ? iteratees : [identity], baseUnary(getIteratee()));
                    var result = baseMap(collection, function(value, key, collection) {
                        var criteria = arrayMap(iteratees, function(iteratee) {
                            return iteratee(value)
                        });
                        return {
                            criteria: criteria,
                            index: ++index,
                            value: value
                        }
                    });
                    return baseSortBy(result, function(object, other) {
                        return compareMultiple(object, other, orders)
                    })
                }

                function basePick(object, paths) {
                    return basePickBy(object, paths, function(value, path) {
                        return hasIn(object, path)
                    })
                }

                function basePickBy(object, paths, predicate) {
                    for (var index = -1, length = paths.length, result = {}; ++index < length;) {
                        var path = paths[index],
                            value = baseGet(object, path);
                        predicate(value, path) && baseSet(result, castPath(path, object), value)
                    }
                    return result
                }

                function basePropertyDeep(path) {
                    return function(object) {
                        return baseGet(object, path)
                    }
                }

                function basePullAll(array, values, iteratee, comparator) {
                    var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
                        index = -1,
                        length = values.length,
                        seen = array;
                    for (array === values && (values = copyArray(values)), iteratee && (seen = arrayMap(array, baseUnary(iteratee))); ++index < length;)
                        for (var fromIndex = 0, value = values[index], computed = iteratee ? iteratee(value) : value;
                            (fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1;) seen !== array && splice.call(seen, fromIndex, 1), splice.call(array, fromIndex, 1);
                    return array
                }

                function basePullAt(array, indexes) {
                    for (var length = array ? indexes.length : 0, lastIndex = length - 1; length--;) {
                        var index = indexes[length];
                        if (length == lastIndex || index !== previous) {
                            var previous = index;
                            isIndex(index) ? splice.call(array, index, 1) : baseUnset(array, index)
                        }
                    }
                    return array
                }

                function baseRandom(lower, upper) {
                    return lower + nativeFloor(nativeRandom() * (upper - lower + 1))
                }

                function baseRange(start, end, step, fromRight) {
                    for (var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result = Array(length); length--;) result[fromRight ? length : ++index] = start, start += step;
                    return result
                }

                function baseRepeat(string, n) {
                    var result = "";
                    if (!string || n < 1 || n > MAX_SAFE_INTEGER) return result;
                    do n % 2 && (result += string), n = nativeFloor(n / 2), n && (string += string); while (n);
                    return result
                }

                function baseRest(func, start) {
                    return setToString(overRest(func, start, identity), func + "")
                }

                function baseSample(collection) {
                    return arraySample(values(collection))
                }

                function baseSampleSize(collection, n) {
                    var array = values(collection);
                    return shuffleSelf(array, baseClamp(n, 0, array.length))
                }

                function baseSet(object, path, value, customizer) {
                    if (!isObject(object)) return object;
                    path = castPath(path, object);
                    for (var index = -1, length = path.length, lastIndex = length - 1, nested = object; null != nested && ++index < length;) {
                        var key = toKey(path[index]),
                            newValue = value;
                        if (index != lastIndex) {
                            var objValue = nested[key];
                            newValue = customizer ? customizer(objValue, key, nested) : undefined, newValue === undefined && (newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {})
                        }
                        assignValue(nested, key, newValue), nested = nested[key]
                    }
                    return object
                }

                function baseShuffle(collection) {
                    return shuffleSelf(values(collection))
                }

                function baseSlice(array, start, end) {
                    var index = -1,
                        length = array.length;
                    start < 0 && (start = -start > length ? 0 : length + start), end = end > length ? length : end, end < 0 && (end += length), length = start > end ? 0 : end - start >>> 0, start >>>= 0;
                    for (var result = Array(length); ++index < length;) result[index] = array[index + start];
                    return result
                }

                function baseSome(collection, predicate) {
                    var result;
                    return baseEach(collection, function(value, index, collection) {
                        return result = predicate(value, index, collection), !result
                    }), !!result
                }

                function baseSortedIndex(array, value, retHighest) {
                    var low = 0,
                        high = null == array ? low : array.length;
                    if ("number" == typeof value && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
                        for (; low < high;) {
                            var mid = low + high >>> 1,
                                computed = array[mid];
                            null !== computed && !isSymbol(computed) && (retHighest ? computed <= value : computed < value) ? low = mid + 1 : high = mid
                        }
                        return high
                    }
                    return baseSortedIndexBy(array, value, identity, retHighest)
                }

                function baseSortedIndexBy(array, value, iteratee, retHighest) {
                    value = iteratee(value);
                    for (var low = 0, high = null == array ? 0 : array.length, valIsNaN = value !== value, valIsNull = null === value, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined; low < high;) {
                        var mid = nativeFloor((low + high) / 2),
                            computed = iteratee(array[mid]),
                            othIsDefined = computed !== undefined,
                            othIsNull = null === computed,
                            othIsReflexive = computed === computed,
                            othIsSymbol = isSymbol(computed);
                        if (valIsNaN) var setLow = retHighest || othIsReflexive;
                        else setLow = valIsUndefined ? othIsReflexive && (retHighest || othIsDefined) : valIsNull ? othIsReflexive && othIsDefined && (retHighest || !othIsNull) : valIsSymbol ? othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol) : !othIsNull && !othIsSymbol && (retHighest ? computed <= value : computed < value);
                        setLow ? low = mid + 1 : high = mid
                    }
                    return nativeMin(high, MAX_ARRAY_INDEX)
                }

                function baseSortedUniq(array, iteratee) {
                    for (var index = -1, length = array.length, resIndex = 0, result = []; ++index < length;) {
                        var value = array[index],
                            computed = iteratee ? iteratee(value) : value;
                        if (!index || !eq(computed, seen)) {
                            var seen = computed;
                            result[resIndex++] = 0 === value ? 0 : value
                        }
                    }
                    return result
                }

                function baseToNumber(value) {
                    return "number" == typeof value ? value : isSymbol(value) ? NAN : +value
                }

                function baseToString(value) {
                    if ("string" == typeof value) return value;
                    if (isArray(value)) return arrayMap(value, baseToString) + "";
                    if (isSymbol(value)) return symbolToString ? symbolToString.call(value) : "";
                    var result = value + "";
                    return "0" == result && 1 / value == -INFINITY ? "-0" : result
                }

                function baseUniq(array, iteratee, comparator) {
                    var index = -1,
                        includes = arrayIncludes,
                        length = array.length,
                        isCommon = !0,
                        result = [],
                        seen = result;
                    if (comparator) isCommon = !1, includes = arrayIncludesWith;
                    else if (length >= LARGE_ARRAY_SIZE) {
                        var set = iteratee ? null : createSet(array);
                        if (set) return setToArray(set);
                        isCommon = !1, includes = cacheHas, seen = new SetCache
                    } else seen = iteratee ? [] : result;
                    outer: for (; ++index < length;) {
                        var value = array[index],
                            computed = iteratee ? iteratee(value) : value;
                        if (value = comparator || 0 !== value ? value : 0, isCommon && computed === computed) {
                            for (var seenIndex = seen.length; seenIndex--;)
                                if (seen[seenIndex] === computed) continue outer;
                            iteratee && seen.push(computed), result.push(value)
                        } else includes(seen, computed, comparator) || (seen !== result && seen.push(computed), result.push(value))
                    }
                    return result
                }

                function baseUnset(object, path) {
                    return path = castPath(path, object), object = parent(object, path), null == object || delete object[toKey(last(path))]
                }

                function baseUpdate(object, path, updater, customizer) {
                    return baseSet(object, path, updater(baseGet(object, path)), customizer)
                }

                function baseWhile(array, predicate, isDrop, fromRight) {
                    for (var length = array.length, index = fromRight ? length : -1;
                        (fromRight ? index-- : ++index < length) && predicate(array[index], index, array););
                    return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index)
                }

                function baseWrapperValue(value, actions) {
                    var result = value;
                    return result instanceof LazyWrapper && (result = result.value()), arrayReduce(actions, function(result, action) {
                        return action.func.apply(action.thisArg, arrayPush([result], action.args))
                    }, result)
                }

                function baseXor(arrays, iteratee, comparator) {
                    var length = arrays.length;
                    if (length < 2) return length ? baseUniq(arrays[0]) : [];
                    for (var index = -1, result = Array(length); ++index < length;)
                        for (var array = arrays[index], othIndex = -1; ++othIndex < length;) othIndex != index && (result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator));
                    return baseUniq(baseFlatten(result, 1), iteratee, comparator)
                }

                function baseZipObject(props, values, assignFunc) {
                    for (var index = -1, length = props.length, valsLength = values.length, result = {}; ++index < length;) {
                        var value = index < valsLength ? values[index] : undefined;
                        assignFunc(result, props[index], value)
                    }
                    return result
                }

                function castArrayLikeObject(value) {
                    return isArrayLikeObject(value) ? value : []
                }

                function castFunction(value) {
                    return "function" == typeof value ? value : identity
                }

                function castPath(value, object) {
                    return isArray(value) ? value : isKey(value, object) ? [value] : stringToPath(toString(value))
                }

                function castSlice(array, start, end) {
                    var length = array.length;
                    return end = end === undefined ? length : end, !start && end >= length ? array : baseSlice(array, start, end)
                }

                function cloneBuffer(buffer, isDeep) {
                    if (isDeep) return buffer.slice();
                    var length = buffer.length,
                        result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
                    return buffer.copy(result), result
                }

                function cloneArrayBuffer(arrayBuffer) {
                    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
                    return new Uint8Array(result).set(new Uint8Array(arrayBuffer)), result
                }

                function cloneDataView(dataView, isDeep) {
                    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
                    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength)
                }

                function cloneRegExp(regexp) {
                    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
                    return result.lastIndex = regexp.lastIndex, result
                }

                function cloneSymbol(symbol) {
                    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {}
                }

                function cloneTypedArray(typedArray, isDeep) {
                    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
                    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length)
                }

                function compareAscending(value, other) {
                    if (value !== other) {
                        var valIsDefined = value !== undefined,
                            valIsNull = null === value,
                            valIsReflexive = value === value,
                            valIsSymbol = isSymbol(value),
                            othIsDefined = other !== undefined,
                            othIsNull = null === other,
                            othIsReflexive = other === other,
                            othIsSymbol = isSymbol(other);
                        if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) return 1;
                        if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) return -1
                    }
                    return 0
                }

                function compareMultiple(object, other, orders) {
                    for (var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length; ++index < length;) {
                        var result = compareAscending(objCriteria[index], othCriteria[index]);
                        if (result) {
                            if (index >= ordersLength) return result;
                            var order = orders[index];
                            return result * ("desc" == order ? -1 : 1)
                        }
                    }
                    return object.index - other.index
                }

                function composeArgs(args, partials, holders, isCurried) {
                    for (var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(leftLength + rangeLength), isUncurried = !isCurried; ++leftIndex < leftLength;) result[leftIndex] = partials[leftIndex];
                    for (; ++argsIndex < holdersLength;)(isUncurried || argsIndex < argsLength) && (result[holders[argsIndex]] = args[argsIndex]);
                    for (; rangeLength--;) result[leftIndex++] = args[argsIndex++];
                    return result
                }

                function composeArgsRight(args, partials, holders, isCurried) {
                    for (var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result = Array(rangeLength + rightLength), isUncurried = !isCurried; ++argsIndex < rangeLength;) result[argsIndex] = args[argsIndex];
                    for (var offset = argsIndex; ++rightIndex < rightLength;) result[offset + rightIndex] = partials[rightIndex];
                    for (; ++holdersIndex < holdersLength;)(isUncurried || argsIndex < argsLength) && (result[offset + holders[holdersIndex]] = args[argsIndex++]);
                    return result
                }

                function copyArray(source, array) {
                    var index = -1,
                        length = source.length;
                    for (array || (array = Array(length)); ++index < length;) array[index] = source[index];
                    return array
                }

                function copyObject(source, props, object, customizer) {
                    var isNew = !object;
                    object || (object = {});
                    for (var index = -1, length = props.length; ++index < length;) {
                        var key = props[index],
                            newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
                        newValue === undefined && (newValue = source[key]), isNew ? baseAssignValue(object, key, newValue) : assignValue(object, key, newValue)
                    }
                    return object
                }

                function copySymbols(source, object) {
                    return copyObject(source, getSymbols(source), object)
                }

                function copySymbolsIn(source, object) {
                    return copyObject(source, getSymbolsIn(source), object)
                }

                function createAggregator(setter, initializer) {
                    return function(collection, iteratee) {
                        var func = isArray(collection) ? arrayAggregator : baseAggregator,
                            accumulator = initializer ? initializer() : {};
                        return func(collection, setter, getIteratee(iteratee, 2), accumulator)
                    }
                }

                function createAssigner(assigner) {
                    return baseRest(function(object, sources) {
                        var index = -1,
                            length = sources.length,
                            customizer = length > 1 ? sources[length - 1] : undefined,
                            guard = length > 2 ? sources[2] : undefined;
                        for (customizer = assigner.length > 3 && "function" == typeof customizer ? (length--, customizer) : undefined, guard && isIterateeCall(sources[0], sources[1], guard) && (customizer = length < 3 ? undefined : customizer, length = 1), object = Object(object); ++index < length;) {
                            var source = sources[index];
                            source && assigner(object, source, index, customizer)
                        }
                        return object
                    })
                }

                function createBaseEach(eachFunc, fromRight) {
                    return function(collection, iteratee) {
                        if (null == collection) return collection;
                        if (!isArrayLike(collection)) return eachFunc(collection, iteratee);
                        for (var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
                            (fromRight ? index-- : ++index < length) && iteratee(iterable[index], index, iterable) !== !1;);
                        return collection
                    }
                }

                function createBaseFor(fromRight) {
                    return function(object, iteratee, keysFunc) {
                        for (var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length; length--;) {
                            var key = props[fromRight ? length : ++index];
                            if (iteratee(iterable[key], key, iterable) === !1) break
                        }
                        return object
                    }
                }

                function createBind(func, bitmask, thisArg) {
                    function wrapper() {
                        var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                        return fn.apply(isBind ? thisArg : this, arguments)
                    }
                    var isBind = bitmask & WRAP_BIND_FLAG,
                        Ctor = createCtor(func);
                    return wrapper
                }

                function createCaseFirst(methodName) {
                    return function(string) {
                        string = toString(string);
                        var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined,
                            chr = strSymbols ? strSymbols[0] : string.charAt(0),
                            trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
                        return chr[methodName]() + trailing
                    }
                }

                function createCompounder(callback) {
                    return function(string) {
                        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "")
                    }
                }

                function createCtor(Ctor) {
                    return function() {
                        var args = arguments;
                        switch (args.length) {
                            case 0:
                                return new Ctor;
                            case 1:
                                return new Ctor(args[0]);
                            case 2:
                                return new Ctor(args[0], args[1]);
                            case 3:
                                return new Ctor(args[0], args[1], args[2]);
                            case 4:
                                return new Ctor(args[0], args[1], args[2], args[3]);
                            case 5:
                                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
                            case 6:
                                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
                            case 7:
                                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6])
                        }
                        var thisBinding = baseCreate(Ctor.prototype),
                            result = Ctor.apply(thisBinding, args);
                        return isObject(result) ? result : thisBinding
                    }
                }

                function createCurry(func, bitmask, arity) {
                    function wrapper() {
                        for (var length = arguments.length, args = Array(length), index = length, placeholder = getHolder(wrapper); index--;) args[index] = arguments[index];
                        var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
                        if (length -= holders.length, length < arity) return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, undefined, args, holders, undefined, undefined, arity - length);
                        var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
                        return apply(fn, this, args)
                    }
                    var Ctor = createCtor(func);
                    return wrapper
                }

                function createFind(findIndexFunc) {
                    return function(collection, predicate, fromIndex) {
                        var iterable = Object(collection);
                        if (!isArrayLike(collection)) {
                            var iteratee = getIteratee(predicate, 3);
                            collection = keys(collection), predicate = function(key) {
                                return iteratee(iterable[key], key, iterable)
                            }
                        }
                        var index = findIndexFunc(collection, predicate, fromIndex);
                        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined
                    }
                }

                function createFlow(fromRight) {
                    return flatRest(function(funcs) {
                        var length = funcs.length,
                            index = length,
                            prereq = LodashWrapper.prototype.thru;
                        for (fromRight && funcs.reverse(); index--;) {
                            var func = funcs[index];
                            if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                            if (prereq && !wrapper && "wrapper" == getFuncName(func)) var wrapper = new LodashWrapper([], (!0))
                        }
                        for (index = wrapper ? index : length; ++index < length;) {
                            func = funcs[index];
                            var funcName = getFuncName(func),
                                data = "wrapper" == funcName ? getData(func) : undefined;
                            wrapper = data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && 1 == data[9] ? wrapper[getFuncName(data[0])].apply(wrapper, data[3]) : 1 == func.length && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func)
                        }
                        return function() {
                            var args = arguments,
                                value = args[0];
                            if (wrapper && 1 == args.length && isArray(value)) return wrapper.plant(value).value();
                            for (var index = 0, result = length ? funcs[index].apply(this, args) : value; ++index < length;) result = funcs[index].call(this, result);
                            return result
                        }
                    })
                }

                function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
                    function wrapper() {
                        for (var length = arguments.length, args = Array(length), index = length; index--;) args[index] = arguments[index];
                        if (isCurried) var placeholder = getHolder(wrapper),
                            holdersCount = countHolders(args, placeholder);
                        if (partials && (args = composeArgs(args, partials, holders, isCurried)), partialsRight && (args = composeArgsRight(args, partialsRight, holdersRight, isCurried)), length -= holdersCount, isCurried && length < arity) {
                            var newHolders = replaceHolders(args, placeholder);
                            return createRecurry(func, bitmask, createHybrid, wrapper.placeholder, thisArg, args, newHolders, argPos, ary, arity - length)
                        }
                        var thisBinding = isBind ? thisArg : this,
                            fn = isBindKey ? thisBinding[func] : func;
                        return length = args.length, argPos ? args = reorder(args, argPos) : isFlip && length > 1 && args.reverse(), isAry && ary < length && (args.length = ary), this && this !== root && this instanceof wrapper && (fn = Ctor || createCtor(fn)), fn.apply(thisBinding, args)
                    }
                    var isAry = bitmask & WRAP_ARY_FLAG,
                        isBind = bitmask & WRAP_BIND_FLAG,
                        isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
                        isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
                        isFlip = bitmask & WRAP_FLIP_FLAG,
                        Ctor = isBindKey ? undefined : createCtor(func);
                    return wrapper
                }

                function createInverter(setter, toIteratee) {
                    return function(object, iteratee) {
                        return baseInverter(object, setter, toIteratee(iteratee), {})
                    }
                }

                function createMathOperation(operator, defaultValue) {
                    return function(value, other) {
                        var result;
                        if (value === undefined && other === undefined) return defaultValue;
                        if (value !== undefined && (result = value), other !== undefined) {
                            if (result === undefined) return other;
                            "string" == typeof value || "string" == typeof other ? (value = baseToString(value), other = baseToString(other)) : (value = baseToNumber(value), other = baseToNumber(other)), result = operator(value, other)
                        }
                        return result
                    }
                }

                function createOver(arrayFunc) {
                    return flatRest(function(iteratees) {
                        return iteratees = arrayMap(iteratees, baseUnary(getIteratee())), baseRest(function(args) {
                            var thisArg = this;
                            return arrayFunc(iteratees, function(iteratee) {
                                return apply(iteratee, thisArg, args)
                            })
                        })
                    })
                }

                function createPadding(length, chars) {
                    chars = chars === undefined ? " " : baseToString(chars);
                    var charsLength = chars.length;
                    if (charsLength < 2) return charsLength ? baseRepeat(chars, length) : chars;
                    var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
                    return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join("") : result.slice(0, length)
                }

                function createPartial(func, bitmask, thisArg, partials) {
                    function wrapper() {
                        for (var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func; ++leftIndex < leftLength;) args[leftIndex] = partials[leftIndex];
                        for (; argsLength--;) args[leftIndex++] = arguments[++argsIndex];
                        return apply(fn, isBind ? thisArg : this, args)
                    }
                    var isBind = bitmask & WRAP_BIND_FLAG,
                        Ctor = createCtor(func);
                    return wrapper
                }

                function createRange(fromRight) {
                    return function(start, end, step) {
                        return step && "number" != typeof step && isIterateeCall(start, end, step) && (end = step = undefined), start = toFinite(start), end === undefined ? (end = start, start = 0) : end = toFinite(end), step = step === undefined ? start < end ? 1 : -1 : toFinite(step), baseRange(start, end, step, fromRight)
                    }
                }

                function createRelationalOperation(operator) {
                    return function(value, other) {
                        return "string" == typeof value && "string" == typeof other || (value = toNumber(value), other = toNumber(other)), operator(value, other)
                    }
                }

                function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
                    var isCurry = bitmask & WRAP_CURRY_FLAG,
                        newHolders = isCurry ? holders : undefined,
                        newHoldersRight = isCurry ? undefined : holders,
                        newPartials = isCurry ? partials : undefined,
                        newPartialsRight = isCurry ? undefined : partials;
                    bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG, bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG), bitmask & WRAP_CURRY_BOUND_FLAG || (bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG));
                    var newData = [func, bitmask, thisArg, newPartials, newHolders, newPartialsRight, newHoldersRight, argPos, ary, arity],
                        result = wrapFunc.apply(undefined, newData);
                    return isLaziable(func) && setData(result, newData), result.placeholder = placeholder, setWrapToString(result, func, bitmask)
                }

                function createRound(methodName) {
                    var func = Math[methodName];
                    return function(number, precision) {
                        if (number = toNumber(number), precision = null == precision ? 0 : nativeMin(toInteger(precision), 292), precision && nativeIsFinite(number)) {
                            var pair = (toString(number) + "e").split("e"),
                                value = func(pair[0] + "e" + (+pair[1] + precision));
                            return pair = (toString(value) + "e").split("e"), +(pair[0] + "e" + (+pair[1] - precision))
                        }
                        return func(number)
                    }
                }

                function createToPairs(keysFunc) {
                    return function(object) {
                        var tag = getTag(object);
                        return tag == mapTag ? mapToArray(object) : tag == setTag ? setToPairs(object) : baseToPairs(object, keysFunc(object))
                    }
                }

                function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
                    var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
                    if (!isBindKey && "function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    var length = partials ? partials.length : 0;
                    if (length || (bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG), partials = holders = undefined), ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0), arity = arity === undefined ? arity : toInteger(arity), length -= holders ? holders.length : 0, bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
                        var partialsRight = partials,
                            holdersRight = holders;
                        partials = holders = undefined
                    }
                    var data = isBindKey ? undefined : getData(func),
                        newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];
                    if (data && mergeData(newData, data), func = newData[0], bitmask = newData[1], thisArg = newData[2], partials = newData[3], holders = newData[4], arity = newData[9] = newData[9] === undefined ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0), !arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG) && (bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)), bitmask && bitmask != WRAP_BIND_FLAG) result = bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG ? createCurry(func, bitmask, arity) : bitmask != WRAP_PARTIAL_FLAG && bitmask != (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG) || holders.length ? createHybrid.apply(undefined, newData) : createPartial(func, bitmask, thisArg, partials);
                    else var result = createBind(func, bitmask, thisArg);
                    var setter = data ? baseSetData : setData;
                    return setWrapToString(setter(result, newData), func, bitmask)
                }

                function customDefaultsAssignIn(objValue, srcValue, key, object) {
                    return objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key) ? srcValue : objValue
                }

                function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
                    return isObject(objValue) && isObject(srcValue) && (stack.set(srcValue, objValue), baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack), stack.delete(srcValue)), objValue
                }

                function customOmitClone(value) {
                    return isPlainObject(value) ? undefined : value
                }

                function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                        arrLength = array.length,
                        othLength = other.length;
                    if (arrLength != othLength && !(isPartial && othLength > arrLength)) return !1;
                    var stacked = stack.get(array);
                    if (stacked && stack.get(other)) return stacked == other;
                    var index = -1,
                        result = !0,
                        seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache : undefined;
                    for (stack.set(array, other), stack.set(other, array); ++index < arrLength;) {
                        var arrValue = array[index],
                            othValue = other[index];
                        if (customizer) var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
                        if (compared !== undefined) {
                            if (compared) continue;
                            result = !1;
                            break
                        }
                        if (seen) {
                            if (!arraySome(other, function(othValue, othIndex) {
                                    if (!cacheHas(seen, othIndex) && (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) return seen.push(othIndex)
                                })) {
                                result = !1;
                                break
                            }
                        } else if (arrValue !== othValue && !equalFunc(arrValue, othValue, bitmask, customizer, stack)) {
                            result = !1;
                            break
                        }
                    }
                    return stack.delete(array), stack.delete(other), result
                }

                function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
                    switch (tag) {
                        case dataViewTag:
                            if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) return !1;
                            object = object.buffer, other = other.buffer;
                        case arrayBufferTag:
                            return !(object.byteLength != other.byteLength || !equalFunc(new Uint8Array(object), new Uint8Array(other)));
                        case boolTag:
                        case dateTag:
                        case numberTag:
                            return eq(+object, +other);
                        case errorTag:
                            return object.name == other.name && object.message == other.message;
                        case regexpTag:
                        case stringTag:
                            return object == other + "";
                        case mapTag:
                            var convert = mapToArray;
                        case setTag:
                            var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
                            if (convert || (convert = setToArray), object.size != other.size && !isPartial) return !1;
                            var stacked = stack.get(object);
                            if (stacked) return stacked == other;
                            bitmask |= COMPARE_UNORDERED_FLAG, stack.set(object, other);
                            var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
                            return stack.delete(object), result;
                        case symbolTag:
                            if (symbolValueOf) return symbolValueOf.call(object) == symbolValueOf.call(other)
                    }
                    return !1
                }

                function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
                    var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
                        objProps = getAllKeys(object),
                        objLength = objProps.length,
                        othProps = getAllKeys(other),
                        othLength = othProps.length;
                    if (objLength != othLength && !isPartial) return !1;
                    for (var index = objLength; index--;) {
                        var key = objProps[index];
                        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) return !1
                    }
                    var stacked = stack.get(object);
                    if (stacked && stack.get(other)) return stacked == other;
                    var result = !0;
                    stack.set(object, other), stack.set(other, object);
                    for (var skipCtor = isPartial; ++index < objLength;) {
                        key = objProps[index];
                        var objValue = object[key],
                            othValue = other[key];
                        if (customizer) var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
                        if (!(compared === undefined ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
                            result = !1;
                            break
                        }
                        skipCtor || (skipCtor = "constructor" == key)
                    }
                    if (result && !skipCtor) {
                        var objCtor = object.constructor,
                            othCtor = other.constructor;
                        objCtor != othCtor && "constructor" in object && "constructor" in other && !("function" == typeof objCtor && objCtor instanceof objCtor && "function" == typeof othCtor && othCtor instanceof othCtor) && (result = !1)
                    }
                    return stack.delete(object), stack.delete(other), result
                }

                function flatRest(func) {
                    return setToString(overRest(func, undefined, flatten), func + "")
                }

                function getAllKeys(object) {
                    return baseGetAllKeys(object, keys, getSymbols)
                }

                function getAllKeysIn(object) {
                    return baseGetAllKeys(object, keysIn, getSymbolsIn)
                }

                function getFuncName(func) {
                    for (var result = func.name + "", array = realNames[result], length = hasOwnProperty.call(realNames, result) ? array.length : 0; length--;) {
                        var data = array[length],
                            otherFunc = data.func;
                        if (null == otherFunc || otherFunc == func) return data.name
                    }
                    return result
                }

                function getHolder(func) {
                    var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
                    return object.placeholder
                }

                function getIteratee() {
                    var result = lodash.iteratee || iteratee;
                    return result = result === iteratee ? baseIteratee : result, arguments.length ? result(arguments[0], arguments[1]) : result
                }

                function getMapData(map, key) {
                    var data = map.__data__;
                    return isKeyable(key) ? data["string" == typeof key ? "string" : "hash"] : data.map
                }

                function getMatchData(object) {
                    for (var result = keys(object), length = result.length; length--;) {
                        var key = result[length],
                            value = object[key];
                        result[length] = [key, value, isStrictComparable(value)]
                    }
                    return result
                }

                function getNative(object, key) {
                    var value = getValue(object, key);
                    return baseIsNative(value) ? value : undefined
                }

                function getRawTag(value) {
                    var isOwn = hasOwnProperty.call(value, symToStringTag),
                        tag = value[symToStringTag];
                    try {
                        value[symToStringTag] = undefined;
                        var unmasked = !0
                    } catch (e) {}
                    var result = nativeObjectToString.call(value);
                    return unmasked && (isOwn ? value[symToStringTag] = tag : delete value[symToStringTag]), result
                }

                function getView(start, end, transforms) {
                    for (var index = -1, length = transforms.length; ++index < length;) {
                        var data = transforms[index],
                            size = data.size;
                        switch (data.type) {
                            case "drop":
                                start += size;
                                break;
                            case "dropRight":
                                end -= size;
                                break;
                            case "take":
                                end = nativeMin(end, start + size);
                                break;
                            case "takeRight":
                                start = nativeMax(start, end - size)
                        }
                    }
                    return {
                        start: start,
                        end: end
                    }
                }

                function getWrapDetails(source) {
                    var match = source.match(reWrapDetails);
                    return match ? match[1].split(reSplitDetails) : []
                }

                function hasPath(object, path, hasFunc) {
                    path = castPath(path, object);
                    for (var index = -1, length = path.length, result = !1; ++index < length;) {
                        var key = toKey(path[index]);
                        if (!(result = null != object && hasFunc(object, key))) break;
                        object = object[key]
                    }
                    return result || ++index != length ? result : (length = null == object ? 0 : object.length, !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object)))
                }

                function initCloneArray(array) {
                    var length = array.length,
                        result = new array.constructor(length);
                    return length && "string" == typeof array[0] && hasOwnProperty.call(array, "index") && (result.index = array.index, result.input = array.input), result
                }

                function initCloneObject(object) {
                    return "function" != typeof object.constructor || isPrototype(object) ? {} : baseCreate(getPrototype(object))
                }

                function initCloneByTag(object, tag, isDeep) {
                    var Ctor = object.constructor;
                    switch (tag) {
                        case arrayBufferTag:
                            return cloneArrayBuffer(object);
                        case boolTag:
                        case dateTag:
                            return new Ctor((+object));
                        case dataViewTag:
                            return cloneDataView(object, isDeep);
                        case float32Tag:
                        case float64Tag:
                        case int8Tag:
                        case int16Tag:
                        case int32Tag:
                        case uint8Tag:
                        case uint8ClampedTag:
                        case uint16Tag:
                        case uint32Tag:
                            return cloneTypedArray(object, isDeep);
                        case mapTag:
                            return new Ctor;
                        case numberTag:
                        case stringTag:
                            return new Ctor(object);
                        case regexpTag:
                            return cloneRegExp(object);
                        case setTag:
                            return new Ctor;
                        case symbolTag:
                            return cloneSymbol(object)
                    }
                }

                function insertWrapDetails(source, details) {
                    var length = details.length;
                    if (!length) return source;
                    var lastIndex = length - 1;
                    return details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex], details = details.join(length > 2 ? ", " : " "), source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n")
                }

                function isFlattenable(value) {
                    return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol])
                }

                function isIndex(value, length) {
                    var type = _typeof2(value);
                    return length = null == length ? MAX_SAFE_INTEGER : length, !!length && ("number" == type || "symbol" != type && reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length
                }

                function isIterateeCall(value, index, object) {
                    if (!isObject(object)) return !1;
                    var type = _typeof2(index);
                    return !!("number" == type ? isArrayLike(object) && isIndex(index, object.length) : "string" == type && index in object) && eq(object[index], value)
                }

                function isKey(value, object) {
                    if (isArray(value)) return !1;
                    var type = _typeof2(value);
                    return !("number" != type && "symbol" != type && "boolean" != type && null != value && !isSymbol(value)) || (reIsPlainProp.test(value) || !reIsDeepProp.test(value) || null != object && value in Object(object))
                }

                function isKeyable(value) {
                    var type = _typeof2(value);
                    return "string" == type || "number" == type || "symbol" == type || "boolean" == type ? "__proto__" !== value : null === value
                }

                function isLaziable(func) {
                    var funcName = getFuncName(func),
                        other = lodash[funcName];
                    if ("function" != typeof other || !(funcName in LazyWrapper.prototype)) return !1;
                    if (func === other) return !0;
                    var data = getData(other);
                    return !!data && func === data[0]
                }

                function isMasked(func) {
                    return !!maskSrcKey && maskSrcKey in func
                }

                function isPrototype(value) {
                    var Ctor = value && value.constructor,
                        proto = "function" == typeof Ctor && Ctor.prototype || objectProto;
                    return value === proto
                }

                function isStrictComparable(value) {
                    return value === value && !isObject(value)
                }

                function matchesStrictComparable(key, srcValue) {
                    return function(object) {
                        return null != object && (object[key] === srcValue && (srcValue !== undefined || key in Object(object)))
                    }
                }

                function memoizeCapped(func) {
                    var result = memoize(func, function(key) {
                            return cache.size === MAX_MEMOIZE_SIZE && cache.clear(), key
                        }),
                        cache = result.cache;
                    return result
                }

                function mergeData(data, source) {
                    var bitmask = data[1],
                        srcBitmask = source[1],
                        newBitmask = bitmask | srcBitmask,
                        isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG),
                        isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
                    if (!isCommon && !isCombo) return data;
                    srcBitmask & WRAP_BIND_FLAG && (data[2] = source[2], newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG);
                    var value = source[3];
                    if (value) {
                        var partials = data[3];
                        data[3] = partials ? composeArgs(partials, value, source[4]) : value, data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4]
                    }
                    return value = source[5], value && (partials = data[5], data[5] = partials ? composeArgsRight(partials, value, source[6]) : value, data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6]), value = source[7], value && (data[7] = value), srcBitmask & WRAP_ARY_FLAG && (data[8] = null == data[8] ? source[8] : nativeMin(data[8], source[8])), null == data[9] && (data[9] = source[9]), data[0] = source[0], data[1] = newBitmask, data
                }

                function nativeKeysIn(object) {
                    var result = [];
                    if (null != object)
                        for (var key in Object(object)) result.push(key);
                    return result
                }

                function objectToString(value) {
                    return nativeObjectToString.call(value)
                }

                function overRest(func, start, transform) {
                    return start = nativeMax(start === undefined ? func.length - 1 : start, 0),
                        function() {
                            for (var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length); ++index < length;) array[index] = args[start + index];
                            index = -1;
                            for (var otherArgs = Array(start + 1); ++index < start;) otherArgs[index] = args[index];
                            return otherArgs[start] = transform(array), apply(func, this, otherArgs)
                        }
                }

                function parent(object, path) {
                    return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1))
                }

                function reorder(array, indexes) {
                    for (var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array); length--;) {
                        var index = indexes[length];
                        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined
                    }
                    return array
                }

                function safeGet(object, key) {
                    if (("constructor" !== key || "function" != typeof object[key]) && "__proto__" != key) return object[key]
                }

                function setWrapToString(wrapper, reference, bitmask) {
                    var source = reference + "";
                    return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)))
                }

                function shortOut(func) {
                    var count = 0,
                        lastCalled = 0;
                    return function() {
                        var stamp = nativeNow(),
                            remaining = HOT_SPAN - (stamp - lastCalled);
                        if (lastCalled = stamp, remaining > 0) {
                            if (++count >= HOT_COUNT) return arguments[0]
                        } else count = 0;
                        return func.apply(undefined, arguments)
                    }
                }

                function shuffleSelf(array, size) {
                    var index = -1,
                        length = array.length,
                        lastIndex = length - 1;
                    for (size = size === undefined ? length : size; ++index < size;) {
                        var rand = baseRandom(index, lastIndex),
                            value = array[rand];
                        array[rand] = array[index], array[index] = value
                    }
                    return array.length = size, array
                }

                function toKey(value) {
                    if ("string" == typeof value || isSymbol(value)) return value;
                    var result = value + "";
                    return "0" == result && 1 / value == -INFINITY ? "-0" : result
                }

                function toSource(func) {
                    if (null != func) {
                        try {
                            return funcToString.call(func)
                        } catch (e) {}
                        try {
                            return func + ""
                        } catch (e) {}
                    }
                    return ""
                }

                function updateWrapDetails(details, bitmask) {
                    return arrayEach(wrapFlags, function(pair) {
                        var value = "_." + pair[0];
                        bitmask & pair[1] && !arrayIncludes(details, value) && details.push(value)
                    }), details.sort()
                }

                function wrapperClone(wrapper) {
                    if (wrapper instanceof LazyWrapper) return wrapper.clone();
                    var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
                    return result.__actions__ = copyArray(wrapper.__actions__), result.__index__ = wrapper.__index__, result.__values__ = wrapper.__values__, result
                }

                function chunk(array, size, guard) {
                    size = (guard ? isIterateeCall(array, size, guard) : size === undefined) ? 1 : nativeMax(toInteger(size), 0);
                    var length = null == array ? 0 : array.length;
                    if (!length || size < 1) return [];
                    for (var index = 0, resIndex = 0, result = Array(nativeCeil(length / size)); index < length;) result[resIndex++] = baseSlice(array, index, index += size);
                    return result
                }

                function compact(array) {
                    for (var index = -1, length = null == array ? 0 : array.length, resIndex = 0, result = []; ++index < length;) {
                        var value = array[index];
                        value && (result[resIndex++] = value)
                    }
                    return result
                }

                function concat() {
                    var length = arguments.length;
                    if (!length) return [];
                    for (var args = Array(length - 1), array = arguments[0], index = length; index--;) args[index - 1] = arguments[index];
                    return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1))
                }

                function drop(array, n, guard) {
                    var length = null == array ? 0 : array.length;
                    return length ? (n = guard || n === undefined ? 1 : toInteger(n), baseSlice(array, n < 0 ? 0 : n, length)) : []
                }

                function dropRight(array, n, guard) {
                    var length = null == array ? 0 : array.length;
                    return length ? (n = guard || n === undefined ? 1 : toInteger(n), n = length - n, baseSlice(array, 0, n < 0 ? 0 : n)) : []
                }

                function dropRightWhile(array, predicate) {
                    return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0, !0) : []
                }

                function dropWhile(array, predicate) {
                    return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !0) : []
                }

                function fill(array, value, start, end) {
                    var length = null == array ? 0 : array.length;
                    return length ? (start && "number" != typeof start && isIterateeCall(array, value, start) && (start = 0, end = length), baseFill(array, value, start, end)) : []
                }

                function findIndex(array, predicate, fromIndex) {
                    var length = null == array ? 0 : array.length;
                    if (!length) return -1;
                    var index = null == fromIndex ? 0 : toInteger(fromIndex);
                    return index < 0 && (index = nativeMax(length + index, 0)), baseFindIndex(array, getIteratee(predicate, 3), index)
                }

                function findLastIndex(array, predicate, fromIndex) {
                    var length = null == array ? 0 : array.length;
                    if (!length) return -1;
                    var index = length - 1;
                    return fromIndex !== undefined && (index = toInteger(fromIndex), index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)), baseFindIndex(array, getIteratee(predicate, 3), index, !0)
                }

                function flatten(array) {
                    var length = null == array ? 0 : array.length;
                    return length ? baseFlatten(array, 1) : []
                }

                function flattenDeep(array) {
                    var length = null == array ? 0 : array.length;
                    return length ? baseFlatten(array, INFINITY) : []
                }

                function flattenDepth(array, depth) {
                    var length = null == array ? 0 : array.length;
                    return length ? (depth = depth === undefined ? 1 : toInteger(depth), baseFlatten(array, depth)) : []
                }

                function fromPairs(pairs) {
                    for (var index = -1, length = null == pairs ? 0 : pairs.length, result = {}; ++index < length;) {
                        var pair = pairs[index];
                        result[pair[0]] = pair[1]
                    }
                    return result
                }

                function head(array) {
                    return array && array.length ? array[0] : undefined
                }

                function indexOf(array, value, fromIndex) {
                    var length = null == array ? 0 : array.length;
                    if (!length) return -1;
                    var index = null == fromIndex ? 0 : toInteger(fromIndex);
                    return index < 0 && (index = nativeMax(length + index, 0)), baseIndexOf(array, value, index)
                }

                function initial(array) {
                    var length = null == array ? 0 : array.length;
                    return length ? baseSlice(array, 0, -1) : []
                }

                function join(array, separator) {
                    return null == array ? "" : nativeJoin.call(array, separator)
                }

                function last(array) {
                    var length = null == array ? 0 : array.length;
                    return length ? array[length - 1] : undefined
                }

                function lastIndexOf(array, value, fromIndex) {
                    var length = null == array ? 0 : array.length;
                    if (!length) return -1;
                    var index = length;
                    return fromIndex !== undefined && (index = toInteger(fromIndex), index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1)), value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, !0)
                }

                function nth(array, n) {
                    return array && array.length ? baseNth(array, toInteger(n)) : undefined
                }

                function pullAll(array, values) {
                    return array && array.length && values && values.length ? basePullAll(array, values) : array
                }

                function pullAllBy(array, values, iteratee) {
                    return array && array.length && values && values.length ? basePullAll(array, values, getIteratee(iteratee, 2)) : array
                }

                function pullAllWith(array, values, comparator) {
                    return array && array.length && values && values.length ? basePullAll(array, values, undefined, comparator) : array
                }

                function remove(array, predicate) {
                    var result = [];
                    if (!array || !array.length) return result;
                    var index = -1,
                        indexes = [],
                        length = array.length;
                    for (predicate = getIteratee(predicate, 3); ++index < length;) {
                        var value = array[index];
                        predicate(value, index, array) && (result.push(value), indexes.push(index))
                    }
                    return basePullAt(array, indexes), result
                }

                function reverse(array) {
                    return null == array ? array : nativeReverse.call(array)
                }

                function slice(array, start, end) {
                    var length = null == array ? 0 : array.length;
                    return length ? (end && "number" != typeof end && isIterateeCall(array, start, end) ? (start = 0, end = length) : (start = null == start ? 0 : toInteger(start), end = end === undefined ? length : toInteger(end)), baseSlice(array, start, end)) : []
                }

                function sortedIndex(array, value) {
                    return baseSortedIndex(array, value)
                }

                function sortedIndexBy(array, value, iteratee) {
                    return baseSortedIndexBy(array, value, getIteratee(iteratee, 2))
                }

                function sortedIndexOf(array, value) {
                    var length = null == array ? 0 : array.length;
                    if (length) {
                        var index = baseSortedIndex(array, value);
                        if (index < length && eq(array[index], value)) return index
                    }
                    return -1
                }

                function sortedLastIndex(array, value) {
                    return baseSortedIndex(array, value, !0)
                }

                function sortedLastIndexBy(array, value, iteratee) {
                    return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), !0)
                }

                function sortedLastIndexOf(array, value) {
                    var length = null == array ? 0 : array.length;
                    if (length) {
                        var index = baseSortedIndex(array, value, !0) - 1;
                        if (eq(array[index], value)) return index
                    }
                    return -1
                }

                function sortedUniq(array) {
                    return array && array.length ? baseSortedUniq(array) : []
                }

                function sortedUniqBy(array, iteratee) {
                    return array && array.length ? baseSortedUniq(array, getIteratee(iteratee, 2)) : []
                }

                function tail(array) {
                    var length = null == array ? 0 : array.length;
                    return length ? baseSlice(array, 1, length) : []
                }

                function take(array, n, guard) {
                    return array && array.length ? (n = guard || n === undefined ? 1 : toInteger(n), baseSlice(array, 0, n < 0 ? 0 : n)) : []
                }

                function takeRight(array, n, guard) {
                    var length = null == array ? 0 : array.length;
                    return length ? (n = guard || n === undefined ? 1 : toInteger(n), n = length - n, baseSlice(array, n < 0 ? 0 : n, length)) : []
                }

                function takeRightWhile(array, predicate) {
                    return array && array.length ? baseWhile(array, getIteratee(predicate, 3), !1, !0) : []
                }

                function takeWhile(array, predicate) {
                    return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : []
                }

                function uniq(array) {
                    return array && array.length ? baseUniq(array) : []
                }

                function uniqBy(array, iteratee) {
                    return array && array.length ? baseUniq(array, getIteratee(iteratee, 2)) : []
                }

                function uniqWith(array, comparator) {
                    return comparator = "function" == typeof comparator ? comparator : undefined, array && array.length ? baseUniq(array, undefined, comparator) : []
                }

                function unzip(array) {
                    if (!array || !array.length) return [];
                    var length = 0;
                    return array = arrayFilter(array, function(group) {
                        if (isArrayLikeObject(group)) return length = nativeMax(group.length, length), !0
                    }), baseTimes(length, function(index) {
                        return arrayMap(array, baseProperty(index))
                    })
                }

                function unzipWith(array, iteratee) {
                    if (!array || !array.length) return [];
                    var result = unzip(array);
                    return null == iteratee ? result : arrayMap(result, function(group) {
                        return apply(iteratee, undefined, group)
                    })
                }

                function zipObject(props, values) {
                    return baseZipObject(props || [], values || [], assignValue)
                }

                function zipObjectDeep(props, values) {
                    return baseZipObject(props || [], values || [], baseSet)
                }

                function chain(value) {
                    var result = lodash(value);
                    return result.__chain__ = !0, result
                }

                function tap(value, interceptor) {
                    return interceptor(value), value
                }

                function thru(value, interceptor) {
                    return interceptor(value)
                }

                function wrapperChain() {
                    return chain(this)
                }

                function wrapperCommit() {
                    return new LodashWrapper(this.value(), this.__chain__)
                }

                function wrapperNext() {
                    this.__values__ === undefined && (this.__values__ = toArray(this.value()));
                    var done = this.__index__ >= this.__values__.length,
                        value = done ? undefined : this.__values__[this.__index__++];
                    return {
                        done: done,
                        value: value
                    }
                }

                function wrapperToIterator() {
                    return this
                }

                function wrapperPlant(value) {
                    for (var result, parent = this; parent instanceof baseLodash;) {
                        var clone = wrapperClone(parent);
                        clone.__index__ = 0, clone.__values__ = undefined, result ? previous.__wrapped__ = clone : result = clone;
                        var previous = clone;
                        parent = parent.__wrapped__
                    }
                    return previous.__wrapped__ = value, result
                }

                function wrapperReverse() {
                    var value = this.__wrapped__;
                    if (value instanceof LazyWrapper) {
                        var wrapped = value;
                        return this.__actions__.length && (wrapped = new LazyWrapper(this)), wrapped = wrapped.reverse(), wrapped.__actions__.push({
                            func: thru,
                            args: [reverse],
                            thisArg: undefined
                        }), new LodashWrapper(wrapped, this.__chain__)
                    }
                    return this.thru(reverse)
                }

                function wrapperValue() {
                    return baseWrapperValue(this.__wrapped__, this.__actions__)
                }

                function every(collection, predicate, guard) {
                    var func = isArray(collection) ? arrayEvery : baseEvery;
                    return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined), func(collection, getIteratee(predicate, 3))
                }

                function filter(collection, predicate) {
                    var func = isArray(collection) ? arrayFilter : baseFilter;
                    return func(collection, getIteratee(predicate, 3))
                }

                function flatMap(collection, iteratee) {
                    return baseFlatten(map(collection, iteratee), 1)
                }

                function flatMapDeep(collection, iteratee) {
                    return baseFlatten(map(collection, iteratee), INFINITY)
                }

                function flatMapDepth(collection, iteratee, depth) {
                    return depth = depth === undefined ? 1 : toInteger(depth), baseFlatten(map(collection, iteratee), depth)
                }

                function forEach(collection, iteratee) {
                    var func = isArray(collection) ? arrayEach : baseEach;
                    return func(collection, getIteratee(iteratee, 3))
                }

                function forEachRight(collection, iteratee) {
                    var func = isArray(collection) ? arrayEachRight : baseEachRight;
                    return func(collection, getIteratee(iteratee, 3))
                }

                function includes(collection, value, fromIndex, guard) {
                    collection = isArrayLike(collection) ? collection : values(collection), fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
                    var length = collection.length;
                    return fromIndex < 0 && (fromIndex = nativeMax(length + fromIndex, 0)), isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1
                }

                function map(collection, iteratee) {
                    var func = isArray(collection) ? arrayMap : baseMap;
                    return func(collection, getIteratee(iteratee, 3))
                }

                function orderBy(collection, iteratees, orders, guard) {
                    return null == collection ? [] : (isArray(iteratees) || (iteratees = null == iteratees ? [] : [iteratees]), orders = guard ? undefined : orders, isArray(orders) || (orders = null == orders ? [] : [orders]), baseOrderBy(collection, iteratees, orders))
                }

                function reduce(collection, iteratee, accumulator) {
                    var func = isArray(collection) ? arrayReduce : baseReduce,
                        initAccum = arguments.length < 3;
                    return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach)
                }

                function reduceRight(collection, iteratee, accumulator) {
                    var func = isArray(collection) ? arrayReduceRight : baseReduce,
                        initAccum = arguments.length < 3;
                    return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight)
                }

                function reject(collection, predicate) {
                    var func = isArray(collection) ? arrayFilter : baseFilter;
                    return func(collection, negate(getIteratee(predicate, 3)))
                }

                function sample(collection) {
                    var func = isArray(collection) ? arraySample : baseSample;
                    return func(collection)
                }

                function sampleSize(collection, n, guard) {
                    n = (guard ? isIterateeCall(collection, n, guard) : n === undefined) ? 1 : toInteger(n);
                    var func = isArray(collection) ? arraySampleSize : baseSampleSize;
                    return func(collection, n)
                }

                function shuffle(collection) {
                    var func = isArray(collection) ? arrayShuffle : baseShuffle;
                    return func(collection)
                }

                function size(collection) {
                    if (null == collection) return 0;
                    if (isArrayLike(collection)) return isString(collection) ? stringSize(collection) : collection.length;
                    var tag = getTag(collection);
                    return tag == mapTag || tag == setTag ? collection.size : baseKeys(collection).length
                }

                function some(collection, predicate, guard) {
                    var func = isArray(collection) ? arraySome : baseSome;
                    return guard && isIterateeCall(collection, predicate, guard) && (predicate = undefined), func(collection, getIteratee(predicate, 3))
                }

                function after(n, func) {
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    return n = toInteger(n),
                        function() {
                            if (--n < 1) return func.apply(this, arguments)
                        }
                }

                function ary(func, n, guard) {
                    return n = guard ? undefined : n, n = func && null == n ? func.length : n, createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n)
                }

                function before(n, func) {
                    var result;
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    return n = toInteger(n),
                        function() {
                            return --n > 0 && (result = func.apply(this, arguments)), n <= 1 && (func = undefined), result
                        }
                }

                function curry(func, arity, guard) {
                    arity = guard ? undefined : arity;
                    var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                    return result.placeholder = curry.placeholder, result
                }

                function curryRight(func, arity, guard) {
                    arity = guard ? undefined : arity;
                    var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
                    return result.placeholder = curryRight.placeholder, result
                }

                function debounce(func, wait, options) {
                    function invokeFunc(time) {
                        var args = lastArgs,
                            thisArg = lastThis;
                        return lastArgs = lastThis = undefined, lastInvokeTime = time, result = func.apply(thisArg, args)
                    }

                    function leadingEdge(time) {
                        return lastInvokeTime = time, timerId = setTimeout(timerExpired, wait), leading ? invokeFunc(time) : result
                    }

                    function remainingWait(time) {
                        var timeSinceLastCall = time - lastCallTime,
                            timeSinceLastInvoke = time - lastInvokeTime,
                            timeWaiting = wait - timeSinceLastCall;
                        return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting
                    }

                    function shouldInvoke(time) {
                        var timeSinceLastCall = time - lastCallTime,
                            timeSinceLastInvoke = time - lastInvokeTime;
                        return lastCallTime === undefined || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait
                    }

                    function timerExpired() {
                        var time = now();
                        return shouldInvoke(time) ? trailingEdge(time) : void(timerId = setTimeout(timerExpired, remainingWait(time)))
                    }

                    function trailingEdge(time) {
                        return timerId = undefined, trailing && lastArgs ? invokeFunc(time) : (lastArgs = lastThis = undefined, result)
                    }

                    function cancel() {
                        timerId !== undefined && clearTimeout(timerId), lastInvokeTime = 0, lastArgs = lastCallTime = lastThis = timerId = undefined
                    }

                    function flush() {
                        return timerId === undefined ? result : trailingEdge(now())
                    }

                    function debounced() {
                        var time = now(),
                            isInvoking = shouldInvoke(time);
                        if (lastArgs = arguments, lastThis = this, lastCallTime = time, isInvoking) {
                            if (timerId === undefined) return leadingEdge(lastCallTime);
                            if (maxing) return clearTimeout(timerId), timerId = setTimeout(timerExpired, wait), invokeFunc(lastCallTime)
                        }
                        return timerId === undefined && (timerId = setTimeout(timerExpired, wait)), result
                    }
                    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0,
                        leading = !1,
                        maxing = !1,
                        trailing = !0;
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    return wait = toNumber(wait) || 0, isObject(options) && (leading = !!options.leading, maxing = "maxWait" in options, maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait, trailing = "trailing" in options ? !!options.trailing : trailing), debounced.cancel = cancel, debounced.flush = flush, debounced
                }

                function flip(func) {
                    return createWrap(func, WRAP_FLIP_FLAG)
                }

                function memoize(func, resolver) {
                    if ("function" != typeof func || null != resolver && "function" != typeof resolver) throw new TypeError(FUNC_ERROR_TEXT);
                    var memoized = function memoized() {
                        var args = arguments,
                            key = resolver ? resolver.apply(this, args) : args[0],
                            cache = memoized.cache;
                        if (cache.has(key)) return cache.get(key);
                        var result = func.apply(this, args);
                        return memoized.cache = cache.set(key, result) || cache, result
                    };
                    return memoized.cache = new(memoize.Cache || MapCache), memoized
                }

                function negate(predicate) {
                    if ("function" != typeof predicate) throw new TypeError(FUNC_ERROR_TEXT);
                    return function() {
                        var args = arguments;
                        switch (args.length) {
                            case 0:
                                return !predicate.call(this);
                            case 1:
                                return !predicate.call(this, args[0]);
                            case 2:
                                return !predicate.call(this, args[0], args[1]);
                            case 3:
                                return !predicate.call(this, args[0], args[1], args[2])
                        }
                        return !predicate.apply(this, args)
                    }
                }

                function once(func) {
                    return before(2, func)
                }

                function rest(func, start) {
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    return start = start === undefined ? start : toInteger(start), baseRest(func, start)
                }

                function spread(func, start) {
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    return start = null == start ? 0 : nativeMax(toInteger(start), 0), baseRest(function(args) {
                        var array = args[start],
                            otherArgs = castSlice(args, 0, start);
                        return array && arrayPush(otherArgs, array), apply(func, this, otherArgs)
                    })
                }

                function throttle(func, wait, options) {
                    var leading = !0,
                        trailing = !0;
                    if ("function" != typeof func) throw new TypeError(FUNC_ERROR_TEXT);
                    return isObject(options) && (leading = "leading" in options ? !!options.leading : leading, trailing = "trailing" in options ? !!options.trailing : trailing), debounce(func, wait, {
                        leading: leading,
                        maxWait: wait,
                        trailing: trailing
                    })
                }

                function unary(func) {
                    return ary(func, 1)
                }

                function wrap(value, wrapper) {
                    return partial(castFunction(wrapper), value)
                }

                function castArray() {
                    if (!arguments.length) return [];
                    var value = arguments[0];
                    return isArray(value) ? value : [value]
                }

                function clone(value) {
                    return baseClone(value, CLONE_SYMBOLS_FLAG)
                }

                function cloneWith(value, customizer) {
                    return customizer = "function" == typeof customizer ? customizer : undefined, baseClone(value, CLONE_SYMBOLS_FLAG, customizer)
                }

                function cloneDeep(value) {
                    return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG)
                }

                function cloneDeepWith(value, customizer) {
                    return customizer = "function" == typeof customizer ? customizer : undefined, baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer)
                }

                function conformsTo(object, source) {
                    return null == source || baseConformsTo(object, source, keys(source))
                }

                function eq(value, other) {
                    return value === other || value !== value && other !== other
                }

                function isArrayLike(value) {
                    return null != value && isLength(value.length) && !isFunction(value)
                }

                function isArrayLikeObject(value) {
                    return isObjectLike(value) && isArrayLike(value)
                }

                function isBoolean(value) {
                    return value === !0 || value === !1 || isObjectLike(value) && baseGetTag(value) == boolTag
                }

                function isElement(value) {
                    return isObjectLike(value) && 1 === value.nodeType && !isPlainObject(value)
                }

                function isEmpty(value) {
                    if (null == value) return !0;
                    if (isArrayLike(value) && (isArray(value) || "string" == typeof value || "function" == typeof value.splice || isBuffer(value) || isTypedArray(value) || isArguments(value))) return !value.length;
                    var tag = getTag(value);
                    if (tag == mapTag || tag == setTag) return !value.size;
                    if (isPrototype(value)) return !baseKeys(value).length;
                    for (var key in value)
                        if (hasOwnProperty.call(value, key)) return !1;
                    return !0
                }

                function isEqual(value, other) {
                    return baseIsEqual(value, other)
                }

                function isEqualWith(value, other, customizer) {
                    customizer = "function" == typeof customizer ? customizer : undefined;
                    var result = customizer ? customizer(value, other) : undefined;
                    return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result
                }

                function isError(value) {
                    if (!isObjectLike(value)) return !1;
                    var tag = baseGetTag(value);
                    return tag == errorTag || tag == domExcTag || "string" == typeof value.message && "string" == typeof value.name && !isPlainObject(value)
                }

                function isFinite(value) {
                    return "number" == typeof value && nativeIsFinite(value)
                }

                function isFunction(value) {
                    if (!isObject(value)) return !1;
                    var tag = baseGetTag(value);
                    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag
                }

                function isInteger(value) {
                    return "number" == typeof value && value == toInteger(value)
                }

                function isLength(value) {
                    return "number" == typeof value && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER
                }

                function isObject(value) {
                    var type = _typeof2(value);
                    return null != value && ("object" == type || "function" == type)
                }

                function isObjectLike(value) {
                    return null != value && "object" == _typeof2(value)
                }

                function isMatch(object, source) {
                    return object === source || baseIsMatch(object, source, getMatchData(source))
                }

                function isMatchWith(object, source, customizer) {
                    return customizer = "function" == typeof customizer ? customizer : undefined, baseIsMatch(object, source, getMatchData(source), customizer)
                }

                function isNaN(value) {
                    return isNumber(value) && value != +value
                }

                function isNative(value) {
                    if (isMaskable(value)) throw new Error(CORE_ERROR_TEXT);
                    return baseIsNative(value)
                }

                function isNull(value) {
                    return null === value
                }

                function isNil(value) {
                    return null == value
                }

                function isNumber(value) {
                    return "number" == typeof value || isObjectLike(value) && baseGetTag(value) == numberTag
                }

                function isPlainObject(value) {
                    if (!isObjectLike(value) || baseGetTag(value) != objectTag) return !1;
                    var proto = getPrototype(value);
                    if (null === proto) return !0;
                    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
                    return "function" == typeof Ctor && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString
                }

                function isSafeInteger(value) {
                    return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER
                }

                function isString(value) {
                    return "string" == typeof value || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag
                }

                function isSymbol(value) {
                    return "symbol" == _typeof2(value) || isObjectLike(value) && baseGetTag(value) == symbolTag
                }

                function isUndefined(value) {
                    return value === undefined
                }

                function isWeakMap(value) {
                    return isObjectLike(value) && getTag(value) == weakMapTag
                }

                function isWeakSet(value) {
                    return isObjectLike(value) && baseGetTag(value) == weakSetTag
                }

                function toArray(value) {
                    if (!value) return [];
                    if (isArrayLike(value)) return isString(value) ? stringToArray(value) : copyArray(value);
                    if (symIterator && value[symIterator]) return iteratorToArray(value[symIterator]());
                    var tag = getTag(value),
                        func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
                    return func(value)
                }

                function toFinite(value) {
                    if (!value) return 0 === value ? value : 0;
                    if (value = toNumber(value), value === INFINITY || value === -INFINITY) {
                        var sign = value < 0 ? -1 : 1;
                        return sign * MAX_INTEGER
                    }
                    return value === value ? value : 0
                }

                function toInteger(value) {
                    var result = toFinite(value),
                        remainder = result % 1;
                    return result === result ? remainder ? result - remainder : result : 0
                }

                function toLength(value) {
                    return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0
                }

                function toNumber(value) {
                    if ("number" == typeof value) return value;
                    if (isSymbol(value)) return NAN;
                    if (isObject(value)) {
                        var other = "function" == typeof value.valueOf ? value.valueOf() : value;
                        value = isObject(other) ? other + "" : other
                    }
                    if ("string" != typeof value) return 0 === value ? value : +value;
                    value = value.replace(reTrim, "");
                    var isBinary = reIsBinary.test(value);
                    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value
                }

                function toPlainObject(value) {
                    return copyObject(value, keysIn(value))
                }

                function toSafeInteger(value) {
                    return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : 0 === value ? value : 0
                }

                function toString(value) {
                    return null == value ? "" : baseToString(value)
                }

                function create(prototype, properties) {
                    var result = baseCreate(prototype);
                    return null == properties ? result : baseAssign(result, properties)
                }

                function findKey(object, predicate) {
                    return baseFindKey(object, getIteratee(predicate, 3), baseForOwn)
                }

                function findLastKey(object, predicate) {
                    return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight)
                }

                function forIn(object, iteratee) {
                    return null == object ? object : baseFor(object, getIteratee(iteratee, 3), keysIn)
                }

                function forInRight(object, iteratee) {
                    return null == object ? object : baseForRight(object, getIteratee(iteratee, 3), keysIn)
                }

                function forOwn(object, iteratee) {
                    return object && baseForOwn(object, getIteratee(iteratee, 3))
                }

                function forOwnRight(object, iteratee) {
                    return object && baseForOwnRight(object, getIteratee(iteratee, 3))
                }

                function functions(object) {
                    return null == object ? [] : baseFunctions(object, keys(object))
                }

                function functionsIn(object) {
                    return null == object ? [] : baseFunctions(object, keysIn(object))
                }

                function get(object, path, defaultValue) {
                    var result = null == object ? undefined : baseGet(object, path);
                    return result === undefined ? defaultValue : result
                }

                function has(object, path) {
                    return null != object && hasPath(object, path, baseHas)
                }

                function hasIn(object, path) {
                    return null != object && hasPath(object, path, baseHasIn)
                }

                function keys(object) {
                    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object)
                }

                function keysIn(object) {
                    return isArrayLike(object) ? arrayLikeKeys(object, !0) : baseKeysIn(object)
                }

                function mapKeys(object, iteratee) {
                    var result = {};
                    return iteratee = getIteratee(iteratee, 3), baseForOwn(object, function(value, key, object) {
                        baseAssignValue(result, iteratee(value, key, object), value)
                    }), result
                }

                function mapValues(object, iteratee) {
                    var result = {};
                    return iteratee = getIteratee(iteratee, 3), baseForOwn(object, function(value, key, object) {
                        baseAssignValue(result, key, iteratee(value, key, object))
                    }), result
                }

                function omitBy(object, predicate) {
                    return pickBy(object, negate(getIteratee(predicate)))
                }

                function pickBy(object, predicate) {
                    if (null == object) return {};
                    var props = arrayMap(getAllKeysIn(object), function(prop) {
                        return [prop]
                    });
                    return predicate = getIteratee(predicate), basePickBy(object, props, function(value, path) {
                        return predicate(value, path[0])
                    })
                }

                function result(object, path, defaultValue) {
                    path = castPath(path, object);
                    var index = -1,
                        length = path.length;
                    for (length || (length = 1, object = undefined); ++index < length;) {
                        var value = null == object ? undefined : object[toKey(path[index])];
                        value === undefined && (index = length, value = defaultValue), object = isFunction(value) ? value.call(object) : value
                    }
                    return object
                }

                function set(object, path, value) {
                    return null == object ? object : baseSet(object, path, value)
                }

                function setWith(object, path, value, customizer) {
                    return customizer = "function" == typeof customizer ? customizer : undefined, null == object ? object : baseSet(object, path, value, customizer)
                }

                function transform(object, iteratee, accumulator) {
                    var isArr = isArray(object),
                        isArrLike = isArr || isBuffer(object) || isTypedArray(object);
                    if (iteratee = getIteratee(iteratee, 4), null == accumulator) {
                        var Ctor = object && object.constructor;
                        accumulator = isArrLike ? isArr ? new Ctor : [] : isObject(object) && isFunction(Ctor) ? baseCreate(getPrototype(object)) : {}
                    }
                    return (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
                        return iteratee(accumulator, value, index, object)
                    }), accumulator
                }

                function unset(object, path) {
                    return null == object || baseUnset(object, path)
                }

                function update(object, path, updater) {
                    return null == object ? object : baseUpdate(object, path, castFunction(updater))
                }

                function updateWith(object, path, updater, customizer) {
                    return customizer = "function" == typeof customizer ? customizer : undefined, null == object ? object : baseUpdate(object, path, castFunction(updater), customizer)
                }

                function values(object) {
                    return null == object ? [] : baseValues(object, keys(object))
                }

                function valuesIn(object) {
                    return null == object ? [] : baseValues(object, keysIn(object))
                }

                function clamp(number, lower, upper) {
                    return upper === undefined && (upper = lower, lower = undefined), upper !== undefined && (upper = toNumber(upper), upper = upper === upper ? upper : 0), lower !== undefined && (lower = toNumber(lower), lower = lower === lower ? lower : 0), baseClamp(toNumber(number), lower, upper)
                }

                function inRange(number, start, end) {
                    return start = toFinite(start), end === undefined ? (end = start, start = 0) : end = toFinite(end), number = toNumber(number), baseInRange(number, start, end)
                }

                function random(lower, upper, floating) {
                    if (floating && "boolean" != typeof floating && isIterateeCall(lower, upper, floating) && (upper = floating = undefined), floating === undefined && ("boolean" == typeof upper ? (floating = upper, upper = undefined) : "boolean" == typeof lower && (floating = lower, lower = undefined)), lower === undefined && upper === undefined ? (lower = 0, upper = 1) : (lower = toFinite(lower), upper === undefined ? (upper = lower, lower = 0) : upper = toFinite(upper)), lower > upper) {
                        var temp = lower;
                        lower = upper, upper = temp
                    }
                    if (floating || lower % 1 || upper % 1) {
                        var rand = nativeRandom();
                        return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper)
                    }
                    return baseRandom(lower, upper)
                }

                function capitalize(string) {
                    return upperFirst(toString(string).toLowerCase())
                }

                function deburr(string) {
                    return string = toString(string), string && string.replace(reLatin, deburrLetter).replace(reComboMark, "")
                }

                function endsWith(string, target, position) {
                    string = toString(string), target = baseToString(target);
                    var length = string.length;
                    position = position === undefined ? length : baseClamp(toInteger(position), 0, length);
                    var end = position;
                    return position -= target.length, position >= 0 && string.slice(position, end) == target
                }

                function escape(string) {
                    return string = toString(string), string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string
                }

                function escapeRegExp(string) {
                    return string = toString(string), string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string
                }

                function pad(string, length, chars) {
                    string = toString(string), length = toInteger(length);
                    var strLength = length ? stringSize(string) : 0;
                    if (!length || strLength >= length) return string;
                    var mid = (length - strLength) / 2;
                    return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars)
                }

                function padEnd(string, length, chars) {
                    string = toString(string), length = toInteger(length);
                    var strLength = length ? stringSize(string) : 0;
                    return length && strLength < length ? string + createPadding(length - strLength, chars) : string
                }

                function padStart(string, length, chars) {
                    string = toString(string), length = toInteger(length);
                    var strLength = length ? stringSize(string) : 0;
                    return length && strLength < length ? createPadding(length - strLength, chars) + string : string
                }

                function parseInt(string, radix, guard) {
                    return guard || null == radix ? radix = 0 : radix && (radix = +radix), nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0)
                }

                function repeat(string, n, guard) {
                    return n = (guard ? isIterateeCall(string, n, guard) : n === undefined) ? 1 : toInteger(n), baseRepeat(toString(string), n)
                }

                function replace() {
                    var args = arguments,
                        string = toString(args[0]);
                    return args.length < 3 ? string : string.replace(args[1], args[2])
                }

                function split(string, separator, limit) {
                    return limit && "number" != typeof limit && isIterateeCall(string, separator, limit) && (separator = limit = undefined), (limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0) ? (string = toString(string), string && ("string" == typeof separator || null != separator && !isRegExp(separator)) && (separator = baseToString(separator), !separator && hasUnicode(string)) ? castSlice(stringToArray(string), 0, limit) : string.split(separator, limit)) : []
                }

                function startsWith(string, target, position) {
                    return string = toString(string), position = null == position ? 0 : baseClamp(toInteger(position), 0, string.length), target = baseToString(target), string.slice(position, position + target.length) == target
                }

                function template(string, options, guard) {
                    var settings = lodash.templateSettings;
                    guard && isIterateeCall(string, options, guard) && (options = undefined), string = toString(string), options = assignInWith({}, options, settings, customDefaultsAssignIn);
                    var isEscaping, isEvaluating, imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
                        importsKeys = keys(imports),
                        importsValues = baseValues(imports, importsKeys),
                        index = 0,
                        interpolate = options.interpolate || reNoMatch,
                        source = "__p += '",
                        reDelimiters = RegExp((options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$", "g"),
                        sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/[\r\n]/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
                    string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
                        return interpolateValue || (interpolateValue = esTemplateValue), source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar), escapeValue && (isEscaping = !0, source += "' +\n__e(" + escapeValue + ") +\n'"), evaluateValue && (isEvaluating = !0, source += "';\n" + evaluateValue + ";\n__p += '"), interpolateValue && (source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'"), index = offset + match.length, match
                    }), source += "';\n";
                    var variable = hasOwnProperty.call(options, "variable") && options.variable;
                    variable || (source = "with (obj) {\n" + source + "\n}\n"), source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;"), source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
                    var result = attempt(function() {
                        return Function(importsKeys, sourceURL + "return " + source).apply(undefined, importsValues)
                    });
                    if (result.source = source, isError(result)) throw result;
                    return result
                }

                function toLower(value) {
                    return toString(value).toLowerCase()
                }

                function toUpper(value) {
                    return toString(value).toUpperCase()
                }

                function trim(string, chars, guard) {
                    if (string = toString(string), string && (guard || chars === undefined)) return string.replace(reTrim, "");
                    if (!string || !(chars = baseToString(chars))) return string;
                    var strSymbols = stringToArray(string),
                        chrSymbols = stringToArray(chars),
                        start = charsStartIndex(strSymbols, chrSymbols),
                        end = charsEndIndex(strSymbols, chrSymbols) + 1;
                    return castSlice(strSymbols, start, end).join("")
                }

                function trimEnd(string, chars, guard) {
                    if (string = toString(string), string && (guard || chars === undefined)) return string.replace(reTrimEnd, "");
                    if (!string || !(chars = baseToString(chars))) return string;
                    var strSymbols = stringToArray(string),
                        end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
                    return castSlice(strSymbols, 0, end).join("")
                }

                function trimStart(string, chars, guard) {
                    if (string = toString(string), string && (guard || chars === undefined)) return string.replace(reTrimStart, "");
                    if (!string || !(chars = baseToString(chars))) return string;
                    var strSymbols = stringToArray(string),
                        start = charsStartIndex(strSymbols, stringToArray(chars));
                    return castSlice(strSymbols, start).join("")
                }

                function truncate(string, options) {
                    var length = DEFAULT_TRUNC_LENGTH,
                        omission = DEFAULT_TRUNC_OMISSION;
                    if (isObject(options)) {
                        var separator = "separator" in options ? options.separator : separator;
                        length = "length" in options ? toInteger(options.length) : length, omission = "omission" in options ? baseToString(options.omission) : omission
                    }
                    string = toString(string);
                    var strLength = string.length;
                    if (hasUnicode(string)) {
                        var strSymbols = stringToArray(string);
                        strLength = strSymbols.length
                    }
                    if (length >= strLength) return string;
                    var end = length - stringSize(omission);
                    if (end < 1) return omission;
                    var result = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
                    if (separator === undefined) return result + omission;
                    if (strSymbols && (end += result.length - end), isRegExp(separator)) {
                        if (string.slice(end).search(separator)) {
                            var match, substring = result;
                            for (separator.global || (separator = RegExp(separator.source, toString(reFlags.exec(separator)) + "g")), separator.lastIndex = 0; match = separator.exec(substring);) var newEnd = match.index;
                            result = result.slice(0, newEnd === undefined ? end : newEnd)
                        }
                    } else if (string.indexOf(baseToString(separator), end) != end) {
                        var index = result.lastIndexOf(separator);
                        index > -1 && (result = result.slice(0, index))
                    }
                    return result + omission
                }

                function unescape(string) {
                    return string = toString(string), string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string
                }

                function words(string, pattern, guard) {
                    return string = toString(string), pattern = guard ? undefined : pattern, pattern === undefined ? hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string) : string.match(pattern) || []
                }

                function cond(pairs) {
                    var length = null == pairs ? 0 : pairs.length,
                        toIteratee = getIteratee();
                    return pairs = length ? arrayMap(pairs, function(pair) {
                        if ("function" != typeof pair[1]) throw new TypeError(FUNC_ERROR_TEXT);
                        return [toIteratee(pair[0]), pair[1]]
                    }) : [], baseRest(function(args) {
                        for (var index = -1; ++index < length;) {
                            var pair = pairs[index];
                            if (apply(pair[0], this, args)) return apply(pair[1], this, args)
                        }
                    })
                }

                function conforms(source) {
                    return baseConforms(baseClone(source, CLONE_DEEP_FLAG))
                }

                function constant(value) {
                    return function() {
                        return value
                    }
                }

                function defaultTo(value, defaultValue) {
                    return null == value || value !== value ? defaultValue : value
                }

                function identity(value) {
                    return value
                }

                function iteratee(func) {
                    return baseIteratee("function" == typeof func ? func : baseClone(func, CLONE_DEEP_FLAG))
                }

                function matches(source) {
                    return baseMatches(baseClone(source, CLONE_DEEP_FLAG))
                }

                function matchesProperty(path, srcValue) {
                    return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG))
                }

                function mixin(object, source, options) {
                    var props = keys(source),
                        methodNames = baseFunctions(source, props);
                    null != options || isObject(source) && (methodNames.length || !props.length) || (options = source, source = object, object = this, methodNames = baseFunctions(source, keys(source)));
                    var chain = !(isObject(options) && "chain" in options && !options.chain),
                        isFunc = isFunction(object);
                    return arrayEach(methodNames, function(methodName) {
                        var func = source[methodName];
                        object[methodName] = func, isFunc && (object.prototype[methodName] = function() {
                            var chainAll = this.__chain__;
                            if (chain || chainAll) {
                                var result = object(this.__wrapped__),
                                    actions = result.__actions__ = copyArray(this.__actions__);
                                return actions.push({
                                    func: func,
                                    args: arguments,
                                    thisArg: object
                                }), result.__chain__ = chainAll, result
                            }
                            return func.apply(object, arrayPush([this.value()], arguments))
                        })
                    }), object
                }

                function noConflict() {
                    return root._ === this && (root._ = oldDash), this
                }

                function noop() {}

                function nthArg(n) {
                    return n = toInteger(n), baseRest(function(args) {
                        return baseNth(args, n)
                    })
                }

                function property(path) {
                    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path)
                }

                function propertyOf(object) {
                    return function(path) {
                        return null == object ? undefined : baseGet(object, path)
                    }
                }

                function stubArray() {
                    return []
                }

                function stubFalse() {
                    return !1
                }

                function stubObject() {
                    return {}
                }

                function stubString() {
                    return ""
                }

                function stubTrue() {
                    return !0
                }

                function times(n, iteratee) {
                    if (n = toInteger(n), n < 1 || n > MAX_SAFE_INTEGER) return [];
                    var index = MAX_ARRAY_LENGTH,
                        length = nativeMin(n, MAX_ARRAY_LENGTH);
                    iteratee = getIteratee(iteratee), n -= MAX_ARRAY_LENGTH;
                    for (var result = baseTimes(length, iteratee); ++index < n;) iteratee(index);
                    return result
                }

                function toPath(value) {
                    return isArray(value) ? arrayMap(value, toKey) : isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)))
                }

                function uniqueId(prefix) {
                    var id = ++idCounter;
                    return toString(prefix) + id
                }

                function max(array) {
                    return array && array.length ? baseExtremum(array, identity, baseGt) : undefined
                }

                function maxBy(array, iteratee) {
                    return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseGt) : undefined
                }

                function mean(array) {
                    return baseMean(array, identity)
                }

                function meanBy(array, iteratee) {
                    return baseMean(array, getIteratee(iteratee, 2))
                }

                function min(array) {
                    return array && array.length ? baseExtremum(array, identity, baseLt) : undefined
                }

                function minBy(array, iteratee) {
                    return array && array.length ? baseExtremum(array, getIteratee(iteratee, 2), baseLt) : undefined
                }

                function sum(array) {
                    return array && array.length ? baseSum(array, identity) : 0
                }

                function sumBy(array, iteratee) {
                    return array && array.length ? baseSum(array, getIteratee(iteratee, 2)) : 0
                }
                context = null == context ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
                var Array = context.Array,
                    Date = context.Date,
                    Error = context.Error,
                    Function = context.Function,
                    Math = context.Math,
                    Object = context.Object,
                    RegExp = context.RegExp,
                    String = context.String,
                    TypeError = context.TypeError,
                    arrayProto = Array.prototype,
                    funcProto = Function.prototype,
                    objectProto = Object.prototype,
                    coreJsData = context["__core-js_shared__"],
                    funcToString = funcProto.toString,
                    hasOwnProperty = objectProto.hasOwnProperty,
                    idCounter = 0,
                    maskSrcKey = function() {
                        var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                        return uid ? "Symbol(src)_1." + uid : ""
                    }(),
                    nativeObjectToString = objectProto.toString,
                    objectCtorString = funcToString.call(Object),
                    oldDash = root._,
                    reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"),
                    Buffer = moduleExports ? context.Buffer : undefined,
                    _Symbol = context.Symbol,
                    Uint8Array = context.Uint8Array,
                    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
                    getPrototype = overArg(Object.getPrototypeOf, Object),
                    objectCreate = Object.create,
                    propertyIsEnumerable = objectProto.propertyIsEnumerable,
                    splice = arrayProto.splice,
                    spreadableSymbol = _Symbol ? _Symbol.isConcatSpreadable : undefined,
                    symIterator = _Symbol ? _Symbol.iterator : undefined,
                    symToStringTag = _Symbol ? _Symbol.toStringTag : undefined,
                    defineProperty = function() {
                        try {
                            var func = getNative(Object, "defineProperty");
                            return func({}, "", {}), func
                        } catch (e) {}
                    }(),
                    ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
                    ctxNow = Date && Date.now !== root.Date.now && Date.now,
                    ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout,
                    nativeCeil = Math.ceil,
                    nativeFloor = Math.floor,
                    nativeGetSymbols = Object.getOwnPropertySymbols,
                    nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
                    nativeIsFinite = context.isFinite,
                    nativeJoin = arrayProto.join,
                    nativeKeys = overArg(Object.keys, Object),
                    nativeMax = Math.max,
                    nativeMin = Math.min,
                    nativeNow = Date.now,
                    nativeParseInt = context.parseInt,
                    nativeRandom = Math.random,
                    nativeReverse = arrayProto.reverse,
                    DataView = getNative(context, "DataView"),
                    Map = getNative(context, "Map"),
                    Promise = getNative(context, "Promise"),
                    Set = getNative(context, "Set"),
                    WeakMap = getNative(context, "WeakMap"),
                    nativeCreate = getNative(Object, "create"),
                    metaMap = WeakMap && new WeakMap,
                    realNames = {},
                    dataViewCtorString = toSource(DataView),
                    mapCtorString = toSource(Map),
                    promiseCtorString = toSource(Promise),
                    setCtorString = toSource(Set),
                    weakMapCtorString = toSource(WeakMap),
                    symbolProto = _Symbol ? _Symbol.prototype : undefined,
                    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
                    symbolToString = symbolProto ? symbolProto.toString : undefined,
                    baseCreate = function() {
                        function object() {}
                        return function(proto) {
                            if (!isObject(proto)) return {};
                            if (objectCreate) return objectCreate(proto);
                            object.prototype = proto;
                            var result = new object;
                            return object.prototype = undefined, result
                        }
                    }();
                lodash.templateSettings = {
                    escape: reEscape,
                    evaluate: reEvaluate,
                    interpolate: reInterpolate,
                    variable: "",
                    imports: {
                        _: lodash
                    }
                }, lodash.prototype = baseLodash.prototype, lodash.prototype.constructor = lodash, LodashWrapper.prototype = baseCreate(baseLodash.prototype), LodashWrapper.prototype.constructor = LodashWrapper, LazyWrapper.prototype = baseCreate(baseLodash.prototype), LazyWrapper.prototype.constructor = LazyWrapper, Hash.prototype.clear = hashClear, Hash.prototype.delete = hashDelete, Hash.prototype.get = hashGet, Hash.prototype.has = hashHas, Hash.prototype.set = hashSet, ListCache.prototype.clear = listCacheClear, ListCache.prototype.delete = listCacheDelete, ListCache.prototype.get = listCacheGet, ListCache.prototype.has = listCacheHas, ListCache.prototype.set = listCacheSet, MapCache.prototype.clear = mapCacheClear, MapCache.prototype.delete = mapCacheDelete, MapCache.prototype.get = mapCacheGet, MapCache.prototype.has = mapCacheHas, MapCache.prototype.set = mapCacheSet, SetCache.prototype.add = SetCache.prototype.push = setCacheAdd, SetCache.prototype.has = setCacheHas, Stack.prototype.clear = stackClear, Stack.prototype.delete = stackDelete, Stack.prototype.get = stackGet, Stack.prototype.has = stackHas, Stack.prototype.set = stackSet;
                var baseEach = createBaseEach(baseForOwn),
                    baseEachRight = createBaseEach(baseForOwnRight, !0),
                    baseFor = createBaseFor(),
                    baseForRight = createBaseFor(!0),
                    baseSetData = metaMap ? function(func, data) {
                        return metaMap.set(func, data), func
                    } : identity,
                    baseSetToString = defineProperty ? function(func, string) {
                        return defineProperty(func, "toString", {
                            configurable: !0,
                            enumerable: !1,
                            value: constant(string),
                            writable: !0
                        })
                    } : identity,
                    castRest = baseRest,
                    clearTimeout = ctxClearTimeout || function(id) {
                        return root.clearTimeout(id)
                    },
                    createSet = Set && 1 / setToArray(new Set([, -0]))[1] == INFINITY ? function(values) {
                        return new Set(values)
                    } : noop,
                    getData = metaMap ? function(func) {
                        return metaMap.get(func)
                    } : noop,
                    getSymbols = nativeGetSymbols ? function(object) {
                        return null == object ? [] : (object = Object(object), arrayFilter(nativeGetSymbols(object), function(symbol) {
                            return propertyIsEnumerable.call(object, symbol)
                        }))
                    } : stubArray,
                    getSymbolsIn = nativeGetSymbols ? function(object) {
                        for (var result = []; object;) arrayPush(result, getSymbols(object)), object = getPrototype(object);
                        return result
                    } : stubArray,
                    getTag = baseGetTag;
                (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) && (getTag = function(value) {
                    var result = baseGetTag(value),
                        Ctor = result == objectTag ? value.constructor : undefined,
                        ctorString = Ctor ? toSource(Ctor) : "";
                    if (ctorString) switch (ctorString) {
                        case dataViewCtorString:
                            return dataViewTag;
                        case mapCtorString:
                            return mapTag;
                        case promiseCtorString:
                            return promiseTag;
                        case setCtorString:
                            return setTag;
                        case weakMapCtorString:
                            return weakMapTag
                    }
                    return result
                });
                var isMaskable = coreJsData ? isFunction : stubFalse,
                    setData = shortOut(baseSetData),
                    setTimeout = ctxSetTimeout || function(func, wait) {
                        return root.setTimeout(func, wait)
                    },
                    setToString = shortOut(baseSetToString),
                    stringToPath = memoizeCapped(function(string) {
                        var result = [];
                        return 46 === string.charCodeAt(0) && result.push(""), string.replace(rePropName, function(match, number, quote, subString) {
                            result.push(quote ? subString.replace(reEscapeChar, "$1") : number || match)
                        }), result
                    }),
                    difference = baseRest(function(array, values) {
                        return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0)) : []
                    }),
                    differenceBy = baseRest(function(array, values) {
                        var iteratee = last(values);
                        return isArrayLikeObject(iteratee) && (iteratee = undefined), isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0), getIteratee(iteratee, 2)) : []
                    }),
                    differenceWith = baseRest(function(array, values) {
                        var comparator = last(values);
                        return isArrayLikeObject(comparator) && (comparator = undefined), isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, !0), undefined, comparator) : []
                    }),
                    intersection = baseRest(function(arrays) {
                        var mapped = arrayMap(arrays, castArrayLikeObject);
                        return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : []
                    }),
                    intersectionBy = baseRest(function(arrays) {
                        var iteratee = last(arrays),
                            mapped = arrayMap(arrays, castArrayLikeObject);
                        return iteratee === last(mapped) ? iteratee = undefined : mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee, 2)) : []
                    }),
                    intersectionWith = baseRest(function(arrays) {
                        var comparator = last(arrays),
                            mapped = arrayMap(arrays, castArrayLikeObject);
                        return comparator = "function" == typeof comparator ? comparator : undefined, comparator && mapped.pop(), mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined, comparator) : []
                    }),
                    pull = baseRest(pullAll),
                    pullAt = flatRest(function(array, indexes) {
                        var length = null == array ? 0 : array.length,
                            result = baseAt(array, indexes);
                        return basePullAt(array, arrayMap(indexes, function(index) {
                            return isIndex(index, length) ? +index : index
                        }).sort(compareAscending)), result
                    }),
                    union = baseRest(function(arrays) {
                        return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0))
                    }),
                    unionBy = baseRest(function(arrays) {
                        var iteratee = last(arrays);
                        return isArrayLikeObject(iteratee) && (iteratee = undefined), baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), getIteratee(iteratee, 2))
                    }),
                    unionWith = baseRest(function(arrays) {
                        var comparator = last(arrays);
                        return comparator = "function" == typeof comparator ? comparator : undefined, baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, !0), undefined, comparator)
                    }),
                    without = baseRest(function(array, values) {
                        return isArrayLikeObject(array) ? baseDifference(array, values) : []
                    }),
                    xor = baseRest(function(arrays) {
                        return baseXor(arrayFilter(arrays, isArrayLikeObject))
                    }),
                    xorBy = baseRest(function(arrays) {
                        var iteratee = last(arrays);
                        return isArrayLikeObject(iteratee) && (iteratee = undefined), baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2))
                    }),
                    xorWith = baseRest(function(arrays) {
                        var comparator = last(arrays);
                        return comparator = "function" == typeof comparator ? comparator : undefined, baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator)
                    }),
                    zip = baseRest(unzip),
                    zipWith = baseRest(function(arrays) {
                        var length = arrays.length,
                            iteratee = length > 1 ? arrays[length - 1] : undefined;
                        return iteratee = "function" == typeof iteratee ? (arrays.pop(), iteratee) : undefined, unzipWith(arrays, iteratee)
                    }),
                    wrapperAt = flatRest(function(paths) {
                        var length = paths.length,
                            start = length ? paths[0] : 0,
                            value = this.__wrapped__,
                            interceptor = function(object) {
                                return baseAt(object, paths)
                            };
                        return !(length > 1 || this.__actions__.length) && value instanceof LazyWrapper && isIndex(start) ? (value = value.slice(start, +start + (length ? 1 : 0)), value.__actions__.push({
                            func: thru,
                            args: [interceptor],
                            thisArg: undefined
                        }), new LodashWrapper(value, this.__chain__).thru(function(array) {
                            return length && !array.length && array.push(undefined), array
                        })) : this.thru(interceptor)
                    }),
                    countBy = createAggregator(function(result, value, key) {
                        hasOwnProperty.call(result, key) ? ++result[key] : baseAssignValue(result, key, 1)
                    }),
                    find = createFind(findIndex),
                    findLast = createFind(findLastIndex),
                    groupBy = createAggregator(function(result, value, key) {
                        hasOwnProperty.call(result, key) ? result[key].push(value) : baseAssignValue(result, key, [value])
                    }),
                    invokeMap = baseRest(function(collection, path, args) {
                        var index = -1,
                            isFunc = "function" == typeof path,
                            result = isArrayLike(collection) ? Array(collection.length) : [];
                        return baseEach(collection, function(value) {
                            result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args)
                        }), result
                    }),
                    keyBy = createAggregator(function(result, value, key) {
                        baseAssignValue(result, key, value)
                    }),
                    partition = createAggregator(function(result, value, key) {
                        result[key ? 0 : 1].push(value)
                    }, function() {
                        return [
                            [],
                            []
                        ]
                    }),
                    sortBy = baseRest(function(collection, iteratees) {
                        if (null == collection) return [];
                        var length = iteratees.length;
                        return length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1]) ? iteratees = [] : length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2]) && (iteratees = [iteratees[0]]), baseOrderBy(collection, baseFlatten(iteratees, 1), [])
                    }),
                    now = ctxNow || function() {
                        return root.Date.now()
                    },
                    bind = baseRest(function(func, thisArg, partials) {
                        var bitmask = WRAP_BIND_FLAG;
                        if (partials.length) {
                            var holders = replaceHolders(partials, getHolder(bind));
                            bitmask |= WRAP_PARTIAL_FLAG
                        }
                        return createWrap(func, bitmask, thisArg, partials, holders)
                    }),
                    bindKey = baseRest(function(object, key, partials) {
                        var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
                        if (partials.length) {
                            var holders = replaceHolders(partials, getHolder(bindKey));
                            bitmask |= WRAP_PARTIAL_FLAG
                        }
                        return createWrap(key, bitmask, object, partials, holders)
                    }),
                    defer = baseRest(function(func, args) {
                        return baseDelay(func, 1, args)
                    }),
                    delay = baseRest(function(func, wait, args) {
                        return baseDelay(func, toNumber(wait) || 0, args)
                    });
                memoize.Cache = MapCache;
                var overArgs = castRest(function(func, transforms) {
                        transforms = 1 == transforms.length && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
                        var funcsLength = transforms.length;
                        return baseRest(function(args) {
                            for (var index = -1, length = nativeMin(args.length, funcsLength); ++index < length;) args[index] = transforms[index].call(this, args[index]);
                            return apply(func, this, args)
                        })
                    }),
                    partial = baseRest(function(func, partials) {
                        var holders = replaceHolders(partials, getHolder(partial));
                        return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders)
                    }),
                    partialRight = baseRest(function(func, partials) {
                        var holders = replaceHolders(partials, getHolder(partialRight));
                        return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders)
                    }),
                    rearg = flatRest(function(func, indexes) {
                        return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes)
                    }),
                    gt = createRelationalOperation(baseGt),
                    gte = createRelationalOperation(function(value, other) {
                        return value >= other
                    }),
                    isArguments = baseIsArguments(function() {
                        return arguments
                    }()) ? baseIsArguments : function(value) {
                        return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee")
                    },
                    isArray = Array.isArray,
                    isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer,
                    isBuffer = nativeIsBuffer || stubFalse,
                    isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate,
                    isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap,
                    isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp,
                    isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet,
                    isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray,
                    lt = createRelationalOperation(baseLt),
                    lte = createRelationalOperation(function(value, other) {
                        return value <= other
                    }),
                    assign = createAssigner(function(object, source) {
                        if (isPrototype(source) || isArrayLike(source)) return void copyObject(source, keys(source), object);
                        for (var key in source) hasOwnProperty.call(source, key) && assignValue(object, key, source[key])
                    }),
                    assignIn = createAssigner(function(object, source) {
                        copyObject(source, keysIn(source), object)
                    }),
                    assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
                        copyObject(source, keysIn(source), object, customizer)
                    }),
                    assignWith = createAssigner(function(object, source, srcIndex, customizer) {
                        copyObject(source, keys(source), object, customizer)
                    }),
                    at = flatRest(baseAt),
                    defaults = baseRest(function(object, sources) {
                        object = Object(object);
                        var index = -1,
                            length = sources.length,
                            guard = length > 2 ? sources[2] : undefined;
                        for (guard && isIterateeCall(sources[0], sources[1], guard) && (length = 1); ++index < length;)
                            for (var source = sources[index], props = keysIn(source), propsIndex = -1, propsLength = props.length; ++propsIndex < propsLength;) {
                                var key = props[propsIndex],
                                    value = object[key];
                                (value === undefined || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) && (object[key] = source[key])
                            }
                        return object
                    }),
                    defaultsDeep = baseRest(function(args) {
                        return args.push(undefined, customDefaultsMerge), apply(mergeWith, undefined, args)
                    }),
                    invert = createInverter(function(result, value, key) {
                        null != value && "function" != typeof value.toString && (value = nativeObjectToString.call(value)), result[value] = key
                    }, constant(identity)),
                    invertBy = createInverter(function(result, value, key) {
                        null != value && "function" != typeof value.toString && (value = nativeObjectToString.call(value)), hasOwnProperty.call(result, value) ? result[value].push(key) : result[value] = [key]
                    }, getIteratee),
                    invoke = baseRest(baseInvoke),
                    merge = createAssigner(function(object, source, srcIndex) {
                        baseMerge(object, source, srcIndex)
                    }),
                    mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
                        baseMerge(object, source, srcIndex, customizer)
                    }),
                    omit = flatRest(function(object, paths) {
                        var result = {};
                        if (null == object) return result;
                        var isDeep = !1;
                        paths = arrayMap(paths, function(path) {
                            return path = castPath(path, object), isDeep || (isDeep = path.length > 1), path
                        }), copyObject(object, getAllKeysIn(object), result), isDeep && (result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
                        for (var length = paths.length; length--;) baseUnset(result, paths[length]);
                        return result
                    }),
                    pick = flatRest(function(object, paths) {
                        return null == object ? {} : basePick(object, paths)
                    }),
                    toPairs = createToPairs(keys),
                    toPairsIn = createToPairs(keysIn),
                    camelCase = createCompounder(function(result, word, index) {
                        return word = word.toLowerCase(), result + (index ? capitalize(word) : word)
                    }),
                    kebabCase = createCompounder(function(result, word, index) {
                        return result + (index ? "-" : "") + word.toLowerCase()
                    }),
                    lowerCase = createCompounder(function(result, word, index) {
                        return result + (index ? " " : "") + word.toLowerCase()
                    }),
                    lowerFirst = createCaseFirst("toLowerCase"),
                    snakeCase = createCompounder(function(result, word, index) {
                        return result + (index ? "_" : "") + word.toLowerCase()
                    }),
                    startCase = createCompounder(function(result, word, index) {
                        return result + (index ? " " : "") + upperFirst(word)
                    }),
                    upperCase = createCompounder(function(result, word, index) {
                        return result + (index ? " " : "") + word.toUpperCase()
                    }),
                    upperFirst = createCaseFirst("toUpperCase"),
                    attempt = baseRest(function(func, args) {
                        try {
                            return apply(func, undefined, args)
                        } catch (e) {
                            return isError(e) ? e : new Error(e)
                        }
                    }),
                    bindAll = flatRest(function(object, methodNames) {
                        return arrayEach(methodNames, function(key) {
                            key = toKey(key), baseAssignValue(object, key, bind(object[key], object))
                        }), object
                    }),
                    flow = createFlow(),
                    flowRight = createFlow(!0),
                    method = baseRest(function(path, args) {
                        return function(object) {
                            return baseInvoke(object, path, args)
                        }
                    }),
                    methodOf = baseRest(function(object, args) {
                        return function(path) {
                            return baseInvoke(object, path, args)
                        }
                    }),
                    over = createOver(arrayMap),
                    overEvery = createOver(arrayEvery),
                    overSome = createOver(arraySome),
                    range = createRange(),
                    rangeRight = createRange(!0),
                    add = createMathOperation(function(augend, addend) {
                        return augend + addend
                    }, 0),
                    ceil = createRound("ceil"),
                    divide = createMathOperation(function(dividend, divisor) {
                        return dividend / divisor
                    }, 1),
                    floor = createRound("floor"),
                    multiply = createMathOperation(function(multiplier, multiplicand) {
                        return multiplier * multiplicand
                    }, 1),
                    round = createRound("round"),
                    subtract = createMathOperation(function(minuend, subtrahend) {
                        return minuend - subtrahend
                    }, 0);
                return lodash.after = after, lodash.ary = ary, lodash.assign = assign, lodash.assignIn = assignIn, lodash.assignInWith = assignInWith, lodash.assignWith = assignWith, lodash.at = at, lodash.before = before, lodash.bind = bind, lodash.bindAll = bindAll, lodash.bindKey = bindKey, lodash.castArray = castArray, lodash.chain = chain, lodash.chunk = chunk, lodash.compact = compact, lodash.concat = concat, lodash.cond = cond, lodash.conforms = conforms, lodash.constant = constant, lodash.countBy = countBy, lodash.create = create, lodash.curry = curry, lodash.curryRight = curryRight, lodash.debounce = debounce, lodash.defaults = defaults, lodash.defaultsDeep = defaultsDeep, lodash.defer = defer, lodash.delay = delay, lodash.difference = difference, lodash.differenceBy = differenceBy, lodash.differenceWith = differenceWith, lodash.drop = drop, lodash.dropRight = dropRight, lodash.dropRightWhile = dropRightWhile, lodash.dropWhile = dropWhile, lodash.fill = fill, lodash.filter = filter, lodash.flatMap = flatMap, lodash.flatMapDeep = flatMapDeep, lodash.flatMapDepth = flatMapDepth, lodash.flatten = flatten, lodash.flattenDeep = flattenDeep, lodash.flattenDepth = flattenDepth, lodash.flip = flip, lodash.flow = flow, lodash.flowRight = flowRight, lodash.fromPairs = fromPairs, lodash.functions = functions, lodash.functionsIn = functionsIn, lodash.groupBy = groupBy, lodash.initial = initial, lodash.intersection = intersection, lodash.intersectionBy = intersectionBy, lodash.intersectionWith = intersectionWith, lodash.invert = invert, lodash.invertBy = invertBy, lodash.invokeMap = invokeMap, lodash.iteratee = iteratee, lodash.keyBy = keyBy, lodash.keys = keys, lodash.keysIn = keysIn, lodash.map = map, lodash.mapKeys = mapKeys, lodash.mapValues = mapValues, lodash.matches = matches, lodash.matchesProperty = matchesProperty, lodash.memoize = memoize, lodash.merge = merge, lodash.mergeWith = mergeWith, lodash.method = method, lodash.methodOf = methodOf, lodash.mixin = mixin, lodash.negate = negate, lodash.nthArg = nthArg, lodash.omit = omit, lodash.omitBy = omitBy, lodash.once = once, lodash.orderBy = orderBy, lodash.over = over, lodash.overArgs = overArgs, lodash.overEvery = overEvery, lodash.overSome = overSome, lodash.partial = partial, lodash.partialRight = partialRight, lodash.partition = partition, lodash.pick = pick, lodash.pickBy = pickBy, lodash.property = property, lodash.propertyOf = propertyOf, lodash.pull = pull, lodash.pullAll = pullAll, lodash.pullAllBy = pullAllBy, lodash.pullAllWith = pullAllWith, lodash.pullAt = pullAt, lodash.range = range, lodash.rangeRight = rangeRight, lodash.rearg = rearg, lodash.reject = reject, lodash.remove = remove, lodash.rest = rest, lodash.reverse = reverse, lodash.sampleSize = sampleSize, lodash.set = set, lodash.setWith = setWith, lodash.shuffle = shuffle, lodash.slice = slice, lodash.sortBy = sortBy, lodash.sortedUniq = sortedUniq, lodash.sortedUniqBy = sortedUniqBy, lodash.split = split, lodash.spread = spread, lodash.tail = tail, lodash.take = take, lodash.takeRight = takeRight, lodash.takeRightWhile = takeRightWhile, lodash.takeWhile = takeWhile, lodash.tap = tap, lodash.throttle = throttle, lodash.thru = thru, lodash.toArray = toArray, lodash.toPairs = toPairs, lodash.toPairsIn = toPairsIn, lodash.toPath = toPath, lodash.toPlainObject = toPlainObject, lodash.transform = transform, lodash.unary = unary, lodash.union = union, lodash.unionBy = unionBy, lodash.unionWith = unionWith, lodash.uniq = uniq, lodash.uniqBy = uniqBy, lodash.uniqWith = uniqWith, lodash.unset = unset, lodash.unzip = unzip, lodash.unzipWith = unzipWith, lodash.update = update, lodash.updateWith = updateWith, lodash.values = values, lodash.valuesIn = valuesIn, lodash.without = without, lodash.words = words, lodash.wrap = wrap, lodash.xor = xor, lodash.xorBy = xorBy, lodash.xorWith = xorWith, lodash.zip = zip, lodash.zipObject = zipObject, lodash.zipObjectDeep = zipObjectDeep, lodash.zipWith = zipWith, lodash.entries = toPairs, lodash.entriesIn = toPairsIn, lodash.extend = assignIn, lodash.extendWith = assignInWith, mixin(lodash, lodash), lodash.add = add, lodash.attempt = attempt, lodash.camelCase = camelCase, lodash.capitalize = capitalize, lodash.ceil = ceil, lodash.clamp = clamp, lodash.clone = clone, lodash.cloneDeep = cloneDeep, lodash.cloneDeepWith = cloneDeepWith, lodash.cloneWith = cloneWith, lodash.conformsTo = conformsTo, lodash.deburr = deburr, lodash.defaultTo = defaultTo, lodash.divide = divide, lodash.endsWith = endsWith, lodash.eq = eq, lodash.escape = escape, lodash.escapeRegExp = escapeRegExp, lodash.every = every, lodash.find = find, lodash.findIndex = findIndex, lodash.findKey = findKey, lodash.findLast = findLast, lodash.findLastIndex = findLastIndex, lodash.findLastKey = findLastKey, lodash.floor = floor, lodash.forEach = forEach, lodash.forEachRight = forEachRight, lodash.forIn = forIn, lodash.forInRight = forInRight, lodash.forOwn = forOwn, lodash.forOwnRight = forOwnRight, lodash.get = get, lodash.gt = gt, lodash.gte = gte, lodash.has = has, lodash.hasIn = hasIn, lodash.head = head, lodash.identity = identity, lodash.includes = includes, lodash.indexOf = indexOf, lodash.inRange = inRange, lodash.invoke = invoke, lodash.isArguments = isArguments, lodash.isArray = isArray, lodash.isArrayBuffer = isArrayBuffer, lodash.isArrayLike = isArrayLike, lodash.isArrayLikeObject = isArrayLikeObject, lodash.isBoolean = isBoolean, lodash.isBuffer = isBuffer, lodash.isDate = isDate, lodash.isElement = isElement, lodash.isEmpty = isEmpty, lodash.isEqual = isEqual, lodash.isEqualWith = isEqualWith, lodash.isError = isError, lodash.isFinite = isFinite, lodash.isFunction = isFunction, lodash.isInteger = isInteger, lodash.isLength = isLength, lodash.isMap = isMap, lodash.isMatch = isMatch, lodash.isMatchWith = isMatchWith, lodash.isNaN = isNaN, lodash.isNative = isNative, lodash.isNil = isNil, lodash.isNull = isNull, lodash.isNumber = isNumber, lodash.isObject = isObject, lodash.isObjectLike = isObjectLike, lodash.isPlainObject = isPlainObject, lodash.isRegExp = isRegExp, lodash.isSafeInteger = isSafeInteger, lodash.isSet = isSet, lodash.isString = isString, lodash.isSymbol = isSymbol, lodash.isTypedArray = isTypedArray, lodash.isUndefined = isUndefined, lodash.isWeakMap = isWeakMap, lodash.isWeakSet = isWeakSet, lodash.join = join, lodash.kebabCase = kebabCase, lodash.last = last, lodash.lastIndexOf = lastIndexOf, lodash.lowerCase = lowerCase, lodash.lowerFirst = lowerFirst, lodash.lt = lt, lodash.lte = lte, lodash.max = max, lodash.maxBy = maxBy, lodash.mean = mean, lodash.meanBy = meanBy, lodash.min = min, lodash.minBy = minBy, lodash.stubArray = stubArray, lodash.stubFalse = stubFalse, lodash.stubObject = stubObject, lodash.stubString = stubString, lodash.stubTrue = stubTrue, lodash.multiply = multiply, lodash.nth = nth, lodash.noConflict = noConflict, lodash.noop = noop, lodash.now = now, lodash.pad = pad, lodash.padEnd = padEnd, lodash.padStart = padStart, lodash.parseInt = parseInt, lodash.random = random, lodash.reduce = reduce, lodash.reduceRight = reduceRight, lodash.repeat = repeat, lodash.replace = replace, lodash.result = result, lodash.round = round, lodash.runInContext = runInContext, lodash.sample = sample, lodash.size = size, lodash.snakeCase = snakeCase, lodash.some = some, lodash.sortedIndex = sortedIndex, lodash.sortedIndexBy = sortedIndexBy, lodash.sortedIndexOf = sortedIndexOf, lodash.sortedLastIndex = sortedLastIndex, lodash.sortedLastIndexBy = sortedLastIndexBy, lodash.sortedLastIndexOf = sortedLastIndexOf, lodash.startCase = startCase, lodash.startsWith = startsWith, lodash.subtract = subtract, lodash.sum = sum, lodash.sumBy = sumBy, lodash.template = template, lodash.times = times, lodash.toFinite = toFinite, lodash.toInteger = toInteger, lodash.toLength = toLength, lodash.toLower = toLower, lodash.toNumber = toNumber, lodash.toSafeInteger = toSafeInteger, lodash.toString = toString, lodash.toUpper = toUpper, lodash.trim = trim, lodash.trimEnd = trimEnd, lodash.trimStart = trimStart, lodash.truncate = truncate, lodash.unescape = unescape, lodash.uniqueId = uniqueId, lodash.upperCase = upperCase, lodash.upperFirst = upperFirst, lodash.each = forEach, lodash.eachRight = forEachRight, lodash.first = head, mixin(lodash, function() {
                    var source = {};
                    return baseForOwn(lodash, function(func, methodName) {
                        hasOwnProperty.call(lodash.prototype, methodName) || (source[methodName] = func)
                    }), source
                }(), {
                    chain: !1
                }), lodash.VERSION = VERSION, arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
                    lodash[methodName].placeholder = lodash
                }), arrayEach(["drop", "take"], function(methodName, index) {
                    LazyWrapper.prototype[methodName] = function(n) {
                        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);
                        var result = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
                        return result.__filtered__ ? result.__takeCount__ = nativeMin(n, result.__takeCount__) : result.__views__.push({
                            size: nativeMin(n, MAX_ARRAY_LENGTH),
                            type: methodName + (result.__dir__ < 0 ? "Right" : "")
                        }), result
                    }, LazyWrapper.prototype[methodName + "Right"] = function(n) {
                        return this.reverse()[methodName](n).reverse()
                    }
                }), arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
                    var type = index + 1,
                        isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
                    LazyWrapper.prototype[methodName] = function(iteratee) {
                        var result = this.clone();
                        return result.__iteratees__.push({
                            iteratee: getIteratee(iteratee, 3),
                            type: type
                        }), result.__filtered__ = result.__filtered__ || isFilter, result
                    }
                }), arrayEach(["head", "last"], function(methodName, index) {
                    var takeName = "take" + (index ? "Right" : "");
                    LazyWrapper.prototype[methodName] = function() {
                        return this[takeName](1).value()[0]
                    }
                }), arrayEach(["initial", "tail"], function(methodName, index) {
                    var dropName = "drop" + (index ? "" : "Right");
                    LazyWrapper.prototype[methodName] = function() {
                        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1)
                    }
                }), LazyWrapper.prototype.compact = function() {
                    return this.filter(identity)
                }, LazyWrapper.prototype.find = function(predicate) {
                    return this.filter(predicate).head()
                }, LazyWrapper.prototype.findLast = function(predicate) {
                    return this.reverse().find(predicate)
                }, LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
                    return "function" == typeof path ? new LazyWrapper(this) : this.map(function(value) {
                        return baseInvoke(value, path, args)
                    })
                }), LazyWrapper.prototype.reject = function(predicate) {
                    return this.filter(negate(getIteratee(predicate)))
                }, LazyWrapper.prototype.slice = function(start, end) {
                    start = toInteger(start);
                    var result = this;
                    return result.__filtered__ && (start > 0 || end < 0) ? new LazyWrapper(result) : (start < 0 ? result = result.takeRight(-start) : start && (result = result.drop(start)), end !== undefined && (end = toInteger(end), result = end < 0 ? result.dropRight(-end) : result.take(end - start)), result)
                }, LazyWrapper.prototype.takeRightWhile = function(predicate) {
                    return this.reverse().takeWhile(predicate).reverse()
                }, LazyWrapper.prototype.toArray = function() {
                    return this.take(MAX_ARRAY_LENGTH)
                }, baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                    var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
                        isTaker = /^(?:head|last)$/.test(methodName),
                        lodashFunc = lodash[isTaker ? "take" + ("last" == methodName ? "Right" : "") : methodName],
                        retUnwrapped = isTaker || /^find/.test(methodName);
                    lodashFunc && (lodash.prototype[methodName] = function() {
                        var value = this.__wrapped__,
                            args = isTaker ? [1] : arguments,
                            isLazy = value instanceof LazyWrapper,
                            iteratee = args[0],
                            useLazy = isLazy || isArray(value),
                            interceptor = function(value) {
                                var result = lodashFunc.apply(lodash, arrayPush([value], args));
                                return isTaker && chainAll ? result[0] : result
                            };
                        useLazy && checkIteratee && "function" == typeof iteratee && 1 != iteratee.length && (isLazy = useLazy = !1);
                        var chainAll = this.__chain__,
                            isHybrid = !!this.__actions__.length,
                            isUnwrapped = retUnwrapped && !chainAll,
                            onlyLazy = isLazy && !isHybrid;
                        if (!retUnwrapped && useLazy) {
                            value = onlyLazy ? value : new LazyWrapper(this);
                            var result = func.apply(value, args);
                            return result.__actions__.push({
                                func: thru,
                                args: [interceptor],
                                thisArg: undefined
                            }), new LodashWrapper(result, chainAll)
                        }
                        return isUnwrapped && onlyLazy ? func.apply(this, args) : (result = this.thru(interceptor), isUnwrapped ? isTaker ? result.value()[0] : result.value() : result)
                    })
                }), arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
                    var func = arrayProto[methodName],
                        chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru",
                        retUnwrapped = /^(?:pop|shift)$/.test(methodName);
                    lodash.prototype[methodName] = function() {
                        var args = arguments;
                        if (retUnwrapped && !this.__chain__) {
                            var value = this.value();
                            return func.apply(isArray(value) ? value : [], args)
                        }
                        return this[chainName](function(value) {
                            return func.apply(isArray(value) ? value : [], args)
                        })
                    }
                }), baseForOwn(LazyWrapper.prototype, function(func, methodName) {
                    var lodashFunc = lodash[methodName];
                    if (lodashFunc) {
                        var key = lodashFunc.name + "";
                        hasOwnProperty.call(realNames, key) || (realNames[key] = []), realNames[key].push({
                            name: methodName,
                            func: lodashFunc
                        })
                    }
                }), realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
                    name: "wrapper",
                    func: undefined
                }], LazyWrapper.prototype.clone = lazyClone, LazyWrapper.prototype.reverse = lazyReverse, LazyWrapper.prototype.value = lazyValue, lodash.prototype.at = wrapperAt, lodash.prototype.chain = wrapperChain, lodash.prototype.commit = wrapperCommit, lodash.prototype.next = wrapperNext, lodash.prototype.plant = wrapperPlant, lodash.prototype.reverse = wrapperReverse, lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue, lodash.prototype.first = lodash.prototype.head, symIterator && (lodash.prototype[symIterator] = wrapperToIterator), lodash
            },
            _ = runInContext();
        "function" == typeof define && "object" == _typeof2(define.amd) && define.amd ? (root._ = _, define(function() {
            return _
        })) : freeModule ? ((freeModule.exports = _)._ = _, freeExports._ = _) : root._ = _
    }.call(this),
    function() {
        var restangular = angular.module("restangular", []);
        restangular.provider("Restangular", function() {
            var Configurer = {};
            Configurer.init = function(object, config) {
                function RestangularResource(config, $http, url, configurer) {
                    var resource = {};
                    return _.each(_.keys(configurer), function(key) {
                        var value = configurer[key];
                        value.params = _.extend({}, value.params, config.defaultRequestParams[value.method.toLowerCase()]), _.isEmpty(value.params) && delete value.params, config.isSafe(value.method) ? resource[key] = function() {
                            return $http(_.extend(value, {
                                url: url
                            }))
                        } : resource[key] = function(data) {
                            return $http(_.extend(value, {
                                url: url,
                                data: data
                            }))
                        }
                    }), resource
                }
                object.configuration = config;
                var safeMethods = ["get", "head", "options", "trace", "getlist"];
                config.isSafe = function(operation) {
                    return _.includes(safeMethods, operation.toLowerCase())
                };
                var absolutePattern = /^https?:\/\//i;
                config.isAbsoluteUrl = function(string) {
                    return _.isUndefined(config.absoluteUrl) || _.isNull(config.absoluteUrl) ? string && absolutePattern.test(string) : config.absoluteUrl
                }, config.absoluteUrl = !!_.isUndefined(config.absoluteUrl) || config.absoluteUrl, object.setSelfLinkAbsoluteUrl = function(value) {
                    config.absoluteUrl = value
                }, config.baseUrl = _.isUndefined(config.baseUrl) ? "" : config.baseUrl, object.setBaseUrl = function(newBaseUrl) {
                    return config.baseUrl = /\/$/.test(newBaseUrl) ? newBaseUrl.substring(0, newBaseUrl.length - 1) : newBaseUrl, this
                }, config.extraFields = config.extraFields || [], object.setExtraFields = function(newExtraFields) {
                    return config.extraFields = newExtraFields, this
                }, config.defaultHttpFields = config.defaultHttpFields || {}, object.setDefaultHttpFields = function(values) {
                    return config.defaultHttpFields = values, this
                }, config.withHttpValues = function(httpLocalConfig, obj) {
                    return _.defaults(obj, httpLocalConfig, config.defaultHttpFields)
                }, config.encodeIds = !!_.isUndefined(config.encodeIds) || config.encodeIds, object.setEncodeIds = function(encode) {
                    config.encodeIds = encode
                }, config.defaultRequestParams = config.defaultRequestParams || {
                    get: {},
                    post: {},
                    put: {},
                    remove: {},
                    common: {}
                }, object.setDefaultRequestParams = function(param1, param2) {
                    var methods = [],
                        params = param2 || param1;
                    return _.isUndefined(param2) ? methods.push("common") : _.isArray(param1) ? methods = param1 : methods.push(param1), _.each(methods, function(method) {
                        config.defaultRequestParams[method] = params
                    }), this
                }, object.requestParams = config.defaultRequestParams, config.defaultHeaders = config.defaultHeaders || {}, object.setDefaultHeaders = function(headers) {
                    return config.defaultHeaders = headers, object.defaultHeaders = config.defaultHeaders, this
                }, object.defaultHeaders = config.defaultHeaders, config.methodOverriders = config.methodOverriders || [], object.setMethodOverriders = function(values) {
                    var overriders = _.extend([], values);
                    return config.isOverridenMethod("delete", overriders) && overriders.push("remove"), config.methodOverriders = overriders, this
                }, config.jsonp = !_.isUndefined(config.jsonp) && config.jsonp, object.setJsonp = function(active) {
                    config.jsonp = active
                }, config.isOverridenMethod = function(method, values) {
                    var search = values || config.methodOverriders;
                    return !_.isUndefined(_.find(search, function(one) {
                        return one.toLowerCase() === method.toLowerCase()
                    }))
                }, config.urlCreator = config.urlCreator || "path", object.setUrlCreator = function(name) {
                    if (!_.has(config.urlCreatorFactory, name)) throw new Error("URL Path selected isn't valid");
                    return config.urlCreator = name, this
                }, config.restangularFields = config.restangularFields || {
                    id: "id",
                    route: "route",
                    parentResource: "parentResource",
                    restangularCollection: "restangularCollection",
                    cannonicalId: "__cannonicalId",
                    etag: "restangularEtag",
                    selfLink: "href",
                    get: "get",
                    getList: "getList",
                    put: "put",
                    post: "post",
                    remove: "remove",
                    head: "head",
                    trace: "trace",
                    options: "options",
                    patch: "patch",
                    getRestangularUrl: "getRestangularUrl",
                    getRequestedUrl: "getRequestedUrl",
                    putElement: "putElement",
                    addRestangularMethod: "addRestangularMethod",
                    getParentList: "getParentList",
                    clone: "clone",
                    ids: "ids",
                    httpConfig: "_$httpConfig",
                    reqParams: "reqParams",
                    one: "one",
                    all: "all",
                    several: "several",
                    oneUrl: "oneUrl",
                    allUrl: "allUrl",
                    customPUT: "customPUT",
                    customPOST: "customPOST",
                    customDELETE: "customDELETE",
                    customGET: "customGET",
                    customGETLIST: "customGETLIST",
                    customOperation: "customOperation",
                    doPUT: "doPUT",
                    doPOST: "doPOST",
                    doDELETE: "doDELETE",
                    doGET: "doGET",
                    doGETLIST: "doGETLIST",
                    fromServer: "fromServer",
                    withConfig: "withConfig",
                    withHttpConfig: "withHttpConfig",
                    singleOne: "singleOne",
                    plain: "plain",
                    save: "save",
                    restangularized: "restangularized"
                }, object.setRestangularFields = function(resFields) {
                    return config.restangularFields = _.extend(config.restangularFields, resFields), this
                }, config.isRestangularized = function(obj) {
                    return !!obj[config.restangularFields.restangularized]
                }, config.setFieldToElem = function(field, elem, value) {
                    var properties = field.split("."),
                        idValue = elem;
                    return _.each(_.initial(properties), function(prop) {
                        idValue[prop] = {}, idValue = idValue[prop]
                    }), idValue[_.last(properties)] = value, this
                }, config.getFieldFromElem = function(field, elem) {
                    var properties = field.split("."),
                        idValue = elem;
                    return _.each(properties, function(prop) {
                        idValue && (idValue = idValue[prop])
                    }), angular.copy(idValue)
                }, config.setIdToElem = function(elem, id) {
                    return config.setFieldToElem(config.restangularFields.id, elem, id), this
                }, config.getIdFromElem = function(elem) {
                    return config.getFieldFromElem(config.restangularFields.id, elem)
                }, config.isValidId = function(elemId) {
                    return "" !== elemId && !_.isUndefined(elemId) && !_.isNull(elemId)
                }, config.setUrlToElem = function(elem, url) {
                    return config.setFieldToElem(config.restangularFields.selfLink, elem, url), this
                }, config.getUrlFromElem = function(elem) {
                    return config.getFieldFromElem(config.restangularFields.selfLink, elem)
                }, config.useCannonicalId = !_.isUndefined(config.useCannonicalId) && config.useCannonicalId, object.setUseCannonicalId = function(value) {
                    return config.useCannonicalId = value, this
                }, config.getCannonicalIdFromElem = function(elem) {
                    var cannonicalId = elem[config.restangularFields.cannonicalId],
                        actualId = config.isValidId(cannonicalId) ? cannonicalId : config.getIdFromElem(elem);
                    return actualId
                }, config.responseInterceptors = config.responseInterceptors || [], config.defaultResponseInterceptor = function(data) {
                    return data
                }, config.responseExtractor = function(data, operation, what, url, response, deferred) {
                    var interceptors = angular.copy(config.responseInterceptors);
                    interceptors.push(config.defaultResponseInterceptor);
                    var theData = data;
                    return _.each(interceptors, function(interceptor) {
                        theData = interceptor(theData, operation, what, url, response, deferred)
                    }), theData
                }, object.addResponseInterceptor = function(extractor) {
                    return config.responseInterceptors.push(extractor), this
                }, config.errorInterceptors = config.errorInterceptors || [], object.addErrorInterceptor = function(interceptor) {
                    return config.errorInterceptors.push(interceptor), this
                }, object.setResponseInterceptor = object.addResponseInterceptor, object.setResponseExtractor = object.addResponseInterceptor, object.setErrorInterceptor = object.addErrorInterceptor, config.requestInterceptors = config.requestInterceptors || [], config.defaultInterceptor = function(element, operation, path, url, headers, params, httpConfig) {
                    return {
                        element: element,
                        headers: headers,
                        params: params,
                        httpConfig: httpConfig
                    }
                }, config.fullRequestInterceptor = function(element, operation, path, url, headers, params, httpConfig) {
                    var interceptors = angular.copy(config.requestInterceptors),
                        defaultRequest = config.defaultInterceptor(element, operation, path, url, headers, params, httpConfig);
                    return _.reduce(interceptors, function(request, interceptor) {
                        return _.extend(request, interceptor(request.element, operation, path, url, request.headers, request.params, request.httpConfig))
                    }, defaultRequest)
                }, object.addRequestInterceptor = function(interceptor) {
                    return config.requestInterceptors.push(function(elem, operation, path, url, headers, params, httpConfig) {
                        return {
                            headers: headers,
                            params: params,
                            element: interceptor(elem, operation, path, url),
                            httpConfig: httpConfig
                        }
                    }), this
                }, object.setRequestInterceptor = object.addRequestInterceptor, object.addFullRequestInterceptor = function(interceptor) {
                    return config.requestInterceptors.push(interceptor), this
                }, object.setFullRequestInterceptor = object.addFullRequestInterceptor, config.onBeforeElemRestangularized = config.onBeforeElemRestangularized || function(elem) {
                    return elem
                }, object.setOnBeforeElemRestangularized = function(post) {
                    return config.onBeforeElemRestangularized = post, this
                }, object.setRestangularizePromiseInterceptor = function(interceptor) {
                    return config.restangularizePromiseInterceptor = interceptor, this
                }, config.onElemRestangularized = config.onElemRestangularized || function(elem) {
                    return elem
                }, object.setOnElemRestangularized = function(post) {
                    return config.onElemRestangularized = post, this
                }, config.shouldSaveParent = config.shouldSaveParent || function() {
                    return !0
                }, object.setParentless = function(values) {
                    return _.isArray(values) ? config.shouldSaveParent = function(route) {
                        return !_.includes(values, route)
                    } : _.isBoolean(values) && (config.shouldSaveParent = function() {
                        return !values
                    }), this
                }, config.suffix = _.isUndefined(config.suffix) ? null : config.suffix, object.setRequestSuffix = function(newSuffix) {
                    return config.suffix = newSuffix, this
                }, config.transformers = config.transformers || {}, object.addElementTransformer = function(type, secondArg, thirdArg) {
                    var isCollection = null,
                        transformer = null;
                    2 === arguments.length ? transformer = secondArg : (transformer = thirdArg, isCollection = secondArg);
                    var typeTransformers = config.transformers[type];
                    return typeTransformers || (typeTransformers = config.transformers[type] = []), typeTransformers.push(function(coll, elem) {
                        return _.isNull(isCollection) || coll === isCollection ? transformer(elem) : elem
                    }), object
                }, object.extendCollection = function(route, fn) {
                    return object.addElementTransformer(route, !0, fn)
                }, object.extendModel = function(route, fn) {
                    return object.addElementTransformer(route, !1, fn)
                }, config.transformElem = function(elem, isCollection, route, Restangular, force) {
                    if (!force && !config.transformLocalElements && !elem[config.restangularFields.fromServer]) return elem;
                    var typeTransformers = config.transformers[route],
                        changedElem = elem;
                    return typeTransformers && _.each(typeTransformers, function(transformer) {
                        changedElem = transformer(isCollection, changedElem)
                    }), config.onElemRestangularized(changedElem, isCollection, route, Restangular)
                }, config.transformLocalElements = !_.isUndefined(config.transformLocalElements) && config.transformLocalElements, object.setTransformOnlyServerElements = function(active) {
                    config.transformLocalElements = !active
                }, config.fullResponse = !_.isUndefined(config.fullResponse) && config.fullResponse, object.setFullResponse = function(full) {
                    return config.fullResponse = full, this
                }, config.urlCreatorFactory = {};
                var BaseCreator = function() {};
                BaseCreator.prototype.setConfig = function(config) {
                    return this.config = config, this
                }, BaseCreator.prototype.parentsArray = function(current) {
                    for (var parents = []; current;) parents.push(current), current = current[this.config.restangularFields.parentResource];
                    return parents.reverse()
                }, BaseCreator.prototype.resource = function(current, $http, localHttpConfig, callHeaders, callParams, what, etag, operation) {
                    var params = _.defaults(callParams || {}, this.config.defaultRequestParams.common),
                        headers = _.defaults(callHeaders || {}, this.config.defaultHeaders);
                    etag && (config.isSafe(operation) ? headers["If-None-Match"] = etag : headers["If-Match"] = etag);
                    var url = this.base(current);
                    if (what) {
                        var add = "";
                        /\/$/.test(url) || (add += "/"), add += what, url += add
                    }
                    return this.config.suffix && url.indexOf(this.config.suffix, url.length - this.config.suffix.length) === -1 && !this.config.getUrlFromElem(current) && (url += this.config.suffix), current[this.config.restangularFields.httpConfig] = void 0, RestangularResource(this.config, $http, url, {
                        getList: this.config.withHttpValues(localHttpConfig, {
                            method: "GET",
                            params: params,
                            headers: headers
                        }),
                        get: this.config.withHttpValues(localHttpConfig, {
                            method: "GET",
                            params: params,
                            headers: headers
                        }),
                        jsonp: this.config.withHttpValues(localHttpConfig, {
                            method: "jsonp",
                            params: params,
                            headers: headers
                        }),
                        put: this.config.withHttpValues(localHttpConfig, {
                            method: "PUT",
                            params: params,
                            headers: headers
                        }),
                        post: this.config.withHttpValues(localHttpConfig, {
                            method: "POST",
                            params: params,
                            headers: headers
                        }),
                        remove: this.config.withHttpValues(localHttpConfig, {
                            method: "DELETE",
                            params: params,
                            headers: headers
                        }),
                        head: this.config.withHttpValues(localHttpConfig, {
                            method: "HEAD",
                            params: params,
                            headers: headers
                        }),
                        trace: this.config.withHttpValues(localHttpConfig, {
                            method: "TRACE",
                            params: params,
                            headers: headers
                        }),
                        options: this.config.withHttpValues(localHttpConfig, {
                            method: "OPTIONS",
                            params: params,
                            headers: headers
                        }),
                        patch: this.config.withHttpValues(localHttpConfig, {
                            method: "PATCH",
                            params: params,
                            headers: headers
                        })
                    })
                };
                var Path = function() {};
                Path.prototype = new BaseCreator, Path.prototype.normalizeUrl = function(url) {
                    var parts = /(http[s]?:\/\/)?(.*)?/.exec(url);
                    return parts[2] = parts[2].replace(/[\\\/]+/g, "/"), "undefined" != typeof parts[1] ? parts[1] + parts[2] : parts[2]
                }, Path.prototype.base = function(current) {
                    var __this = this;
                    return _.reduce(this.parentsArray(current), function(acum, elem) {
                        var elemUrl, elemSelfLink = __this.config.getUrlFromElem(elem);
                        if (elemSelfLink) {
                            if (__this.config.isAbsoluteUrl(elemSelfLink)) return elemSelfLink;
                            elemUrl = elemSelfLink
                        } else if (elemUrl = elem[__this.config.restangularFields.route], elem[__this.config.restangularFields.restangularCollection]) {
                            var ids = elem[__this.config.restangularFields.ids];
                            ids && (elemUrl += "/" + ids.join(","))
                        } else {
                            var elemId;
                            elemId = __this.config.useCannonicalId ? __this.config.getCannonicalIdFromElem(elem) : __this.config.getIdFromElem(elem), config.isValidId(elemId) && !elem.singleOne && (elemUrl += "/" + (__this.config.encodeIds ? encodeURIComponent(elemId) : elemId))
                        }
                        return acum = acum.replace(/\/$/, "") + "/" + elemUrl, __this.normalizeUrl(acum)
                    }, this.config.baseUrl)
                }, Path.prototype.fetchUrl = function(current, what) {
                    var baseUrl = this.base(current);
                    return what && (baseUrl += "/" + what), baseUrl
                }, Path.prototype.fetchRequestedUrl = function(current, what) {
                    function sortedKeys(obj) {
                        var keys = [];
                        for (var key in obj) obj.hasOwnProperty(key) && keys.push(key);
                        return keys.sort()
                    }

                    function forEachSorted(obj, iterator, context) {
                        for (var keys = sortedKeys(obj), i = 0; i < keys.length; i++) iterator.call(context, obj[keys[i]], keys[i]);
                        return keys
                    }

                    function encodeUriQuery(val, pctEncodeSpaces) {
                        return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, pctEncodeSpaces ? "%20" : "+")
                    }
                    var url = this.fetchUrl(current, what),
                        params = current[config.restangularFields.reqParams];
                    if (!params) return url + (this.config.suffix || "");
                    var parts = [];
                    return forEachSorted(params, function(value, key) {
                        null !== value && void 0 !== value && (angular.isArray(value) || (value = [value]), angular.forEach(value, function(v) {
                            angular.isObject(v) && (v = angular.toJson(v)), parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(v))
                        }))
                    }), url + (this.config.suffix || "") + (url.indexOf("?") === -1 ? "?" : "&") + parts.join("&")
                }, config.urlCreatorFactory.path = Path
            };
            var globalConfiguration = {};
            Configurer.init(this, globalConfiguration), this.$get = ["$http", "$q", function($http, $q) {
                function createServiceForConfiguration(config) {
                    function restangularizeBase(parent, elem, route, reqParams, fromServer) {
                        if (elem[config.restangularFields.route] = route, elem[config.restangularFields.getRestangularUrl] = _.bind(urlHandler.fetchUrl, urlHandler, elem), elem[config.restangularFields.getRequestedUrl] = _.bind(urlHandler.fetchRequestedUrl, urlHandler, elem), elem[config.restangularFields.addRestangularMethod] = _.bind(addRestangularMethodFunction, elem), elem[config.restangularFields.clone] = _.bind(copyRestangularizedElement, elem, elem), elem[config.restangularFields.reqParams] = _.isEmpty(reqParams) ? null : reqParams, elem[config.restangularFields.withHttpConfig] = _.bind(withHttpConfig, elem), elem[config.restangularFields.plain] = _.bind(stripRestangular, elem, elem), elem[config.restangularFields.restangularized] = !0, elem[config.restangularFields.one] = _.bind(one, elem, elem), elem[config.restangularFields.all] = _.bind(all, elem, elem), elem[config.restangularFields.several] = _.bind(several, elem, elem), elem[config.restangularFields.oneUrl] = _.bind(oneUrl, elem, elem), elem[config.restangularFields.allUrl] = _.bind(allUrl, elem, elem), elem[config.restangularFields.fromServer] = !!fromServer, parent && config.shouldSaveParent(route)) {
                            var parentId = config.getIdFromElem(parent),
                                parentUrl = config.getUrlFromElem(parent),
                                restangularFieldsForParent = _.union(_.values(_.pick(config.restangularFields, ["route", "singleOne", "parentResource"])), config.extraFields),
                                parentResource = _.pick(parent, restangularFieldsForParent);
                            config.isValidId(parentId) && config.setIdToElem(parentResource, parentId, route), config.isValidId(parentUrl) && config.setUrlToElem(parentResource, parentUrl, route), elem[config.restangularFields.parentResource] = parentResource
                        } else elem[config.restangularFields.parentResource] = null;
                        return elem
                    }

                    function one(parent, route, id, singleOne) {
                        var error;
                        if (_.isNumber(route) || _.isNumber(parent)) throw error = "You're creating a Restangular entity with the number ", error += "instead of the route or the parent. For example, you can't call .one(12).", new Error(error);
                        if (_.isUndefined(route)) throw error = "You're creating a Restangular entity either without the path. ", error += "For example you can't call .one(). Please check if your arguments are valid.", new Error(error);
                        var elem = {};
                        return config.setIdToElem(elem, id, route), config.setFieldToElem(config.restangularFields.singleOne, elem, singleOne), restangularizeElem(parent, elem, route, !1)
                    }

                    function all(parent, route) {
                        return restangularizeCollection(parent, [], route, !1)
                    }

                    function several(parent, route) {
                        var collection = [];
                        return collection[config.restangularFields.ids] = Array.prototype.splice.call(arguments, 2), restangularizeCollection(parent, collection, route, !1)
                    }

                    function oneUrl(parent, route, url) {
                        if (!route) throw new Error("Route is mandatory when creating new Restangular objects.");
                        var elem = {};
                        return config.setUrlToElem(elem, url, route), restangularizeElem(parent, elem, route, !1)
                    }

                    function allUrl(parent, route, url) {
                        if (!route) throw new Error("Route is mandatory when creating new Restangular objects.");
                        var elem = {};
                        return config.setUrlToElem(elem, url, route), restangularizeCollection(parent, elem, route, !1)
                    }

                    function restangularizePromise(promise, isCollection, valueToFill) {
                        return promise.call = _.bind(promiseCall, promise), promise.get = _.bind(promiseGet, promise), promise[config.restangularFields.restangularCollection] = isCollection, isCollection && (promise.push = _.bind(promiseCall, promise, "push")), promise.$object = valueToFill, config.restangularizePromiseInterceptor && config.restangularizePromiseInterceptor(promise), promise
                    }

                    function promiseCall(method) {
                        var deferred = $q.defer(),
                            callArgs = arguments,
                            filledValue = {};
                        return this.then(function(val) {
                            var params = Array.prototype.slice.call(callArgs, 1),
                                func = val[method];
                            func.apply(val, params), filledValue = val, deferred.resolve(val)
                        }), restangularizePromise(deferred.promise, this[config.restangularFields.restangularCollection], filledValue)
                    }

                    function promiseGet(what) {
                        var deferred = $q.defer(),
                            filledValue = {};
                        return this.then(function(val) {
                            filledValue = val[what], deferred.resolve(filledValue)
                        }), restangularizePromise(deferred.promise, this[config.restangularFields.restangularCollection], filledValue)
                    }

                    function resolvePromise(deferred, response, data, filledValue) {
                        return _.extend(filledValue, data), config.fullResponse ? deferred.resolve(_.extend(response, {
                            data: data
                        })) : void deferred.resolve(data)
                    }

                    function stripRestangular(elem) {
                        if (_.isArray(elem)) {
                            var array = [];
                            return _.each(elem, function(value) {
                                array.push(config.isRestangularized(value) ? stripRestangular(value) : value)
                            }), array
                        }
                        return _.omit(elem, _.values(_.omit(config.restangularFields, "id")))
                    }

                    function addCustomOperation(elem) {
                        elem[config.restangularFields.customOperation] = _.bind(customFunction, elem), _.each(["put", "post", "get", "delete"], function(oper) {
                            _.each(["do", "custom"], function(alias) {
                                var callFunction, callOperation = "delete" === oper ? "remove" : oper,
                                    name = alias + oper.toUpperCase();
                                callFunction = "put" !== callOperation && "post" !== callOperation ? customFunction : function(operation, elem, path, params, headers) {
                                    return _.bind(customFunction, this)(operation, path, params, headers, elem)
                                }, elem[name] = _.bind(callFunction, elem, callOperation)
                            })
                        }), elem[config.restangularFields.customGETLIST] = _.bind(fetchFunction, elem), elem[config.restangularFields.doGETLIST] = elem[config.restangularFields.customGETLIST]
                    }

                    function copyRestangularizedElement(fromElement, toElement) {
                        var copiedElement = angular.copy(fromElement, toElement);
                        return restangularizeElem(copiedElement[config.restangularFields.parentResource], copiedElement, copiedElement[config.restangularFields.route], !0)
                    }

                    function restangularizeElem(parent, element, route, fromServer, collection, reqParams) {
                        var elem = config.onBeforeElemRestangularized(element, !1, route),
                            localElem = restangularizeBase(parent, elem, route, reqParams, fromServer);
                        return config.useCannonicalId && (localElem[config.restangularFields.cannonicalId] = config.getIdFromElem(localElem)), collection && (localElem[config.restangularFields.getParentList] = function() {
                            return collection
                        }), localElem[config.restangularFields.restangularCollection] = !1, localElem[config.restangularFields.get] = _.bind(getFunction, localElem), localElem[config.restangularFields.getList] = _.bind(fetchFunction, localElem), localElem[config.restangularFields.put] = _.bind(putFunction, localElem), localElem[config.restangularFields.post] = _.bind(postFunction, localElem), localElem[config.restangularFields.remove] = _.bind(deleteFunction, localElem), localElem[config.restangularFields.head] = _.bind(headFunction, localElem), localElem[config.restangularFields.trace] = _.bind(traceFunction, localElem), localElem[config.restangularFields.options] = _.bind(optionsFunction, localElem), localElem[config.restangularFields.patch] = _.bind(patchFunction, localElem), localElem[config.restangularFields.save] = _.bind(save, localElem), addCustomOperation(localElem), config.transformElem(localElem, !1, route, service, !0)
                    }

                    function restangularizeCollection(parent, element, route, fromServer, reqParams) {
                        var elem = config.onBeforeElemRestangularized(element, !0, route),
                            localElem = restangularizeBase(parent, elem, route, reqParams, fromServer);
                        return localElem[config.restangularFields.restangularCollection] = !0, localElem[config.restangularFields.post] = _.bind(postFunction, localElem, null), localElem[config.restangularFields.remove] = _.bind(deleteFunction, localElem), localElem[config.restangularFields.head] = _.bind(headFunction, localElem), localElem[config.restangularFields.trace] = _.bind(traceFunction, localElem), localElem[config.restangularFields.putElement] = _.bind(putElementFunction, localElem), localElem[config.restangularFields.options] = _.bind(optionsFunction, localElem), localElem[config.restangularFields.patch] = _.bind(patchFunction, localElem), localElem[config.restangularFields.get] = _.bind(getById, localElem), localElem[config.restangularFields.getList] = _.bind(fetchFunction, localElem, null), addCustomOperation(localElem), config.transformElem(localElem, !0, route, service, !0)
                    }

                    function restangularizeCollectionAndElements(parent, element, route) {
                        var collection = restangularizeCollection(parent, element, route, !1);
                        return _.each(collection, function(elem) {
                            restangularizeElem(parent, elem, route, !1)
                        }), collection
                    }

                    function getById(id, reqParams, headers) {
                        return this.customGET(id.toString(), reqParams, headers)
                    }

                    function putElementFunction(idx, params, headers) {
                        var __this = this,
                            elemToPut = this[idx],
                            deferred = $q.defer(),
                            filledArray = [];
                        return filledArray = config.transformElem(filledArray, !0, elemToPut[config.restangularFields.route], service), elemToPut.put(params, headers).then(function(serverElem) {
                            var newArray = copyRestangularizedElement(__this);
                            newArray[idx] = serverElem, filledArray = newArray, deferred.resolve(newArray)
                        }, function(response) {
                            deferred.reject(response)
                        }), restangularizePromise(deferred.promise, !0, filledArray)
                    }

                    function parseResponse(resData, operation, route, fetchUrl, response, deferred) {
                        var data = config.responseExtractor(resData, operation, route, fetchUrl, response, deferred),
                            etag = response.headers("ETag");
                        return data && etag && (data[config.restangularFields.etag] = etag), data
                    }

                    function fetchFunction(what, reqParams, headers) {
                        var __this = this,
                            deferred = $q.defer(),
                            operation = "getList",
                            url = urlHandler.fetchUrl(this, what),
                            whatFetched = what || __this[config.restangularFields.route],
                            request = config.fullRequestInterceptor(null, operation, whatFetched, url, headers || {}, reqParams || {}, this[config.restangularFields.httpConfig] || {}),
                            filledArray = [];
                        filledArray = config.transformElem(filledArray, !0, whatFetched, service);
                        var method = "getList";
                        config.jsonp && (method = "jsonp");
                        var okCallback = function(response) {
                            var resData = response.data,
                                fullParams = response.config.params,
                                data = parseResponse(resData, operation, whatFetched, url, response, deferred);
                            if ((_.isUndefined(data) || "" === data) && (data = []), !_.isArray(data)) throw new Error("Response for getList SHOULD be an array and not an object or something else");
                            var processedData = _.map(data, function(elem) {
                                return __this[config.restangularFields.restangularCollection] ? restangularizeElem(__this[config.restangularFields.parentResource], elem, __this[config.restangularFields.route], !0, data) : restangularizeElem(__this, elem, what, !0, data)
                            });
                            processedData = _.extend(data, processedData), __this[config.restangularFields.restangularCollection] ? resolvePromise(deferred, response, restangularizeCollection(__this[config.restangularFields.parentResource], processedData, __this[config.restangularFields.route], !0, fullParams), filledArray) : resolvePromise(deferred, response, restangularizeCollection(__this, processedData, what, !0, fullParams), filledArray)
                        };
                        return urlHandler.resource(this, $http, request.httpConfig, request.headers, request.params, what, this[config.restangularFields.etag], operation)[method]().then(okCallback, function(response) {
                            304 === response.status && __this[config.restangularFields.restangularCollection] ? resolvePromise(deferred, response, __this, filledArray) : _.every(config.errorInterceptors, function(cb) {
                                return cb(response, deferred, okCallback) !== !1
                            }) && deferred.reject(response)
                        }), restangularizePromise(deferred.promise, !0, filledArray)
                    }

                    function withHttpConfig(httpConfig) {
                        return this[config.restangularFields.httpConfig] = httpConfig, this
                    }

                    function save(params, headers) {
                        return this[config.restangularFields.fromServer] ? this[config.restangularFields.put](params, headers) : _.bind(elemFunction, this)("post", void 0, params, void 0, headers)
                    }

                    function elemFunction(operation, what, params, obj, headers) {
                        var __this = this,
                            deferred = $q.defer(),
                            resParams = params || {},
                            route = what || this[config.restangularFields.route],
                            fetchUrl = urlHandler.fetchUrl(this, what),
                            callObj = obj || this,
                            etag = callObj[config.restangularFields.etag] || ("post" !== operation ? this[config.restangularFields.etag] : null);
                        _.isObject(callObj) && config.isRestangularized(callObj) && (callObj = stripRestangular(callObj));
                        var request = config.fullRequestInterceptor(callObj, operation, route, fetchUrl, headers || {}, resParams || {}, this[config.restangularFields.httpConfig] || {}),
                            filledObject = {};
                        filledObject = config.transformElem(filledObject, !1, route, service);
                        var okCallback = function(response) {
                                var resData = response.data,
                                    fullParams = response.config.params,
                                    elem = parseResponse(resData, operation, route, fetchUrl, response, deferred);
                                if (elem) {
                                    var data;
                                    "post" !== operation || __this[config.restangularFields.restangularCollection] ? (data = restangularizeElem(__this[config.restangularFields.parentResource], elem, __this[config.restangularFields.route], !0, null, fullParams), data[config.restangularFields.singleOne] = __this[config.restangularFields.singleOne], resolvePromise(deferred, response, data, filledObject)) : (data = restangularizeElem(__this[config.restangularFields.parentResource], elem, route, !0, null, fullParams), resolvePromise(deferred, response, data, filledObject))
                                } else resolvePromise(deferred, response, void 0, filledObject)
                            },
                            errorCallback = function(response) {
                                304 === response.status && config.isSafe(operation) ? resolvePromise(deferred, response, __this, filledObject) : _.every(config.errorInterceptors, function(cb) {
                                    return cb(response, deferred, okCallback) !== !1
                                }) && deferred.reject(response)
                            },
                            callOperation = operation,
                            callHeaders = _.extend({}, request.headers),
                            isOverrideOperation = config.isOverridenMethod(operation);
                        return isOverrideOperation ? (callOperation = "post", callHeaders = _.extend(callHeaders, {
                            "X-HTTP-Method-Override": "remove" === operation ? "DELETE" : operation.toUpperCase()
                        })) : config.jsonp && "get" === callOperation && (callOperation = "jsonp"), config.isSafe(operation) ? isOverrideOperation ? urlHandler.resource(this, $http, request.httpConfig, callHeaders, request.params, what, etag, callOperation)[callOperation]({}).then(okCallback, errorCallback) : urlHandler.resource(this, $http, request.httpConfig, callHeaders, request.params, what, etag, callOperation)[callOperation]().then(okCallback, errorCallback) : urlHandler.resource(this, $http, request.httpConfig, callHeaders, request.params, what, etag, callOperation)[callOperation](request.element).then(okCallback, errorCallback), restangularizePromise(deferred.promise, !1, filledObject)
                    }

                    function getFunction(params, headers) {
                        return _.bind(elemFunction, this)("get", void 0, params, void 0, headers)
                    }

                    function deleteFunction(params, headers) {
                        return _.bind(elemFunction, this)("remove", void 0, params, void 0, headers)
                    }

                    function putFunction(params, headers) {
                        return _.bind(elemFunction, this)("put", void 0, params, void 0, headers)
                    }

                    function postFunction(what, elem, params, headers) {
                        return _.bind(elemFunction, this)("post", what, params, elem, headers)
                    }

                    function headFunction(params, headers) {
                        return _.bind(elemFunction, this)("head", void 0, params, void 0, headers)
                    }

                    function traceFunction(params, headers) {
                        return _.bind(elemFunction, this)("trace", void 0, params, void 0, headers)
                    }

                    function optionsFunction(params, headers) {
                        return _.bind(elemFunction, this)("options", void 0, params, void 0, headers)
                    }

                    function patchFunction(elem, params, headers) {
                        return _.bind(elemFunction, this)("patch", void 0, params, elem, headers)
                    }

                    function customFunction(operation, path, params, headers, elem) {
                        return _.bind(elemFunction, this)(operation, path, params, elem, headers)
                    }

                    function addRestangularMethodFunction(name, operation, path, defaultParams, defaultHeaders, defaultElem) {
                        var bindedFunction;
                        bindedFunction = "getList" === operation ? _.bind(fetchFunction, this, path) : _.bind(customFunction, this, operation, path);
                        var createdFunction = function(params, headers, elem) {
                            var callParams = _.defaults({
                                params: params,
                                headers: headers,
                                elem: elem
                            }, {
                                params: defaultParams,
                                headers: defaultHeaders,
                                elem: defaultElem
                            });
                            return bindedFunction(callParams.params, callParams.headers, callParams.elem)
                        };
                        config.isSafe(operation) ? this[name] = createdFunction : this[name] = function(elem, params, headers) {
                            return createdFunction(params, headers, elem)
                        }
                    }

                    function withConfigurationFunction(configurer) {
                        var newConfig = angular.copy(_.omit(config, "configuration"));
                        return Configurer.init(newConfig, newConfig), configurer(newConfig), createServiceForConfiguration(newConfig)
                    }

                    function toService(route, parent) {
                        var knownCollectionMethods = _.values(config.restangularFields),
                            serv = {},
                            collection = (parent || service).all(route);
                        serv.one = _.bind(one, parent || service, parent, route), serv.post = _.bind(collection.post, collection), serv.getList = _.bind(collection.getList, collection);
                        for (var prop in collection) collection.hasOwnProperty(prop) && _.isFunction(collection[prop]) && !_.includes(knownCollectionMethods, prop) && (serv[prop] = _.bind(collection[prop], collection));
                        return serv
                    }
                    var service = {},
                        urlHandler = new config.urlCreatorFactory[config.urlCreator];
                    return urlHandler.setConfig(config), Configurer.init(service, config), service.copy = _.bind(copyRestangularizedElement, service), service.service = _.bind(toService, service), service.withConfig = _.bind(withConfigurationFunction, service), service.one = _.bind(one, service, null), service.all = _.bind(all, service, null), service.several = _.bind(several, service, null), service.oneUrl = _.bind(oneUrl, service, null), service.allUrl = _.bind(allUrl, service, null), service.stripRestangular = _.bind(stripRestangular, service), service.restangularizeElement = _.bind(restangularizeElem, service), service.restangularizeCollection = _.bind(restangularizeCollectionAndElements, service), service
                }
                return createServiceForConfiguration(globalConfiguration)
            }]
        })
    }(),
    function(global, factory) {
        "object" === ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "undefined" != typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define(factory) : global.moment = factory()
    }(this, function() {
        "use strict";

        function hooks() {
            return hookCallback.apply(null, arguments)
        }

        function setHookCallback(callback) {
            hookCallback = callback
        }

        function isArray(input) {
            return input instanceof Array || "[object Array]" === Object.prototype.toString.call(input)
        }

        function isObject(input) {
            return null != input && "[object Object]" === Object.prototype.toString.call(input)
        }

        function isObjectEmpty(obj) {
            if (Object.getOwnPropertyNames) return 0 === Object.getOwnPropertyNames(obj).length;
            var k;
            for (k in obj)
                if (obj.hasOwnProperty(k)) return !1;
            return !0
        }

        function isUndefined(input) {
            return void 0 === input
        }

        function isNumber(input) {
            return "number" == typeof input || "[object Number]" === Object.prototype.toString.call(input)
        }

        function isDate(input) {
            return input instanceof Date || "[object Date]" === Object.prototype.toString.call(input)
        }

        function map(arr, fn) {
            var i, res = [];
            for (i = 0; i < arr.length; ++i) res.push(fn(arr[i], i));
            return res
        }

        function hasOwnProp(a, b) {
            return Object.prototype.hasOwnProperty.call(a, b)
        }

        function extend(a, b) {
            for (var i in b) hasOwnProp(b, i) && (a[i] = b[i]);
            return hasOwnProp(b, "toString") && (a.toString = b.toString), hasOwnProp(b, "valueOf") && (a.valueOf = b.valueOf), a
        }

        function createUTC(input, format, locale, strict) {
            return createLocalOrUTC(input, format, locale, strict, !0).utc()
        }

        function defaultParsingFlags() {
            return {
                empty: !1,
                unusedTokens: [],
                unusedInput: [],
                overflow: -2,
                charsLeftOver: 0,
                nullInput: !1,
                invalidMonth: null,
                invalidFormat: !1,
                userInvalidated: !1,
                iso: !1,
                parsedDateParts: [],
                meridiem: null,
                rfc2822: !1,
                weekdayMismatch: !1
            }
        }

        function getParsingFlags(m) {
            return null == m._pf && (m._pf = defaultParsingFlags()), m._pf
        }

        function isValid(m) {
            if (null == m._isValid) {
                var flags = getParsingFlags(m),
                    parsedParts = some.call(flags.parsedDateParts, function(i) {
                        return null != i
                    }),
                    isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
                if (m._strict && (isNowValid = isNowValid && 0 === flags.charsLeftOver && 0 === flags.unusedTokens.length && void 0 === flags.bigHour), null != Object.isFrozen && Object.isFrozen(m)) return isNowValid;
                m._isValid = isNowValid
            }
            return m._isValid
        }

        function createInvalid(flags) {
            var m = createUTC(NaN);
            return null != flags ? extend(getParsingFlags(m), flags) : getParsingFlags(m).userInvalidated = !0, m
        }

        function copyConfig(to, from) {
            var i, prop, val;
            if (isUndefined(from._isAMomentObject) || (to._isAMomentObject = from._isAMomentObject), isUndefined(from._i) || (to._i = from._i), isUndefined(from._f) || (to._f = from._f), isUndefined(from._l) || (to._l = from._l), isUndefined(from._strict) || (to._strict = from._strict), isUndefined(from._tzm) || (to._tzm = from._tzm), isUndefined(from._isUTC) || (to._isUTC = from._isUTC), isUndefined(from._offset) || (to._offset = from._offset), isUndefined(from._pf) || (to._pf = getParsingFlags(from)), isUndefined(from._locale) || (to._locale = from._locale), momentProperties.length > 0)
                for (i = 0; i < momentProperties.length; i++) prop = momentProperties[i], val = from[prop], isUndefined(val) || (to[prop] = val);
            return to
        }

        function Moment(config) {
            copyConfig(this, config), this._d = new Date(null != config._d ? config._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), updateInProgress === !1 && (updateInProgress = !0, hooks.updateOffset(this), updateInProgress = !1)
        }

        function isMoment(obj) {
            return obj instanceof Moment || null != obj && null != obj._isAMomentObject
        }

        function absFloor(number) {
            return number < 0 ? Math.ceil(number) || 0 : Math.floor(number)
        }

        function toInt(argumentForCoercion) {
            var coercedNumber = +argumentForCoercion,
                value = 0;
            return 0 !== coercedNumber && isFinite(coercedNumber) && (value = absFloor(coercedNumber)), value
        }

        function compareArrays(array1, array2, dontConvert) {
            var i, len = Math.min(array1.length, array2.length),
                lengthDiff = Math.abs(array1.length - array2.length),
                diffs = 0;
            for (i = 0; i < len; i++)(dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) && diffs++;
            return diffs + lengthDiff
        }

        function warn(msg) {
            hooks.suppressDeprecationWarnings === !1 && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + msg)
        }

        function deprecate(msg, fn) {
            var firstTime = !0;
            return extend(function() {
                if (null != hooks.deprecationHandler && hooks.deprecationHandler(null, msg), firstTime) {
                    for (var arg, args = [], i = 0; i < arguments.length; i++) {
                        if (arg = "", "object" === _typeof2(arguments[i])) {
                            arg += "\n[" + i + "] ";
                            for (var key in arguments[0]) arg += key + ": " + arguments[0][key] + ", ";
                            arg = arg.slice(0, -2)
                        } else arg = arguments[i];
                        args.push(arg)
                    }
                    warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + (new Error).stack), firstTime = !1
                }
                return fn.apply(this, arguments)
            }, fn)
        }

        function deprecateSimple(name, msg) {
            null != hooks.deprecationHandler && hooks.deprecationHandler(name, msg), deprecations[name] || (warn(msg), deprecations[name] = !0)
        }

        function isFunction(input) {
            return input instanceof Function || "[object Function]" === Object.prototype.toString.call(input)
        }

        function set(config) {
            var prop, i;
            for (i in config) prop = config[i], isFunction(prop) ? this[i] = prop : this["_" + i] = prop;
            this._config = config, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source)
        }

        function mergeConfigs(parentConfig, childConfig) {
            var prop, res = extend({}, parentConfig);
            for (prop in childConfig) hasOwnProp(childConfig, prop) && (isObject(parentConfig[prop]) && isObject(childConfig[prop]) ? (res[prop] = {}, extend(res[prop], parentConfig[prop]), extend(res[prop], childConfig[prop])) : null != childConfig[prop] ? res[prop] = childConfig[prop] : delete res[prop]);
            for (prop in parentConfig) hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop]) && (res[prop] = extend({}, res[prop]));
            return res
        }

        function Locale(config) {
            null != config && this.set(config)
        }

        function calendar(key, mom, now) {
            var output = this._calendar[key] || this._calendar.sameElse;
            return isFunction(output) ? output.call(mom, now) : output
        }

        function longDateFormat(key) {
            var format = this._longDateFormat[key],
                formatUpper = this._longDateFormat[key.toUpperCase()];
            return format || !formatUpper ? format : (this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
                return val.slice(1)
            }), this._longDateFormat[key])
        }

        function invalidDate() {
            return this._invalidDate
        }

        function ordinal(number) {
            return this._ordinal.replace("%d", number)
        }

        function relativeTime(number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number)
        }

        function pastFuture(diff, output) {
            var format = this._relativeTime[diff > 0 ? "future" : "past"];
            return isFunction(format) ? format(output) : format.replace(/%s/i, output)
        }

        function addUnitAlias(unit, shorthand) {
            var lowerCase = unit.toLowerCase();
            aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit
        }

        function normalizeUnits(units) {
            return "string" == typeof units ? aliases[units] || aliases[units.toLowerCase()] : void 0
        }

        function normalizeObjectUnits(inputObject) {
            var normalizedProp, prop, normalizedInput = {};
            for (prop in inputObject) hasOwnProp(inputObject, prop) && (normalizedProp = normalizeUnits(prop), normalizedProp && (normalizedInput[normalizedProp] = inputObject[prop]));
            return normalizedInput
        }

        function addUnitPriority(unit, priority) {
            priorities[unit] = priority
        }

        function getPrioritizedUnits(unitsObj) {
            var units = [];
            for (var u in unitsObj) units.push({
                unit: u,
                priority: priorities[u]
            });
            return units.sort(function(a, b) {
                return a.priority - b.priority
            }), units
        }

        function zeroFill(number, targetLength, forceSign) {
            var absNumber = "" + Math.abs(number),
                zerosToFill = targetLength - absNumber.length,
                sign = number >= 0;
            return (sign ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber
        }

        function addFormatToken(token, padded, ordinal, callback) {
            var func = callback;
            "string" == typeof callback && (func = function() {
                return this[callback]()
            }), token && (formatTokenFunctions[token] = func), padded && (formatTokenFunctions[padded[0]] = function() {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2])
            }), ordinal && (formatTokenFunctions[ordinal] = function() {
                return this.localeData().ordinal(func.apply(this, arguments), token)
            })
        }

        function removeFormattingTokens(input) {
            return input.match(/\[[\s\S]/) ? input.replace(/^\[|\]$/g, "") : input.replace(/\\/g, "")
        }

        function makeFormatFunction(format) {
            var i, length, array = format.match(formattingTokens);
            for (i = 0, length = array.length; i < length; i++) formatTokenFunctions[array[i]] ? array[i] = formatTokenFunctions[array[i]] : array[i] = removeFormattingTokens(array[i]);
            return function(mom) {
                var i, output = "";
                for (i = 0; i < length; i++) output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
                return output
            }
        }

        function formatMoment(m, format) {
            return m.isValid() ? (format = expandFormat(format, m.localeData()), formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format), formatFunctions[format](m)) : m.localeData().invalidDate()
        }

        function expandFormat(format, locale) {
            function replaceLongDateFormatTokens(input) {
                return locale.longDateFormat(input) || input
            }
            var i = 5;
            for (localFormattingTokens.lastIndex = 0; i >= 0 && localFormattingTokens.test(format);) format = format.replace(localFormattingTokens, replaceLongDateFormatTokens), localFormattingTokens.lastIndex = 0, i -= 1;
            return format
        }

        function addRegexToken(token, regex, strictRegex) {
            regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
                return isStrict && strictRegex ? strictRegex : regex
            }
        }

        function getParseRegexForToken(token, config) {
            return hasOwnProp(regexes, token) ? regexes[token](config._strict, config._locale) : new RegExp(unescapeFormat(token))
        }

        function unescapeFormat(s) {
            return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
                return p1 || p2 || p3 || p4
            }))
        }

        function regexEscape(s) {
            return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
        }

        function addParseToken(token, callback) {
            var i, func = callback;
            for ("string" == typeof token && (token = [token]), isNumber(callback) && (func = function(input, array) {
                    array[callback] = toInt(input)
                }), i = 0; i < token.length; i++) tokens[token[i]] = func
        }

        function addWeekParseToken(token, callback) {
            addParseToken(token, function(input, array, config, token) {
                config._w = config._w || {}, callback(input, config._w, config, token)
            })
        }

        function addTimeToArrayFromToken(token, input, config) {
            null != input && hasOwnProp(tokens, token) && tokens[token](input, config._a, config, token)
        }

        function daysInYear(year) {
            return isLeapYear(year) ? 366 : 365
        }

        function isLeapYear(year) {
            return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0
        }

        function getIsLeapYear() {
            return isLeapYear(this.year())
        }

        function makeGetSet(unit, keepTime) {
            return function(value) {
                return null != value ? (set$1(this, unit, value), hooks.updateOffset(this, keepTime), this) : get(this, unit)
            }
        }

        function get(mom, unit) {
            return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN
        }

        function set$1(mom, unit, value) {
            mom.isValid() && !isNaN(value) && ("FullYear" === unit && isLeapYear(mom.year()) && 1 === mom.month() && 29 === mom.date() ? mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month())) : mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value))
        }

        function stringGet(units) {
            return units = normalizeUnits(units), isFunction(this[units]) ? this[units]() : this
        }

        function stringSet(units, value) {
            if ("object" === _typeof2(units)) {
                units = normalizeObjectUnits(units);
                for (var prioritized = getPrioritizedUnits(units), i = 0; i < prioritized.length; i++) this[prioritized[i].unit](units[prioritized[i].unit])
            } else if (units = normalizeUnits(units), isFunction(this[units])) return this[units](value);
            return this
        }

        function mod(n, x) {
            return (n % x + x) % x
        }

        function daysInMonth(year, month) {
            if (isNaN(year) || isNaN(month)) return NaN;
            var modMonth = mod(month, 12);
            return year += (month - modMonth) / 12, 1 === modMonth ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2
        }

        function localeMonths(m, format) {
            return m ? isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? "format" : "standalone"][m.month()] : isArray(this._months) ? this._months : this._months.standalone
        }

        function localeMonthsShort(m, format) {
            return m ? isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? "format" : "standalone"][m.month()] : isArray(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone
        }

        function handleStrictParse(monthName, format, strict) {
            var i, ii, mom, llc = monthName.toLocaleLowerCase();
            if (!this._monthsParse)
                for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], i = 0; i < 12; ++i) mom = createUTC([2e3, i]), this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase(), this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
            return strict ? "MMM" === format ? (ii = indexOf.call(this._shortMonthsParse, llc), ii !== -1 ? ii : null) : (ii = indexOf.call(this._longMonthsParse, llc), ii !== -1 ? ii : null) : "MMM" === format ? (ii = indexOf.call(this._shortMonthsParse, llc), ii !== -1 ? ii : (ii = indexOf.call(this._longMonthsParse, llc), ii !== -1 ? ii : null)) : (ii = indexOf.call(this._longMonthsParse, llc), ii !== -1 ? ii : (ii = indexOf.call(this._shortMonthsParse, llc), ii !== -1 ? ii : null))
        }

        function localeMonthsParse(monthName, format, strict) {
            var i, mom, regex;
            if (this._monthsParseExact) return handleStrictParse.call(this, monthName, format, strict);
            for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), i = 0; i < 12; i++) {
                if (mom = createUTC([2e3, i]), strict && !this._longMonthsParse[i] && (this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i"), this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i")), strict || this._monthsParse[i] || (regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, ""), this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i")), strict && "MMMM" === format && this._longMonthsParse[i].test(monthName)) return i;
                if (strict && "MMM" === format && this._shortMonthsParse[i].test(monthName)) return i;
                if (!strict && this._monthsParse[i].test(monthName)) return i
            }
        }

        function setMonth(mom, value) {
            var dayOfMonth;
            if (!mom.isValid()) return mom;
            if ("string" == typeof value)
                if (/^\d+$/.test(value)) value = toInt(value);
                else if (value = mom.localeData().monthsParse(value), !isNumber(value)) return mom;
            return dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value)), mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth), mom
        }

        function getSetMonth(value) {
            return null != value ? (setMonth(this, value), hooks.updateOffset(this, !0), this) : get(this, "Month")
        }

        function getDaysInMonth() {
            return daysInMonth(this.year(), this.month())
        }

        function monthsShortRegex(isStrict) {
            return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this), isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex) : (hasOwnProp(this, "_monthsShortRegex") || (this._monthsShortRegex = defaultMonthsShortRegex), this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex)
        }

        function monthsRegex(isStrict) {
            return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this), isStrict ? this._monthsStrictRegex : this._monthsRegex) : (hasOwnProp(this, "_monthsRegex") || (this._monthsRegex = defaultMonthsRegex), this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex)
        }

        function computeMonthsParse() {
            function cmpLenRev(a, b) {
                return b.length - a.length
            }
            var i, mom, shortPieces = [],
                longPieces = [],
                mixedPieces = [];
            for (i = 0; i < 12; i++) mom = createUTC([2e3, i]), shortPieces.push(this.monthsShort(mom, "")), longPieces.push(this.months(mom, "")), mixedPieces.push(this.months(mom, "")), mixedPieces.push(this.monthsShort(mom, ""));
            for (shortPieces.sort(cmpLenRev), longPieces.sort(cmpLenRev), mixedPieces.sort(cmpLenRev), i = 0; i < 12; i++) shortPieces[i] = regexEscape(shortPieces[i]), longPieces[i] = regexEscape(longPieces[i]);
            for (i = 0; i < 24; i++) mixedPieces[i] = regexEscape(mixedPieces[i]);
            this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i")
        }

        function createDate(y, m, d, h, M, s, ms) {
            var date = new Date(y, m, d, h, M, s, ms);
            return y < 100 && y >= 0 && isFinite(date.getFullYear()) && date.setFullYear(y), date
        }

        function createUTCDate(y) {
            var date = new Date(Date.UTC.apply(null, arguments));
            return y < 100 && y >= 0 && isFinite(date.getUTCFullYear()) && date.setUTCFullYear(y), date
        }

        function firstWeekOffset(year, dow, doy) {
            var fwd = 7 + dow - doy,
                fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
            return -fwdlw + fwd - 1
        }

        function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
            var resYear, resDayOfYear, localWeekday = (7 + weekday - dow) % 7,
                weekOffset = firstWeekOffset(year, dow, doy),
                dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset;
            return dayOfYear <= 0 ? (resYear = year - 1, resDayOfYear = daysInYear(resYear) + dayOfYear) : dayOfYear > daysInYear(year) ? (resYear = year + 1, resDayOfYear = dayOfYear - daysInYear(year)) : (resYear = year, resDayOfYear = dayOfYear), {
                year: resYear,
                dayOfYear: resDayOfYear
            }
        }

        function weekOfYear(mom, dow, doy) {
            var resWeek, resYear, weekOffset = firstWeekOffset(mom.year(), dow, doy),
                week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1;
            return week < 1 ? (resYear = mom.year() - 1, resWeek = week + weeksInYear(resYear, dow, doy)) : week > weeksInYear(mom.year(), dow, doy) ? (resWeek = week - weeksInYear(mom.year(), dow, doy), resYear = mom.year() + 1) : (resYear = mom.year(), resWeek = week), {
                week: resWeek,
                year: resYear
            }
        }

        function weeksInYear(year, dow, doy) {
            var weekOffset = firstWeekOffset(year, dow, doy),
                weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
            return (daysInYear(year) - weekOffset + weekOffsetNext) / 7
        }

        function localeWeek(mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week
        }

        function localeFirstDayOfWeek() {
            return this._week.dow
        }

        function localeFirstDayOfYear() {
            return this._week.doy
        }

        function getSetWeek(input) {
            var week = this.localeData().week(this);
            return null == input ? week : this.add(7 * (input - week), "d")
        }

        function getSetISOWeek(input) {
            var week = weekOfYear(this, 1, 4).week;
            return null == input ? week : this.add(7 * (input - week), "d")
        }

        function parseWeekday(input, locale) {
            return "string" != typeof input ? input : isNaN(input) ? (input = locale.weekdaysParse(input), "number" == typeof input ? input : null) : parseInt(input, 10)
        }

        function parseIsoWeekday(input, locale) {
            return "string" == typeof input ? locale.weekdaysParse(input) % 7 || 7 : isNaN(input) ? null : input
        }

        function localeWeekdays(m, format) {
            return m ? isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format) ? "format" : "standalone"][m.day()] : isArray(this._weekdays) ? this._weekdays : this._weekdays.standalone
        }

        function localeWeekdaysShort(m) {
            return m ? this._weekdaysShort[m.day()] : this._weekdaysShort
        }

        function localeWeekdaysMin(m) {
            return m ? this._weekdaysMin[m.day()] : this._weekdaysMin
        }

        function handleStrictParse$1(weekdayName, format, strict) {
            var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
            if (!this._weekdaysParse)
                for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], i = 0; i < 7; ++i) mom = createUTC([2e3, 1]).day(i), this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase(), this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase(), this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
            return strict ? "dddd" === format ? (ii = indexOf.call(this._weekdaysParse, llc), ii !== -1 ? ii : null) : "ddd" === format ? (ii = indexOf.call(this._shortWeekdaysParse, llc), ii !== -1 ? ii : null) : (ii = indexOf.call(this._minWeekdaysParse, llc), ii !== -1 ? ii : null) : "dddd" === format ? (ii = indexOf.call(this._weekdaysParse, llc), ii !== -1 ? ii : (ii = indexOf.call(this._shortWeekdaysParse, llc), ii !== -1 ? ii : (ii = indexOf.call(this._minWeekdaysParse, llc), ii !== -1 ? ii : null))) : "ddd" === format ? (ii = indexOf.call(this._shortWeekdaysParse, llc), ii !== -1 ? ii : (ii = indexOf.call(this._weekdaysParse, llc), ii !== -1 ? ii : (ii = indexOf.call(this._minWeekdaysParse, llc), ii !== -1 ? ii : null))) : (ii = indexOf.call(this._minWeekdaysParse, llc), ii !== -1 ? ii : (ii = indexOf.call(this._weekdaysParse, llc), ii !== -1 ? ii : (ii = indexOf.call(this._shortWeekdaysParse, llc), ii !== -1 ? ii : null)))
        }

        function localeWeekdaysParse(weekdayName, format, strict) {
            var i, mom, regex;
            if (this._weekdaysParseExact) return handleStrictParse$1.call(this, weekdayName, format, strict);
            for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), i = 0; i < 7; i++) {
                if (mom = createUTC([2e3, 1]).day(i), strict && !this._fullWeekdaysParse[i] && (this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", ".?") + "$", "i"), this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", ".?") + "$", "i"), this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", ".?") + "$", "i")), this._weekdaysParse[i] || (regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, ""), this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i")), strict && "dddd" === format && this._fullWeekdaysParse[i].test(weekdayName)) return i;
                if (strict && "ddd" === format && this._shortWeekdaysParse[i].test(weekdayName)) return i;
                if (strict && "dd" === format && this._minWeekdaysParse[i].test(weekdayName)) return i;
                if (!strict && this._weekdaysParse[i].test(weekdayName)) return i
            }
        }

        function getSetDayOfWeek(input) {
            if (!this.isValid()) return null != input ? this : NaN;
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            return null != input ? (input = parseWeekday(input, this.localeData()), this.add(input - day, "d")) : day
        }

        function getSetLocaleDayOfWeek(input) {
            if (!this.isValid()) return null != input ? this : NaN;
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return null == input ? weekday : this.add(input - weekday, "d")
        }

        function getSetISODayOfWeek(input) {
            if (!this.isValid()) return null != input ? this : NaN;
            if (null != input) {
                var weekday = parseIsoWeekday(input, this.localeData());
                return this.day(this.day() % 7 ? weekday : weekday - 7)
            }
            return this.day() || 7
        }

        function weekdaysRegex(isStrict) {
            return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex) : (hasOwnProp(this, "_weekdaysRegex") || (this._weekdaysRegex = defaultWeekdaysRegex), this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex)
        }

        function weekdaysShortRegex(isStrict) {
            return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (hasOwnProp(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = defaultWeekdaysShortRegex), this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
        }

        function weekdaysMinRegex(isStrict) {
            return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (hasOwnProp(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = defaultWeekdaysMinRegex), this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
        }

        function computeWeekdaysParse() {
            function cmpLenRev(a, b) {
                return b.length - a.length
            }
            var i, mom, minp, shortp, longp, minPieces = [],
                shortPieces = [],
                longPieces = [],
                mixedPieces = [];
            for (i = 0; i < 7; i++) mom = createUTC([2e3, 1]).day(i), minp = this.weekdaysMin(mom, ""), shortp = this.weekdaysShort(mom, ""), longp = this.weekdays(mom, ""), minPieces.push(minp), shortPieces.push(shortp), longPieces.push(longp), mixedPieces.push(minp), mixedPieces.push(shortp), mixedPieces.push(longp);
            for (minPieces.sort(cmpLenRev), shortPieces.sort(cmpLenRev), longPieces.sort(cmpLenRev), mixedPieces.sort(cmpLenRev), i = 0; i < 7; i++) shortPieces[i] = regexEscape(shortPieces[i]), longPieces[i] = regexEscape(longPieces[i]), mixedPieces[i] = regexEscape(mixedPieces[i]);
            this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i")
        }

        function hFormat() {
            return this.hours() % 12 || 12
        }

        function kFormat() {
            return this.hours() || 24
        }

        function meridiem(token, lowercase) {
            addFormatToken(token, 0, 0, function() {
                return this.localeData().meridiem(this.hours(), this.minutes(), lowercase)
            })
        }

        function matchMeridiem(isStrict, locale) {
            return locale._meridiemParse
        }

        function localeIsPM(input) {
            return "p" === (input + "").toLowerCase().charAt(0)
        }

        function localeMeridiem(hours, minutes, isLower) {
            return hours > 11 ? isLower ? "pm" : "PM" : isLower ? "am" : "AM"
        }

        function normalizeLocale(key) {
            return key ? key.toLowerCase().replace("_", "-") : key
        }

        function chooseLocale(names) {
            for (var j, next, locale, split, i = 0; i < names.length;) {
                for (split = normalizeLocale(names[i]).split("-"), j = split.length, next = normalizeLocale(names[i + 1]), next = next ? next.split("-") : null; j > 0;) {
                    if (locale = loadLocale(split.slice(0, j).join("-"))) return locale;
                    if (next && next.length >= j && compareArrays(split, next, !0) >= j - 1) break;
                    j--
                }
                i++
            }
            return null
        }

        function loadLocale(name) {
            var oldLocale = null;
            if (!locales[name] && "undefined" != typeof module && module && module.exports) try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                aliasedRequire("./locale/" + name), getSetGlobalLocale(oldLocale)
            } catch (e) {}
            return locales[name]
        }

        function getSetGlobalLocale(key, values) {
            var data;
            return key && (data = isUndefined(values) ? getLocale(key) : defineLocale(key, values), data && (globalLocale = data)), globalLocale._abbr
        }

        function defineLocale(name, config) {
            if (null !== config) {
                var parentConfig = baseConfig;
                if (config.abbr = name, null != locales[name]) deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), parentConfig = locales[name]._config;
                else if (null != config.parentLocale) {
                    if (null == locales[config.parentLocale]) return localeFamilies[config.parentLocale] || (localeFamilies[config.parentLocale] = []), localeFamilies[config.parentLocale].push({
                        name: name,
                        config: config
                    }), null;
                    parentConfig = locales[config.parentLocale]._config
                }
                return locales[name] = new Locale(mergeConfigs(parentConfig, config)), localeFamilies[name] && localeFamilies[name].forEach(function(x) {
                    defineLocale(x.name, x.config)
                }), getSetGlobalLocale(name), locales[name]
            }
            return delete locales[name], null
        }

        function updateLocale(name, config) {
            if (null != config) {
                var locale, tmpLocale, parentConfig = baseConfig;
                tmpLocale = loadLocale(name), null != tmpLocale && (parentConfig = tmpLocale._config), config = mergeConfigs(parentConfig, config), locale = new Locale(config), locale.parentLocale = locales[name], locales[name] = locale, getSetGlobalLocale(name)
            } else null != locales[name] && (null != locales[name].parentLocale ? locales[name] = locales[name].parentLocale : null != locales[name] && delete locales[name]);
            return locales[name]
        }

        function getLocale(key) {
            var locale;
            if (key && key._locale && key._locale._abbr && (key = key._locale._abbr), !key) return globalLocale;
            if (!isArray(key)) {
                if (locale = loadLocale(key)) return locale;
                key = [key]
            }
            return chooseLocale(key)
        }

        function listLocales() {
            return keys(locales)
        }

        function checkOverflow(m) {
            var overflow, a = m._a;
            return a && getParsingFlags(m).overflow === -2 && (overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || 24 === a[HOUR] && (0 !== a[MINUTE] || 0 !== a[SECOND] || 0 !== a[MILLISECOND]) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1, getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE) && (overflow = DATE), getParsingFlags(m)._overflowWeeks && overflow === -1 && (overflow = WEEK), getParsingFlags(m)._overflowWeekday && overflow === -1 && (overflow = WEEKDAY), getParsingFlags(m).overflow = overflow), m
        }

        function defaults(a, b, c) {
            return null != a ? a : null != b ? b : c
        }

        function currentDateArray(config) {
            var nowValue = new Date(hooks.now());
            return config._useUTC ? [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()] : [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()]
        }

        function configFromArray(config) {
            var i, date, currentDate, yearToUse, input = [];
            if (!config._d) {
                for (currentDate = currentDateArray(config), config._w && null == config._a[DATE] && null == config._a[MONTH] && dayOfYearFromWeekInfo(config), null != config._dayOfYear && (yearToUse = defaults(config._a[YEAR], currentDate[YEAR]), (config._dayOfYear > daysInYear(yearToUse) || 0 === config._dayOfYear) && (getParsingFlags(config)._overflowDayOfYear = !0), date = createUTCDate(yearToUse, 0, config._dayOfYear), config._a[MONTH] = date.getUTCMonth(), config._a[DATE] = date.getUTCDate()), i = 0; i < 3 && null == config._a[i]; ++i) config._a[i] = input[i] = currentDate[i];
                for (; i < 7; i++) config._a[i] = input[i] = null == config._a[i] ? 2 === i ? 1 : 0 : config._a[i];
                24 === config._a[HOUR] && 0 === config._a[MINUTE] && 0 === config._a[SECOND] && 0 === config._a[MILLISECOND] && (config._nextDay = !0, config._a[HOUR] = 0), config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input), null != config._tzm && config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm), config._nextDay && (config._a[HOUR] = 24), config._w && "undefined" != typeof config._w.d && config._w.d !== config._d.getDay() && (getParsingFlags(config).weekdayMismatch = !0)
            }
        }

        function dayOfYearFromWeekInfo(config) {
            var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;
            if (w = config._w, null != w.GG || null != w.W || null != w.E) dow = 1, doy = 4, weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year), week = defaults(w.W, 1), weekday = defaults(w.E, 1), (weekday < 1 || weekday > 7) && (weekdayOverflow = !0);
            else {
                dow = config._locale._week.dow, doy = config._locale._week.doy;
                var curWeek = weekOfYear(createLocal(), dow, doy);
                weekYear = defaults(w.gg, config._a[YEAR], curWeek.year), week = defaults(w.w, curWeek.week), null != w.d ? (weekday = w.d, (weekday < 0 || weekday > 6) && (weekdayOverflow = !0)) : null != w.e ? (weekday = w.e + dow, (w.e < 0 || w.e > 6) && (weekdayOverflow = !0)) : weekday = dow
            }
            week < 1 || week > weeksInYear(weekYear, dow, doy) ? getParsingFlags(config)._overflowWeeks = !0 : null != weekdayOverflow ? getParsingFlags(config)._overflowWeekday = !0 : (temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), config._a[YEAR] = temp.year, config._dayOfYear = temp.dayOfYear)
        }

        function configFromISO(config) {
            var i, l, allowTime, dateFormat, timeFormat, tzFormat, string = config._i,
                match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string);
            if (match) {
                for (getParsingFlags(config).iso = !0, i = 0, l = isoDates.length; i < l; i++)
                    if (isoDates[i][1].exec(match[1])) {
                        dateFormat = isoDates[i][0], allowTime = isoDates[i][2] !== !1;
                        break
                    } if (null == dateFormat) return void(config._isValid = !1);
                if (match[3]) {
                    for (i = 0, l = isoTimes.length; i < l; i++)
                        if (isoTimes[i][1].exec(match[3])) {
                            timeFormat = (match[2] || " ") + isoTimes[i][0];
                            break
                        } if (null == timeFormat) return void(config._isValid = !1)
                }
                if (!allowTime && null != timeFormat) return void(config._isValid = !1);
                if (match[4]) {
                    if (!tzRegex.exec(match[4])) return void(config._isValid = !1);
                    tzFormat = "Z"
                }
                config._f = dateFormat + (timeFormat || "") + (tzFormat || ""), configFromStringAndFormat(config)
            } else config._isValid = !1
        }

        function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
            var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];
            return secondStr && result.push(parseInt(secondStr, 10)), result
        }

        function untruncateYear(yearStr) {
            var year = parseInt(yearStr, 10);
            return year <= 49 ? 2e3 + year : year <= 999 ? 1900 + year : year
        }

        function preprocessRFC2822(s) {
            return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").trim()
        }

        function checkWeekday(weekdayStr, parsedInput, config) {
            if (weekdayStr) {
                var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr),
                    weekdayActual = new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay();
                if (weekdayProvided !== weekdayActual) return getParsingFlags(config).weekdayMismatch = !0, config._isValid = !1, !1
            }
            return !0
        }

        function calculateOffset(obsOffset, militaryOffset, numOffset) {
            if (obsOffset) return obsOffsets[obsOffset];
            if (militaryOffset) return 0;
            var hm = parseInt(numOffset, 10),
                m = hm % 100,
                h = (hm - m) / 100;
            return 60 * h + m
        }

        function configFromRFC2822(config) {
            var match = rfc2822.exec(preprocessRFC2822(config._i));
            if (match) {
                var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
                if (!checkWeekday(match[1], parsedArray, config)) return;
                config._a = parsedArray, config._tzm = calculateOffset(match[8], match[9], match[10]), config._d = createUTCDate.apply(null, config._a), config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm), getParsingFlags(config).rfc2822 = !0
            } else config._isValid = !1
        }

        function configFromString(config) {
            var matched = aspNetJsonRegex.exec(config._i);
            return null !== matched ? void(config._d = new Date((+matched[1]))) : (configFromISO(config), void(config._isValid === !1 && (delete config._isValid, configFromRFC2822(config), config._isValid === !1 && (delete config._isValid, hooks.createFromInputFallback(config)))))
        }

        function configFromStringAndFormat(config) {
            if (config._f === hooks.ISO_8601) return void configFromISO(config);
            if (config._f === hooks.RFC_2822) return void configFromRFC2822(config);
            config._a = [], getParsingFlags(config).empty = !0;
            var i, parsedInput, tokens, token, skipped, string = "" + config._i,
                stringLength = string.length,
                totalParsedInputLength = 0;
            for (tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [], i = 0; i < tokens.length; i++) token = tokens[i], parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0], parsedInput && (skipped = string.substr(0, string.indexOf(parsedInput)), skipped.length > 0 && getParsingFlags(config).unusedInput.push(skipped), string = string.slice(string.indexOf(parsedInput) + parsedInput.length), totalParsedInputLength += parsedInput.length), formatTokenFunctions[token] ? (parsedInput ? getParsingFlags(config).empty = !1 : getParsingFlags(config).unusedTokens.push(token), addTimeToArrayFromToken(token, parsedInput, config)) : config._strict && !parsedInput && getParsingFlags(config).unusedTokens.push(token);
            getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength, string.length > 0 && getParsingFlags(config).unusedInput.push(string), config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === !0 && config._a[HOUR] > 0 && (getParsingFlags(config).bigHour = void 0), getParsingFlags(config).parsedDateParts = config._a.slice(0), getParsingFlags(config).meridiem = config._meridiem, config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem), configFromArray(config), checkOverflow(config)
        }

        function meridiemFixWrap(locale, hour, meridiem) {
            var isPm;
            return null == meridiem ? hour : null != locale.meridiemHour ? locale.meridiemHour(hour, meridiem) : null != locale.isPM ? (isPm = locale.isPM(meridiem), isPm && hour < 12 && (hour += 12), isPm || 12 !== hour || (hour = 0), hour) : hour
        }

        function configFromStringAndArray(config) {
            var tempConfig, bestMoment, scoreToBeat, i, currentScore;
            if (0 === config._f.length) return getParsingFlags(config).invalidFormat = !0, void(config._d = new Date(NaN));
            for (i = 0; i < config._f.length; i++) currentScore = 0, tempConfig = copyConfig({}, config), null != config._useUTC && (tempConfig._useUTC = config._useUTC), tempConfig._f = config._f[i], configFromStringAndFormat(tempConfig), isValid(tempConfig) && (currentScore += getParsingFlags(tempConfig).charsLeftOver, currentScore += 10 * getParsingFlags(tempConfig).unusedTokens.length, getParsingFlags(tempConfig).score = currentScore, (null == scoreToBeat || currentScore < scoreToBeat) && (scoreToBeat = currentScore, bestMoment = tempConfig));
            extend(config, bestMoment || tempConfig)
        }

        function configFromObject(config) {
            if (!config._d) {
                var i = normalizeObjectUnits(config._i);
                config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function(obj) {
                    return obj && parseInt(obj, 10)
                }), configFromArray(config)
            }
        }

        function createFromConfig(config) {
            var res = new Moment(checkOverflow(prepareConfig(config)));
            return res._nextDay && (res.add(1, "d"), res._nextDay = void 0), res
        }

        function prepareConfig(config) {
            var input = config._i,
                format = config._f;
            return config._locale = config._locale || getLocale(config._l), null === input || void 0 === format && "" === input ? createInvalid({
                nullInput: !0
            }) : ("string" == typeof input && (config._i = input = config._locale.preparse(input)), isMoment(input) ? new Moment(checkOverflow(input)) : (isDate(input) ? config._d = input : isArray(format) ? configFromStringAndArray(config) : format ? configFromStringAndFormat(config) : configFromInput(config), isValid(config) || (config._d = null), config))
        }

        function configFromInput(config) {
            var input = config._i;
            isUndefined(input) ? config._d = new Date(hooks.now()) : isDate(input) ? config._d = new Date(input.valueOf()) : "string" == typeof input ? configFromString(config) : isArray(input) ? (config._a = map(input.slice(0), function(obj) {
                return parseInt(obj, 10)
            }), configFromArray(config)) : isObject(input) ? configFromObject(config) : isNumber(input) ? config._d = new Date(input) : hooks.createFromInputFallback(config)
        }

        function createLocalOrUTC(input, format, locale, strict, isUTC) {
            var c = {};
            return locale !== !0 && locale !== !1 || (strict = locale, locale = void 0), (isObject(input) && isObjectEmpty(input) || isArray(input) && 0 === input.length) && (input = void 0), c._isAMomentObject = !0, c._useUTC = c._isUTC = isUTC, c._l = locale, c._i = input, c._f = format, c._strict = strict, createFromConfig(c)
        }

        function createLocal(input, format, locale, strict) {
            return createLocalOrUTC(input, format, locale, strict, !1)
        }

        function pickBy(fn, moments) {
            var res, i;
            if (1 === moments.length && isArray(moments[0]) && (moments = moments[0]), !moments.length) return createLocal();
            for (res = moments[0], i = 1; i < moments.length; ++i) moments[i].isValid() && !moments[i][fn](res) || (res = moments[i]);
            return res
        }

        function min() {
            var args = [].slice.call(arguments, 0);
            return pickBy("isBefore", args)
        }

        function max() {
            var args = [].slice.call(arguments, 0);
            return pickBy("isAfter", args)
        }

        function isDurationValid(m) {
            for (var key in m)
                if (indexOf.call(ordering, key) === -1 || null != m[key] && isNaN(m[key])) return !1;
            for (var unitHasDecimal = !1, i = 0; i < ordering.length; ++i)
                if (m[ordering[i]]) {
                    if (unitHasDecimal) return !1;
                    parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]]) && (unitHasDecimal = !0)
                } return !0
        }

        function isValid$1() {
            return this._isValid
        }

        function createInvalid$1() {
            return createDuration(NaN)
        }

        function Duration(duration) {
            var normalizedInput = normalizeObjectUnits(duration),
                years = normalizedInput.year || 0,
                quarters = normalizedInput.quarter || 0,
                months = normalizedInput.month || 0,
                weeks = normalizedInput.week || 0,
                days = normalizedInput.day || 0,
                hours = normalizedInput.hour || 0,
                minutes = normalizedInput.minute || 0,
                seconds = normalizedInput.second || 0,
                milliseconds = normalizedInput.millisecond || 0;
            this._isValid = isDurationValid(normalizedInput), this._milliseconds = +milliseconds + 1e3 * seconds + 6e4 * minutes + 1e3 * hours * 60 * 60, this._days = +days + 7 * weeks, this._months = +months + 3 * quarters + 12 * years, this._data = {}, this._locale = getLocale(), this._bubble()
        }

        function isDuration(obj) {
            return obj instanceof Duration
        }

        function absRound(number) {
            return number < 0 ? Math.round(-1 * number) * -1 : Math.round(number)
        }

        function offset(token, separator) {
            addFormatToken(token, 0, 0, function() {
                var offset = this.utcOffset(),
                    sign = "+";
                return offset < 0 && (offset = -offset, sign = "-"), sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2)
            })
        }

        function offsetFromString(matcher, string) {
            var matches = (string || "").match(matcher);
            if (null === matches) return null;
            var chunk = matches[matches.length - 1] || [],
                parts = (chunk + "").match(chunkOffset) || ["-", 0, 0],
                minutes = +(60 * parts[1]) + toInt(parts[2]);
            return 0 === minutes ? 0 : "+" === parts[0] ? minutes : -minutes
        }

        function cloneWithOffset(input, model) {
            var res, diff;
            return model._isUTC ? (res = model.clone(), diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(), res._d.setTime(res._d.valueOf() + diff), hooks.updateOffset(res, !1), res) : createLocal(input).local()
        }

        function getDateOffset(m) {
            return 15 * -Math.round(m._d.getTimezoneOffset() / 15)
        }

        function getSetOffset(input, keepLocalTime, keepMinutes) {
            var localAdjust, offset = this._offset || 0;
            if (!this.isValid()) return null != input ? this : NaN;
            if (null != input) {
                if ("string" == typeof input) {
                    if (input = offsetFromString(matchShortOffset, input), null === input) return this
                } else Math.abs(input) < 16 && !keepMinutes && (input = 60 * input);
                return !this._isUTC && keepLocalTime && (localAdjust = getDateOffset(this)), this._offset = input, this._isUTC = !0, null != localAdjust && this.add(localAdjust, "m"), offset !== input && (!keepLocalTime || this._changeInProgress ? addSubtract(this, createDuration(input - offset, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, hooks.updateOffset(this, !0), this._changeInProgress = null)), this
            }
            return this._isUTC ? offset : getDateOffset(this)
        }

        function getSetZone(input, keepLocalTime) {
            return null != input ? ("string" != typeof input && (input = -input), this.utcOffset(input, keepLocalTime), this) : -this.utcOffset()
        }

        function setOffsetToUTC(keepLocalTime) {
            return this.utcOffset(0, keepLocalTime)
        }

        function setOffsetToLocal(keepLocalTime) {
            return this._isUTC && (this.utcOffset(0, keepLocalTime), this._isUTC = !1, keepLocalTime && this.subtract(getDateOffset(this), "m")), this
        }

        function setOffsetToParsedOffset() {
            if (null != this._tzm) this.utcOffset(this._tzm, !1, !0);
            else if ("string" == typeof this._i) {
                var tZone = offsetFromString(matchOffset, this._i);
                null != tZone ? this.utcOffset(tZone) : this.utcOffset(0, !0)
            }
            return this
        }

        function hasAlignedHourOffset(input) {
            return !!this.isValid() && (input = input ? createLocal(input).utcOffset() : 0, (this.utcOffset() - input) % 60 === 0)
        }

        function isDaylightSavingTime() {
            return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
        }

        function isDaylightSavingTimeShifted() {
            if (!isUndefined(this._isDSTShifted)) return this._isDSTShifted;
            var c = {};
            if (copyConfig(c, this), c = prepareConfig(c),
                c._a) {
                var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
                this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0
            } else this._isDSTShifted = !1;
            return this._isDSTShifted
        }

        function isLocal() {
            return !!this.isValid() && !this._isUTC
        }

        function isUtcOffset() {
            return !!this.isValid() && this._isUTC
        }

        function isUtc() {
            return !!this.isValid() && (this._isUTC && 0 === this._offset)
        }

        function createDuration(input, key) {
            var sign, ret, diffRes, duration = input,
                match = null;
            return isDuration(input) ? duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            } : isNumber(input) ? (duration = {}, key ? duration[key] = input : duration.milliseconds = input) : (match = aspNetRegex.exec(input)) ? (sign = "-" === match[1] ? -1 : 1, duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(1e3 * match[MILLISECOND])) * sign
            }) : (match = isoRegex.exec(input)) ? (sign = "-" === match[1] ? -1 : ("+" === match[1], 1), duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign)
            }) : null == duration ? duration = {} : "object" === _typeof2(duration) && ("from" in duration || "to" in duration) && (diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to)), duration = {}, duration.ms = diffRes.milliseconds, duration.M = diffRes.months), ret = new Duration(duration), isDuration(input) && hasOwnProp(input, "_locale") && (ret._locale = input._locale), ret
        }

        function parseIso(inp, sign) {
            var res = inp && parseFloat(inp.replace(",", "."));
            return (isNaN(res) ? 0 : res) * sign
        }

        function positiveMomentsDifference(base, other) {
            var res = {
                milliseconds: 0,
                months: 0
            };
            return res.months = other.month() - base.month() + 12 * (other.year() - base.year()), base.clone().add(res.months, "M").isAfter(other) && --res.months, res.milliseconds = +other - +base.clone().add(res.months, "M"), res
        }

        function momentsDifference(base, other) {
            var res;
            return base.isValid() && other.isValid() ? (other = cloneWithOffset(other, base), base.isBefore(other) ? res = positiveMomentsDifference(base, other) : (res = positiveMomentsDifference(other, base), res.milliseconds = -res.milliseconds, res.months = -res.months), res) : {
                milliseconds: 0,
                months: 0
            }
        }

        function createAdder(direction, name) {
            return function(val, period) {
                var dur, tmp;
                return null === period || isNaN(+period) || (deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), tmp = val, val = period, period = tmp), val = "string" == typeof val ? +val : val, dur = createDuration(val, period), addSubtract(this, dur, direction), this
            }
        }

        function addSubtract(mom, duration, isAdding, updateOffset) {
            var milliseconds = duration._milliseconds,
                days = absRound(duration._days),
                months = absRound(duration._months);
            mom.isValid() && (updateOffset = null == updateOffset || updateOffset, months && setMonth(mom, get(mom, "Month") + months * isAdding), days && set$1(mom, "Date", get(mom, "Date") + days * isAdding), milliseconds && mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding), updateOffset && hooks.updateOffset(mom, days || months))
        }

        function getCalendarFormat(myMoment, now) {
            var diff = myMoment.diff(now, "days", !0);
            return diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse"
        }

        function calendar$1(time, formats) {
            var now = time || createLocal(),
                sod = cloneWithOffset(now, this).startOf("day"),
                format = hooks.calendarFormat(this, sod) || "sameElse",
                output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
            return this.format(output || this.localeData().calendar(format, this, createLocal(now)))
        }

        function clone() {
            return new Moment(this)
        }

        function isAfter(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input);
            return !(!this.isValid() || !localInput.isValid()) && (units = normalizeUnits(isUndefined(units) ? "millisecond" : units), "millisecond" === units ? this.valueOf() > localInput.valueOf() : localInput.valueOf() < this.clone().startOf(units).valueOf())
        }

        function isBefore(input, units) {
            var localInput = isMoment(input) ? input : createLocal(input);
            return !(!this.isValid() || !localInput.isValid()) && (units = normalizeUnits(isUndefined(units) ? "millisecond" : units), "millisecond" === units ? this.valueOf() < localInput.valueOf() : this.clone().endOf(units).valueOf() < localInput.valueOf())
        }

        function isBetween(from, to, units, inclusivity) {
            return inclusivity = inclusivity || "()", ("(" === inclusivity[0] ? this.isAfter(from, units) : !this.isBefore(from, units)) && (")" === inclusivity[1] ? this.isBefore(to, units) : !this.isAfter(to, units))
        }

        function isSame(input, units) {
            var inputMs, localInput = isMoment(input) ? input : createLocal(input);
            return !(!this.isValid() || !localInput.isValid()) && (units = normalizeUnits(units || "millisecond"), "millisecond" === units ? this.valueOf() === localInput.valueOf() : (inputMs = localInput.valueOf(), this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf()))
        }

        function isSameOrAfter(input, units) {
            return this.isSame(input, units) || this.isAfter(input, units)
        }

        function isSameOrBefore(input, units) {
            return this.isSame(input, units) || this.isBefore(input, units)
        }

        function diff(input, units, asFloat) {
            var that, zoneDelta, output;
            if (!this.isValid()) return NaN;
            if (that = cloneWithOffset(input, this), !that.isValid()) return NaN;
            switch (zoneDelta = 6e4 * (that.utcOffset() - this.utcOffset()), units = normalizeUnits(units)) {
                case "year":
                    output = monthDiff(this, that) / 12;
                    break;
                case "month":
                    output = monthDiff(this, that);
                    break;
                case "quarter":
                    output = monthDiff(this, that) / 3;
                    break;
                case "second":
                    output = (this - that) / 1e3;
                    break;
                case "minute":
                    output = (this - that) / 6e4;
                    break;
                case "hour":
                    output = (this - that) / 36e5;
                    break;
                case "day":
                    output = (this - that - zoneDelta) / 864e5;
                    break;
                case "week":
                    output = (this - that - zoneDelta) / 6048e5;
                    break;
                default:
                    output = this - that
            }
            return asFloat ? output : absFloor(output)
        }

        function monthDiff(a, b) {
            var anchor2, adjust, wholeMonthDiff = 12 * (b.year() - a.year()) + (b.month() - a.month()),
                anchor = a.clone().add(wholeMonthDiff, "months");
            return b - anchor < 0 ? (anchor2 = a.clone().add(wholeMonthDiff - 1, "months"), adjust = (b - anchor) / (anchor - anchor2)) : (anchor2 = a.clone().add(wholeMonthDiff + 1, "months"), adjust = (b - anchor) / (anchor2 - anchor)), -(wholeMonthDiff + adjust) || 0
        }

        function toString() {
            return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
        }

        function toISOString() {
            if (!this.isValid()) return null;
            var m = this.clone().utc();
            return m.year() < 0 || m.year() > 9999 ? formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]") : isFunction(Date.prototype.toISOString) ? this.toDate().toISOString() : formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]")
        }

        function inspect() {
            if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
            var func = "moment",
                zone = "";
            this.isLocal() || (func = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", zone = "Z");
            var prefix = "[" + func + '("]',
                year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY",
                datetime = "-MM-DD[T]HH:mm:ss.SSS",
                suffix = zone + '[")]';
            return this.format(prefix + year + datetime + suffix)
        }

        function format(inputString) {
            inputString || (inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat);
            var output = formatMoment(this, inputString);
            return this.localeData().postformat(output)
        }

        function from(time, withoutSuffix) {
            return this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid()) ? createDuration({
                to: this,
                from: time
            }).locale(this.locale()).humanize(!withoutSuffix) : this.localeData().invalidDate()
        }

        function fromNow(withoutSuffix) {
            return this.from(createLocal(), withoutSuffix)
        }

        function to(time, withoutSuffix) {
            return this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid()) ? createDuration({
                from: this,
                to: time
            }).locale(this.locale()).humanize(!withoutSuffix) : this.localeData().invalidDate()
        }

        function toNow(withoutSuffix) {
            return this.to(createLocal(), withoutSuffix)
        }

        function locale(key) {
            var newLocaleData;
            return void 0 === key ? this._locale._abbr : (newLocaleData = getLocale(key), null != newLocaleData && (this._locale = newLocaleData), this)
        }

        function localeData() {
            return this._locale
        }

        function startOf(units) {
            switch (units = normalizeUnits(units)) {
                case "year":
                    this.month(0);
                case "quarter":
                case "month":
                    this.date(1);
                case "week":
                case "isoWeek":
                case "day":
                case "date":
                    this.hours(0);
                case "hour":
                    this.minutes(0);
                case "minute":
                    this.seconds(0);
                case "second":
                    this.milliseconds(0)
            }
            return "week" === units && this.weekday(0), "isoWeek" === units && this.isoWeekday(1), "quarter" === units && this.month(3 * Math.floor(this.month() / 3)), this
        }

        function endOf(units) {
            return units = normalizeUnits(units), void 0 === units || "millisecond" === units ? this : ("date" === units && (units = "day"), this.startOf(units).add(1, "isoWeek" === units ? "week" : units).subtract(1, "ms"))
        }

        function valueOf() {
            return this._d.valueOf() - 6e4 * (this._offset || 0)
        }

        function unix() {
            return Math.floor(this.valueOf() / 1e3)
        }

        function toDate() {
            return new Date(this.valueOf())
        }

        function toArray() {
            var m = this;
            return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()]
        }

        function toObject() {
            var m = this;
            return {
                years: m.year(),
                months: m.month(),
                date: m.date(),
                hours: m.hours(),
                minutes: m.minutes(),
                seconds: m.seconds(),
                milliseconds: m.milliseconds()
            }
        }

        function toJSON() {
            return this.isValid() ? this.toISOString() : null
        }

        function isValid$2() {
            return isValid(this)
        }

        function parsingFlags() {
            return extend({}, getParsingFlags(this))
        }

        function invalidAt() {
            return getParsingFlags(this).overflow
        }

        function creationData() {
            return {
                input: this._i,
                format: this._f,
                locale: this._locale,
                isUTC: this._isUTC,
                strict: this._strict
            }
        }

        function addWeekYearFormatToken(token, getter) {
            addFormatToken(0, [token, token.length], 0, getter)
        }

        function getSetWeekYear(input) {
            return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy)
        }

        function getSetISOWeekYear(input) {
            return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4)
        }

        function getISOWeeksInYear() {
            return weeksInYear(this.year(), 1, 4)
        }

        function getWeeksInYear() {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy)
        }

        function getSetWeekYearHelper(input, week, weekday, dow, doy) {
            var weeksTarget;
            return null == input ? weekOfYear(this, dow, doy).year : (weeksTarget = weeksInYear(input, dow, doy), week > weeksTarget && (week = weeksTarget), setWeekAll.call(this, input, week, weekday, dow, doy))
        }

        function setWeekAll(weekYear, week, weekday, dow, doy) {
            var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
                date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
            return this.year(date.getUTCFullYear()), this.month(date.getUTCMonth()), this.date(date.getUTCDate()), this
        }

        function getSetQuarter(input) {
            return null == input ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (input - 1) + this.month() % 3)
        }

        function getSetDayOfYear(input) {
            var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
            return null == input ? dayOfYear : this.add(input - dayOfYear, "d")
        }

        function parseMs(input, array) {
            array[MILLISECOND] = toInt(1e3 * ("0." + input))
        }

        function getZoneAbbr() {
            return this._isUTC ? "UTC" : ""
        }

        function getZoneName() {
            return this._isUTC ? "Coordinated Universal Time" : ""
        }

        function createUnix(input) {
            return createLocal(1e3 * input)
        }

        function createInZone() {
            return createLocal.apply(null, arguments).parseZone()
        }

        function preParsePostFormat(string) {
            return string
        }

        function get$1(format, index, field, setter) {
            var locale = getLocale(),
                utc = createUTC().set(setter, index);
            return locale[field](utc, format)
        }

        function listMonthsImpl(format, index, field) {
            if (isNumber(format) && (index = format, format = void 0), format = format || "", null != index) return get$1(format, index, field, "month");
            var i, out = [];
            for (i = 0; i < 12; i++) out[i] = get$1(format, i, field, "month");
            return out
        }

        function listWeekdaysImpl(localeSorted, format, index, field) {
            "boolean" == typeof localeSorted ? (isNumber(format) && (index = format, format = void 0), format = format || "") : (format = localeSorted, index = format, localeSorted = !1, isNumber(format) && (index = format, format = void 0), format = format || "");
            var locale = getLocale(),
                shift = localeSorted ? locale._week.dow : 0;
            if (null != index) return get$1(format, (index + shift) % 7, field, "day");
            var i, out = [];
            for (i = 0; i < 7; i++) out[i] = get$1(format, (i + shift) % 7, field, "day");
            return out
        }

        function listMonths(format, index) {
            return listMonthsImpl(format, index, "months")
        }

        function listMonthsShort(format, index) {
            return listMonthsImpl(format, index, "monthsShort")
        }

        function listWeekdays(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, "weekdays")
        }

        function listWeekdaysShort(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, "weekdaysShort")
        }

        function listWeekdaysMin(localeSorted, format, index) {
            return listWeekdaysImpl(localeSorted, format, index, "weekdaysMin")
        }

        function abs() {
            var data = this._data;
            return this._milliseconds = mathAbs(this._milliseconds), this._days = mathAbs(this._days), this._months = mathAbs(this._months), data.milliseconds = mathAbs(data.milliseconds), data.seconds = mathAbs(data.seconds), data.minutes = mathAbs(data.minutes), data.hours = mathAbs(data.hours), data.months = mathAbs(data.months), data.years = mathAbs(data.years), this
        }

        function addSubtract$1(duration, input, value, direction) {
            var other = createDuration(input, value);
            return duration._milliseconds += direction * other._milliseconds, duration._days += direction * other._days, duration._months += direction * other._months, duration._bubble()
        }

        function add$1(input, value) {
            return addSubtract$1(this, input, value, 1)
        }

        function subtract$1(input, value) {
            return addSubtract$1(this, input, value, -1)
        }

        function absCeil(number) {
            return number < 0 ? Math.floor(number) : Math.ceil(number)
        }

        function bubble() {
            var seconds, minutes, hours, years, monthsFromDays, milliseconds = this._milliseconds,
                days = this._days,
                months = this._months,
                data = this._data;
            return milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0 || (milliseconds += 864e5 * absCeil(monthsToDays(months) + days), days = 0, months = 0), data.milliseconds = milliseconds % 1e3, seconds = absFloor(milliseconds / 1e3), data.seconds = seconds % 60, minutes = absFloor(seconds / 60), data.minutes = minutes % 60, hours = absFloor(minutes / 60), data.hours = hours % 24, days += absFloor(hours / 24), monthsFromDays = absFloor(daysToMonths(days)), months += monthsFromDays, days -= absCeil(monthsToDays(monthsFromDays)), years = absFloor(months / 12), months %= 12, data.days = days, data.months = months, data.years = years, this
        }

        function daysToMonths(days) {
            return 4800 * days / 146097
        }

        function monthsToDays(months) {
            return 146097 * months / 4800
        }

        function as(units) {
            if (!this.isValid()) return NaN;
            var days, months, milliseconds = this._milliseconds;
            if (units = normalizeUnits(units), "month" === units || "year" === units) return days = this._days + milliseconds / 864e5, months = this._months + daysToMonths(days), "month" === units ? months : months / 12;
            switch (days = this._days + Math.round(monthsToDays(this._months)), units) {
                case "week":
                    return days / 7 + milliseconds / 6048e5;
                case "day":
                    return days + milliseconds / 864e5;
                case "hour":
                    return 24 * days + milliseconds / 36e5;
                case "minute":
                    return 1440 * days + milliseconds / 6e4;
                case "second":
                    return 86400 * days + milliseconds / 1e3;
                case "millisecond":
                    return Math.floor(864e5 * days) + milliseconds;
                default:
                    throw new Error("Unknown unit " + units)
            }
        }

        function valueOf$1() {
            return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * toInt(this._months / 12) : NaN
        }

        function makeAs(alias) {
            return function() {
                return this.as(alias)
            }
        }

        function clone$1() {
            return createDuration(this)
        }

        function get$2(units) {
            return units = normalizeUnits(units), this.isValid() ? this[units + "s"]() : NaN
        }

        function makeGetter(name) {
            return function() {
                return this.isValid() ? this._data[name] : NaN
            }
        }

        function weeks() {
            return absFloor(this.days() / 7)
        }

        function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
            return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture)
        }

        function relativeTime$1(posNegDuration, withoutSuffix, locale) {
            var duration = createDuration(posNegDuration).abs(),
                seconds = round(duration.as("s")),
                minutes = round(duration.as("m")),
                hours = round(duration.as("h")),
                days = round(duration.as("d")),
                months = round(duration.as("M")),
                years = round(duration.as("y")),
                a = seconds <= thresholds.ss && ["s", seconds] || seconds < thresholds.s && ["ss", seconds] || minutes <= 1 && ["m"] || minutes < thresholds.m && ["mm", minutes] || hours <= 1 && ["h"] || hours < thresholds.h && ["hh", hours] || days <= 1 && ["d"] || days < thresholds.d && ["dd", days] || months <= 1 && ["M"] || months < thresholds.M && ["MM", months] || years <= 1 && ["y"] || ["yy", years];
            return a[2] = withoutSuffix, a[3] = +posNegDuration > 0, a[4] = locale, substituteTimeAgo.apply(null, a)
        }

        function getSetRelativeTimeRounding(roundingFunction) {
            return void 0 === roundingFunction ? round : "function" == typeof roundingFunction && (round = roundingFunction, !0)
        }

        function getSetRelativeTimeThreshold(threshold, limit) {
            return void 0 !== thresholds[threshold] && (void 0 === limit ? thresholds[threshold] : (thresholds[threshold] = limit, "s" === threshold && (thresholds.ss = limit - 1), !0))
        }

        function humanize(withSuffix) {
            if (!this.isValid()) return this.localeData().invalidDate();
            var locale = this.localeData(),
                output = relativeTime$1(this, !withSuffix, locale);
            return withSuffix && (output = locale.pastFuture(+this, output)), locale.postformat(output)
        }

        function sign(x) {
            return (x > 0) - (x < 0) || +x
        }

        function toISOString$1() {
            if (!this.isValid()) return this.localeData().invalidDate();
            var minutes, hours, years, seconds = abs$1(this._milliseconds) / 1e3,
                days = abs$1(this._days),
                months = abs$1(this._months);
            minutes = absFloor(seconds / 60), hours = absFloor(minutes / 60), seconds %= 60, minutes %= 60, years = absFloor(months / 12), months %= 12;
            var Y = years,
                M = months,
                D = days,
                h = hours,
                m = minutes,
                s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, "") : "",
                total = this.asSeconds();
            if (!total) return "P0D";
            var totalSign = total < 0 ? "-" : "",
                ymSign = sign(this._months) !== sign(total) ? "-" : "",
                daysSign = sign(this._days) !== sign(total) ? "-" : "",
                hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "";
            return totalSign + "P" + (Y ? ymSign + Y + "Y" : "") + (M ? ymSign + M + "M" : "") + (D ? daysSign + D + "D" : "") + (h || m || s ? "T" : "") + (h ? hmsSign + h + "H" : "") + (m ? hmsSign + m + "M" : "") + (s ? hmsSign + s + "S" : "")
        }
        var hookCallback, some;
        some = Array.prototype.some ? Array.prototype.some : function(fun) {
            for (var t = Object(this), len = t.length >>> 0, i = 0; i < len; i++)
                if (i in t && fun.call(this, t[i], i, t)) return !0;
            return !1
        };
        var momentProperties = hooks.momentProperties = [],
            updateInProgress = !1,
            deprecations = {};
        hooks.suppressDeprecationWarnings = !1, hooks.deprecationHandler = null;
        var keys;
        keys = Object.keys ? Object.keys : function(obj) {
            var i, res = [];
            for (i in obj) hasOwnProp(obj, i) && res.push(i);
            return res
        };
        var defaultCalendar = {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            defaultLongDateFormat = {
                LTS: "h:mm:ss A",
                LT: "h:mm A",
                L: "MM/DD/YYYY",
                LL: "MMMM D, YYYY",
                LLL: "MMMM D, YYYY h:mm A",
                LLLL: "dddd, MMMM D, YYYY h:mm A"
            },
            defaultInvalidDate = "Invalid date",
            defaultOrdinal = "%d",
            defaultDayOfMonthOrdinalParse = /\d{1,2}/,
            defaultRelativeTime = {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            aliases = {},
            priorities = {},
            formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
            localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
            formatFunctions = {},
            formatTokenFunctions = {},
            match1 = /\d/,
            match2 = /\d\d/,
            match3 = /\d{3}/,
            match4 = /\d{4}/,
            match6 = /[+-]?\d{6}/,
            match1to2 = /\d\d?/,
            match3to4 = /\d\d\d\d?/,
            match5to6 = /\d\d\d\d\d\d?/,
            match1to3 = /\d{1,3}/,
            match1to4 = /\d{1,4}/,
            match1to6 = /[+-]?\d{1,6}/,
            matchUnsigned = /\d+/,
            matchSigned = /[+-]?\d+/,
            matchOffset = /Z|[+-]\d\d:?\d\d/gi,
            matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi,
            matchTimestamp = /[+-]?\d+(\.\d{1,3})?/,
            matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i,
            regexes = {},
            tokens = {},
            YEAR = 0,
            MONTH = 1,
            DATE = 2,
            HOUR = 3,
            MINUTE = 4,
            SECOND = 5,
            MILLISECOND = 6,
            WEEK = 7,
            WEEKDAY = 8;
        addFormatToken("Y", 0, 0, function() {
            var y = this.year();
            return y <= 9999 ? "" + y : "+" + y
        }), addFormatToken(0, ["YY", 2], 0, function() {
            return this.year() % 100
        }), addFormatToken(0, ["YYYY", 4], 0, "year"), addFormatToken(0, ["YYYYY", 5], 0, "year"), addFormatToken(0, ["YYYYYY", 6, !0], 0, "year"), addUnitAlias("year", "y"), addUnitPriority("year", 1), addRegexToken("Y", matchSigned), addRegexToken("YY", match1to2, match2), addRegexToken("YYYY", match1to4, match4), addRegexToken("YYYYY", match1to6, match6), addRegexToken("YYYYYY", match1to6, match6), addParseToken(["YYYYY", "YYYYYY"], YEAR), addParseToken("YYYY", function(input, array) {
            array[YEAR] = 2 === input.length ? hooks.parseTwoDigitYear(input) : toInt(input)
        }), addParseToken("YY", function(input, array) {
            array[YEAR] = hooks.parseTwoDigitYear(input)
        }), addParseToken("Y", function(input, array) {
            array[YEAR] = parseInt(input, 10)
        }), hooks.parseTwoDigitYear = function(input) {
            return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3)
        };
        var indexOf, getSetYear = makeGetSet("FullYear", !0);
        indexOf = Array.prototype.indexOf ? Array.prototype.indexOf : function(o) {
            var i;
            for (i = 0; i < this.length; ++i)
                if (this[i] === o) return i;
            return -1
        }, addFormatToken("M", ["MM", 2], "Mo", function() {
            return this.month() + 1
        }), addFormatToken("MMM", 0, 0, function(format) {
            return this.localeData().monthsShort(this, format)
        }), addFormatToken("MMMM", 0, 0, function(format) {
            return this.localeData().months(this, format)
        }), addUnitAlias("month", "M"), addUnitPriority("month", 8), addRegexToken("M", match1to2), addRegexToken("MM", match1to2, match2), addRegexToken("MMM", function(isStrict, locale) {
            return locale.monthsShortRegex(isStrict)
        }), addRegexToken("MMMM", function(isStrict, locale) {
            return locale.monthsRegex(isStrict)
        }), addParseToken(["M", "MM"], function(input, array) {
            array[MONTH] = toInt(input) - 1
        }), addParseToken(["MMM", "MMMM"], function(input, array, config, token) {
            var month = config._locale.monthsParse(input, token, config._strict);
            null != month ? array[MONTH] = month : getParsingFlags(config).invalidMonth = input
        });
        var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
            defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            defaultMonthsShortRegex = matchWord,
            defaultMonthsRegex = matchWord;
        addFormatToken("w", ["ww", 2], "wo", "week"), addFormatToken("W", ["WW", 2], "Wo", "isoWeek"), addUnitAlias("week", "w"), addUnitAlias("isoWeek", "W"), addUnitPriority("week", 5), addUnitPriority("isoWeek", 5), addRegexToken("w", match1to2), addRegexToken("ww", match1to2, match2), addRegexToken("W", match1to2), addRegexToken("WW", match1to2, match2), addWeekParseToken(["w", "ww", "W", "WW"], function(input, week, config, token) {
            week[token.substr(0, 1)] = toInt(input)
        });
        var defaultLocaleWeek = {
            dow: 0,
            doy: 6
        };
        addFormatToken("d", 0, "do", "day"), addFormatToken("dd", 0, 0, function(format) {
            return this.localeData().weekdaysMin(this, format)
        }), addFormatToken("ddd", 0, 0, function(format) {
            return this.localeData().weekdaysShort(this, format)
        }), addFormatToken("dddd", 0, 0, function(format) {
            return this.localeData().weekdays(this, format)
        }), addFormatToken("e", 0, 0, "weekday"), addFormatToken("E", 0, 0, "isoWeekday"), addUnitAlias("day", "d"), addUnitAlias("weekday", "e"), addUnitAlias("isoWeekday", "E"), addUnitPriority("day", 11), addUnitPriority("weekday", 11), addUnitPriority("isoWeekday", 11), addRegexToken("d", match1to2), addRegexToken("e", match1to2), addRegexToken("E", match1to2), addRegexToken("dd", function(isStrict, locale) {
            return locale.weekdaysMinRegex(isStrict)
        }), addRegexToken("ddd", function(isStrict, locale) {
            return locale.weekdaysShortRegex(isStrict)
        }), addRegexToken("dddd", function(isStrict, locale) {
            return locale.weekdaysRegex(isStrict)
        }), addWeekParseToken(["dd", "ddd", "dddd"], function(input, week, config, token) {
            var weekday = config._locale.weekdaysParse(input, token, config._strict);
            null != weekday ? week.d = weekday : getParsingFlags(config).invalidWeekday = input
        }), addWeekParseToken(["d", "e", "E"], function(input, week, config, token) {
            week[token] = toInt(input)
        });
        var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            defaultWeekdaysRegex = matchWord,
            defaultWeekdaysShortRegex = matchWord,
            defaultWeekdaysMinRegex = matchWord;
        addFormatToken("H", ["HH", 2], 0, "hour"), addFormatToken("h", ["hh", 2], 0, hFormat), addFormatToken("k", ["kk", 2], 0, kFormat), addFormatToken("hmm", 0, 0, function() {
            return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2)
        }), addFormatToken("hmmss", 0, 0, function() {
            return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2)
        }), addFormatToken("Hmm", 0, 0, function() {
            return "" + this.hours() + zeroFill(this.minutes(), 2)
        }), addFormatToken("Hmmss", 0, 0, function() {
            return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2)
        }), meridiem("a", !0), meridiem("A", !1), addUnitAlias("hour", "h"), addUnitPriority("hour", 13), addRegexToken("a", matchMeridiem), addRegexToken("A", matchMeridiem), addRegexToken("H", match1to2), addRegexToken("h", match1to2), addRegexToken("k", match1to2), addRegexToken("HH", match1to2, match2), addRegexToken("hh", match1to2, match2), addRegexToken("kk", match1to2, match2), addRegexToken("hmm", match3to4), addRegexToken("hmmss", match5to6), addRegexToken("Hmm", match3to4), addRegexToken("Hmmss", match5to6), addParseToken(["H", "HH"], HOUR), addParseToken(["k", "kk"], function(input, array, config) {
            var kInput = toInt(input);
            array[HOUR] = 24 === kInput ? 0 : kInput
        }), addParseToken(["a", "A"], function(input, array, config) {
            config._isPm = config._locale.isPM(input), config._meridiem = input
        }), addParseToken(["h", "hh"], function(input, array, config) {
            array[HOUR] = toInt(input), getParsingFlags(config).bigHour = !0
        }), addParseToken("hmm", function(input, array, config) {
            var pos = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos)), array[MINUTE] = toInt(input.substr(pos)), getParsingFlags(config).bigHour = !0
        }), addParseToken("hmmss", function(input, array, config) {
            var pos1 = input.length - 4,
                pos2 = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos1)), array[MINUTE] = toInt(input.substr(pos1, 2)), array[SECOND] = toInt(input.substr(pos2)), getParsingFlags(config).bigHour = !0
        }), addParseToken("Hmm", function(input, array, config) {
            var pos = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos)), array[MINUTE] = toInt(input.substr(pos))
        }), addParseToken("Hmmss", function(input, array, config) {
            var pos1 = input.length - 4,
                pos2 = input.length - 2;
            array[HOUR] = toInt(input.substr(0, pos1)), array[MINUTE] = toInt(input.substr(pos1, 2)), array[SECOND] = toInt(input.substr(pos2))
        });
        var globalLocale, defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
            getSetHour = makeGetSet("Hours", !0),
            baseConfig = {
                calendar: defaultCalendar,
                longDateFormat: defaultLongDateFormat,
                invalidDate: defaultInvalidDate,
                ordinal: defaultOrdinal,
                dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
                relativeTime: defaultRelativeTime,
                months: defaultLocaleMonths,
                monthsShort: defaultLocaleMonthsShort,
                week: defaultLocaleWeek,
                weekdays: defaultLocaleWeekdays,
                weekdaysMin: defaultLocaleWeekdaysMin,
                weekdaysShort: defaultLocaleWeekdaysShort,
                meridiemParse: defaultLocaleMeridiemParse
            },
            locales = {},
            localeFamilies = {},
            extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
            tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
            isoDates = [
                ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
                ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
                ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
                ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
                ["YYYY-DDD", /\d{4}-\d{3}/],
                ["YYYY-MM", /\d{4}-\d\d/, !1],
                ["YYYYYYMMDD", /[+-]\d{10}/],
                ["YYYYMMDD", /\d{8}/],
                ["GGGG[W]WWE", /\d{4}W\d{3}/],
                ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
                ["YYYYDDD", /\d{7}/]
            ],
            isoTimes = [
                ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
                ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
                ["HH:mm:ss", /\d\d:\d\d:\d\d/],
                ["HH:mm", /\d\d:\d\d/],
                ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
                ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
                ["HHmmss", /\d\d\d\d\d\d/],
                ["HHmm", /\d\d\d\d/],
                ["HH", /\d\d/]
            ],
            aspNetJsonRegex = /^\/?Date\((\-?\d+)/i,
            rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
            obsOffsets = {
                UT: 0,
                GMT: 0,
                EDT: -240,
                EST: -300,
                CDT: -300,
                CST: -360,
                MDT: -360,
                MST: -420,
                PDT: -420,
                PST: -480
            };
        hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged and will be removed in an upcoming major release. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", function(config) {
            config._d = new Date(config._i + (config._useUTC ? " UTC" : ""))
        }), hooks.ISO_8601 = function() {}, hooks.RFC_2822 = function() {};
        var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
                var other = createLocal.apply(null, arguments);
                return this.isValid() && other.isValid() ? other < this ? this : other : createInvalid()
            }),
            prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", function() {
                var other = createLocal.apply(null, arguments);
                return this.isValid() && other.isValid() ? other > this ? this : other : createInvalid()
            }),
            now = function() {
                return Date.now ? Date.now() : +new Date
            },
            ordering = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];
        offset("Z", ":"), offset("ZZ", ""), addRegexToken("Z", matchShortOffset), addRegexToken("ZZ", matchShortOffset), addParseToken(["Z", "ZZ"], function(input, array, config) {
            config._useUTC = !0, config._tzm = offsetFromString(matchShortOffset, input)
        });
        var chunkOffset = /([\+\-]|\d\d)/gi;
        hooks.updateOffset = function() {};
        var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/,
            isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
        createDuration.fn = Duration.prototype, createDuration.invalid = createInvalid$1;
        var add = createAdder(1, "add"),
            subtract = createAdder(-1, "subtract");
        hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
        var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function(key) {
            return void 0 === key ? this.localeData() : this.locale(key)
        });
        addFormatToken(0, ["gg", 2], 0, function() {
            return this.weekYear() % 100
        }), addFormatToken(0, ["GG", 2], 0, function() {
            return this.isoWeekYear() % 100
        }), addWeekYearFormatToken("gggg", "weekYear"), addWeekYearFormatToken("ggggg", "weekYear"), addWeekYearFormatToken("GGGG", "isoWeekYear"), addWeekYearFormatToken("GGGGG", "isoWeekYear"), addUnitAlias("weekYear", "gg"), addUnitAlias("isoWeekYear", "GG"), addUnitPriority("weekYear", 1), addUnitPriority("isoWeekYear", 1), addRegexToken("G", matchSigned), addRegexToken("g", matchSigned), addRegexToken("GG", match1to2, match2), addRegexToken("gg", match1to2, match2), addRegexToken("GGGG", match1to4, match4), addRegexToken("gggg", match1to4, match4), addRegexToken("GGGGG", match1to6, match6), addRegexToken("ggggg", match1to6, match6), addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], function(input, week, config, token) {
            week[token.substr(0, 2)] = toInt(input)
        }), addWeekParseToken(["gg", "GG"], function(input, week, config, token) {
            week[token] = hooks.parseTwoDigitYear(input)
        }), addFormatToken("Q", 0, "Qo", "quarter"), addUnitAlias("quarter", "Q"), addUnitPriority("quarter", 7), addRegexToken("Q", match1), addParseToken("Q", function(input, array) {
            array[MONTH] = 3 * (toInt(input) - 1)
        }), addFormatToken("D", ["DD", 2], "Do", "date"), addUnitAlias("date", "D"), addUnitPriority("date", 9), addRegexToken("D", match1to2), addRegexToken("DD", match1to2, match2), addRegexToken("Do", function(isStrict, locale) {
            return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient
        }), addParseToken(["D", "DD"], DATE), addParseToken("Do", function(input, array) {
            array[DATE] = toInt(input.match(match1to2)[0], 10)
        });
        var getSetDayOfMonth = makeGetSet("Date", !0);
        addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), addUnitAlias("dayOfYear", "DDD"), addUnitPriority("dayOfYear", 4), addRegexToken("DDD", match1to3), addRegexToken("DDDD", match3), addParseToken(["DDD", "DDDD"], function(input, array, config) {
            config._dayOfYear = toInt(input)
        }), addFormatToken("m", ["mm", 2], 0, "minute"), addUnitAlias("minute", "m"), addUnitPriority("minute", 14), addRegexToken("m", match1to2), addRegexToken("mm", match1to2, match2), addParseToken(["m", "mm"], MINUTE);
        var getSetMinute = makeGetSet("Minutes", !1);
        addFormatToken("s", ["ss", 2], 0, "second"), addUnitAlias("second", "s"), addUnitPriority("second", 15), addRegexToken("s", match1to2), addRegexToken("ss", match1to2, match2), addParseToken(["s", "ss"], SECOND);
        var getSetSecond = makeGetSet("Seconds", !1);
        addFormatToken("S", 0, 0, function() {
            return ~~(this.millisecond() / 100)
        }), addFormatToken(0, ["SS", 2], 0, function() {
            return ~~(this.millisecond() / 10)
        }), addFormatToken(0, ["SSS", 3], 0, "millisecond"), addFormatToken(0, ["SSSS", 4], 0, function() {
            return 10 * this.millisecond()
        }), addFormatToken(0, ["SSSSS", 5], 0, function() {
            return 100 * this.millisecond()
        }), addFormatToken(0, ["SSSSSS", 6], 0, function() {
            return 1e3 * this.millisecond()
        }), addFormatToken(0, ["SSSSSSS", 7], 0, function() {
            return 1e4 * this.millisecond()
        }), addFormatToken(0, ["SSSSSSSS", 8], 0, function() {
            return 1e5 * this.millisecond()
        }), addFormatToken(0, ["SSSSSSSSS", 9], 0, function() {
            return 1e6 * this.millisecond()
        }), addUnitAlias("millisecond", "ms"), addUnitPriority("millisecond", 16), addRegexToken("S", match1to3, match1), addRegexToken("SS", match1to3, match2), addRegexToken("SSS", match1to3, match3);
        var token;
        for (token = "SSSS"; token.length <= 9; token += "S") addRegexToken(token, matchUnsigned);
        for (token = "S"; token.length <= 9; token += "S") addParseToken(token, parseMs);
        var getSetMillisecond = makeGetSet("Milliseconds", !1);
        addFormatToken("z", 0, 0, "zoneAbbr"), addFormatToken("zz", 0, 0, "zoneName");
        var proto = Moment.prototype;
        proto.add = add, proto.calendar = calendar$1, proto.clone = clone, proto.diff = diff, proto.endOf = endOf, proto.format = format, proto.from = from, proto.fromNow = fromNow, proto.to = to, proto.toNow = toNow, proto.get = stringGet, proto.invalidAt = invalidAt, proto.isAfter = isAfter, proto.isBefore = isBefore, proto.isBetween = isBetween, proto.isSame = isSame, proto.isSameOrAfter = isSameOrAfter, proto.isSameOrBefore = isSameOrBefore, proto.isValid = isValid$2, proto.lang = lang, proto.locale = locale, proto.localeData = localeData, proto.max = prototypeMax, proto.min = prototypeMin, proto.parsingFlags = parsingFlags, proto.set = stringSet, proto.startOf = startOf, proto.subtract = subtract, proto.toArray = toArray, proto.toObject = toObject, proto.toDate = toDate, proto.toISOString = toISOString, proto.inspect = inspect, proto.toJSON = toJSON, proto.toString = toString, proto.unix = unix, proto.valueOf = valueOf, proto.creationData = creationData, proto.year = getSetYear, proto.isLeapYear = getIsLeapYear, proto.weekYear = getSetWeekYear, proto.isoWeekYear = getSetISOWeekYear, proto.quarter = proto.quarters = getSetQuarter, proto.month = getSetMonth, proto.daysInMonth = getDaysInMonth, proto.week = proto.weeks = getSetWeek, proto.isoWeek = proto.isoWeeks = getSetISOWeek, proto.weeksInYear = getWeeksInYear, proto.isoWeeksInYear = getISOWeeksInYear, proto.date = getSetDayOfMonth, proto.day = proto.days = getSetDayOfWeek, proto.weekday = getSetLocaleDayOfWeek, proto.isoWeekday = getSetISODayOfWeek, proto.dayOfYear = getSetDayOfYear, proto.hour = proto.hours = getSetHour, proto.minute = proto.minutes = getSetMinute, proto.second = proto.seconds = getSetSecond, proto.millisecond = proto.milliseconds = getSetMillisecond, proto.utcOffset = getSetOffset, proto.utc = setOffsetToUTC, proto.local = setOffsetToLocal, proto.parseZone = setOffsetToParsedOffset, proto.hasAlignedHourOffset = hasAlignedHourOffset, proto.isDST = isDaylightSavingTime, proto.isLocal = isLocal, proto.isUtcOffset = isUtcOffset, proto.isUtc = isUtc, proto.isUTC = isUtc, proto.zoneAbbr = getZoneAbbr, proto.zoneName = getZoneName, proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth), proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth), proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear), proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone), proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
        var proto$1 = Locale.prototype;
        proto$1.calendar = calendar, proto$1.longDateFormat = longDateFormat, proto$1.invalidDate = invalidDate, proto$1.ordinal = ordinal, proto$1.preparse = preParsePostFormat, proto$1.postformat = preParsePostFormat, proto$1.relativeTime = relativeTime, proto$1.pastFuture = pastFuture, proto$1.set = set, proto$1.months = localeMonths, proto$1.monthsShort = localeMonthsShort, proto$1.monthsParse = localeMonthsParse, proto$1.monthsRegex = monthsRegex, proto$1.monthsShortRegex = monthsShortRegex, proto$1.week = localeWeek, proto$1.firstDayOfYear = localeFirstDayOfYear, proto$1.firstDayOfWeek = localeFirstDayOfWeek, proto$1.weekdays = localeWeekdays, proto$1.weekdaysMin = localeWeekdaysMin, proto$1.weekdaysShort = localeWeekdaysShort, proto$1.weekdaysParse = localeWeekdaysParse, proto$1.weekdaysRegex = weekdaysRegex, proto$1.weekdaysShortRegex = weekdaysShortRegex, proto$1.weekdaysMinRegex = weekdaysMinRegex, proto$1.isPM = localeIsPM, proto$1.meridiem = localeMeridiem, getSetGlobalLocale("en", {
            dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
            ordinal: function(number) {
                var b = number % 10,
                    output = 1 === toInt(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th";
                return number + output
            }
        }), hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale), hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
        var mathAbs = Math.abs,
            asMilliseconds = makeAs("ms"),
            asSeconds = makeAs("s"),
            asMinutes = makeAs("m"),
            asHours = makeAs("h"),
            asDays = makeAs("d"),
            asWeeks = makeAs("w"),
            asMonths = makeAs("M"),
            asYears = makeAs("y"),
            milliseconds = makeGetter("milliseconds"),
            seconds = makeGetter("seconds"),
            minutes = makeGetter("minutes"),
            hours = makeGetter("hours"),
            days = makeGetter("days"),
            months = makeGetter("months"),
            years = makeGetter("years"),
            round = Math.round,
            thresholds = {
                ss: 44,
                s: 45,
                m: 45,
                h: 22,
                d: 26,
                M: 11
            },
            abs$1 = Math.abs,
            proto$2 = Duration.prototype;
        return proto$2.isValid = isValid$1, proto$2.abs = abs, proto$2.add = add$1, proto$2.subtract = subtract$1, proto$2.as = as, proto$2.asMilliseconds = asMilliseconds, proto$2.asSeconds = asSeconds, proto$2.asMinutes = asMinutes, proto$2.asHours = asHours, proto$2.asDays = asDays, proto$2.asWeeks = asWeeks, proto$2.asMonths = asMonths, proto$2.asYears = asYears, proto$2.valueOf = valueOf$1, proto$2._bubble = bubble, proto$2.clone = clone$1, proto$2.get = get$2, proto$2.milliseconds = milliseconds, proto$2.seconds = seconds, proto$2.minutes = minutes, proto$2.hours = hours, proto$2.days = days, proto$2.weeks = weeks, proto$2.months = months, proto$2.years = years, proto$2.humanize = humanize, proto$2.toISOString = toISOString$1, proto$2.toString = toISOString$1, proto$2.toJSON = toISOString$1, proto$2.locale = locale, proto$2.localeData = localeData, proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1), proto$2.lang = lang, addFormatToken("X", 0, 0, "unix"), addFormatToken("x", 0, 0, "valueOf"), addRegexToken("x", matchSigned), addRegexToken("X", matchTimestamp), addParseToken("X", function(input, array, config) {
            config._d = new Date(1e3 * parseFloat(input, 10))
        }), addParseToken("x", function(input, array, config) {
            config._d = new Date(toInt(input))
        }), hooks.version = "2.19.3", setHookCallback(createLocal), hooks.fn = proto, hooks.min = min, hooks.max = max, hooks.now = now, hooks.utc = createUTC, hooks.unix = createUnix, hooks.months = listMonths, hooks.isDate = isDate, hooks.locale = getSetGlobalLocale, hooks.invalid = createInvalid, hooks.duration = createDuration, hooks.isMoment = isMoment, hooks.weekdays = listWeekdays, hooks.parseZone = createInZone, hooks.localeData = getLocale, hooks.isDuration = isDuration, hooks.monthsShort = listMonthsShort, hooks.weekdaysMin = listWeekdaysMin, hooks.defineLocale = defineLocale, hooks.updateLocale = updateLocale, hooks.locales = listLocales, hooks.weekdaysShort = listWeekdaysShort, hooks.normalizeUnits = normalizeUnits, hooks.relativeTimeRounding = getSetRelativeTimeRounding, hooks.relativeTimeThreshold = getSetRelativeTimeThreshold, hooks.calendarFormat = getCalendarFormat, hooks.prototype = proto, hooks
    });
var _gsScope = "undefined" != typeof module && module.exports && "undefined" != typeof global ? global : this || window;
(_gsScope._gsQueue || (_gsScope._gsQueue = [])).push(function() {
        "use strict";
        var _doc = (_gsScope.document || {}).documentElement,
            _window = _gsScope,
            _max = function(element, axis) {
                var dim = "x" === axis ? "Width" : "Height",
                    scroll = "scroll" + dim,
                    client = "client" + dim,
                    body = document.body;
                return element === _window || element === _doc || element === body ? Math.max(_doc[scroll], body[scroll]) - (_window["inner" + dim] || _doc[client] || body[client]) : element[scroll] - element["offset" + dim]
            },
            _unwrapElement = function(value) {
                return "string" == typeof value && (value = TweenLite.selector(value)), value.length && value !== _window && value[0] && value[0].style && !value.nodeType && (value = value[0]), value === _window || value.nodeType && value.style ? value : null
            },
            _buildGetter = function(e, axis) {
                var p = "scroll" + ("x" === axis ? "Left" : "Top");
                return e === _window && (null != e.pageXOffset ? p = "page" + axis.toUpperCase() + "Offset" : e = null != _doc[p] ? _doc : document.body),
                    function() {
                        return e[p]
                    }
            },
            _getOffset = function(element, container) {
                var rect = _unwrapElement(element).getBoundingClientRect(),
                    isRoot = !container || container === _window || container === document.body,
                    cRect = (isRoot ? _doc : container).getBoundingClientRect(),
                    offsets = {
                        x: rect.left - cRect.left,
                        y: rect.top - cRect.top
                    };
                return !isRoot && container && (offsets.x += _buildGetter(container, "x")(), offsets.y += _buildGetter(container, "y")()), offsets
            },
            _parseVal = function(value, target, axis) {
                var type = _typeof2(value);
                return isNaN(value) ? "number" === type || "string" === type && "=" === value.charAt(1) ? value : "max" === value ? _max(target, axis) : Math.min(_max(target, axis), _getOffset(value, target)[axis]) : parseFloat(value)
            },
            ScrollToPlugin = _gsScope._gsDefine.plugin({
                propName: "scrollTo",
                API: 2,
                global: !0,
                version: "1.9.0",
                init: function(target, value, tween) {
                    return this._wdw = target === _window, this._target = target, this._tween = tween, "object" !== _typeof2(value) ? (value = {
                        y: value
                    }, "string" == typeof value.y && "max" !== value.y && "=" !== value.y.charAt(1) && (value.x = value.y)) : value.nodeType && (value = {
                        y: value,
                        x: value
                    }), this.vars = value, this._autoKill = value.autoKill !== !1, this.getX = _buildGetter(target, "x"), this.getY = _buildGetter(target, "y"), this.x = this.xPrev = this.getX(), this.y = this.yPrev = this.getY(), null != value.x ? (this._addTween(this, "x", this.x, _parseVal(value.x, target, "x") - (value.offsetX || 0), "scrollTo_x", !0), this._overwriteProps.push("scrollTo_x")) : this.skipX = !0, null != value.y ? (this._addTween(this, "y", this.y, _parseVal(value.y, target, "y") - (value.offsetY || 0), "scrollTo_y", !0), this._overwriteProps.push("scrollTo_y")) : this.skipY = !0, !0
                },
                set: function(v) {
                    this._super.setRatio.call(this, v);
                    var x = this._wdw || !this.skipX ? this.getX() : this.xPrev,
                        y = this._wdw || !this.skipY ? this.getY() : this.yPrev,
                        yDif = y - this.yPrev,
                        xDif = x - this.xPrev,
                        threshold = ScrollToPlugin.autoKillThreshold;
                    this.x < 0 && (this.x = 0), this.y < 0 && (this.y = 0), this._autoKill && (!this.skipX && (xDif > threshold || xDif < -threshold) && x < _max(this._target, "x") && (this.skipX = !0), !this.skipY && (yDif > threshold || yDif < -threshold) && y < _max(this._target, "y") && (this.skipY = !0), this.skipX && this.skipY && (this._tween.kill(), this.vars.onAutoKill && this.vars.onAutoKill.apply(this.vars.onAutoKillScope || this._tween, this.vars.onAutoKillParams || []))), this._wdw ? _window.scrollTo(this.skipX ? x : this.x, this.skipY ? y : this.y) : (this.skipY || (this._target.scrollTop = this.y), this.skipX || (this._target.scrollLeft = this.x)), this.xPrev = this.x, this.yPrev = this.y
                }
            }),
            p = ScrollToPlugin.prototype;
        ScrollToPlugin.max = _max, ScrollToPlugin.getOffset = _getOffset, ScrollToPlugin.buildGetter = _buildGetter, ScrollToPlugin.autoKillThreshold = 7, p._kill = function(lookup) {
            return lookup.scrollTo_x && (this.skipX = !0), lookup.scrollTo_y && (this.skipY = !0), this._super._kill.call(this, lookup)
        }
    }), _gsScope._gsDefine && _gsScope._gsQueue.pop()(),
    function(name) {
        "use strict";
        var getGlobal = function() {
            return (_gsScope.GreenSockGlobals || _gsScope)[name]
        };
        "undefined" != typeof module && module.exports ? (require("../TweenLite.js"), module.exports = getGlobal()) : "function" == typeof define && define.amd && define(["TweenLite"], getGlobal)
    }("ScrollToPlugin"),
    function(window, angular) {
        var isDefined = angular.isDefined,
            isUndefined = angular.isUndefined,
            isNumber = angular.isNumber,
            isObject = angular.isObject,
            isArray = angular.isArray,
            isString = angular.isString,
            extend = angular.extend,
            toJson = angular.toJson;
        angular.module("LocalStorageModule", []).provider("localStorageService", function() {
            this.prefix = "ls", this.storageType = "localStorage", this.cookie = {
                expiry: 30,
                path: "/",
                secure: !1
            }, this.defaultToCookie = !0, this.notify = {
                setItem: !0,
                removeItem: !1
            }, this.setPrefix = function(prefix) {
                return this.prefix = prefix, this
            }, this.setStorageType = function(storageType) {
                return this.storageType = storageType, this
            }, this.setDefaultToCookie = function(shouldDefault) {
                return this.defaultToCookie = !!shouldDefault, this
            }, this.setStorageCookie = function(exp, path, secure) {
                return this.cookie.expiry = exp, this.cookie.path = path, this.cookie.secure = secure, this
            }, this.setStorageCookieDomain = function(domain) {
                return this.cookie.domain = domain, this
            }, this.setNotify = function(itemSet, itemRemove) {
                return this.notify = {
                    setItem: itemSet,
                    removeItem: itemRemove
                }, this
            }, this.$get = ["$rootScope", "$window", "$document", "$parse", "$timeout", function($rootScope, $window, $document, $parse, $timeout) {
                function handleStorageChangeCallback(e) {
                    if (e || (e = $window.event), notify.setItem && isString(e.key) && isKeyPrefixOurs(e.key)) {
                        var key = underiveQualifiedKey(e.key);
                        $timeout(function() {
                            $rootScope.$broadcast("LocalStorageModule.notification.changed", {
                                key: key,
                                newvalue: e.newValue,
                                storageType: self.storageType
                            })
                        })
                    }
                }
                var webStorage, self = this,
                    prefix = self.prefix,
                    cookie = self.cookie,
                    notify = self.notify,
                    storageType = self.storageType;
                $document ? $document[0] && ($document = $document[0]) : $document = document, "." !== prefix.substr(-1) && (prefix = prefix ? prefix + "." : "");
                var deriveQualifiedKey = function(key) {
                        return prefix + key
                    },
                    underiveQualifiedKey = function(key) {
                        return key.replace(new RegExp("^" + prefix, "g"), "")
                    },
                    isKeyPrefixOurs = function(key) {
                        return 0 === key.indexOf(prefix)
                    },
                    checkSupport = function() {
                        try {
                            var supported = storageType in $window && null !== $window[storageType],
                                key = deriveQualifiedKey("__" + Math.round(1e7 * Math.random()));
                            return supported && (webStorage = $window[storageType], webStorage.setItem(key, ""), webStorage.removeItem(key)), supported
                        } catch (e) {
                            return self.defaultToCookie && (storageType = "cookie"), $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), !1
                        }
                    },
                    browserSupportsLocalStorage = checkSupport(),
                    addToLocalStorage = function(key, value, type) {
                        if (setStorageType(type), value = isUndefined(value) ? null : toJson(value), !browserSupportsLocalStorage && self.defaultToCookie || "cookie" === self.storageType) return browserSupportsLocalStorage || $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED"), notify.setItem && $rootScope.$broadcast("LocalStorageModule.notification.setitem", {
                            key: key,
                            newvalue: value,
                            storageType: "cookie"
                        }), addToCookies(key, value);
                        try {
                            webStorage && webStorage.setItem(deriveQualifiedKey(key), value), notify.setItem && $rootScope.$broadcast("LocalStorageModule.notification.setitem", {
                                key: key,
                                newvalue: value,
                                storageType: self.storageType
                            })
                        } catch (e) {
                            return $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), addToCookies(key, value)
                        }
                        return !0
                    },
                    getFromLocalStorage = function(key, type) {
                        if (setStorageType(type), !browserSupportsLocalStorage && self.defaultToCookie || "cookie" === self.storageType) return browserSupportsLocalStorage || $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED"), getFromCookies(key);
                        var item = webStorage ? webStorage.getItem(deriveQualifiedKey(key)) : null;
                        if (!item || "null" === item) return null;
                        try {
                            return JSON.parse(item)
                        } catch (e) {
                            return item
                        }
                    },
                    removeFromLocalStorage = function() {
                        var consumed = 0;
                        arguments.length >= 1 && ("localStorage" === arguments[arguments.length - 1] || "sessionStorage" === arguments[arguments.length - 1]) && (consumed = 1, setStorageType(arguments[arguments.length - 1]));
                        var i, key;
                        for (i = 0; i < arguments.length - consumed; i++)
                            if (key = arguments[i], !browserSupportsLocalStorage && self.defaultToCookie || "cookie" === self.storageType) browserSupportsLocalStorage || $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED"), notify.removeItem && $rootScope.$broadcast("LocalStorageModule.notification.removeitem", {
                                key: key,
                                storageType: "cookie"
                            }), removeFromCookies(key);
                            else try {
                                webStorage.removeItem(deriveQualifiedKey(key)), notify.removeItem && $rootScope.$broadcast("LocalStorageModule.notification.removeitem", {
                                    key: key,
                                    storageType: self.storageType
                                })
                            } catch (e) {
                                $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), removeFromCookies(key)
                            }
                    },
                    getKeysForLocalStorage = function(type) {
                        if (setStorageType(type), !browserSupportsLocalStorage) return $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED"), [];
                        var prefixLength = prefix.length,
                            keys = [];
                        for (var key in webStorage)
                            if (key.substr(0, prefixLength) === prefix) try {
                                keys.push(key.substr(prefixLength))
                            } catch (e) {
                                return $rootScope.$broadcast("LocalStorageModule.notification.error", e.Description), []
                            }
                        return keys
                    },
                    clearAllFromLocalStorage = function(regularExpression, type) {
                        setStorageType(type);
                        var prefixRegex = prefix ? new RegExp("^" + prefix) : new RegExp,
                            testRegex = regularExpression ? new RegExp(regularExpression) : new RegExp;
                        if (!browserSupportsLocalStorage && self.defaultToCookie || "cookie" === self.storageType) return browserSupportsLocalStorage || $rootScope.$broadcast("LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED"), clearAllFromCookies();
                        if (!browserSupportsLocalStorage && !self.defaultToCookie) return !1;
                        var prefixLength = prefix.length;
                        for (var key in webStorage)
                            if (prefixRegex.test(key) && testRegex.test(key.substr(prefixLength))) try {
                                removeFromLocalStorage(key.substr(prefixLength))
                            } catch (e) {
                                return $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), clearAllFromCookies()
                            }
                        return !0
                    },
                    browserSupportsCookies = function() {
                        try {
                            return $window.navigator.cookieEnabled || "cookie" in $document && ($document.cookie.length > 0 || ($document.cookie = "test").indexOf.call($document.cookie, "test") > -1)
                        } catch (e) {
                            return $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), !1
                        }
                    }(),
                    addToCookies = function(key, value, daysToExpiry, secure) {
                        if (isUndefined(value)) return !1;
                        if ((isArray(value) || isObject(value)) && (value = toJson(value)), !browserSupportsCookies) return $rootScope.$broadcast("LocalStorageModule.notification.error", "COOKIES_NOT_SUPPORTED"), !1;
                        try {
                            var expiry = "",
                                expiryDate = new Date,
                                cookieDomain = "";
                            if (null === value ? (expiryDate.setTime(expiryDate.getTime() + -864e5), expiry = "; expires=" + expiryDate.toGMTString(), value = "") : isNumber(daysToExpiry) && 0 !== daysToExpiry ? (expiryDate.setTime(expiryDate.getTime() + 24 * daysToExpiry * 60 * 60 * 1e3), expiry = "; expires=" + expiryDate.toGMTString()) : 0 !== cookie.expiry && (expiryDate.setTime(expiryDate.getTime() + 24 * cookie.expiry * 60 * 60 * 1e3), expiry = "; expires=" + expiryDate.toGMTString()), key) {
                                var cookiePath = "; path=" + cookie.path;
                                cookie.domain && (cookieDomain = "; domain=" + cookie.domain), "boolean" == typeof secure ? secure === !0 && (cookieDomain += "; secure") : cookie.secure === !0 && (cookieDomain += "; secure"), $document.cookie = deriveQualifiedKey(key) + "=" + encodeURIComponent(value) + expiry + cookiePath + cookieDomain
                            }
                        } catch (e) {
                            return $rootScope.$broadcast("LocalStorageModule.notification.error", e.message), !1
                        }
                        return !0
                    },
                    getFromCookies = function(key) {
                        if (!browserSupportsCookies) return $rootScope.$broadcast("LocalStorageModule.notification.error", "COOKIES_NOT_SUPPORTED"), !1;
                        for (var cookies = $document.cookie && $document.cookie.split(";") || [], i = 0; i < cookies.length; i++) {
                            for (var thisCookie = cookies[i];
                                " " === thisCookie.charAt(0);) thisCookie = thisCookie.substring(1, thisCookie.length);
                            if (0 === thisCookie.indexOf(deriveQualifiedKey(key) + "=")) {
                                var storedValues = decodeURIComponent(thisCookie.substring(prefix.length + key.length + 1, thisCookie.length));
                                try {
                                    var parsedValue = JSON.parse(storedValues);
                                    return "number" == typeof parsedValue ? storedValues : parsedValue
                                } catch (e) {
                                    return storedValues
                                }
                            }
                        }
                        return null
                    },
                    removeFromCookies = function(key) {
                        addToCookies(key, null)
                    },
                    clearAllFromCookies = function() {
                        for (var thisCookie = null, prefixLength = prefix.length, cookies = $document.cookie.split(";"), i = 0; i < cookies.length; i++) {
                            for (thisCookie = cookies[i];
                                " " === thisCookie.charAt(0);) thisCookie = thisCookie.substring(1, thisCookie.length);
                            var key = thisCookie.substring(prefixLength, thisCookie.indexOf("="));
                            removeFromCookies(key)
                        }
                    },
                    getStorageType = function() {
                        return storageType
                    },
                    setStorageType = function(type) {
                        return type && storageType !== type && (storageType = type, browserSupportsLocalStorage = checkSupport()), browserSupportsLocalStorage
                    },
                    bindToScope = function(scope, key, def, lsKey, type) {
                        lsKey = lsKey || key;
                        var value = getFromLocalStorage(lsKey, type);
                        return null === value && isDefined(def) ? value = def : isObject(value) && isObject(def) && (value = extend(value, def)), $parse(key).assign(scope, value), scope.$watch(key, function(newVal) {
                            addToLocalStorage(lsKey, newVal, type)
                        }, isObject(scope[key]))
                    };
                browserSupportsLocalStorage && ($window.addEventListener ? ($window.addEventListener("storage", handleStorageChangeCallback, !1), $rootScope.$on("$destroy", function() {
                    $window.removeEventListener("storage", handleStorageChangeCallback)
                })) : $window.attachEvent && ($window.attachEvent("onstorage", handleStorageChangeCallback), $rootScope.$on("$destroy", function() {
                    $window.detachEvent("onstorage", handleStorageChangeCallback)
                })));
                var lengthOfLocalStorage = function(type) {
                    setStorageType(type);
                    for (var count = 0, storage = $window[storageType], i = 0; i < storage.length; i++) 0 === storage.key(i).indexOf(prefix) && count++;
                    return count
                };
                return {
                    isSupported: browserSupportsLocalStorage,
                    getStorageType: getStorageType,
                    setStorageType: setStorageType,
                    set: addToLocalStorage,
                    add: addToLocalStorage,
                    get: getFromLocalStorage,
                    keys: getKeysForLocalStorage,
                    remove: removeFromLocalStorage,
                    clearAll: clearAllFromLocalStorage,
                    bind: bindToScope,
                    deriveKey: deriveQualifiedKey,
                    underiveKey: underiveQualifiedKey,
                    length: lengthOfLocalStorage,
                    defaultToCookie: this.defaultToCookie,
                    cookie: {
                        isSupported: browserSupportsCookies,
                        set: addToCookies,
                        add: addToCookies,
                        get: getFromCookies,
                        remove: removeFromCookies,
                        clearAll: clearAllFromCookies
                    }
                }
            }]
        })
    }(window, window.angular),
    function(f) {
        if ("object" === ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "undefined" != typeof module) module.exports = f();
        else if ("function" == typeof define && define.amd) define([], f);
        else {
            var g;
            g = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, g.Clipboard = f()
        }
    }(function() {
        var define;
        return function e(t, n, r) {
            function s(o, u) {
                if (!n[o]) {
                    if (!t[o]) {
                        var a = "function" == typeof require && require;
                        if (!u && a) return a(o, !0);
                        if (i) return i(o, !0);
                        var f = new Error("Cannot find module '" + o + "'");
                        throw f.code = "MODULE_NOT_FOUND", f
                    }
                    var l = n[o] = {
                        exports: {}
                    };
                    t[o][0].call(l.exports, function(e) {
                        var n = t[o][1][e];
                        return s(n ? n : e)
                    }, l, l.exports, e, t, n, r)
                }
                return n[o].exports
            }
            for (var i = "function" == typeof require && require, o = 0; o < r.length; o++) s(r[o]);
            return s
        }({
            1: [function(require, module, exports) {
                function closest(element, selector) {
                    for (; element && element.nodeType !== DOCUMENT_NODE_TYPE;) {
                        if (element.matches(selector)) return element;
                        element = element.parentNode
                    }
                }
                var DOCUMENT_NODE_TYPE = 9;
                if (Element && !Element.prototype.matches) {
                    var proto = Element.prototype;
                    proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector
                }
                module.exports = closest
            }, {}],
            2: [function(require, module, exports) {
                function delegate(element, selector, type, callback, useCapture) {
                    var listenerFn = listener.apply(this, arguments);
                    return element.addEventListener(type, listenerFn, useCapture), {
                        destroy: function() {
                            element.removeEventListener(type, listenerFn, useCapture)
                        }
                    }
                }

                function listener(element, selector, type, callback) {
                    return function(e) {
                        e.delegateTarget = closest(e.target, selector), e.delegateTarget && callback.call(element, e)
                    }
                }
                var closest = require("./closest");
                module.exports = delegate
            }, {
                "./closest": 1
            }],
            3: [function(require, module, exports) {
                exports.node = function(value) {
                    return void 0 !== value && value instanceof HTMLElement && 1 === value.nodeType
                }, exports.nodeList = function(value) {
                    var type = Object.prototype.toString.call(value);
                    return void 0 !== value && ("[object NodeList]" === type || "[object HTMLCollection]" === type) && "length" in value && (0 === value.length || exports.node(value[0]))
                }, exports.string = function(value) {
                    return "string" == typeof value || value instanceof String
                }, exports.fn = function(value) {
                    var type = Object.prototype.toString.call(value);
                    return "[object Function]" === type
                }
            }, {}],
            4: [function(require, module, exports) {
                function listen(target, type, callback) {
                    if (!target && !type && !callback) throw new Error("Missing required arguments");
                    if (!is.string(type)) throw new TypeError("Second argument must be a String");
                    if (!is.fn(callback)) throw new TypeError("Third argument must be a Function");
                    if (is.node(target)) return listenNode(target, type, callback);
                    if (is.nodeList(target)) return listenNodeList(target, type, callback);
                    if (is.string(target)) return listenSelector(target, type, callback);
                    throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList")
                }

                function listenNode(node, type, callback) {
                    return node.addEventListener(type, callback), {
                        destroy: function() {
                            node.removeEventListener(type, callback)
                        }
                    }
                }

                function listenNodeList(nodeList, type, callback) {
                    return Array.prototype.forEach.call(nodeList, function(node) {
                        node.addEventListener(type, callback)
                    }), {
                        destroy: function() {
                            Array.prototype.forEach.call(nodeList, function(node) {
                                node.removeEventListener(type, callback)
                            })
                        }
                    }
                }

                function listenSelector(selector, type, callback) {
                    return delegate(document.body, selector, type, callback)
                }
                var is = require("./is"),
                    delegate = require("delegate");
                module.exports = listen
            }, {
                "./is": 3,
                delegate: 2
            }],
            5: [function(require, module, exports) {
                function select(element) {
                    var selectedText;
                    if ("SELECT" === element.nodeName) element.focus(), selectedText = element.value;
                    else if ("INPUT" === element.nodeName || "TEXTAREA" === element.nodeName) element.focus(), element.setSelectionRange(0, element.value.length), selectedText = element.value;
                    else {
                        element.hasAttribute("contenteditable") && element.focus();
                        var selection = window.getSelection(),
                            range = document.createRange();
                        range.selectNodeContents(element), selection.removeAllRanges(), selection.addRange(range), selectedText = selection.toString()
                    }
                    return selectedText
                }
                module.exports = select
            }, {}],
            6: [function(require, module, exports) {
                function E() {}
                E.prototype = {
                    on: function(name, callback, ctx) {
                        var e = this.e || (this.e = {});
                        return (e[name] || (e[name] = [])).push({
                            fn: callback,
                            ctx: ctx
                        }), this
                    },
                    once: function(name, callback, ctx) {
                        function listener() {
                            self.off(name, listener), callback.apply(ctx, arguments)
                        }
                        var self = this;
                        return listener._ = callback, this.on(name, listener, ctx)
                    },
                    emit: function(name) {
                        var data = [].slice.call(arguments, 1),
                            evtArr = ((this.e || (this.e = {}))[name] || []).slice(),
                            i = 0,
                            len = evtArr.length;
                        for (i; i < len; i++) evtArr[i].fn.apply(evtArr[i].ctx, data);
                        return this
                    },
                    off: function(name, callback) {
                        var e = this.e || (this.e = {}),
                            evts = e[name],
                            liveEvents = [];
                        if (evts && callback)
                            for (var i = 0, len = evts.length; i < len; i++) evts[i].fn !== callback && evts[i].fn._ !== callback && liveEvents.push(evts[i]);
                        return liveEvents.length ? e[name] = liveEvents : delete e[name], this
                    }
                }, module.exports = E
            }, {}],
            7: [function(require, module, exports) {
                ! function(global, factory) {
                    if ("function" == typeof define && define.amd) define(["module", "select"], factory);
                    else if ("undefined" != typeof exports) factory(module, require("select"));
                    else {
                        var mod = {
                            exports: {}
                        };
                        factory(mod, global.select), global.clipboardAction = mod.exports
                    }
                }(this, function(module, _select) {
                    "use strict";

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {
                            default: obj
                        }
                    }

                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
                    }
                    var _select2 = _interopRequireDefault(_select),
                        _typeof = "function" == typeof Symbol && "symbol" === _typeof2(Symbol.iterator) ? function(obj) {
                            return _typeof2(obj)
                        } : function(obj) {
                            return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof2(obj)
                        },
                        _createClass = function() {
                            function defineProperties(target, props) {
                                for (var i = 0; i < props.length; i++) {
                                    var descriptor = props[i];
                                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
                                }
                            }
                            return function(Constructor, protoProps, staticProps) {
                                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor
                            }
                        }(),
                        ClipboardAction = function() {
                            function ClipboardAction(options) {
                                _classCallCheck(this, ClipboardAction), this.resolveOptions(options), this.initSelection()
                            }
                            return _createClass(ClipboardAction, [{
                                key: "resolveOptions",
                                value: function() {
                                    var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                                    this.action = options.action, this.emitter = options.emitter, this.target = options.target, this.text = options.text, this.trigger = options.trigger, this.selectedText = ""
                                }
                            }, {
                                key: "initSelection",
                                value: function() {
                                    this.text ? this.selectFake() : this.target && this.selectTarget()
                                }
                            }, {
                                key: "selectFake",
                                value: function() {
                                    var _this = this,
                                        isRTL = "rtl" == document.documentElement.getAttribute("dir");
                                    this.removeFake(), this.fakeHandlerCallback = function() {
                                        return _this.removeFake()
                                    }, this.fakeHandler = document.body.addEventListener("click", this.fakeHandlerCallback) || !0, this.fakeElem = document.createElement("textarea"), this.fakeElem.style.fontSize = "12pt", this.fakeElem.style.border = "0", this.fakeElem.style.padding = "0", this.fakeElem.style.margin = "0", this.fakeElem.style.position = "absolute", this.fakeElem.style[isRTL ? "right" : "left"] = "-9999px";
                                    var yPosition = window.pageYOffset || document.documentElement.scrollTop;
                                    this.fakeElem.addEventListener("focus", window.scrollTo(0, yPosition)), this.fakeElem.style.top = yPosition + "px", this.fakeElem.setAttribute("readonly", ""), this.fakeElem.value = this.text, document.body.appendChild(this.fakeElem), this.selectedText = (0, _select2.default)(this.fakeElem), this.copyText()
                                }
                            }, {
                                key: "removeFake",
                                value: function() {
                                    this.fakeHandler && (document.body.removeEventListener("click", this.fakeHandlerCallback), this.fakeHandler = null, this.fakeHandlerCallback = null), this.fakeElem && (document.body.removeChild(this.fakeElem), this.fakeElem = null)
                                }
                            }, {
                                key: "selectTarget",
                                value: function() {
                                    this.selectedText = (0, _select2.default)(this.target), this.copyText()
                                }
                            }, {
                                key: "copyText",
                                value: function() {
                                    var succeeded = void 0;
                                    try {
                                        succeeded = document.execCommand(this.action)
                                    } catch (err) {
                                        succeeded = !1
                                    }
                                    this.handleResult(succeeded)
                                }
                            }, {
                                key: "handleResult",
                                value: function(succeeded) {
                                    this.emitter.emit(succeeded ? "success" : "error", {
                                        action: this.action,
                                        text: this.selectedText,
                                        trigger: this.trigger,
                                        clearSelection: this.clearSelection.bind(this)
                                    })
                                }
                            }, {
                                key: "clearSelection",
                                value: function() {
                                    this.target && this.target.blur(), window.getSelection().removeAllRanges()
                                }
                            }, {
                                key: "destroy",
                                value: function() {
                                    this.removeFake()
                                }
                            }, {
                                key: "action",
                                set: function() {
                                    var action = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "copy";
                                    if (this._action = action, "copy" !== this._action && "cut" !== this._action) throw new Error('Invalid "action" value, use either "copy" or "cut"')
                                },
                                get: function() {
                                    return this._action
                                }
                            }, {
                                key: "target",
                                set: function(target) {
                                    if (void 0 !== target) {
                                        if (!target || "object" !== ("undefined" == typeof target ? "undefined" : _typeof(target)) || 1 !== target.nodeType) throw new Error('Invalid "target" value, use a valid Element');
                                        if ("copy" === this.action && target.hasAttribute("disabled")) throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                                        if ("cut" === this.action && (target.hasAttribute("readonly") || target.hasAttribute("disabled"))) throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');
                                        this._target = target
                                    }
                                },
                                get: function() {
                                    return this._target
                                }
                            }]), ClipboardAction
                        }();
                    module.exports = ClipboardAction
                })
            }, {
                select: 5
            }],
            8: [function(require, module, exports) {
                ! function(global, factory) {
                    if ("function" == typeof define && define.amd) define(["module", "./clipboard-action", "tiny-emitter", "good-listener"], factory);
                    else if ("undefined" != typeof exports) factory(module, require("./clipboard-action"), require("tiny-emitter"), require("good-listener"));
                    else {
                        var mod = {
                            exports: {}
                        };
                        factory(mod, global.clipboardAction, global.tinyEmitter, global.goodListener), global.clipboard = mod.exports
                    }
                }(this, function(module, _clipboardAction, _tinyEmitter, _goodListener) {
                    "use strict";

                    function _interopRequireDefault(obj) {
                        return obj && obj.__esModule ? obj : {
                            default: obj
                        }
                    }

                    function _classCallCheck(instance, Constructor) {
                        if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
                    }

                    function _possibleConstructorReturn(self, call) {
                        if (!self) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return !call || "object" !== _typeof2(call) && "function" != typeof call ? self : call
                    }

                    function _inherits(subClass, superClass) {
                        if ("function" != typeof superClass && null !== superClass) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(superClass));
                        subClass.prototype = Object.create(superClass && superClass.prototype, {
                            constructor: {
                                value: subClass,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        }), superClass && (Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass)
                    }

                    function getAttributeValue(suffix, element) {
                        var attribute = "data-clipboard-" + suffix;
                        if (element.hasAttribute(attribute)) return element.getAttribute(attribute)
                    }
                    var _clipboardAction2 = _interopRequireDefault(_clipboardAction),
                        _tinyEmitter2 = _interopRequireDefault(_tinyEmitter),
                        _goodListener2 = _interopRequireDefault(_goodListener),
                        _createClass = function() {
                            function defineProperties(target, props) {
                                for (var i = 0; i < props.length; i++) {
                                    var descriptor = props[i];
                                    descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
                                }
                            }
                            return function(Constructor, protoProps, staticProps) {
                                return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor
                            }
                        }(),
                        Clipboard = function(_Emitter) {
                            function Clipboard(trigger, options) {
                                _classCallCheck(this, Clipboard);
                                var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this));
                                return _this.resolveOptions(options), _this.listenClick(trigger), _this
                            }
                            return _inherits(Clipboard, _Emitter), _createClass(Clipboard, [{
                                key: "resolveOptions",
                                value: function() {
                                    var options = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                                    this.action = "function" == typeof options.action ? options.action : this.defaultAction, this.target = "function" == typeof options.target ? options.target : this.defaultTarget, this.text = "function" == typeof options.text ? options.text : this.defaultText
                                }
                            }, {
                                key: "listenClick",
                                value: function(trigger) {
                                    var _this2 = this;
                                    this.listener = (0, _goodListener2.default)(trigger, "click", function(e) {
                                        return _this2.onClick(e)
                                    })
                                }
                            }, {
                                key: "onClick",
                                value: function(e) {
                                    var trigger = e.delegateTarget || e.currentTarget;
                                    this.clipboardAction && (this.clipboardAction = null), this.clipboardAction = new _clipboardAction2.default({
                                        action: this.action(trigger),
                                        target: this.target(trigger),
                                        text: this.text(trigger),
                                        trigger: trigger,
                                        emitter: this
                                    })
                                }
                            }, {
                                key: "defaultAction",
                                value: function(trigger) {
                                    return getAttributeValue("action", trigger)
                                }
                            }, {
                                key: "defaultTarget",
                                value: function(trigger) {
                                    var selector = getAttributeValue("target", trigger);
                                    if (selector) return document.querySelector(selector)
                                }
                            }, {
                                key: "defaultText",
                                value: function(trigger) {
                                    return getAttributeValue("text", trigger)
                                }
                            }, {
                                key: "destroy",
                                value: function() {
                                    this.listener.destroy(), this.clipboardAction && (this.clipboardAction.destroy(), this.clipboardAction = null)
                                }
                            }]), Clipboard
                        }(_tinyEmitter2.default);
                    module.exports = Clipboard
                })
            }, {
                "./clipboard-action": 7,
                "good-listener": 4,
                "tiny-emitter": 6
            }]
        }, {}, [8])(8)
    }),
    function(global, factory) {
        "object" === ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "undefined" != typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define(factory) : global.CodeMirror = factory()
    }(this, function() {
        "use strict";

        function classTest(cls) {
            return new RegExp("(^|\\s)" + cls + "(?:$|\\s)\\s*")
        }

        function removeChildren(e) {
            for (var count = e.childNodes.length; count > 0; --count) e.removeChild(e.firstChild);
            return e
        }

        function removeChildrenAndAdd(parent, e) {
            return removeChildren(parent).appendChild(e)
        }

        function elt(tag, content, className, style) {
            var e = document.createElement(tag);
            if (className && (e.className = className), style && (e.style.cssText = style), "string" == typeof content) e.appendChild(document.createTextNode(content));
            else if (content)
                for (var i = 0; i < content.length; ++i) e.appendChild(content[i]);
            return e
        }

        function eltP(tag, content, className, style) {
            var e = elt(tag, content, className, style);
            return e.setAttribute("role", "presentation"), e
        }

        function contains(parent, child) {
            if (3 == child.nodeType && (child = child.parentNode), parent.contains) return parent.contains(child);
            do
                if (11 == child.nodeType && (child = child.host), child == parent) return !0; while (child = child.parentNode)
        }

        function activeElt() {
            var activeElement;
            try {
                activeElement = document.activeElement
            } catch (e) {
                activeElement = document.body || null
            }
            for (; activeElement && activeElement.shadowRoot && activeElement.shadowRoot.activeElement;) activeElement = activeElement.shadowRoot.activeElement;
            return activeElement
        }

        function addClass(node, cls) {
            var current = node.className;
            classTest(cls).test(current) || (node.className += (current ? " " : "") + cls)
        }

        function joinClasses(a, b) {
            for (var as = a.split(" "), i = 0; i < as.length; i++) as[i] && !classTest(as[i]).test(b) && (b += " " + as[i]);
            return b
        }

        function bind(f) {
            var args = Array.prototype.slice.call(arguments, 1);
            return function() {
                return f.apply(null, args)
            }
        }

        function copyObj(obj, target, overwrite) {
            target || (target = {});
            for (var prop in obj) !obj.hasOwnProperty(prop) || overwrite === !1 && target.hasOwnProperty(prop) || (target[prop] = obj[prop]);
            return target
        }

        function countColumn(string, end, tabSize, startIndex, startValue) {
            null == end && (end = string.search(/[^\s\u00a0]/), end == -1 && (end = string.length));
            for (var i = startIndex || 0, n = startValue || 0;;) {
                var nextTab = string.indexOf("\t", i);
                if (nextTab < 0 || nextTab >= end) return n + (end - i);
                n += nextTab - i, n += tabSize - n % tabSize, i = nextTab + 1
            }
        }

        function indexOf(array, elt) {
            for (var i = 0; i < array.length; ++i)
                if (array[i] == elt) return i;
            return -1
        }

        function findColumn(string, goal, tabSize) {
            for (var pos = 0, col = 0;;) {
                var nextTab = string.indexOf("\t", pos);
                nextTab == -1 && (nextTab = string.length);
                var skipped = nextTab - pos;
                if (nextTab == string.length || col + skipped >= goal) return pos + Math.min(skipped, goal - col);
                if (col += nextTab - pos, col += tabSize - col % tabSize, pos = nextTab + 1, col >= goal) return pos
            }
        }

        function spaceStr(n) {
            for (; spaceStrs.length <= n;) spaceStrs.push(lst(spaceStrs) + " ");
            return spaceStrs[n]
        }

        function lst(arr) {
            return arr[arr.length - 1]
        }

        function map(array, f) {
            for (var out = [], i = 0; i < array.length; i++) out[i] = f(array[i], i);
            return out
        }

        function insertSorted(array, value, score) {
            for (var pos = 0, priority = score(value); pos < array.length && score(array[pos]) <= priority;) pos++;
            array.splice(pos, 0, value)
        }

        function nothing() {}

        function createObj(base, props) {
            var inst;
            return Object.create ? inst = Object.create(base) : (nothing.prototype = base, inst = new nothing), props && copyObj(props, inst), inst
        }

        function isWordCharBasic(ch) {
            return /\w/.test(ch) || ch > "" && (ch.toUpperCase() != ch.toLowerCase() || nonASCIISingleCaseWordChar.test(ch))
        }

        function isWordChar(ch, helper) {
            return helper ? !!(helper.source.indexOf("\\w") > -1 && isWordCharBasic(ch)) || helper.test(ch) : isWordCharBasic(ch)
        }

        function isEmpty(obj) {
            for (var n in obj)
                if (obj.hasOwnProperty(n) && obj[n]) return !1;
            return !0
        }

        function isExtendingChar(ch) {
            return ch.charCodeAt(0) >= 768 && extendingChars.test(ch)
        }

        function skipExtendingChars(str, pos, dir) {
            for (;
                (dir < 0 ? pos > 0 : pos < str.length) && isExtendingChar(str.charAt(pos));) pos += dir;
            return pos
        }

        function findFirst(pred, from, to) {
            for (var dir = from > to ? -1 : 1;;) {
                if (from == to) return from;
                var midF = (from + to) / 2,
                    mid = dir < 0 ? Math.ceil(midF) : Math.floor(midF);
                if (mid == from) return pred(mid) ? from : to;
                pred(mid) ? to = mid : from = mid + dir
            }
        }

        function Display(place, doc, input) {
            var d = this;
            this.input = input, d.scrollbarFiller = elt("div", null, "CodeMirror-scrollbar-filler"), d.scrollbarFiller.setAttribute("cm-not-content", "true"), d.gutterFiller = elt("div", null, "CodeMirror-gutter-filler"), d.gutterFiller.setAttribute("cm-not-content", "true"), d.lineDiv = eltP("div", null, "CodeMirror-code"), d.selectionDiv = elt("div", null, null, "position: relative; z-index: 1"), d.cursorDiv = elt("div", null, "CodeMirror-cursors"), d.measure = elt("div", null, "CodeMirror-measure"), d.lineMeasure = elt("div", null, "CodeMirror-measure"), d.lineSpace = eltP("div", [d.measure, d.lineMeasure, d.selectionDiv, d.cursorDiv, d.lineDiv], null, "position: relative; outline: none");
            var lines = eltP("div", [d.lineSpace], "CodeMirror-lines");
            d.mover = elt("div", [lines], null, "position: relative"), d.sizer = elt("div", [d.mover], "CodeMirror-sizer"), d.sizerWidth = null, d.heightForcer = elt("div", null, null, "position: absolute; height: " + scrollerGap + "px; width: 1px;"), d.gutters = elt("div", null, "CodeMirror-gutters"), d.lineGutter = null, d.scroller = elt("div", [d.sizer, d.heightForcer, d.gutters], "CodeMirror-scroll"), d.scroller.setAttribute("tabIndex", "-1"), d.wrapper = elt("div", [d.scrollbarFiller, d.gutterFiller, d.scroller], "CodeMirror"), ie && ie_version < 8 && (d.gutters.style.zIndex = -1, d.scroller.style.paddingRight = 0), webkit || gecko && mobile || (d.scroller.draggable = !0), place && (place.appendChild ? place.appendChild(d.wrapper) : place(d.wrapper)), d.viewFrom = d.viewTo = doc.first, d.reportedViewFrom = d.reportedViewTo = doc.first, d.view = [], d.renderedView = null, d.externalMeasured = null, d.viewOffset = 0, d.lastWrapHeight = d.lastWrapWidth = 0, d.updateLineNumbers = null, d.nativeBarWidth = d.barHeight = d.barWidth = 0, d.scrollbarsClipped = !1, d.lineNumWidth = d.lineNumInnerWidth = d.lineNumChars = null, d.alignWidgets = !1, d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null, d.maxLine = null, d.maxLineLength = 0, d.maxLineChanged = !1, d.wheelDX = d.wheelDY = d.wheelStartX = d.wheelStartY = null, d.shift = !1, d.selForContextMenu = null, d.activeTouch = null, input.init(d)
        }

        function getLine(doc, n) {
            if (n -= doc.first, n < 0 || n >= doc.size) throw new Error("There is no line " + (n + doc.first) + " in the document.");
            for (var chunk = doc; !chunk.lines;)
                for (var i = 0;; ++i) {
                    var child = chunk.children[i],
                        sz = child.chunkSize();
                    if (n < sz) {
                        chunk = child;
                        break
                    }
                    n -= sz
                }
            return chunk.lines[n]
        }

        function getBetween(doc, start, end) {
            var out = [],
                n = start.line;
            return doc.iter(start.line, end.line + 1, function(line) {
                var text = line.text;
                n == end.line && (text = text.slice(0, end.ch)), n == start.line && (text = text.slice(start.ch)), out.push(text), ++n
            }), out
        }

        function getLines(doc, from, to) {
            var out = [];
            return doc.iter(from, to, function(line) {
                out.push(line.text)
            }), out
        }

        function updateLineHeight(line, height) {
            var diff = height - line.height;
            if (diff)
                for (var n = line; n; n = n.parent) n.height += diff
        }

        function lineNo(line) {
            if (null == line.parent) return null;
            for (var cur = line.parent, no = indexOf(cur.lines, line), chunk = cur.parent; chunk; cur = chunk, chunk = chunk.parent)
                for (var i = 0; chunk.children[i] != cur; ++i) no += chunk.children[i].chunkSize();
            return no + cur.first
        }

        function _lineAtHeight(chunk, h) {
            var n = chunk.first;
            outer: do {
                for (var i$1 = 0; i$1 < chunk.children.length; ++i$1) {
                    var child = chunk.children[i$1],
                        ch = child.height;
                    if (h < ch) {
                        chunk = child;
                        continue outer
                    }
                    h -= ch, n += child.chunkSize()
                }
                return n
            } while (!chunk.lines);
            for (var i = 0; i < chunk.lines.length; ++i) {
                var line = chunk.lines[i],
                    lh = line.height;
                if (h < lh) break;
                h -= lh
            }
            return n + i
        }

        function isLine(doc, l) {
            return l >= doc.first && l < doc.first + doc.size
        }

        function lineNumberFor(options, i) {
            return String(options.lineNumberFormatter(i + options.firstLineNumber))
        }

        function Pos(line, ch, sticky) {
            return void 0 === sticky && (sticky = null), this instanceof Pos ? (this.line = line, this.ch = ch, void(this.sticky = sticky)) : new Pos(line, ch, sticky)
        }

        function cmp(a, b) {
            return a.line - b.line || a.ch - b.ch
        }

        function equalCursorPos(a, b) {
            return a.sticky == b.sticky && 0 == cmp(a, b)
        }

        function copyPos(x) {
            return Pos(x.line, x.ch)
        }

        function maxPos(a, b) {
            return cmp(a, b) < 0 ? b : a
        }

        function minPos(a, b) {
            return cmp(a, b) < 0 ? a : b
        }

        function clipLine(doc, n) {
            return Math.max(doc.first, Math.min(n, doc.first + doc.size - 1))
        }

        function _clipPos(doc, pos) {
            if (pos.line < doc.first) return Pos(doc.first, 0);
            var last = doc.first + doc.size - 1;
            return pos.line > last ? Pos(last, getLine(doc, last).text.length) : clipToLen(pos, getLine(doc, pos.line).text.length)
        }

        function clipToLen(pos, linelen) {
            var ch = pos.ch;
            return null == ch || ch > linelen ? Pos(pos.line, linelen) : ch < 0 ? Pos(pos.line, 0) : pos
        }

        function clipPosArray(doc, array) {
            for (var out = [], i = 0; i < array.length; i++) out[i] = _clipPos(doc, array[i]);
            return out
        }

        function seeReadOnlySpans() {
            sawReadOnlySpans = !0
        }

        function seeCollapsedSpans() {
            sawCollapsedSpans = !0
        }

        function MarkedSpan(marker, from, to) {
            this.marker = marker, this.from = from, this.to = to
        }

        function getMarkedSpanFor(spans, marker) {
            if (spans)
                for (var i = 0; i < spans.length; ++i) {
                    var span = spans[i];
                    if (span.marker == marker) return span
                }
        }

        function removeMarkedSpan(spans, span) {
            for (var r, i = 0; i < spans.length; ++i) spans[i] != span && (r || (r = [])).push(spans[i]);
            return r
        }

        function addMarkedSpan(line, span) {
            line.markedSpans = line.markedSpans ? line.markedSpans.concat([span]) : [span], span.marker.attachLine(line)
        }

        function markedSpansBefore(old, startCh, isInsert) {
            var nw;
            if (old)
                for (var i = 0; i < old.length; ++i) {
                    var span = old[i],
                        marker = span.marker,
                        startsBefore = null == span.from || (marker.inclusiveLeft ? span.from <= startCh : span.from < startCh);
                    if (startsBefore || span.from == startCh && "bookmark" == marker.type && (!isInsert || !span.marker.insertLeft)) {
                        var endsAfter = null == span.to || (marker.inclusiveRight ? span.to >= startCh : span.to > startCh);
                        (nw || (nw = [])).push(new MarkedSpan(marker, span.from, endsAfter ? null : span.to))
                    }
                }
            return nw
        }

        function markedSpansAfter(old, endCh, isInsert) {
            var nw;
            if (old)
                for (var i = 0; i < old.length; ++i) {
                    var span = old[i],
                        marker = span.marker,
                        endsAfter = null == span.to || (marker.inclusiveRight ? span.to >= endCh : span.to > endCh);
                    if (endsAfter || span.from == endCh && "bookmark" == marker.type && (!isInsert || span.marker.insertLeft)) {
                        var startsBefore = null == span.from || (marker.inclusiveLeft ? span.from <= endCh : span.from < endCh);
                        (nw || (nw = [])).push(new MarkedSpan(marker, startsBefore ? null : span.from - endCh, null == span.to ? null : span.to - endCh))
                    }
                }
            return nw
        }

        function stretchSpansOverChange(doc, change) {
            if (change.full) return null;
            var oldFirst = isLine(doc, change.from.line) && getLine(doc, change.from.line).markedSpans,
                oldLast = isLine(doc, change.to.line) && getLine(doc, change.to.line).markedSpans;
            if (!oldFirst && !oldLast) return null;
            var startCh = change.from.ch,
                endCh = change.to.ch,
                isInsert = 0 == cmp(change.from, change.to),
                first = markedSpansBefore(oldFirst, startCh, isInsert),
                last = markedSpansAfter(oldLast, endCh, isInsert),
                sameLine = 1 == change.text.length,
                offset = lst(change.text).length + (sameLine ? startCh : 0);
            if (first)
                for (var i = 0; i < first.length; ++i) {
                    var span = first[i];
                    if (null == span.to) {
                        var found = getMarkedSpanFor(last, span.marker);
                        found ? sameLine && (span.to = null == found.to ? null : found.to + offset) : span.to = startCh
                    }
                }
            if (last)
                for (var i$1 = 0; i$1 < last.length; ++i$1) {
                    var span$1 = last[i$1];
                    if (null != span$1.to && (span$1.to += offset), null == span$1.from) {
                        var found$1 = getMarkedSpanFor(first, span$1.marker);
                        found$1 || (span$1.from = offset, sameLine && (first || (first = [])).push(span$1))
                    } else span$1.from += offset, sameLine && (first || (first = [])).push(span$1)
                }
            first && (first = clearEmptySpans(first)), last && last != first && (last = clearEmptySpans(last));
            var newMarkers = [first];
            if (!sameLine) {
                var gapMarkers, gap = change.text.length - 2;
                if (gap > 0 && first)
                    for (var i$2 = 0; i$2 < first.length; ++i$2) null == first[i$2].to && (gapMarkers || (gapMarkers = [])).push(new MarkedSpan(first[i$2].marker, null, null));
                for (var i$3 = 0; i$3 < gap; ++i$3) newMarkers.push(gapMarkers);
                newMarkers.push(last)
            }
            return newMarkers
        }

        function clearEmptySpans(spans) {
            for (var i = 0; i < spans.length; ++i) {
                var span = spans[i];
                null != span.from && span.from == span.to && span.marker.clearWhenEmpty !== !1 && spans.splice(i--, 1)
            }
            return spans.length ? spans : null
        }

        function removeReadOnlyRanges(doc, from, to) {
            var markers = null;
            if (doc.iter(from.line, to.line + 1, function(line) {
                    if (line.markedSpans)
                        for (var i = 0; i < line.markedSpans.length; ++i) {
                            var mark = line.markedSpans[i].marker;
                            !mark.readOnly || markers && indexOf(markers, mark) != -1 || (markers || (markers = [])).push(mark)
                        }
                }), !markers) return null;
            for (var parts = [{
                    from: from,
                    to: to
                }], i = 0; i < markers.length; ++i)
                for (var mk = markers[i], m = mk.find(0), j = 0; j < parts.length; ++j) {
                    var p = parts[j];
                    if (!(cmp(p.to, m.from) < 0 || cmp(p.from, m.to) > 0)) {
                        var newParts = [j, 1],
                            dfrom = cmp(p.from, m.from),
                            dto = cmp(p.to, m.to);
                        (dfrom < 0 || !mk.inclusiveLeft && !dfrom) && newParts.push({
                            from: p.from,
                            to: m.from
                        }), (dto > 0 || !mk.inclusiveRight && !dto) && newParts.push({
                            from: m.to,
                            to: p.to
                        }), parts.splice.apply(parts, newParts), j += newParts.length - 3
                    }
                }
            return parts
        }

        function detachMarkedSpans(line) {
            var spans = line.markedSpans;
            if (spans) {
                for (var i = 0; i < spans.length; ++i) spans[i].marker.detachLine(line);
                line.markedSpans = null
            }
        }

        function attachMarkedSpans(line, spans) {
            if (spans) {
                for (var i = 0; i < spans.length; ++i) spans[i].marker.attachLine(line);
                line.markedSpans = spans
            }
        }

        function extraLeft(marker) {
            return marker.inclusiveLeft ? -1 : 0
        }

        function extraRight(marker) {
            return marker.inclusiveRight ? 1 : 0
        }

        function compareCollapsedMarkers(a, b) {
            var lenDiff = a.lines.length - b.lines.length;
            if (0 != lenDiff) return lenDiff;
            var aPos = a.find(),
                bPos = b.find(),
                fromCmp = cmp(aPos.from, bPos.from) || extraLeft(a) - extraLeft(b);
            if (fromCmp) return -fromCmp;
            var toCmp = cmp(aPos.to, bPos.to) || extraRight(a) - extraRight(b);
            return toCmp ? toCmp : b.id - a.id
        }

        function collapsedSpanAtSide(line, start) {
            var found, sps = sawCollapsedSpans && line.markedSpans;
            if (sps)
                for (var sp = void 0, i = 0; i < sps.length; ++i) sp = sps[i], sp.marker.collapsed && null == (start ? sp.from : sp.to) && (!found || compareCollapsedMarkers(found, sp.marker) < 0) && (found = sp.marker);
            return found
        }

        function collapsedSpanAtStart(line) {
            return collapsedSpanAtSide(line, !0)
        }

        function collapsedSpanAtEnd(line) {
            return collapsedSpanAtSide(line, !1)
        }

        function conflictingCollapsedRange(doc, lineNo$$1, from, to, marker) {
            var line = getLine(doc, lineNo$$1),
                sps = sawCollapsedSpans && line.markedSpans;
            if (sps)
                for (var i = 0; i < sps.length; ++i) {
                    var sp = sps[i];
                    if (sp.marker.collapsed) {
                        var found = sp.marker.find(0),
                            fromCmp = cmp(found.from, from) || extraLeft(sp.marker) - extraLeft(marker),
                            toCmp = cmp(found.to, to) || extraRight(sp.marker) - extraRight(marker);
                        if (!(fromCmp >= 0 && toCmp <= 0 || fromCmp <= 0 && toCmp >= 0) && (fromCmp <= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.to, from) >= 0 : cmp(found.to, from) > 0) || fromCmp >= 0 && (sp.marker.inclusiveRight && marker.inclusiveLeft ? cmp(found.from, to) <= 0 : cmp(found.from, to) < 0))) return !0
                    }
                }
        }

        function visualLine(line) {
            for (var merged; merged = collapsedSpanAtStart(line);) line = merged.find(-1, !0).line;
            return line
        }

        function visualLineEnd(line) {
            for (var merged; merged = collapsedSpanAtEnd(line);) line = merged.find(1, !0).line;
            return line
        }

        function visualLineContinued(line) {
            for (var merged, lines; merged = collapsedSpanAtEnd(line);) line = merged.find(1, !0).line, (lines || (lines = [])).push(line);
            return lines
        }

        function visualLineNo(doc, lineN) {
            var line = getLine(doc, lineN),
                vis = visualLine(line);
            return line == vis ? lineN : lineNo(vis)
        }

        function visualLineEndNo(doc, lineN) {
            if (lineN > doc.lastLine()) return lineN;
            var merged, line = getLine(doc, lineN);
            if (!lineIsHidden(doc, line)) return lineN;
            for (; merged = collapsedSpanAtEnd(line);) line = merged.find(1, !0).line;
            return lineNo(line) + 1
        }

        function lineIsHidden(doc, line) {
            var sps = sawCollapsedSpans && line.markedSpans;
            if (sps)
                for (var sp = void 0, i = 0; i < sps.length; ++i)
                    if (sp = sps[i], sp.marker.collapsed) {
                        if (null == sp.from) return !0;
                        if (!sp.marker.widgetNode && 0 == sp.from && sp.marker.inclusiveLeft && lineIsHiddenInner(doc, line, sp)) return !0
                    }
        }

        function lineIsHiddenInner(doc, line, span) {
            if (null == span.to) {
                var end = span.marker.find(1, !0);
                return lineIsHiddenInner(doc, end.line, getMarkedSpanFor(end.line.markedSpans, span.marker))
            }
            if (span.marker.inclusiveRight && span.to == line.text.length) return !0;
            for (var sp = void 0, i = 0; i < line.markedSpans.length; ++i)
                if (sp = line.markedSpans[i], sp.marker.collapsed && !sp.marker.widgetNode && sp.from == span.to && (null == sp.to || sp.to != span.from) && (sp.marker.inclusiveLeft || span.marker.inclusiveRight) && lineIsHiddenInner(doc, line, sp)) return !0
        }

        function _heightAtLine(lineObj) {
            lineObj = visualLine(lineObj);
            for (var h = 0, chunk = lineObj.parent, i = 0; i < chunk.lines.length; ++i) {
                var line = chunk.lines[i];
                if (line == lineObj) break;
                h += line.height
            }
            for (var p = chunk.parent; p; chunk = p, p = chunk.parent)
                for (var i$1 = 0; i$1 < p.children.length; ++i$1) {
                    var cur = p.children[i$1];
                    if (cur == chunk) break;
                    h += cur.height
                }
            return h
        }

        function lineLength(line) {
            if (0 == line.height) return 0;
            for (var merged, len = line.text.length, cur = line; merged = collapsedSpanAtStart(cur);) {
                var found = merged.find(0, !0);
                cur = found.from.line, len += found.from.ch - found.to.ch
            }
            for (cur = line; merged = collapsedSpanAtEnd(cur);) {
                var found$1 = merged.find(0, !0);
                len -= cur.text.length - found$1.from.ch, cur = found$1.to.line, len += cur.text.length - found$1.to.ch
            }
            return len
        }

        function findMaxLine(cm) {
            var d = cm.display,
                doc = cm.doc;
            d.maxLine = getLine(doc, doc.first), d.maxLineLength = lineLength(d.maxLine), d.maxLineChanged = !0, doc.iter(function(line) {
                var len = lineLength(line);
                len > d.maxLineLength && (d.maxLineLength = len, d.maxLine = line)
            })
        }

        function iterateBidiSections(order, from, to, f) {
            if (!order) return f(from, to, "ltr", 0);
            for (var found = !1, i = 0; i < order.length; ++i) {
                var part = order[i];
                (part.from < to && part.to > from || from == to && part.to == from) && (f(Math.max(part.from, from), Math.min(part.to, to), 1 == part.level ? "rtl" : "ltr", i), found = !0)
            }
            found || f(from, to, "ltr")
        }

        function getBidiPartAt(order, ch, sticky) {
            var found;
            bidiOther = null;
            for (var i = 0; i < order.length; ++i) {
                var cur = order[i];
                if (cur.from < ch && cur.to > ch) return i;
                cur.to == ch && (cur.from != cur.to && "before" == sticky ? found = i : bidiOther = i), cur.from == ch && (cur.from != cur.to && "before" != sticky ? found = i : bidiOther = i)
            }
            return null != found ? found : bidiOther
        }

        function getOrder(line, direction) {
            var order = line.order;
            return null == order && (order = line.order = bidiOrdering(line.text, direction)), order
        }

        function getHandlers(emitter, type) {
            return emitter._handlers && emitter._handlers[type] || noHandlers
        }

        function off(emitter, type, f) {
            if (emitter.removeEventListener) emitter.removeEventListener(type, f, !1);
            else if (emitter.detachEvent) emitter.detachEvent("on" + type, f);
            else {
                var map$$1 = emitter._handlers,
                    arr = map$$1 && map$$1[type];
                if (arr) {
                    var index = indexOf(arr, f);
                    index > -1 && (map$$1[type] = arr.slice(0, index).concat(arr.slice(index + 1)))
                }
            }
        }

        function signal(emitter, type) {
            var handlers = getHandlers(emitter, type);
            if (handlers.length)
                for (var args = Array.prototype.slice.call(arguments, 2), i = 0; i < handlers.length; ++i) handlers[i].apply(null, args)
        }

        function signalDOMEvent(cm, e, override) {
            return "string" == typeof e && (e = {
                type: e,
                preventDefault: function() {
                    this.defaultPrevented = !0
                }
            }), signal(cm, override || e.type, cm, e), e_defaultPrevented(e) || e.codemirrorIgnore
        }

        function signalCursorActivity(cm) {
            var arr = cm._handlers && cm._handlers.cursorActivity;
            if (arr)
                for (var set = cm.curOp.cursorActivityHandlers || (cm.curOp.cursorActivityHandlers = []), i = 0; i < arr.length; ++i) indexOf(set, arr[i]) == -1 && set.push(arr[i])
        }

        function hasHandler(emitter, type) {
            return getHandlers(emitter, type).length > 0
        }

        function eventMixin(ctor) {
            ctor.prototype.on = function(type, f) {
                on(this, type, f)
            }, ctor.prototype.off = function(type, f) {
                off(this, type, f)
            }
        }

        function e_preventDefault(e) {
            e.preventDefault ? e.preventDefault() : e.returnValue = !1
        }

        function e_stopPropagation(e) {
            e.stopPropagation ? e.stopPropagation() : e.cancelBubble = !0
        }

        function e_defaultPrevented(e) {
            return null != e.defaultPrevented ? e.defaultPrevented : 0 == e.returnValue
        }

        function e_stop(e) {
            e_preventDefault(e), e_stopPropagation(e)
        }

        function e_target(e) {
            return e.target || e.srcElement
        }

        function e_button(e) {
            var b = e.which;
            return null == b && (1 & e.button ? b = 1 : 2 & e.button ? b = 3 : 4 & e.button && (b = 2)), mac && e.ctrlKey && 1 == b && (b = 3), b
        }

        function zeroWidthElement(measure) {
            if (null == zwspSupported) {
                var test = elt("span", "");
                removeChildrenAndAdd(measure, elt("span", [test, document.createTextNode("x")])), 0 != measure.firstChild.offsetHeight && (zwspSupported = test.offsetWidth <= 1 && test.offsetHeight > 2 && !(ie && ie_version < 8))
            }
            var node = zwspSupported ? elt("span", "") : elt("span", "", null, "display: inline-block; width: 1px; margin-right: -1px");
            return node.setAttribute("cm-text", ""), node
        }

        function hasBadBidiRects(measure) {
            if (null != badBidiRects) return badBidiRects;
            var txt = removeChildrenAndAdd(measure, document.createTextNode("AA")),
                r0 = range(txt, 0, 1).getBoundingClientRect(),
                r1 = range(txt, 1, 2).getBoundingClientRect();
            return removeChildren(measure), !(!r0 || r0.left == r0.right) && (badBidiRects = r1.right - r0.right < 3)
        }

        function hasBadZoomedRects(measure) {
            if (null != badZoomedRects) return badZoomedRects;
            var node = removeChildrenAndAdd(measure, elt("span", "x")),
                normal = node.getBoundingClientRect(),
                fromRange = range(node, 0, 1).getBoundingClientRect();
            return badZoomedRects = Math.abs(normal.left - fromRange.left) > 1
        }

        function defineMode(name, mode) {
            arguments.length > 2 && (mode.dependencies = Array.prototype.slice.call(arguments, 2)), modes[name] = mode
        }

        function defineMIME(mime, spec) {
            mimeModes[mime] = spec
        }

        function resolveMode(spec) {
            if ("string" == typeof spec && mimeModes.hasOwnProperty(spec)) spec = mimeModes[spec];
            else if (spec && "string" == typeof spec.name && mimeModes.hasOwnProperty(spec.name)) {
                var found = mimeModes[spec.name];
                "string" == typeof found && (found = {
                    name: found
                }), spec = createObj(found, spec), spec.name = found.name
            } else {
                if ("string" == typeof spec && /^[\w\-]+\/[\w\-]+\+xml$/.test(spec)) return resolveMode("application/xml");
                if ("string" == typeof spec && /^[\w\-]+\/[\w\-]+\+json$/.test(spec)) return resolveMode("application/json")
            }
            return "string" == typeof spec ? {
                name: spec
            } : spec || {
                name: "null"
            }
        }

        function getMode(options, spec) {
            spec = resolveMode(spec);
            var mfactory = modes[spec.name];
            if (!mfactory) return getMode(options, "text/plain");
            var modeObj = mfactory(options, spec);
            if (modeExtensions.hasOwnProperty(spec.name)) {
                var exts = modeExtensions[spec.name];
                for (var prop in exts) exts.hasOwnProperty(prop) && (modeObj.hasOwnProperty(prop) && (modeObj["_" + prop] = modeObj[prop]), modeObj[prop] = exts[prop])
            }
            if (modeObj.name = spec.name, spec.helperType && (modeObj.helperType = spec.helperType), spec.modeProps)
                for (var prop$1 in spec.modeProps) modeObj[prop$1] = spec.modeProps[prop$1];
            return modeObj
        }

        function extendMode(mode, properties) {
            var exts = modeExtensions.hasOwnProperty(mode) ? modeExtensions[mode] : modeExtensions[mode] = {};
            copyObj(properties, exts)
        }

        function copyState(mode, state) {
            if (state === !0) return state;
            if (mode.copyState) return mode.copyState(state);
            var nstate = {};
            for (var n in state) {
                var val = state[n];
                val instanceof Array && (val = val.concat([])), nstate[n] = val
            }
            return nstate
        }

        function innerMode(mode, state) {
            for (var info; mode.innerMode && (info = mode.innerMode(state), info && info.mode != mode);) state = info.state, mode = info.mode;
            return info || {
                mode: mode,
                state: state
            }
        }

        function startState(mode, a1, a2) {
            return !mode.startState || mode.startState(a1, a2)
        }

        function highlightLine(cm, line, context, forceToEnd) {
            var st = [cm.state.modeGen],
                lineClasses = {};
            runMode(cm, line.text, cm.doc.mode, context, function(end, style) {
                return st.push(end, style)
            }, lineClasses, forceToEnd);
            for (var state = context.state, loop = function(o) {
                    context.baseTokens = st;
                    var overlay = cm.state.overlays[o],
                        i = 1,
                        at = 0;
                    context.state = !0, runMode(cm, line.text, overlay.mode, context, function(end, style) {
                        for (var start = i; at < end;) {
                            var i_end = st[i];
                            i_end > end && st.splice(i, 1, end, st[i + 1], i_end), i += 2, at = Math.min(end, i_end)
                        }
                        if (style)
                            if (overlay.opaque) st.splice(start, i - start, end, "overlay " + style), i = start + 2;
                            else
                                for (; start < i; start += 2) {
                                    var cur = st[start + 1];
                                    st[start + 1] = (cur ? cur + " " : "") + "overlay " + style
                                }
                    }, lineClasses), context.state = state, context.baseTokens = null, context.baseTokenPos = 1
                }, o = 0; o < cm.state.overlays.length; ++o) loop(o);
            return {
                styles: st,
                classes: lineClasses.bgClass || lineClasses.textClass ? lineClasses : null
            }
        }

        function getLineStyles(cm, line, updateFrontier) {
            if (!line.styles || line.styles[0] != cm.state.modeGen) {
                var context = getContextBefore(cm, lineNo(line)),
                    resetState = line.text.length > cm.options.maxHighlightLength && copyState(cm.doc.mode, context.state),
                    result = highlightLine(cm, line, context);
                resetState && (context.state = resetState), line.stateAfter = context.save(!resetState), line.styles = result.styles, result.classes ? line.styleClasses = result.classes : line.styleClasses && (line.styleClasses = null), updateFrontier === cm.doc.highlightFrontier && (cm.doc.modeFrontier = Math.max(cm.doc.modeFrontier, ++cm.doc.highlightFrontier))
            }
            return line.styles
        }

        function getContextBefore(cm, n, precise) {
            var doc = cm.doc,
                display = cm.display;
            if (!doc.mode.startState) return new Context(doc, (!0), n);
            var start = findStartLine(cm, n, precise),
                saved = start > doc.first && getLine(doc, start - 1).stateAfter,
                context = saved ? Context.fromSaved(doc, saved, start) : new Context(doc, startState(doc.mode), start);
            return doc.iter(start, n, function(line) {
                processLine(cm, line.text, context);
                var pos = context.line;
                line.stateAfter = pos == n - 1 || pos % 5 == 0 || pos >= display.viewFrom && pos < display.viewTo ? context.save() : null, context.nextLine()
            }), precise && (doc.modeFrontier = context.line), context
        }

        function processLine(cm, text, context, startAt) {
            var mode = cm.doc.mode,
                stream = new StringStream(text, cm.options.tabSize, context);
            for (stream.start = stream.pos = startAt || 0, "" == text && callBlankLine(mode, context.state); !stream.eol();) readToken(mode, stream, context.state), stream.start = stream.pos
        }

        function callBlankLine(mode, state) {
            if (mode.blankLine) return mode.blankLine(state);
            if (mode.innerMode) {
                var inner = innerMode(mode, state);
                return inner.mode.blankLine ? inner.mode.blankLine(inner.state) : void 0
            }
        }

        function readToken(mode, stream, state, inner) {
            for (var i = 0; i < 10; i++) {
                inner && (inner[0] = innerMode(mode, state).mode);
                var style = mode.token(stream, state);
                if (stream.pos > stream.start) return style
            }
            throw new Error("Mode " + mode.name + " failed to advance stream.")
        }

        function takeToken(cm, pos, precise, asArray) {
            var style, doc = cm.doc,
                mode = doc.mode;
            pos = _clipPos(doc, pos);
            var tokens, line = getLine(doc, pos.line),
                context = getContextBefore(cm, pos.line, precise),
                stream = new StringStream(line.text, cm.options.tabSize, context);
            for (asArray && (tokens = []);
                (asArray || stream.pos < pos.ch) && !stream.eol();) stream.start = stream.pos, style = readToken(mode, stream, context.state), asArray && tokens.push(new Token(stream, style, copyState(doc.mode, context.state)));
            return asArray ? tokens : new Token(stream, style, context.state)
        }

        function extractLineClasses(type, output) {
            if (type)
                for (;;) {
                    var lineClass = type.match(/(?:^|\s+)line-(background-)?(\S+)/);
                    if (!lineClass) break;
                    type = type.slice(0, lineClass.index) + type.slice(lineClass.index + lineClass[0].length);
                    var prop = lineClass[1] ? "bgClass" : "textClass";
                    null == output[prop] ? output[prop] = lineClass[2] : new RegExp("(?:^|s)" + lineClass[2] + "(?:$|s)").test(output[prop]) || (output[prop] += " " + lineClass[2])
                }
            return type
        }

        function runMode(cm, text, mode, context, f, lineClasses, forceToEnd) {
            var flattenSpans = mode.flattenSpans;
            null == flattenSpans && (flattenSpans = cm.options.flattenSpans);
            var style, curStart = 0,
                curStyle = null,
                stream = new StringStream(text, cm.options.tabSize, context),
                inner = cm.options.addModeClass && [null];
            for ("" == text && extractLineClasses(callBlankLine(mode, context.state), lineClasses); !stream.eol();) {
                if (stream.pos > cm.options.maxHighlightLength ? (flattenSpans = !1, forceToEnd && processLine(cm, text, context, stream.pos), stream.pos = text.length, style = null) : style = extractLineClasses(readToken(mode, stream, context.state, inner), lineClasses), inner) {
                    var mName = inner[0].name;
                    mName && (style = "m-" + (style ? mName + " " + style : mName))
                }
                if (!flattenSpans || curStyle != style) {
                    for (; curStart < stream.start;) curStart = Math.min(stream.start, curStart + 5e3), f(curStart, curStyle);
                    curStyle = style
                }
                stream.start = stream.pos
            }
            for (; curStart < stream.pos;) {
                var pos = Math.min(stream.pos, curStart + 5e3);
                f(pos, curStyle), curStart = pos
            }
        }

        function findStartLine(cm, n, precise) {
            for (var minindent, minline, doc = cm.doc, lim = precise ? -1 : n - (cm.doc.mode.innerMode ? 1e3 : 100), search = n; search > lim; --search) {
                if (search <= doc.first) return doc.first;
                var line = getLine(doc, search - 1),
                    after = line.stateAfter;
                if (after && (!precise || search + (after instanceof SavedContext ? after.lookAhead : 0) <= doc.modeFrontier)) return search;
                var indented = countColumn(line.text, null, cm.options.tabSize);
                (null == minline || minindent > indented) && (minline = search - 1, minindent = indented)
            }
            return minline
        }

        function retreatFrontier(doc, n) {
            if (doc.modeFrontier = Math.min(doc.modeFrontier, n), !(doc.highlightFrontier < n - 10)) {
                for (var start = doc.first, line = n - 1; line > start; line--) {
                    var saved = getLine(doc, line).stateAfter;
                    if (saved && (!(saved instanceof SavedContext) || line + saved.lookAhead < n)) {
                        start = line + 1;
                        break
                    }
                }
                doc.highlightFrontier = Math.min(doc.highlightFrontier, start)
            }
        }

        function updateLine(line, text, markedSpans, estimateHeight) {
            line.text = text, line.stateAfter && (line.stateAfter = null), line.styles && (line.styles = null), null != line.order && (line.order = null), detachMarkedSpans(line), attachMarkedSpans(line, markedSpans);
            var estHeight = estimateHeight ? estimateHeight(line) : 1;
            estHeight != line.height && updateLineHeight(line, estHeight);
        }

        function cleanUpLine(line) {
            line.parent = null, detachMarkedSpans(line)
        }

        function interpretTokenStyle(style, options) {
            if (!style || /^\s*$/.test(style)) return null;
            var cache = options.addModeClass ? styleToClassCacheWithMode : styleToClassCache;
            return cache[style] || (cache[style] = style.replace(/\S+/g, "cm-$&"))
        }

        function buildLineContent(cm, lineView) {
            var content = eltP("span", null, null, webkit ? "padding-right: .1px" : null),
                builder = {
                    pre: eltP("pre", [content], "CodeMirror-line"),
                    content: content,
                    col: 0,
                    pos: 0,
                    cm: cm,
                    trailingSpace: !1,
                    splitSpaces: (ie || webkit) && cm.getOption("lineWrapping")
                };
            lineView.measure = {};
            for (var i = 0; i <= (lineView.rest ? lineView.rest.length : 0); i++) {
                var line = i ? lineView.rest[i - 1] : lineView.line,
                    order = void 0;
                builder.pos = 0, builder.addToken = buildToken, hasBadBidiRects(cm.display.measure) && (order = getOrder(line, cm.doc.direction)) && (builder.addToken = buildTokenBadBidi(builder.addToken, order)), builder.map = [];
                var allowFrontierUpdate = lineView != cm.display.externalMeasured && lineNo(line);
                insertLineContent(line, builder, getLineStyles(cm, line, allowFrontierUpdate)), line.styleClasses && (line.styleClasses.bgClass && (builder.bgClass = joinClasses(line.styleClasses.bgClass, builder.bgClass || "")), line.styleClasses.textClass && (builder.textClass = joinClasses(line.styleClasses.textClass, builder.textClass || ""))), 0 == builder.map.length && builder.map.push(0, 0, builder.content.appendChild(zeroWidthElement(cm.display.measure))), 0 == i ? (lineView.measure.map = builder.map, lineView.measure.cache = {}) : ((lineView.measure.maps || (lineView.measure.maps = [])).push(builder.map), (lineView.measure.caches || (lineView.measure.caches = [])).push({}))
            }
            if (webkit) {
                var last = builder.content.lastChild;
                (/\bcm-tab\b/.test(last.className) || last.querySelector && last.querySelector(".cm-tab")) && (builder.content.className = "cm-tab-wrap-hack")
            }
            return signal(cm, "renderLine", cm, lineView.line, builder.pre), builder.pre.className && (builder.textClass = joinClasses(builder.pre.className, builder.textClass || "")), builder
        }

        function defaultSpecialCharPlaceholder(ch) {
            var token = elt("span", "", "cm-invalidchar");
            return token.title = "\\u" + ch.charCodeAt(0).toString(16), token.setAttribute("aria-label", token.title), token
        }

        function buildToken(builder, text, style, startStyle, endStyle, title, css) {
            if (text) {
                var content, displayText = builder.splitSpaces ? splitSpaces(text, builder.trailingSpace) : text,
                    special = builder.cm.state.specialChars,
                    mustWrap = !1;
                if (special.test(text)) {
                    content = document.createDocumentFragment();
                    for (var pos = 0;;) {
                        special.lastIndex = pos;
                        var m = special.exec(text),
                            skipped = m ? m.index - pos : text.length - pos;
                        if (skipped) {
                            var txt = document.createTextNode(displayText.slice(pos, pos + skipped));
                            ie && ie_version < 9 ? content.appendChild(elt("span", [txt])) : content.appendChild(txt), builder.map.push(builder.pos, builder.pos + skipped, txt), builder.col += skipped, builder.pos += skipped
                        }
                        if (!m) break;
                        pos += skipped + 1;
                        var txt$1 = void 0;
                        if ("\t" == m[0]) {
                            var tabSize = builder.cm.options.tabSize,
                                tabWidth = tabSize - builder.col % tabSize;
                            txt$1 = content.appendChild(elt("span", spaceStr(tabWidth), "cm-tab")), txt$1.setAttribute("role", "presentation"), txt$1.setAttribute("cm-text", "\t"), builder.col += tabWidth
                        } else "\r" == m[0] || "\n" == m[0] ? (txt$1 = content.appendChild(elt("span", "\r" == m[0] ? "" : "", "cm-invalidchar")), txt$1.setAttribute("cm-text", m[0]), builder.col += 1) : (txt$1 = builder.cm.options.specialCharPlaceholder(m[0]), txt$1.setAttribute("cm-text", m[0]), ie && ie_version < 9 ? content.appendChild(elt("span", [txt$1])) : content.appendChild(txt$1), builder.col += 1);
                        builder.map.push(builder.pos, builder.pos + 1, txt$1), builder.pos++
                    }
                } else builder.col += text.length, content = document.createTextNode(displayText), builder.map.push(builder.pos, builder.pos + text.length, content), ie && ie_version < 9 && (mustWrap = !0), builder.pos += text.length;
                if (builder.trailingSpace = 32 == displayText.charCodeAt(text.length - 1), style || startStyle || endStyle || mustWrap || css) {
                    var fullStyle = style || "";
                    startStyle && (fullStyle += startStyle), endStyle && (fullStyle += endStyle);
                    var token = elt("span", [content], fullStyle, css);
                    return title && (token.title = title), builder.content.appendChild(token)
                }
                builder.content.appendChild(content)
            }
        }

        function splitSpaces(text, trailingBefore) {
            if (text.length > 1 && !/  /.test(text)) return text;
            for (var spaceBefore = trailingBefore, result = "", i = 0; i < text.length; i++) {
                var ch = text.charAt(i);
                " " != ch || !spaceBefore || i != text.length - 1 && 32 != text.charCodeAt(i + 1) || (ch = ""), result += ch, spaceBefore = " " == ch
            }
            return result
        }

        function buildTokenBadBidi(inner, order) {
            return function(builder, text, style, startStyle, endStyle, title, css) {
                style = style ? style + " cm-force-border" : "cm-force-border";
                for (var start = builder.pos, end = start + text.length;;) {
                    for (var part = void 0, i = 0; i < order.length && (part = order[i], !(part.to > start && part.from <= start)); i++);
                    if (part.to >= end) return inner(builder, text, style, startStyle, endStyle, title, css);
                    inner(builder, text.slice(0, part.to - start), style, startStyle, null, title, css), startStyle = null, text = text.slice(part.to - start), start = part.to
                }
            }
        }

        function buildCollapsedSpan(builder, size, marker, ignoreWidget) {
            var widget = !ignoreWidget && marker.widgetNode;
            widget && builder.map.push(builder.pos, builder.pos + size, widget), !ignoreWidget && builder.cm.display.input.needsContentAttribute && (widget || (widget = builder.content.appendChild(document.createElement("span"))), widget.setAttribute("cm-marker", marker.id)), widget && (builder.cm.display.input.setUneditable(widget), builder.content.appendChild(widget)), builder.pos += size, builder.trailingSpace = !1
        }

        function insertLineContent(line, builder, styles) {
            var spans = line.markedSpans,
                allText = line.text,
                at = 0;
            if (spans)
                for (var style, css, spanStyle, spanEndStyle, spanStartStyle, title, collapsed, len = allText.length, pos = 0, i = 1, text = "", nextChange = 0;;) {
                    if (nextChange == pos) {
                        spanStyle = spanEndStyle = spanStartStyle = title = css = "", collapsed = null, nextChange = 1 / 0;
                        for (var foundBookmarks = [], endStyles = void 0, j = 0; j < spans.length; ++j) {
                            var sp = spans[j],
                                m = sp.marker;
                            "bookmark" == m.type && sp.from == pos && m.widgetNode ? foundBookmarks.push(m) : sp.from <= pos && (null == sp.to || sp.to > pos || m.collapsed && sp.to == pos && sp.from == pos) ? (null != sp.to && sp.to != pos && nextChange > sp.to && (nextChange = sp.to, spanEndStyle = ""), m.className && (spanStyle += " " + m.className), m.css && (css = (css ? css + ";" : "") + m.css), m.startStyle && sp.from == pos && (spanStartStyle += " " + m.startStyle), m.endStyle && sp.to == nextChange && (endStyles || (endStyles = [])).push(m.endStyle, sp.to), m.title && !title && (title = m.title), m.collapsed && (!collapsed || compareCollapsedMarkers(collapsed.marker, m) < 0) && (collapsed = sp)) : sp.from > pos && nextChange > sp.from && (nextChange = sp.from)
                        }
                        if (endStyles)
                            for (var j$1 = 0; j$1 < endStyles.length; j$1 += 2) endStyles[j$1 + 1] == nextChange && (spanEndStyle += " " + endStyles[j$1]);
                        if (!collapsed || collapsed.from == pos)
                            for (var j$2 = 0; j$2 < foundBookmarks.length; ++j$2) buildCollapsedSpan(builder, 0, foundBookmarks[j$2]);
                        if (collapsed && (collapsed.from || 0) == pos) {
                            if (buildCollapsedSpan(builder, (null == collapsed.to ? len + 1 : collapsed.to) - pos, collapsed.marker, null == collapsed.from), null == collapsed.to) return;
                            collapsed.to == pos && (collapsed = !1)
                        }
                    }
                    if (pos >= len) break;
                    for (var upto = Math.min(len, nextChange);;) {
                        if (text) {
                            var end = pos + text.length;
                            if (!collapsed) {
                                var tokenText = end > upto ? text.slice(0, upto - pos) : text;
                                builder.addToken(builder, tokenText, style ? style + spanStyle : spanStyle, spanStartStyle, pos + tokenText.length == nextChange ? spanEndStyle : "", title, css)
                            }
                            if (end >= upto) {
                                text = text.slice(upto - pos), pos = upto;
                                break
                            }
                            pos = end, spanStartStyle = ""
                        }
                        text = allText.slice(at, at = styles[i++]), style = interpretTokenStyle(styles[i++], builder.cm.options)
                    }
                } else
                    for (var i$1 = 1; i$1 < styles.length; i$1 += 2) builder.addToken(builder, allText.slice(at, at = styles[i$1]), interpretTokenStyle(styles[i$1 + 1], builder.cm.options))
        }

        function LineView(doc, line, lineN) {
            this.line = line, this.rest = visualLineContinued(line), this.size = this.rest ? lineNo(lst(this.rest)) - lineN + 1 : 1, this.node = this.text = null, this.hidden = lineIsHidden(doc, line)
        }

        function buildViewArray(cm, from, to) {
            for (var nextPos, array = [], pos = from; pos < to; pos = nextPos) {
                var view = new LineView(cm.doc, getLine(cm.doc, pos), pos);
                nextPos = pos + view.size, array.push(view)
            }
            return array
        }

        function pushOperation(op) {
            operationGroup ? operationGroup.ops.push(op) : op.ownsGroup = operationGroup = {
                ops: [op],
                delayedCallbacks: []
            }
        }

        function fireCallbacksForOps(group) {
            var callbacks = group.delayedCallbacks,
                i = 0;
            do {
                for (; i < callbacks.length; i++) callbacks[i].call(null);
                for (var j = 0; j < group.ops.length; j++) {
                    var op = group.ops[j];
                    if (op.cursorActivityHandlers)
                        for (; op.cursorActivityCalled < op.cursorActivityHandlers.length;) op.cursorActivityHandlers[op.cursorActivityCalled++].call(null, op.cm)
                }
            } while (i < callbacks.length)
        }

        function finishOperation(op, endCb) {
            var group = op.ownsGroup;
            if (group) try {
                fireCallbacksForOps(group)
            } finally {
                operationGroup = null, endCb(group)
            }
        }

        function signalLater(emitter, type) {
            var arr = getHandlers(emitter, type);
            if (arr.length) {
                var list, args = Array.prototype.slice.call(arguments, 2);
                operationGroup ? list = operationGroup.delayedCallbacks : orphanDelayedCallbacks ? list = orphanDelayedCallbacks : (list = orphanDelayedCallbacks = [], setTimeout(fireOrphanDelayed, 0));
                for (var loop = function(i) {
                        list.push(function() {
                            return arr[i].apply(null, args)
                        })
                    }, i = 0; i < arr.length; ++i) loop(i)
            }
        }

        function fireOrphanDelayed() {
            var delayed = orphanDelayedCallbacks;
            orphanDelayedCallbacks = null;
            for (var i = 0; i < delayed.length; ++i) delayed[i]()
        }

        function updateLineForChanges(cm, lineView, lineN, dims) {
            for (var j = 0; j < lineView.changes.length; j++) {
                var type = lineView.changes[j];
                "text" == type ? updateLineText(cm, lineView) : "gutter" == type ? updateLineGutter(cm, lineView, lineN, dims) : "class" == type ? updateLineClasses(cm, lineView) : "widget" == type && updateLineWidgets(cm, lineView, dims)
            }
            lineView.changes = null
        }

        function ensureLineWrapped(lineView) {
            return lineView.node == lineView.text && (lineView.node = elt("div", null, null, "position: relative"), lineView.text.parentNode && lineView.text.parentNode.replaceChild(lineView.node, lineView.text), lineView.node.appendChild(lineView.text), ie && ie_version < 8 && (lineView.node.style.zIndex = 2)), lineView.node
        }

        function updateLineBackground(cm, lineView) {
            var cls = lineView.bgClass ? lineView.bgClass + " " + (lineView.line.bgClass || "") : lineView.line.bgClass;
            if (cls && (cls += " CodeMirror-linebackground"), lineView.background) cls ? lineView.background.className = cls : (lineView.background.parentNode.removeChild(lineView.background), lineView.background = null);
            else if (cls) {
                var wrap = ensureLineWrapped(lineView);
                lineView.background = wrap.insertBefore(elt("div", null, cls), wrap.firstChild), cm.display.input.setUneditable(lineView.background)
            }
        }

        function getLineContent(cm, lineView) {
            var ext = cm.display.externalMeasured;
            return ext && ext.line == lineView.line ? (cm.display.externalMeasured = null, lineView.measure = ext.measure, ext.built) : buildLineContent(cm, lineView)
        }

        function updateLineText(cm, lineView) {
            var cls = lineView.text.className,
                built = getLineContent(cm, lineView);
            lineView.text == lineView.node && (lineView.node = built.pre), lineView.text.parentNode.replaceChild(built.pre, lineView.text), lineView.text = built.pre, built.bgClass != lineView.bgClass || built.textClass != lineView.textClass ? (lineView.bgClass = built.bgClass, lineView.textClass = built.textClass, updateLineClasses(cm, lineView)) : cls && (lineView.text.className = cls)
        }

        function updateLineClasses(cm, lineView) {
            updateLineBackground(cm, lineView), lineView.line.wrapClass ? ensureLineWrapped(lineView).className = lineView.line.wrapClass : lineView.node != lineView.text && (lineView.node.className = "");
            var textClass = lineView.textClass ? lineView.textClass + " " + (lineView.line.textClass || "") : lineView.line.textClass;
            lineView.text.className = textClass || ""
        }

        function updateLineGutter(cm, lineView, lineN, dims) {
            if (lineView.gutter && (lineView.node.removeChild(lineView.gutter), lineView.gutter = null), lineView.gutterBackground && (lineView.node.removeChild(lineView.gutterBackground), lineView.gutterBackground = null), lineView.line.gutterClass) {
                var wrap = ensureLineWrapped(lineView);
                lineView.gutterBackground = elt("div", null, "CodeMirror-gutter-background " + lineView.line.gutterClass, "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px; width: " + dims.gutterTotalWidth + "px"), cm.display.input.setUneditable(lineView.gutterBackground), wrap.insertBefore(lineView.gutterBackground, lineView.text)
            }
            var markers = lineView.line.gutterMarkers;
            if (cm.options.lineNumbers || markers) {
                var wrap$1 = ensureLineWrapped(lineView),
                    gutterWrap = lineView.gutter = elt("div", null, "CodeMirror-gutter-wrapper", "left: " + (cm.options.fixedGutter ? dims.fixedPos : -dims.gutterTotalWidth) + "px");
                if (cm.display.input.setUneditable(gutterWrap), wrap$1.insertBefore(gutterWrap, lineView.text), lineView.line.gutterClass && (gutterWrap.className += " " + lineView.line.gutterClass), !cm.options.lineNumbers || markers && markers["CodeMirror-linenumbers"] || (lineView.lineNumber = gutterWrap.appendChild(elt("div", lineNumberFor(cm.options, lineN), "CodeMirror-linenumber CodeMirror-gutter-elt", "left: " + dims.gutterLeft["CodeMirror-linenumbers"] + "px; width: " + cm.display.lineNumInnerWidth + "px"))), markers)
                    for (var k = 0; k < cm.options.gutters.length; ++k) {
                        var id = cm.options.gutters[k],
                            found = markers.hasOwnProperty(id) && markers[id];
                        found && gutterWrap.appendChild(elt("div", [found], "CodeMirror-gutter-elt", "left: " + dims.gutterLeft[id] + "px; width: " + dims.gutterWidth[id] + "px"))
                    }
            }
        }

        function updateLineWidgets(cm, lineView, dims) {
            lineView.alignable && (lineView.alignable = null);
            for (var node = lineView.node.firstChild, next = void 0; node; node = next) next = node.nextSibling, "CodeMirror-linewidget" == node.className && lineView.node.removeChild(node);
            insertLineWidgets(cm, lineView, dims)
        }

        function buildLineElement(cm, lineView, lineN, dims) {
            var built = getLineContent(cm, lineView);
            return lineView.text = lineView.node = built.pre, built.bgClass && (lineView.bgClass = built.bgClass), built.textClass && (lineView.textClass = built.textClass), updateLineClasses(cm, lineView), updateLineGutter(cm, lineView, lineN, dims), insertLineWidgets(cm, lineView, dims), lineView.node
        }

        function insertLineWidgets(cm, lineView, dims) {
            if (insertLineWidgetsFor(cm, lineView.line, lineView, dims, !0), lineView.rest)
                for (var i = 0; i < lineView.rest.length; i++) insertLineWidgetsFor(cm, lineView.rest[i], lineView, dims, !1)
        }

        function insertLineWidgetsFor(cm, line, lineView, dims, allowAbove) {
            if (line.widgets)
                for (var wrap = ensureLineWrapped(lineView), i = 0, ws = line.widgets; i < ws.length; ++i) {
                    var widget = ws[i],
                        node = elt("div", [widget.node], "CodeMirror-linewidget");
                    widget.handleMouseEvents || node.setAttribute("cm-ignore-events", "true"), positionLineWidget(widget, node, lineView, dims), cm.display.input.setUneditable(node), allowAbove && widget.above ? wrap.insertBefore(node, lineView.gutter || lineView.text) : wrap.appendChild(node), signalLater(widget, "redraw")
                }
        }

        function positionLineWidget(widget, node, lineView, dims) {
            if (widget.noHScroll) {
                (lineView.alignable || (lineView.alignable = [])).push(node);
                var width = dims.wrapperWidth;
                node.style.left = dims.fixedPos + "px", widget.coverGutter || (width -= dims.gutterTotalWidth, node.style.paddingLeft = dims.gutterTotalWidth + "px"), node.style.width = width + "px"
            }
            widget.coverGutter && (node.style.zIndex = 5, node.style.position = "relative", widget.noHScroll || (node.style.marginLeft = -dims.gutterTotalWidth + "px"))
        }

        function widgetHeight(widget) {
            if (null != widget.height) return widget.height;
            var cm = widget.doc.cm;
            if (!cm) return 0;
            if (!contains(document.body, widget.node)) {
                var parentStyle = "position: relative;";
                widget.coverGutter && (parentStyle += "margin-left: -" + cm.display.gutters.offsetWidth + "px;"), widget.noHScroll && (parentStyle += "width: " + cm.display.wrapper.clientWidth + "px;"), removeChildrenAndAdd(cm.display.measure, elt("div", [widget.node], null, parentStyle))
            }
            return widget.height = widget.node.parentNode.offsetHeight
        }

        function eventInWidget(display, e) {
            for (var n = e_target(e); n != display.wrapper; n = n.parentNode)
                if (!n || 1 == n.nodeType && "true" == n.getAttribute("cm-ignore-events") || n.parentNode == display.sizer && n != display.mover) return !0
        }

        function paddingTop(display) {
            return display.lineSpace.offsetTop
        }

        function paddingVert(display) {
            return display.mover.offsetHeight - display.lineSpace.offsetHeight
        }

        function paddingH(display) {
            if (display.cachedPaddingH) return display.cachedPaddingH;
            var e = removeChildrenAndAdd(display.measure, elt("pre", "x")),
                style = window.getComputedStyle ? window.getComputedStyle(e) : e.currentStyle,
                data = {
                    left: parseInt(style.paddingLeft),
                    right: parseInt(style.paddingRight)
                };
            return isNaN(data.left) || isNaN(data.right) || (display.cachedPaddingH = data), data
        }

        function scrollGap(cm) {
            return scrollerGap - cm.display.nativeBarWidth
        }

        function displayWidth(cm) {
            return cm.display.scroller.clientWidth - scrollGap(cm) - cm.display.barWidth
        }

        function displayHeight(cm) {
            return cm.display.scroller.clientHeight - scrollGap(cm) - cm.display.barHeight
        }

        function ensureLineHeights(cm, lineView, rect) {
            var wrapping = cm.options.lineWrapping,
                curWidth = wrapping && displayWidth(cm);
            if (!lineView.measure.heights || wrapping && lineView.measure.width != curWidth) {
                var heights = lineView.measure.heights = [];
                if (wrapping) {
                    lineView.measure.width = curWidth;
                    for (var rects = lineView.text.firstChild.getClientRects(), i = 0; i < rects.length - 1; i++) {
                        var cur = rects[i],
                            next = rects[i + 1];
                        Math.abs(cur.bottom - next.bottom) > 2 && heights.push((cur.bottom + next.top) / 2 - rect.top)
                    }
                }
                heights.push(rect.bottom - rect.top)
            }
        }

        function mapFromLineView(lineView, line, lineN) {
            if (lineView.line == line) return {
                map: lineView.measure.map,
                cache: lineView.measure.cache
            };
            for (var i = 0; i < lineView.rest.length; i++)
                if (lineView.rest[i] == line) return {
                    map: lineView.measure.maps[i],
                    cache: lineView.measure.caches[i]
                };
            for (var i$1 = 0; i$1 < lineView.rest.length; i$1++)
                if (lineNo(lineView.rest[i$1]) > lineN) return {
                    map: lineView.measure.maps[i$1],
                    cache: lineView.measure.caches[i$1],
                    before: !0
                }
        }

        function updateExternalMeasurement(cm, line) {
            line = visualLine(line);
            var lineN = lineNo(line),
                view = cm.display.externalMeasured = new LineView(cm.doc, line, lineN);
            view.lineN = lineN;
            var built = view.built = buildLineContent(cm, view);
            return view.text = built.pre, removeChildrenAndAdd(cm.display.lineMeasure, built.pre), view
        }

        function measureChar(cm, line, ch, bias) {
            return measureCharPrepared(cm, prepareMeasureForLine(cm, line), ch, bias)
        }

        function findViewForLine(cm, lineN) {
            if (lineN >= cm.display.viewFrom && lineN < cm.display.viewTo) return cm.display.view[findViewIndex(cm, lineN)];
            var ext = cm.display.externalMeasured;
            return ext && lineN >= ext.lineN && lineN < ext.lineN + ext.size ? ext : void 0
        }

        function prepareMeasureForLine(cm, line) {
            var lineN = lineNo(line),
                view = findViewForLine(cm, lineN);
            view && !view.text ? view = null : view && view.changes && (updateLineForChanges(cm, view, lineN, getDimensions(cm)), cm.curOp.forceUpdate = !0), view || (view = updateExternalMeasurement(cm, line));
            var info = mapFromLineView(view, line, lineN);
            return {
                line: line,
                view: view,
                rect: null,
                map: info.map,
                cache: info.cache,
                before: info.before,
                hasHeights: !1
            }
        }

        function measureCharPrepared(cm, prepared, ch, bias, varHeight) {
            prepared.before && (ch = -1);
            var found, key = ch + (bias || "");
            return prepared.cache.hasOwnProperty(key) ? found = prepared.cache[key] : (prepared.rect || (prepared.rect = prepared.view.text.getBoundingClientRect()), prepared.hasHeights || (ensureLineHeights(cm, prepared.view, prepared.rect), prepared.hasHeights = !0), found = measureCharInner(cm, prepared, ch, bias), found.bogus || (prepared.cache[key] = found)), {
                left: found.left,
                right: found.right,
                top: varHeight ? found.rtop : found.top,
                bottom: varHeight ? found.rbottom : found.bottom
            }
        }

        function nodeAndOffsetInLineMap(map$$1, ch, bias) {
            for (var node, start, end, collapse, mStart, mEnd, i = 0; i < map$$1.length; i += 3)
                if (mStart = map$$1[i], mEnd = map$$1[i + 1], ch < mStart ? (start = 0, end = 1, collapse = "left") : ch < mEnd ? (start = ch - mStart, end = start + 1) : (i == map$$1.length - 3 || ch == mEnd && map$$1[i + 3] > ch) && (end = mEnd - mStart, start = end - 1, ch >= mEnd && (collapse = "right")), null != start) {
                    if (node = map$$1[i + 2], mStart == mEnd && bias == (node.insertLeft ? "left" : "right") && (collapse = bias), "left" == bias && 0 == start)
                        for (; i && map$$1[i - 2] == map$$1[i - 3] && map$$1[i - 1].insertLeft;) node = map$$1[(i -= 3) + 2], collapse = "left";
                    if ("right" == bias && start == mEnd - mStart)
                        for (; i < map$$1.length - 3 && map$$1[i + 3] == map$$1[i + 4] && !map$$1[i + 5].insertLeft;) node = map$$1[(i += 3) + 2], collapse = "right";
                    break
                } return {
                node: node,
                start: start,
                end: end,
                collapse: collapse,
                coverStart: mStart,
                coverEnd: mEnd
            }
        }

        function getUsefulRect(rects, bias) {
            var rect = nullRect;
            if ("left" == bias)
                for (var i = 0; i < rects.length && (rect = rects[i]).left == rect.right; i++);
            else
                for (var i$1 = rects.length - 1; i$1 >= 0 && (rect = rects[i$1]).left == rect.right; i$1--);
            return rect
        }

        function measureCharInner(cm, prepared, ch, bias) {
            var rect, place = nodeAndOffsetInLineMap(prepared.map, ch, bias),
                node = place.node,
                start = place.start,
                end = place.end,
                collapse = place.collapse;
            if (3 == node.nodeType) {
                for (var i$1 = 0; i$1 < 4; i$1++) {
                    for (; start && isExtendingChar(prepared.line.text.charAt(place.coverStart + start));) --start;
                    for (; place.coverStart + end < place.coverEnd && isExtendingChar(prepared.line.text.charAt(place.coverStart + end));) ++end;
                    if (rect = ie && ie_version < 9 && 0 == start && end == place.coverEnd - place.coverStart ? node.parentNode.getBoundingClientRect() : getUsefulRect(range(node, start, end).getClientRects(), bias), rect.left || rect.right || 0 == start) break;
                    end = start, start -= 1, collapse = "right"
                }
                ie && ie_version < 11 && (rect = maybeUpdateRectForZooming(cm.display.measure, rect))
            } else {
                start > 0 && (collapse = bias = "right");
                var rects;
                rect = cm.options.lineWrapping && (rects = node.getClientRects()).length > 1 ? rects["right" == bias ? rects.length - 1 : 0] : node.getBoundingClientRect()
            }
            if (ie && ie_version < 9 && !start && (!rect || !rect.left && !rect.right)) {
                var rSpan = node.parentNode.getClientRects()[0];
                rect = rSpan ? {
                    left: rSpan.left,
                    right: rSpan.left + charWidth(cm.display),
                    top: rSpan.top,
                    bottom: rSpan.bottom
                } : nullRect
            }
            for (var rtop = rect.top - prepared.rect.top, rbot = rect.bottom - prepared.rect.top, mid = (rtop + rbot) / 2, heights = prepared.view.measure.heights, i = 0; i < heights.length - 1 && !(mid < heights[i]); i++);
            var top = i ? heights[i - 1] : 0,
                bot = heights[i],
                result = {
                    left: ("right" == collapse ? rect.right : rect.left) - prepared.rect.left,
                    right: ("left" == collapse ? rect.left : rect.right) - prepared.rect.left,
                    top: top,
                    bottom: bot
                };
            return rect.left || rect.right || (result.bogus = !0), cm.options.singleCursorHeightPerLine || (result.rtop = rtop, result.rbottom = rbot), result
        }

        function maybeUpdateRectForZooming(measure, rect) {
            if (!window.screen || null == screen.logicalXDPI || screen.logicalXDPI == screen.deviceXDPI || !hasBadZoomedRects(measure)) return rect;
            var scaleX = screen.logicalXDPI / screen.deviceXDPI,
                scaleY = screen.logicalYDPI / screen.deviceYDPI;
            return {
                left: rect.left * scaleX,
                right: rect.right * scaleX,
                top: rect.top * scaleY,
                bottom: rect.bottom * scaleY
            }
        }

        function clearLineMeasurementCacheFor(lineView) {
            if (lineView.measure && (lineView.measure.cache = {}, lineView.measure.heights = null, lineView.rest))
                for (var i = 0; i < lineView.rest.length; i++) lineView.measure.caches[i] = {}
        }

        function clearLineMeasurementCache(cm) {
            cm.display.externalMeasure = null, removeChildren(cm.display.lineMeasure);
            for (var i = 0; i < cm.display.view.length; i++) clearLineMeasurementCacheFor(cm.display.view[i])
        }

        function clearCaches(cm) {
            clearLineMeasurementCache(cm), cm.display.cachedCharWidth = cm.display.cachedTextHeight = cm.display.cachedPaddingH = null, cm.options.lineWrapping || (cm.display.maxLineChanged = !0), cm.display.lineNumChars = null
        }

        function pageScrollX() {
            return chrome && android ? -(document.body.getBoundingClientRect().left - parseInt(getComputedStyle(document.body).marginLeft)) : window.pageXOffset || (document.documentElement || document.body).scrollLeft
        }

        function pageScrollY() {
            return chrome && android ? -(document.body.getBoundingClientRect().top - parseInt(getComputedStyle(document.body).marginTop)) : window.pageYOffset || (document.documentElement || document.body).scrollTop
        }

        function widgetTopHeight(lineObj) {
            var height = 0;
            if (lineObj.widgets)
                for (var i = 0; i < lineObj.widgets.length; ++i) lineObj.widgets[i].above && (height += widgetHeight(lineObj.widgets[i]));
            return height
        }

        function intoCoordSystem(cm, lineObj, rect, context, includeWidgets) {
            if (!includeWidgets) {
                var height = widgetTopHeight(lineObj);
                rect.top += height, rect.bottom += height
            }
            if ("line" == context) return rect;
            context || (context = "local");
            var yOff = _heightAtLine(lineObj);
            if ("local" == context ? yOff += paddingTop(cm.display) : yOff -= cm.display.viewOffset, "page" == context || "window" == context) {
                var lOff = cm.display.lineSpace.getBoundingClientRect();
                yOff += lOff.top + ("window" == context ? 0 : pageScrollY());
                var xOff = lOff.left + ("window" == context ? 0 : pageScrollX());
                rect.left += xOff, rect.right += xOff
            }
            return rect.top += yOff, rect.bottom += yOff, rect
        }

        function fromCoordSystem(cm, coords, context) {
            if ("div" == context) return coords;
            var left = coords.left,
                top = coords.top;
            if ("page" == context) left -= pageScrollX(), top -= pageScrollY();
            else if ("local" == context || !context) {
                var localBox = cm.display.sizer.getBoundingClientRect();
                left += localBox.left, top += localBox.top
            }
            var lineSpaceBox = cm.display.lineSpace.getBoundingClientRect();
            return {
                left: left - lineSpaceBox.left,
                top: top - lineSpaceBox.top
            }
        }

        function _charCoords(cm, pos, context, lineObj, bias) {
            return lineObj || (lineObj = getLine(cm.doc, pos.line)), intoCoordSystem(cm, lineObj, measureChar(cm, lineObj, pos.ch, bias), context)
        }

        function _cursorCoords(cm, pos, context, lineObj, preparedMeasure, varHeight) {
            function get(ch, right) {
                var m = measureCharPrepared(cm, preparedMeasure, ch, right ? "right" : "left", varHeight);
                return right ? m.left = m.right : m.right = m.left, intoCoordSystem(cm, lineObj, m, context)
            }

            function getBidi(ch, partPos, invert) {
                var part = order[partPos],
                    right = 1 == part.level;
                return get(invert ? ch - 1 : ch, right != invert)
            }
            lineObj = lineObj || getLine(cm.doc, pos.line), preparedMeasure || (preparedMeasure = prepareMeasureForLine(cm, lineObj));
            var order = getOrder(lineObj, cm.doc.direction),
                ch = pos.ch,
                sticky = pos.sticky;
            if (ch >= lineObj.text.length ? (ch = lineObj.text.length, sticky = "before") : ch <= 0 && (ch = 0, sticky = "after"), !order) return get("before" == sticky ? ch - 1 : ch, "before" == sticky);
            var partPos = getBidiPartAt(order, ch, sticky),
                other = bidiOther,
                val = getBidi(ch, partPos, "before" == sticky);
            return null != other && (val.other = getBidi(ch, other, "before" != sticky)), val
        }

        function estimateCoords(cm, pos) {
            var left = 0;
            pos = _clipPos(cm.doc, pos), cm.options.lineWrapping || (left = charWidth(cm.display) * pos.ch);
            var lineObj = getLine(cm.doc, pos.line),
                top = _heightAtLine(lineObj) + paddingTop(cm.display);
            return {
                left: left,
                right: left,
                top: top,
                bottom: top + lineObj.height
            }
        }

        function PosWithInfo(line, ch, sticky, outside, xRel) {
            var pos = Pos(line, ch, sticky);
            return pos.xRel = xRel, outside && (pos.outside = !0), pos
        }

        function _coordsChar(cm, x, y) {
            var doc = cm.doc;
            if (y += cm.display.viewOffset, y < 0) return PosWithInfo(doc.first, 0, null, !0, -1);
            var lineN = _lineAtHeight(doc, y),
                last = doc.first + doc.size - 1;
            if (lineN > last) return PosWithInfo(doc.first + doc.size - 1, getLine(doc, last).text.length, null, !0, 1);
            x < 0 && (x = 0);
            for (var lineObj = getLine(doc, lineN);;) {
                var found = coordsCharInner(cm, lineObj, lineN, x, y),
                    merged = collapsedSpanAtEnd(lineObj),
                    mergedPos = merged && merged.find(0, !0);
                if (!merged || !(found.ch > mergedPos.from.ch || found.ch == mergedPos.from.ch && found.xRel > 0)) return found;
                lineN = lineNo(lineObj = mergedPos.to.line)
            }
        }

        function wrappedLineExtent(cm, lineObj, preparedMeasure, y) {
            y -= widgetTopHeight(lineObj);
            var end = lineObj.text.length,
                begin = findFirst(function(ch) {
                    return measureCharPrepared(cm, preparedMeasure, ch - 1).bottom <= y
                }, end, 0);
            return end = findFirst(function(ch) {
                return measureCharPrepared(cm, preparedMeasure, ch).top > y
            }, begin, end), {
                begin: begin,
                end: end
            }
        }

        function wrappedLineExtentChar(cm, lineObj, preparedMeasure, target) {
            preparedMeasure || (preparedMeasure = prepareMeasureForLine(cm, lineObj));
            var targetTop = intoCoordSystem(cm, lineObj, measureCharPrepared(cm, preparedMeasure, target), "line").top;
            return wrappedLineExtent(cm, lineObj, preparedMeasure, targetTop)
        }

        function boxIsAfter(box, x, y, left) {
            return !(box.bottom <= y) && (box.top > y || (left ? box.left : box.right) > x)
        }

        function coordsCharInner(cm, lineObj, lineNo$$1, x, y) {
            y -= _heightAtLine(lineObj);
            var preparedMeasure = prepareMeasureForLine(cm, lineObj),
                widgetHeight$$1 = widgetTopHeight(lineObj),
                begin = 0,
                end = lineObj.text.length,
                ltr = !0,
                order = getOrder(lineObj, cm.doc.direction);
            if (order) {
                var part = (cm.options.lineWrapping ? coordsBidiPartWrapped : coordsBidiPart)(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y);
                ltr = 1 != part.level, begin = ltr ? part.from : part.to - 1, end = ltr ? part.to : part.from - 1
            }
            var baseX, sticky, chAround = null,
                boxAround = null,
                ch = findFirst(function(ch) {
                    var box = measureCharPrepared(cm, preparedMeasure, ch);
                    return box.top += widgetHeight$$1, box.bottom += widgetHeight$$1, !!boxIsAfter(box, x, y, !1) && (box.top <= y && box.left <= x && (chAround = ch, boxAround = box), !0)
                }, begin, end),
                outside = !1;
            if (boxAround) {
                var atLeft = x - boxAround.left < boxAround.right - x,
                    atStart = atLeft == ltr;
                ch = chAround + (atStart ? 0 : 1), sticky = atStart ? "after" : "before", baseX = atLeft ? boxAround.left : boxAround.right
            } else {
                ltr || ch != end && ch != begin || ch++, sticky = 0 == ch ? "after" : ch == lineObj.text.length ? "before" : measureCharPrepared(cm, preparedMeasure, ch - (ltr ? 1 : 0)).bottom + widgetHeight$$1 <= y == ltr ? "after" : "before";
                var coords = _cursorCoords(cm, Pos(lineNo$$1, ch, sticky), "line", lineObj, preparedMeasure);
                baseX = coords.left, outside = y < coords.top || y >= coords.bottom
            }
            return ch = skipExtendingChars(lineObj.text, ch, 1), PosWithInfo(lineNo$$1, ch, sticky, outside, x - baseX)
        }

        function coordsBidiPart(cm, lineObj, lineNo$$1, preparedMeasure, order, x, y) {
            var index = findFirst(function(i) {
                    var part = order[i],
                        ltr = 1 != part.level;
                    return boxIsAfter(_cursorCoords(cm, Pos(lineNo$$1, ltr ? part.to : part.from, ltr ? "before" : "after"), "line", lineObj, preparedMeasure), x, y, !0)
                }, 0, order.length - 1),
                part = order[index];
            if (index > 0) {
                var ltr = 1 != part.level,
                    start = _cursorCoords(cm, Pos(lineNo$$1, ltr ? part.from : part.to, ltr ? "after" : "before"), "line", lineObj, preparedMeasure);
                boxIsAfter(start, x, y, !0) && start.top > y && (part = order[index - 1])
            }
            return part
        }

        function coordsBidiPartWrapped(cm, lineObj, _lineNo, preparedMeasure, order, x, y) {
            var ref = wrappedLineExtent(cm, lineObj, preparedMeasure, y),
                begin = ref.begin,
                end = ref.end;
            /\s/.test(lineObj.text.charAt(end - 1)) && end--;
            for (var part = null, closestDist = null, i = 0; i < order.length; i++) {
                var p = order[i];
                if (!(p.from >= end || p.to <= begin)) {
                    var ltr = 1 != p.level,
                        endX = measureCharPrepared(cm, preparedMeasure, ltr ? Math.min(end, p.to) - 1 : Math.max(begin, p.from)).right,
                        dist = endX < x ? x - endX + 1e9 : endX - x;
                    (!part || closestDist > dist) && (part = p, closestDist = dist)
                }
            }
            return part || (part = order[order.length - 1]), part.from < begin && (part = {
                from: begin,
                to: part.to,
                level: part.level
            }), part.to > end && (part = {
                from: part.from,
                to: end,
                level: part.level
            }), part
        }

        function textHeight(display) {
            if (null != display.cachedTextHeight) return display.cachedTextHeight;
            if (null == measureText) {
                measureText = elt("pre");
                for (var i = 0; i < 49; ++i) measureText.appendChild(document.createTextNode("x")), measureText.appendChild(elt("br"));
                measureText.appendChild(document.createTextNode("x"))
            }
            removeChildrenAndAdd(display.measure, measureText);
            var height = measureText.offsetHeight / 50;
            return height > 3 && (display.cachedTextHeight = height), removeChildren(display.measure), height || 1
        }

        function charWidth(display) {
            if (null != display.cachedCharWidth) return display.cachedCharWidth;
            var anchor = elt("span", "xxxxxxxxxx"),
                pre = elt("pre", [anchor]);
            removeChildrenAndAdd(display.measure, pre);
            var rect = anchor.getBoundingClientRect(),
                width = (rect.right - rect.left) / 10;
            return width > 2 && (display.cachedCharWidth = width), width || 10
        }

        function getDimensions(cm) {
            for (var d = cm.display, left = {}, width = {}, gutterLeft = d.gutters.clientLeft, n = d.gutters.firstChild, i = 0; n; n = n.nextSibling, ++i) left[cm.options.gutters[i]] = n.offsetLeft + n.clientLeft + gutterLeft, width[cm.options.gutters[i]] = n.clientWidth;
            return {
                fixedPos: compensateForHScroll(d),
                gutterTotalWidth: d.gutters.offsetWidth,
                gutterLeft: left,
                gutterWidth: width,
                wrapperWidth: d.wrapper.clientWidth
            }
        }

        function compensateForHScroll(display) {
            return display.scroller.getBoundingClientRect().left - display.sizer.getBoundingClientRect().left
        }

        function estimateHeight(cm) {
            var th = textHeight(cm.display),
                wrapping = cm.options.lineWrapping,
                perLine = wrapping && Math.max(5, cm.display.scroller.clientWidth / charWidth(cm.display) - 3);
            return function(line) {
                if (lineIsHidden(cm.doc, line)) return 0;
                var widgetsHeight = 0;
                if (line.widgets)
                    for (var i = 0; i < line.widgets.length; i++) line.widgets[i].height && (widgetsHeight += line.widgets[i].height);
                return wrapping ? widgetsHeight + (Math.ceil(line.text.length / perLine) || 1) * th : widgetsHeight + th
            }
        }

        function estimateLineHeights(cm) {
            var doc = cm.doc,
                est = estimateHeight(cm);
            doc.iter(function(line) {
                var estHeight = est(line);
                estHeight != line.height && updateLineHeight(line, estHeight)
            })
        }

        function posFromMouse(cm, e, liberal, forRect) {
            var display = cm.display;
            if (!liberal && "true" == e_target(e).getAttribute("cm-not-content")) return null;
            var x, y, space = display.lineSpace.getBoundingClientRect();
            try {
                x = e.clientX - space.left, y = e.clientY - space.top
            } catch (e) {
                return null
            }
            var line, coords = _coordsChar(cm, x, y);
            if (forRect && 1 == coords.xRel && (line = getLine(cm.doc, coords.line).text).length == coords.ch) {
                var colDiff = countColumn(line, line.length, cm.options.tabSize) - line.length;
                coords = Pos(coords.line, Math.max(0, Math.round((x - paddingH(cm.display).left) / charWidth(cm.display)) - colDiff))
            }
            return coords
        }

        function findViewIndex(cm, n) {
            if (n >= cm.display.viewTo) return null;
            if (n -= cm.display.viewFrom, n < 0) return null;
            for (var view = cm.display.view, i = 0; i < view.length; i++)
                if (n -= view[i].size, n < 0) return i
        }

        function updateSelection(cm) {
            cm.display.input.showSelection(cm.display.input.prepareSelection())
        }

        function prepareSelection(cm, primary) {
            void 0 === primary && (primary = !0);
            for (var doc = cm.doc, result = {}, curFragment = result.cursors = document.createDocumentFragment(), selFragment = result.selection = document.createDocumentFragment(), i = 0; i < doc.sel.ranges.length; i++)
                if (primary || i != doc.sel.primIndex) {
                    var range$$1 = doc.sel.ranges[i];
                    if (!(range$$1.from().line >= cm.display.viewTo || range$$1.to().line < cm.display.viewFrom)) {
                        var collapsed = range$$1.empty();
                        (collapsed || cm.options.showCursorWhenSelecting) && drawSelectionCursor(cm, range$$1.head, curFragment), collapsed || drawSelectionRange(cm, range$$1, selFragment)
                    }
                } return result
        }

        function drawSelectionCursor(cm, head, output) {
            var pos = _cursorCoords(cm, head, "div", null, null, !cm.options.singleCursorHeightPerLine),
                cursor = output.appendChild(elt("div", "", "CodeMirror-cursor"));
            if (cursor.style.left = pos.left + "px", cursor.style.top = pos.top + "px", cursor.style.height = Math.max(0, pos.bottom - pos.top) * cm.options.cursorHeight + "px", pos.other) {
                var otherCursor = output.appendChild(elt("div", "", "CodeMirror-cursor CodeMirror-secondarycursor"));
                otherCursor.style.display = "", otherCursor.style.left = pos.other.left + "px", otherCursor.style.top = pos.other.top + "px", otherCursor.style.height = .85 * (pos.other.bottom - pos.other.top) + "px"
            }
        }

        function cmpCoords(a, b) {
            return a.top - b.top || a.left - b.left
        }

        function drawSelectionRange(cm, range$$1, output) {
            function add(left, top, width, bottom) {
                top < 0 && (top = 0), top = Math.round(top), bottom = Math.round(bottom), fragment.appendChild(elt("div", null, "CodeMirror-selected", "position: absolute; left: " + left + "px;\n                             top: " + top + "px; width: " + (null == width ? rightSide - left : width) + "px;\n                             height: " + (bottom - top) + "px"))
            }

            function drawForLine(line, fromArg, toArg) {
                function coords(ch, bias) {
                    return _charCoords(cm, Pos(line, ch), "div", lineObj, bias)
                }

                function wrapX(pos, dir, side) {
                    var extent = wrappedLineExtentChar(cm, lineObj, null, pos),
                        prop = "ltr" == dir == ("after" == side) ? "left" : "right",
                        ch = "after" == side ? extent.begin : extent.end - (/\s/.test(lineObj.text.charAt(extent.end - 1)) ? 2 : 1);
                    return coords(ch, prop)[prop]
                }
                var start, end, lineObj = getLine(doc, line),
                    lineLen = lineObj.text.length,
                    order = getOrder(lineObj, doc.direction);
                return iterateBidiSections(order, fromArg || 0, null == toArg ? lineLen : toArg, function(from, to, dir, i) {
                    var ltr = "ltr" == dir,
                        fromPos = coords(from, ltr ? "left" : "right"),
                        toPos = coords(to - 1, ltr ? "right" : "left"),
                        openStart = null == fromArg && 0 == from,
                        openEnd = null == toArg && to == lineLen,
                        first = 0 == i,
                        last = !order || i == order.length - 1;
                    if (toPos.top - fromPos.top <= 3) {
                        var openLeft = (docLTR ? openStart : openEnd) && first,
                            openRight = (docLTR ? openEnd : openStart) && last,
                            left = openLeft ? leftSide : (ltr ? fromPos : toPos).left,
                            right = openRight ? rightSide : (ltr ? toPos : fromPos).right;
                        add(left, fromPos.top, right - left, fromPos.bottom)
                    } else {
                        var topLeft, topRight, botLeft, botRight;
                        ltr ? (topLeft = docLTR && openStart && first ? leftSide : fromPos.left, topRight = docLTR ? rightSide : wrapX(from, dir, "before"), botLeft = docLTR ? leftSide : wrapX(to, dir, "after"), botRight = docLTR && openEnd && last ? rightSide : toPos.right) : (topLeft = docLTR ? wrapX(from, dir, "before") : leftSide, topRight = !docLTR && openStart && first ? rightSide : fromPos.right, botLeft = !docLTR && openEnd && last ? leftSide : toPos.left, botRight = docLTR ? wrapX(to, dir, "after") : rightSide), add(topLeft, fromPos.top, topRight - topLeft, fromPos.bottom), fromPos.bottom < toPos.top && add(leftSide, fromPos.bottom, null, toPos.top), add(botLeft, toPos.top, botRight - botLeft, toPos.bottom)
                    }(!start || cmpCoords(fromPos, start) < 0) && (start = fromPos), cmpCoords(toPos, start) < 0 && (start = toPos), (!end || cmpCoords(fromPos, end) < 0) && (end = fromPos), cmpCoords(toPos, end) < 0 && (end = toPos)
                }), {
                    start: start,
                    end: end
                }
            }
            var display = cm.display,
                doc = cm.doc,
                fragment = document.createDocumentFragment(),
                padding = paddingH(cm.display),
                leftSide = padding.left,
                rightSide = Math.max(display.sizerWidth, displayWidth(cm) - display.sizer.offsetLeft) - padding.right,
                docLTR = "ltr" == doc.direction,
                sFrom = range$$1.from(),
                sTo = range$$1.to();
            if (sFrom.line == sTo.line) drawForLine(sFrom.line, sFrom.ch, sTo.ch);
            else {
                var fromLine = getLine(doc, sFrom.line),
                    toLine = getLine(doc, sTo.line),
                    singleVLine = visualLine(fromLine) == visualLine(toLine),
                    leftEnd = drawForLine(sFrom.line, sFrom.ch, singleVLine ? fromLine.text.length + 1 : null).end,
                    rightStart = drawForLine(sTo.line, singleVLine ? 0 : null, sTo.ch).start;
                singleVLine && (leftEnd.top < rightStart.top - 2 ? (add(leftEnd.right, leftEnd.top, null, leftEnd.bottom), add(leftSide, rightStart.top, rightStart.left, rightStart.bottom)) : add(leftEnd.right, leftEnd.top, rightStart.left - leftEnd.right, leftEnd.bottom)), leftEnd.bottom < rightStart.top && add(leftSide, leftEnd.bottom, null, rightStart.top)
            }
            output.appendChild(fragment)
        }

        function restartBlink(cm) {
            if (cm.state.focused) {
                var display = cm.display;
                clearInterval(display.blinker);
                var on = !0;
                display.cursorDiv.style.visibility = "", cm.options.cursorBlinkRate > 0 ? display.blinker = setInterval(function() {
                    return display.cursorDiv.style.visibility = (on = !on) ? "" : "hidden"
                }, cm.options.cursorBlinkRate) : cm.options.cursorBlinkRate < 0 && (display.cursorDiv.style.visibility = "hidden")
            }
        }

        function ensureFocus(cm) {
            cm.state.focused || (cm.display.input.focus(), onFocus(cm))
        }

        function delayBlurEvent(cm) {
            cm.state.delayingBlurEvent = !0, setTimeout(function() {
                cm.state.delayingBlurEvent && (cm.state.delayingBlurEvent = !1, onBlur(cm))
            }, 100)
        }

        function onFocus(cm, e) {
            cm.state.delayingBlurEvent && (cm.state.delayingBlurEvent = !1), "nocursor" != cm.options.readOnly && (cm.state.focused || (signal(cm, "focus", cm, e), cm.state.focused = !0, addClass(cm.display.wrapper, "CodeMirror-focused"), cm.curOp || cm.display.selForContextMenu == cm.doc.sel || (cm.display.input.reset(), webkit && setTimeout(function() {
                return cm.display.input.reset(!0)
            }, 20)), cm.display.input.receivedFocus()), restartBlink(cm))
        }

        function onBlur(cm, e) {
            cm.state.delayingBlurEvent || (cm.state.focused && (signal(cm, "blur", cm, e), cm.state.focused = !1, rmClass(cm.display.wrapper, "CodeMirror-focused")), clearInterval(cm.display.blinker), setTimeout(function() {
                cm.state.focused || (cm.display.shift = !1)
            }, 150))
        }

        function updateHeightsInViewport(cm) {
            for (var display = cm.display, prevBottom = display.lineDiv.offsetTop, i = 0; i < display.view.length; i++) {
                var cur = display.view[i],
                    height = void 0;
                if (!cur.hidden) {
                    if (ie && ie_version < 8) {
                        var bot = cur.node.offsetTop + cur.node.offsetHeight;
                        height = bot - prevBottom, prevBottom = bot
                    } else {
                        var box = cur.node.getBoundingClientRect();
                        height = box.bottom - box.top
                    }
                    var diff = cur.line.height - height;
                    if (height < 2 && (height = textHeight(display)), (diff > .005 || diff < -.005) && (updateLineHeight(cur.line, height), updateWidgetHeight(cur.line), cur.rest))
                        for (var j = 0; j < cur.rest.length; j++) updateWidgetHeight(cur.rest[j])
                }
            }
        }

        function updateWidgetHeight(line) {
            if (line.widgets)
                for (var i = 0; i < line.widgets.length; ++i) {
                    var w = line.widgets[i],
                        parent = w.node.parentNode;
                    parent && (w.height = parent.offsetHeight)
                }
        }

        function visibleLines(display, doc, viewport) {
            var top = viewport && null != viewport.top ? Math.max(0, viewport.top) : display.scroller.scrollTop;
            top = Math.floor(top - paddingTop(display));
            var bottom = viewport && null != viewport.bottom ? viewport.bottom : top + display.wrapper.clientHeight,
                from = _lineAtHeight(doc, top),
                to = _lineAtHeight(doc, bottom);
            if (viewport && viewport.ensure) {
                var ensureFrom = viewport.ensure.from.line,
                    ensureTo = viewport.ensure.to.line;
                ensureFrom < from ? (from = ensureFrom, to = _lineAtHeight(doc, _heightAtLine(getLine(doc, ensureFrom)) + display.wrapper.clientHeight)) : Math.min(ensureTo, doc.lastLine()) >= to && (from = _lineAtHeight(doc, _heightAtLine(getLine(doc, ensureTo)) - display.wrapper.clientHeight), to = ensureTo)
            }
            return {
                from: from,
                to: Math.max(to, from + 1)
            }
        }

        function alignHorizontally(cm) {
            var display = cm.display,
                view = display.view;
            if (display.alignWidgets || display.gutters.firstChild && cm.options.fixedGutter) {
                for (var comp = compensateForHScroll(display) - display.scroller.scrollLeft + cm.doc.scrollLeft, gutterW = display.gutters.offsetWidth, left = comp + "px", i = 0; i < view.length; i++)
                    if (!view[i].hidden) {
                        cm.options.fixedGutter && (view[i].gutter && (view[i].gutter.style.left = left), view[i].gutterBackground && (view[i].gutterBackground.style.left = left));
                        var align = view[i].alignable;
                        if (align)
                            for (var j = 0; j < align.length; j++) align[j].style.left = left
                    } cm.options.fixedGutter && (display.gutters.style.left = comp + gutterW + "px")
            }
        }

        function maybeUpdateLineNumberWidth(cm) {
            if (!cm.options.lineNumbers) return !1;
            var doc = cm.doc,
                last = lineNumberFor(cm.options, doc.first + doc.size - 1),
                display = cm.display;
            if (last.length != display.lineNumChars) {
                var test = display.measure.appendChild(elt("div", [elt("div", last)], "CodeMirror-linenumber CodeMirror-gutter-elt")),
                    innerW = test.firstChild.offsetWidth,
                    padding = test.offsetWidth - innerW;
                return display.lineGutter.style.width = "", display.lineNumInnerWidth = Math.max(innerW, display.lineGutter.offsetWidth - padding) + 1, display.lineNumWidth = display.lineNumInnerWidth + padding, display.lineNumChars = display.lineNumInnerWidth ? last.length : -1, display.lineGutter.style.width = display.lineNumWidth + "px", updateGutterSpace(cm), !0
            }
            return !1
        }

        function maybeScrollWindow(cm, rect) {
            if (!signalDOMEvent(cm, "scrollCursorIntoView")) {
                var display = cm.display,
                    box = display.sizer.getBoundingClientRect(),
                    doScroll = null;
                if (rect.top + box.top < 0 ? doScroll = !0 : rect.bottom + box.top > (window.innerHeight || document.documentElement.clientHeight) && (doScroll = !1), null != doScroll && !phantom) {
                    var scrollNode = elt("div", "", null, "position: absolute;\n                         top: " + (rect.top - display.viewOffset - paddingTop(cm.display)) + "px;\n                         height: " + (rect.bottom - rect.top + scrollGap(cm) + display.barHeight) + "px;\n                         left: " + rect.left + "px; width: " + Math.max(2, rect.right - rect.left) + "px;");
                    cm.display.lineSpace.appendChild(scrollNode), scrollNode.scrollIntoView(doScroll), cm.display.lineSpace.removeChild(scrollNode)
                }
            }
        }

        function scrollPosIntoView(cm, pos, end, margin) {
            null == margin && (margin = 0);
            var rect;
            cm.options.lineWrapping || pos != end || (pos = pos.ch ? Pos(pos.line, "before" == pos.sticky ? pos.ch - 1 : pos.ch, "after") : pos, end = "before" == pos.sticky ? Pos(pos.line, pos.ch + 1, "before") : pos);
            for (var limit = 0; limit < 5; limit++) {
                var changed = !1,
                    coords = _cursorCoords(cm, pos),
                    endCoords = end && end != pos ? _cursorCoords(cm, end) : coords;
                rect = {
                    left: Math.min(coords.left, endCoords.left),
                    top: Math.min(coords.top, endCoords.top) - margin,
                    right: Math.max(coords.left, endCoords.left),
                    bottom: Math.max(coords.bottom, endCoords.bottom) + margin
                };
                var scrollPos = calculateScrollPos(cm, rect),
                    startTop = cm.doc.scrollTop,
                    startLeft = cm.doc.scrollLeft;
                if (null != scrollPos.scrollTop && (updateScrollTop(cm, scrollPos.scrollTop), Math.abs(cm.doc.scrollTop - startTop) > 1 && (changed = !0)), null != scrollPos.scrollLeft && (setScrollLeft(cm, scrollPos.scrollLeft), Math.abs(cm.doc.scrollLeft - startLeft) > 1 && (changed = !0)), !changed) break
            }
            return rect
        }

        function scrollIntoView(cm, rect) {
            var scrollPos = calculateScrollPos(cm, rect);
            null != scrollPos.scrollTop && updateScrollTop(cm, scrollPos.scrollTop), null != scrollPos.scrollLeft && setScrollLeft(cm, scrollPos.scrollLeft)
        }

        function calculateScrollPos(cm, rect) {
            var display = cm.display,
                snapMargin = textHeight(cm.display);
            rect.top < 0 && (rect.top = 0);
            var screentop = cm.curOp && null != cm.curOp.scrollTop ? cm.curOp.scrollTop : display.scroller.scrollTop,
                screen = displayHeight(cm),
                result = {};
            rect.bottom - rect.top > screen && (rect.bottom = rect.top + screen);
            var docBottom = cm.doc.height + paddingVert(display),
                atTop = rect.top < snapMargin,
                atBottom = rect.bottom > docBottom - snapMargin;
            if (rect.top < screentop) result.scrollTop = atTop ? 0 : rect.top;
            else if (rect.bottom > screentop + screen) {
                var newTop = Math.min(rect.top, (atBottom ? docBottom : rect.bottom) - screen);
                newTop != screentop && (result.scrollTop = newTop)
            }
            var screenleft = cm.curOp && null != cm.curOp.scrollLeft ? cm.curOp.scrollLeft : display.scroller.scrollLeft,
                screenw = displayWidth(cm) - (cm.options.fixedGutter ? display.gutters.offsetWidth : 0),
                tooWide = rect.right - rect.left > screenw;
            return tooWide && (rect.right = rect.left + screenw), rect.left < 10 ? result.scrollLeft = 0 : rect.left < screenleft ? result.scrollLeft = Math.max(0, rect.left - (tooWide ? 0 : 10)) : rect.right > screenw + screenleft - 3 && (result.scrollLeft = rect.right + (tooWide ? 0 : 10) - screenw), result
        }

        function addToScrollTop(cm, top) {
            null != top && (resolveScrollToPos(cm), cm.curOp.scrollTop = (null == cm.curOp.scrollTop ? cm.doc.scrollTop : cm.curOp.scrollTop) + top)
        }

        function ensureCursorVisible(cm) {
            resolveScrollToPos(cm);
            var cur = cm.getCursor();
            cm.curOp.scrollToPos = {
                from: cur,
                to: cur,
                margin: cm.options.cursorScrollMargin
            }
        }

        function scrollToCoords(cm, x, y) {
            null == x && null == y || resolveScrollToPos(cm), null != x && (cm.curOp.scrollLeft = x), null != y && (cm.curOp.scrollTop = y)
        }

        function scrollToRange(cm, range$$1) {
            resolveScrollToPos(cm), cm.curOp.scrollToPos = range$$1
        }

        function resolveScrollToPos(cm) {
            var range$$1 = cm.curOp.scrollToPos;
            if (range$$1) {
                cm.curOp.scrollToPos = null;
                var from = estimateCoords(cm, range$$1.from),
                    to = estimateCoords(cm, range$$1.to);
                scrollToCoordsRange(cm, from, to, range$$1.margin)
            }
        }

        function scrollToCoordsRange(cm, from, to, margin) {
            var sPos = calculateScrollPos(cm, {
                left: Math.min(from.left, to.left),
                top: Math.min(from.top, to.top) - margin,
                right: Math.max(from.right, to.right),
                bottom: Math.max(from.bottom, to.bottom) + margin
            });
            scrollToCoords(cm, sPos.scrollLeft, sPos.scrollTop)
        }

        function updateScrollTop(cm, val) {
            Math.abs(cm.doc.scrollTop - val) < 2 || (gecko || updateDisplaySimple(cm, {
                top: val
            }), setScrollTop(cm, val, !0), gecko && updateDisplaySimple(cm), startWorker(cm, 100))
        }

        function setScrollTop(cm, val, forceScroll) {
            val = Math.min(cm.display.scroller.scrollHeight - cm.display.scroller.clientHeight, val), (cm.display.scroller.scrollTop != val || forceScroll) && (cm.doc.scrollTop = val, cm.display.scrollbars.setScrollTop(val), cm.display.scroller.scrollTop != val && (cm.display.scroller.scrollTop = val))
        }

        function setScrollLeft(cm, val, isScroller, forceScroll) {
            val = Math.min(val, cm.display.scroller.scrollWidth - cm.display.scroller.clientWidth), (isScroller ? val == cm.doc.scrollLeft : Math.abs(cm.doc.scrollLeft - val) < 2) && !forceScroll || (cm.doc.scrollLeft = val, alignHorizontally(cm), cm.display.scroller.scrollLeft != val && (cm.display.scroller.scrollLeft = val), cm.display.scrollbars.setScrollLeft(val))
        }

        function measureForScrollbars(cm) {
            var d = cm.display,
                gutterW = d.gutters.offsetWidth,
                docH = Math.round(cm.doc.height + paddingVert(cm.display));
            return {
                clientHeight: d.scroller.clientHeight,
                viewHeight: d.wrapper.clientHeight,
                scrollWidth: d.scroller.scrollWidth,
                clientWidth: d.scroller.clientWidth,
                viewWidth: d.wrapper.clientWidth,
                barLeft: cm.options.fixedGutter ? gutterW : 0,
                docHeight: docH,
                scrollHeight: docH + scrollGap(cm) + d.barHeight,
                nativeBarWidth: d.nativeBarWidth,
                gutterWidth: gutterW
            }
        }

        function updateScrollbars(cm, measure) {
            measure || (measure = measureForScrollbars(cm));
            var startWidth = cm.display.barWidth,
                startHeight = cm.display.barHeight;
            updateScrollbarsInner(cm, measure);
            for (var i = 0; i < 4 && startWidth != cm.display.barWidth || startHeight != cm.display.barHeight; i++) startWidth != cm.display.barWidth && cm.options.lineWrapping && updateHeightsInViewport(cm), updateScrollbarsInner(cm, measureForScrollbars(cm)), startWidth = cm.display.barWidth, startHeight = cm.display.barHeight
        }

        function updateScrollbarsInner(cm, measure) {
            var d = cm.display,
                sizes = d.scrollbars.update(measure);
            d.sizer.style.paddingRight = (d.barWidth = sizes.right) + "px", d.sizer.style.paddingBottom = (d.barHeight = sizes.bottom) + "px", d.heightForcer.style.borderBottom = sizes.bottom + "px solid transparent", sizes.right && sizes.bottom ? (d.scrollbarFiller.style.display = "block", d.scrollbarFiller.style.height = sizes.bottom + "px", d.scrollbarFiller.style.width = sizes.right + "px") : d.scrollbarFiller.style.display = "", sizes.bottom && cm.options.coverGutterNextToScrollbar && cm.options.fixedGutter ? (d.gutterFiller.style.display = "block", d.gutterFiller.style.height = sizes.bottom + "px", d.gutterFiller.style.width = measure.gutterWidth + "px") : d.gutterFiller.style.display = ""
        }

        function initScrollbars(cm) {
            cm.display.scrollbars && (cm.display.scrollbars.clear(), cm.display.scrollbars.addClass && rmClass(cm.display.wrapper, cm.display.scrollbars.addClass)), cm.display.scrollbars = new scrollbarModel[cm.options.scrollbarStyle](function(node) {
                cm.display.wrapper.insertBefore(node, cm.display.scrollbarFiller), on(node, "mousedown", function() {
                    cm.state.focused && setTimeout(function() {
                        return cm.display.input.focus()
                    }, 0)
                }), node.setAttribute("cm-not-content", "true")
            }, function(pos, axis) {
                "horizontal" == axis ? setScrollLeft(cm, pos) : updateScrollTop(cm, pos)
            }, cm), cm.display.scrollbars.addClass && addClass(cm.display.wrapper, cm.display.scrollbars.addClass)
        }

        function _startOperation(cm) {
            cm.curOp = {
                cm: cm,
                viewChanged: !1,
                startHeight: cm.doc.height,
                forceUpdate: !1,
                updateInput: null,
                typing: !1,
                changeObjs: null,
                cursorActivityHandlers: null,
                cursorActivityCalled: 0,
                selectionChanged: !1,
                updateMaxLine: !1,
                scrollLeft: null,
                scrollTop: null,
                scrollToPos: null,
                focus: !1,
                id: ++nextOpId
            }, pushOperation(cm.curOp)
        }

        function _endOperation(cm) {
            var op = cm.curOp;
            finishOperation(op, function(group) {
                for (var i = 0; i < group.ops.length; i++) group.ops[i].cm.curOp = null;
                endOperations(group)
            })
        }

        function endOperations(group) {
            for (var ops = group.ops, i = 0; i < ops.length; i++) endOperation_R1(ops[i]);
            for (var i$1 = 0; i$1 < ops.length; i$1++) endOperation_W1(ops[i$1]);
            for (var i$2 = 0; i$2 < ops.length; i$2++) endOperation_R2(ops[i$2]);
            for (var i$3 = 0; i$3 < ops.length; i$3++) endOperation_W2(ops[i$3]);
            for (var i$4 = 0; i$4 < ops.length; i$4++) endOperation_finish(ops[i$4])
        }

        function endOperation_R1(op) {
            var cm = op.cm,
                display = cm.display;
            maybeClipScrollbars(cm), op.updateMaxLine && findMaxLine(cm), op.mustUpdate = op.viewChanged || op.forceUpdate || null != op.scrollTop || op.scrollToPos && (op.scrollToPos.from.line < display.viewFrom || op.scrollToPos.to.line >= display.viewTo) || display.maxLineChanged && cm.options.lineWrapping, op.update = op.mustUpdate && new DisplayUpdate(cm, op.mustUpdate && {
                top: op.scrollTop,
                ensure: op.scrollToPos
            }, op.forceUpdate)
        }

        function endOperation_W1(op) {
            op.updatedDisplay = op.mustUpdate && updateDisplayIfNeeded(op.cm, op.update)
        }

        function endOperation_R2(op) {
            var cm = op.cm,
                display = cm.display;
            op.updatedDisplay && updateHeightsInViewport(cm), op.barMeasure = measureForScrollbars(cm), display.maxLineChanged && !cm.options.lineWrapping && (op.adjustWidthTo = measureChar(cm, display.maxLine, display.maxLine.text.length).left + 3, cm.display.sizerWidth = op.adjustWidthTo, op.barMeasure.scrollWidth = Math.max(display.scroller.clientWidth, display.sizer.offsetLeft + op.adjustWidthTo + scrollGap(cm) + cm.display.barWidth), op.maxScrollLeft = Math.max(0, display.sizer.offsetLeft + op.adjustWidthTo - displayWidth(cm))), (op.updatedDisplay || op.selectionChanged) && (op.preparedSelection = display.input.prepareSelection())
        }

        function endOperation_W2(op) {
            var cm = op.cm;
            null != op.adjustWidthTo && (cm.display.sizer.style.minWidth = op.adjustWidthTo + "px", op.maxScrollLeft < cm.doc.scrollLeft && setScrollLeft(cm, Math.min(cm.display.scroller.scrollLeft, op.maxScrollLeft), !0), cm.display.maxLineChanged = !1);
            var takeFocus = op.focus && op.focus == activeElt();
            op.preparedSelection && cm.display.input.showSelection(op.preparedSelection, takeFocus), (op.updatedDisplay || op.startHeight != cm.doc.height) && updateScrollbars(cm, op.barMeasure), op.updatedDisplay && setDocumentHeight(cm, op.barMeasure), op.selectionChanged && restartBlink(cm), cm.state.focused && op.updateInput && cm.display.input.reset(op.typing), takeFocus && ensureFocus(op.cm)
        }

        function endOperation_finish(op) {
            var cm = op.cm,
                display = cm.display,
                doc = cm.doc;
            if (op.updatedDisplay && postUpdateDisplay(cm, op.update), null == display.wheelStartX || null == op.scrollTop && null == op.scrollLeft && !op.scrollToPos || (display.wheelStartX = display.wheelStartY = null), null != op.scrollTop && setScrollTop(cm, op.scrollTop, op.forceScroll), null != op.scrollLeft && setScrollLeft(cm, op.scrollLeft, !0, !0), op.scrollToPos) {
                var rect = scrollPosIntoView(cm, _clipPos(doc, op.scrollToPos.from), _clipPos(doc, op.scrollToPos.to), op.scrollToPos.margin);
                maybeScrollWindow(cm, rect)
            }
            var hidden = op.maybeHiddenMarkers,
                unhidden = op.maybeUnhiddenMarkers;
            if (hidden)
                for (var i = 0; i < hidden.length; ++i) hidden[i].lines.length || signal(hidden[i], "hide");
            if (unhidden)
                for (var i$1 = 0; i$1 < unhidden.length; ++i$1) unhidden[i$1].lines.length && signal(unhidden[i$1], "unhide");
            display.wrapper.offsetHeight && (doc.scrollTop = cm.display.scroller.scrollTop), op.changeObjs && signal(cm, "changes", cm, op.changeObjs), op.update && op.update.finish()
        }

        function runInOp(cm, f) {
            if (cm.curOp) return f();
            _startOperation(cm);
            try {
                return f()
            } finally {
                _endOperation(cm)
            }
        }

        function operation(cm, f) {
            return function() {
                if (cm.curOp) return f.apply(cm, arguments);
                _startOperation(cm);
                try {
                    return f.apply(cm, arguments)
                } finally {
                    _endOperation(cm)
                }
            }
        }

        function methodOp(f) {
            return function() {
                if (this.curOp) return f.apply(this, arguments);
                _startOperation(this);
                try {
                    return f.apply(this, arguments)
                } finally {
                    _endOperation(this)
                }
            }
        }

        function docMethodOp(f) {
            return function() {
                var cm = this.cm;
                if (!cm || cm.curOp) return f.apply(this, arguments);
                _startOperation(cm);
                try {
                    return f.apply(this, arguments)
                } finally {
                    _endOperation(cm)
                }
            }
        }

        function regChange(cm, from, to, lendiff) {
            null == from && (from = cm.doc.first), null == to && (to = cm.doc.first + cm.doc.size), lendiff || (lendiff = 0);
            var display = cm.display;
            if (lendiff && to < display.viewTo && (null == display.updateLineNumbers || display.updateLineNumbers > from) && (display.updateLineNumbers = from), cm.curOp.viewChanged = !0, from >= display.viewTo) sawCollapsedSpans && visualLineNo(cm.doc, from) < display.viewTo && resetView(cm);
            else if (to <= display.viewFrom) sawCollapsedSpans && visualLineEndNo(cm.doc, to + lendiff) > display.viewFrom ? resetView(cm) : (display.viewFrom += lendiff, display.viewTo += lendiff);
            else if (from <= display.viewFrom && to >= display.viewTo) resetView(cm);
            else if (from <= display.viewFrom) {
                var cut = viewCuttingPoint(cm, to, to + lendiff, 1);
                cut ? (display.view = display.view.slice(cut.index), display.viewFrom = cut.lineN, display.viewTo += lendiff) : resetView(cm)
            } else if (to >= display.viewTo) {
                var cut$1 = viewCuttingPoint(cm, from, from, -1);
                cut$1 ? (display.view = display.view.slice(0, cut$1.index), display.viewTo = cut$1.lineN) : resetView(cm)
            } else {
                var cutTop = viewCuttingPoint(cm, from, from, -1),
                    cutBot = viewCuttingPoint(cm, to, to + lendiff, 1);
                cutTop && cutBot ? (display.view = display.view.slice(0, cutTop.index).concat(buildViewArray(cm, cutTop.lineN, cutBot.lineN)).concat(display.view.slice(cutBot.index)), display.viewTo += lendiff) : resetView(cm)
            }
            var ext = display.externalMeasured;
            ext && (to < ext.lineN ? ext.lineN += lendiff : from < ext.lineN + ext.size && (display.externalMeasured = null))
        }

        function regLineChange(cm, line, type) {
            cm.curOp.viewChanged = !0;
            var display = cm.display,
                ext = cm.display.externalMeasured;
            if (ext && line >= ext.lineN && line < ext.lineN + ext.size && (display.externalMeasured = null), !(line < display.viewFrom || line >= display.viewTo)) {
                var lineView = display.view[findViewIndex(cm, line)];
                if (null != lineView.node) {
                    var arr = lineView.changes || (lineView.changes = []);
                    indexOf(arr, type) == -1 && arr.push(type)
                }
            }
        }

        function resetView(cm) {
            cm.display.viewFrom = cm.display.viewTo = cm.doc.first, cm.display.view = [], cm.display.viewOffset = 0
        }

        function viewCuttingPoint(cm, oldN, newN, dir) {
            var diff, index = findViewIndex(cm, oldN),
                view = cm.display.view;
            if (!sawCollapsedSpans || newN == cm.doc.first + cm.doc.size) return {
                index: index,
                lineN: newN
            };
            for (var n = cm.display.viewFrom, i = 0; i < index; i++) n += view[i].size;
            if (n != oldN) {
                if (dir > 0) {
                    if (index == view.length - 1) return null;
                    diff = n + view[index].size - oldN, index++
                } else diff = n - oldN;
                oldN += diff, newN += diff
            }
            for (; visualLineNo(cm.doc, newN) != newN;) {
                if (index == (dir < 0 ? 0 : view.length - 1)) return null;
                newN += dir * view[index - (dir < 0 ? 1 : 0)].size, index += dir
            }
            return {
                index: index,
                lineN: newN
            }
        }

        function adjustView(cm, from, to) {
            var display = cm.display,
                view = display.view;
            0 == view.length || from >= display.viewTo || to <= display.viewFrom ? (display.view = buildViewArray(cm, from, to), display.viewFrom = from) : (display.viewFrom > from ? display.view = buildViewArray(cm, from, display.viewFrom).concat(display.view) : display.viewFrom < from && (display.view = display.view.slice(findViewIndex(cm, from))), display.viewFrom = from, display.viewTo < to ? display.view = display.view.concat(buildViewArray(cm, display.viewTo, to)) : display.viewTo > to && (display.view = display.view.slice(0, findViewIndex(cm, to)))), display.viewTo = to
        }

        function countDirtyView(cm) {
            for (var view = cm.display.view, dirty = 0, i = 0; i < view.length; i++) {
                var lineView = view[i];
                lineView.hidden || lineView.node && !lineView.changes || ++dirty
            }
            return dirty
        }

        function startWorker(cm, time) {
            cm.doc.highlightFrontier < cm.display.viewTo && cm.state.highlight.set(time, bind(highlightWorker, cm))
        }

        function highlightWorker(cm) {
            var doc = cm.doc;
            if (!(doc.highlightFrontier >= cm.display.viewTo)) {
                var end = +new Date + cm.options.workTime,
                    context = getContextBefore(cm, doc.highlightFrontier),
                    changedLines = [];
                doc.iter(context.line, Math.min(doc.first + doc.size, cm.display.viewTo + 500), function(line) {
                    if (context.line >= cm.display.viewFrom) {
                        var oldStyles = line.styles,
                            resetState = line.text.length > cm.options.maxHighlightLength ? copyState(doc.mode, context.state) : null,
                            highlighted = highlightLine(cm, line, context, !0);
                        resetState && (context.state = resetState), line.styles = highlighted.styles;
                        var oldCls = line.styleClasses,
                            newCls = highlighted.classes;
                        newCls ? line.styleClasses = newCls : oldCls && (line.styleClasses = null);
                        for (var ischange = !oldStyles || oldStyles.length != line.styles.length || oldCls != newCls && (!oldCls || !newCls || oldCls.bgClass != newCls.bgClass || oldCls.textClass != newCls.textClass), i = 0; !ischange && i < oldStyles.length; ++i) ischange = oldStyles[i] != line.styles[i];
                        ischange && changedLines.push(context.line), line.stateAfter = context.save(), context.nextLine()
                    } else line.text.length <= cm.options.maxHighlightLength && processLine(cm, line.text, context), line.stateAfter = context.line % 5 == 0 ? context.save() : null, context.nextLine();
                    if (+new Date > end) return startWorker(cm, cm.options.workDelay), !0
                }), doc.highlightFrontier = context.line, doc.modeFrontier = Math.max(doc.modeFrontier, context.line), changedLines.length && runInOp(cm, function() {
                    for (var i = 0; i < changedLines.length; i++) regLineChange(cm, changedLines[i], "text")
                })
            }
        }

        function maybeClipScrollbars(cm) {
            var display = cm.display;
            !display.scrollbarsClipped && display.scroller.offsetWidth && (display.nativeBarWidth = display.scroller.offsetWidth - display.scroller.clientWidth, display.heightForcer.style.height = scrollGap(cm) + "px", display.sizer.style.marginBottom = -display.nativeBarWidth + "px", display.sizer.style.borderRightWidth = scrollGap(cm) + "px", display.scrollbarsClipped = !0)
        }

        function selectionSnapshot(cm) {
            if (cm.hasFocus()) return null;
            var active = activeElt();
            if (!active || !contains(cm.display.lineDiv, active)) return null;
            var result = {
                activeElt: active
            };
            if (window.getSelection) {
                var sel = window.getSelection();
                sel.anchorNode && sel.extend && contains(cm.display.lineDiv, sel.anchorNode) && (result.anchorNode = sel.anchorNode, result.anchorOffset = sel.anchorOffset, result.focusNode = sel.focusNode, result.focusOffset = sel.focusOffset)
            }
            return result
        }

        function restoreSelection(snapshot) {
            if (snapshot && snapshot.activeElt && snapshot.activeElt != activeElt() && (snapshot.activeElt.focus(), snapshot.anchorNode && contains(document.body, snapshot.anchorNode) && contains(document.body, snapshot.focusNode))) {
                var sel = window.getSelection(),
                    range$$1 = document.createRange();
                range$$1.setEnd(snapshot.anchorNode, snapshot.anchorOffset), range$$1.collapse(!1), sel.removeAllRanges(), sel.addRange(range$$1), sel.extend(snapshot.focusNode, snapshot.focusOffset)
            }
        }

        function updateDisplayIfNeeded(cm, update) {
            var display = cm.display,
                doc = cm.doc;
            if (update.editorIsHidden) return resetView(cm), !1;
            if (!update.force && update.visible.from >= display.viewFrom && update.visible.to <= display.viewTo && (null == display.updateLineNumbers || display.updateLineNumbers >= display.viewTo) && display.renderedView == display.view && 0 == countDirtyView(cm)) return !1;
            maybeUpdateLineNumberWidth(cm) && (resetView(cm), update.dims = getDimensions(cm));
            var end = doc.first + doc.size,
                from = Math.max(update.visible.from - cm.options.viewportMargin, doc.first),
                to = Math.min(end, update.visible.to + cm.options.viewportMargin);
            display.viewFrom < from && from - display.viewFrom < 20 && (from = Math.max(doc.first, display.viewFrom)), display.viewTo > to && display.viewTo - to < 20 && (to = Math.min(end, display.viewTo)), sawCollapsedSpans && (from = visualLineNo(cm.doc, from), to = visualLineEndNo(cm.doc, to));
            var different = from != display.viewFrom || to != display.viewTo || display.lastWrapHeight != update.wrapperHeight || display.lastWrapWidth != update.wrapperWidth;
            adjustView(cm, from, to), display.viewOffset = _heightAtLine(getLine(cm.doc, display.viewFrom)), cm.display.mover.style.top = display.viewOffset + "px";
            var toUpdate = countDirtyView(cm);
            if (!different && 0 == toUpdate && !update.force && display.renderedView == display.view && (null == display.updateLineNumbers || display.updateLineNumbers >= display.viewTo)) return !1;
            var selSnapshot = selectionSnapshot(cm);
            return toUpdate > 4 && (display.lineDiv.style.display = "none"), patchDisplay(cm, display.updateLineNumbers, update.dims), toUpdate > 4 && (display.lineDiv.style.display = ""), display.renderedView = display.view, restoreSelection(selSnapshot), removeChildren(display.cursorDiv), removeChildren(display.selectionDiv), display.gutters.style.height = display.sizer.style.minHeight = 0, different && (display.lastWrapHeight = update.wrapperHeight, display.lastWrapWidth = update.wrapperWidth, startWorker(cm, 400)), display.updateLineNumbers = null, !0
        }

        function postUpdateDisplay(cm, update) {
            for (var viewport = update.viewport, first = !0;
                (first && cm.options.lineWrapping && update.oldDisplayWidth != displayWidth(cm) || (viewport && null != viewport.top && (viewport = {
                    top: Math.min(cm.doc.height + paddingVert(cm.display) - displayHeight(cm), viewport.top)
                }), update.visible = visibleLines(cm.display, cm.doc, viewport), !(update.visible.from >= cm.display.viewFrom && update.visible.to <= cm.display.viewTo))) && updateDisplayIfNeeded(cm, update); first = !1) {
                updateHeightsInViewport(cm);
                var barMeasure = measureForScrollbars(cm);
                updateSelection(cm), updateScrollbars(cm, barMeasure), setDocumentHeight(cm, barMeasure), update.force = !1
            }
            update.signal(cm, "update", cm), cm.display.viewFrom == cm.display.reportedViewFrom && cm.display.viewTo == cm.display.reportedViewTo || (update.signal(cm, "viewportChange", cm, cm.display.viewFrom, cm.display.viewTo), cm.display.reportedViewFrom = cm.display.viewFrom, cm.display.reportedViewTo = cm.display.viewTo)
        }

        function updateDisplaySimple(cm, viewport) {
            var update = new DisplayUpdate(cm, viewport);
            if (updateDisplayIfNeeded(cm, update)) {
                updateHeightsInViewport(cm), postUpdateDisplay(cm, update);
                var barMeasure = measureForScrollbars(cm);
                updateSelection(cm), updateScrollbars(cm, barMeasure), setDocumentHeight(cm, barMeasure), update.finish()
            }
        }

        function patchDisplay(cm, updateNumbersFrom, dims) {
            function rm(node) {
                var next = node.nextSibling;
                return webkit && mac && cm.display.currentWheelTarget == node ? node.style.display = "none" : node.parentNode.removeChild(node), next
            }
            for (var display = cm.display, lineNumbers = cm.options.lineNumbers, container = display.lineDiv, cur = container.firstChild, view = display.view, lineN = display.viewFrom, i = 0; i < view.length; i++) {
                var lineView = view[i];
                if (lineView.hidden);
                else if (lineView.node && lineView.node.parentNode == container) {
                    for (; cur != lineView.node;) cur = rm(cur);
                    var updateNumber = lineNumbers && null != updateNumbersFrom && updateNumbersFrom <= lineN && lineView.lineNumber;
                    lineView.changes && (indexOf(lineView.changes, "gutter") > -1 && (updateNumber = !1), updateLineForChanges(cm, lineView, lineN, dims)), updateNumber && (removeChildren(lineView.lineNumber), lineView.lineNumber.appendChild(document.createTextNode(lineNumberFor(cm.options, lineN)))), cur = lineView.node.nextSibling
                } else {
                    var node = buildLineElement(cm, lineView, lineN, dims);
                    container.insertBefore(node, cur)
                }
                lineN += lineView.size
            }
            for (; cur;) cur = rm(cur)
        }

        function updateGutterSpace(cm) {
            var width = cm.display.gutters.offsetWidth;
            cm.display.sizer.style.marginLeft = width + "px"
        }

        function setDocumentHeight(cm, measure) {
            cm.display.sizer.style.minHeight = measure.docHeight + "px", cm.display.heightForcer.style.top = measure.docHeight + "px", cm.display.gutters.style.height = measure.docHeight + cm.display.barHeight + scrollGap(cm) + "px"
        }

        function updateGutters(cm) {
            var gutters = cm.display.gutters,
                specs = cm.options.gutters;
            removeChildren(gutters);
            for (var i = 0; i < specs.length; ++i) {
                var gutterClass = specs[i],
                    gElt = gutters.appendChild(elt("div", null, "CodeMirror-gutter " + gutterClass));
                "CodeMirror-linenumbers" == gutterClass && (cm.display.lineGutter = gElt, gElt.style.width = (cm.display.lineNumWidth || 1) + "px")
            }
            gutters.style.display = i ? "" : "none", updateGutterSpace(cm)
        }

        function setGuttersForLineNumbers(options) {
            var found = indexOf(options.gutters, "CodeMirror-linenumbers");
            found == -1 && options.lineNumbers ? options.gutters = options.gutters.concat(["CodeMirror-linenumbers"]) : found > -1 && !options.lineNumbers && (options.gutters = options.gutters.slice(0), options.gutters.splice(found, 1))
        }

        function wheelEventDelta(e) {
            var dx = e.wheelDeltaX,
                dy = e.wheelDeltaY;
            return null == dx && e.detail && e.axis == e.HORIZONTAL_AXIS && (dx = e.detail), null == dy && e.detail && e.axis == e.VERTICAL_AXIS ? dy = e.detail : null == dy && (dy = e.wheelDelta), {
                x: dx,
                y: dy
            }
        }

        function wheelEventPixels(e) {
            var delta = wheelEventDelta(e);
            return delta.x *= wheelPixelsPerUnit, delta.y *= wheelPixelsPerUnit, delta
        }

        function onScrollWheel(cm, e) {
            var delta = wheelEventDelta(e),
                dx = delta.x,
                dy = delta.y,
                display = cm.display,
                scroll = display.scroller,
                canScrollX = scroll.scrollWidth > scroll.clientWidth,
                canScrollY = scroll.scrollHeight > scroll.clientHeight;
            if (dx && canScrollX || dy && canScrollY) {
                if (dy && mac && webkit) outer: for (var cur = e.target, view = display.view; cur != scroll; cur = cur.parentNode)
                    for (var i = 0; i < view.length; i++)
                        if (view[i].node == cur) {
                            cm.display.currentWheelTarget = cur;
                            break outer
                        } if (dx && !gecko && !presto && null != wheelPixelsPerUnit) return dy && canScrollY && updateScrollTop(cm, Math.max(0, scroll.scrollTop + dy * wheelPixelsPerUnit)), setScrollLeft(cm, Math.max(0, scroll.scrollLeft + dx * wheelPixelsPerUnit)), (!dy || dy && canScrollY) && e_preventDefault(e), void(display.wheelStartX = null);
                if (dy && null != wheelPixelsPerUnit) {
                    var pixels = dy * wheelPixelsPerUnit,
                        top = cm.doc.scrollTop,
                        bot = top + display.wrapper.clientHeight;
                    pixels < 0 ? top = Math.max(0, top + pixels - 50) : bot = Math.min(cm.doc.height, bot + pixels + 50), updateDisplaySimple(cm, {
                        top: top,
                        bottom: bot
                    })
                }
                wheelSamples < 20 && (null == display.wheelStartX ? (display.wheelStartX = scroll.scrollLeft, display.wheelStartY = scroll.scrollTop, display.wheelDX = dx, display.wheelDY = dy, setTimeout(function() {
                    if (null != display.wheelStartX) {
                        var movedX = scroll.scrollLeft - display.wheelStartX,
                            movedY = scroll.scrollTop - display.wheelStartY,
                            sample = movedY && display.wheelDY && movedY / display.wheelDY || movedX && display.wheelDX && movedX / display.wheelDX;
                        display.wheelStartX = display.wheelStartY = null, sample && (wheelPixelsPerUnit = (wheelPixelsPerUnit * wheelSamples + sample) / (wheelSamples + 1), ++wheelSamples)
                    }
                }, 200)) : (display.wheelDX += dx, display.wheelDY += dy))
            }
        }

        function normalizeSelection(ranges, primIndex) {
            var prim = ranges[primIndex];
            ranges.sort(function(a, b) {
                return cmp(a.from(), b.from())
            }), primIndex = indexOf(ranges, prim);
            for (var i = 1; i < ranges.length; i++) {
                var cur = ranges[i],
                    prev = ranges[i - 1];
                if (cmp(prev.to(), cur.from()) >= 0) {
                    var from = minPos(prev.from(), cur.from()),
                        to = maxPos(prev.to(), cur.to()),
                        inv = prev.empty() ? cur.from() == cur.head : prev.from() == prev.head;
                    i <= primIndex && --primIndex, ranges.splice(--i, 2, new Range(inv ? to : from, inv ? from : to))
                }
            }
            return new Selection(ranges, primIndex)
        }

        function simpleSelection(anchor, head) {
            return new Selection([new Range(anchor, head || anchor)], 0)
        }

        function changeEnd(change) {
            return change.text ? Pos(change.from.line + change.text.length - 1, lst(change.text).length + (1 == change.text.length ? change.from.ch : 0)) : change.to
        }

        function adjustForChange(pos, change) {
            if (cmp(pos, change.from) < 0) return pos;
            if (cmp(pos, change.to) <= 0) return changeEnd(change);
            var line = pos.line + change.text.length - (change.to.line - change.from.line) - 1,
                ch = pos.ch;
            return pos.line == change.to.line && (ch += changeEnd(change).ch - change.to.ch), Pos(line, ch)
        }

        function computeSelAfterChange(doc, change) {
            for (var out = [], i = 0; i < doc.sel.ranges.length; i++) {
                var range = doc.sel.ranges[i];
                out.push(new Range(adjustForChange(range.anchor, change), adjustForChange(range.head, change)))
            }
            return normalizeSelection(out, doc.sel.primIndex)
        }

        function offsetPos(pos, old, nw) {
            return pos.line == old.line ? Pos(nw.line, pos.ch - old.ch + nw.ch) : Pos(nw.line + (pos.line - old.line), pos.ch)
        }

        function computeReplacedSel(doc, changes, hint) {
            for (var out = [], oldPrev = Pos(doc.first, 0), newPrev = oldPrev, i = 0; i < changes.length; i++) {
                var change = changes[i],
                    from = offsetPos(change.from, oldPrev, newPrev),
                    to = offsetPos(changeEnd(change), oldPrev, newPrev);
                if (oldPrev = change.to, newPrev = to, "around" == hint) {
                    var range = doc.sel.ranges[i],
                        inv = cmp(range.head, range.anchor) < 0;
                    out[i] = new Range(inv ? to : from, inv ? from : to)
                } else out[i] = new Range(from, from)
            }
            return new Selection(out, doc.sel.primIndex)
        }

        function loadMode(cm) {
            cm.doc.mode = getMode(cm.options, cm.doc.modeOption), resetModeState(cm)
        }

        function resetModeState(cm) {
            cm.doc.iter(function(line) {
                line.stateAfter && (line.stateAfter = null), line.styles && (line.styles = null)
            }), cm.doc.modeFrontier = cm.doc.highlightFrontier = cm.doc.first, startWorker(cm, 100), cm.state.modeGen++, cm.curOp && regChange(cm)
        }

        function isWholeLineUpdate(doc, change) {
            return 0 == change.from.ch && 0 == change.to.ch && "" == lst(change.text) && (!doc.cm || doc.cm.options.wholeLineUpdateBefore)
        }

        function updateDoc(doc, change, markedSpans, estimateHeight$$1) {
            function spansFor(n) {
                return markedSpans ? markedSpans[n] : null
            }

            function update(line, text, spans) {
                updateLine(line, text, spans, estimateHeight$$1), signalLater(line, "change", line, change)
            }

            function linesFor(start, end) {
                for (var result = [], i = start; i < end; ++i) result.push(new Line(text[i], spansFor(i), estimateHeight$$1));
                return result
            }
            var from = change.from,
                to = change.to,
                text = change.text,
                firstLine = getLine(doc, from.line),
                lastLine = getLine(doc, to.line),
                lastText = lst(text),
                lastSpans = spansFor(text.length - 1),
                nlines = to.line - from.line;
            if (change.full) doc.insert(0, linesFor(0, text.length)), doc.remove(text.length, doc.size - text.length);
            else if (isWholeLineUpdate(doc, change)) {
                var added = linesFor(0, text.length - 1);
                update(lastLine, lastLine.text, lastSpans), nlines && doc.remove(from.line, nlines), added.length && doc.insert(from.line, added)
            } else if (firstLine == lastLine)
                if (1 == text.length) update(firstLine, firstLine.text.slice(0, from.ch) + lastText + firstLine.text.slice(to.ch), lastSpans);
                else {
                    var added$1 = linesFor(1, text.length - 1);
                    added$1.push(new Line(lastText + firstLine.text.slice(to.ch), lastSpans, estimateHeight$$1)), update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0)), doc.insert(from.line + 1, added$1)
                }
            else if (1 == text.length) update(firstLine, firstLine.text.slice(0, from.ch) + text[0] + lastLine.text.slice(to.ch), spansFor(0)), doc.remove(from.line + 1, nlines);
            else {
                update(firstLine, firstLine.text.slice(0, from.ch) + text[0], spansFor(0)), update(lastLine, lastText + lastLine.text.slice(to.ch), lastSpans);
                var added$2 = linesFor(1, text.length - 1);
                nlines > 1 && doc.remove(from.line + 1, nlines - 1), doc.insert(from.line + 1, added$2)
            }
            signalLater(doc, "change", doc, change)
        }

        function linkedDocs(doc, f, sharedHistOnly) {
            function propagate(doc, skip, sharedHist) {
                if (doc.linked)
                    for (var i = 0; i < doc.linked.length; ++i) {
                        var rel = doc.linked[i];
                        if (rel.doc != skip) {
                            var shared = sharedHist && rel.sharedHist;
                            sharedHistOnly && !shared || (f(rel.doc, shared), propagate(rel.doc, doc, shared))
                        }
                    }
            }
            propagate(doc, null, !0)
        }

        function attachDoc(cm, doc) {
            if (doc.cm) throw new Error("This document is already in use.");
            cm.doc = doc, doc.cm = cm, estimateLineHeights(cm), loadMode(cm), setDirectionClass(cm), cm.options.lineWrapping || findMaxLine(cm), cm.options.mode = doc.modeOption, regChange(cm)
        }

        function setDirectionClass(cm) {
            ("rtl" == cm.doc.direction ? addClass : rmClass)(cm.display.lineDiv, "CodeMirror-rtl")
        }

        function directionChanged(cm) {
            runInOp(cm, function() {
                setDirectionClass(cm), regChange(cm)
            })
        }

        function History(startGen) {
            this.done = [], this.undone = [], this.undoDepth = 1 / 0, this.lastModTime = this.lastSelTime = 0, this.lastOp = this.lastSelOp = null, this.lastOrigin = this.lastSelOrigin = null, this.generation = this.maxGeneration = startGen || 1
        }

        function historyChangeFromChange(doc, change) {
            var histChange = {
                from: copyPos(change.from),
                to: changeEnd(change),
                text: getBetween(doc, change.from, change.to)
            };
            return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1), linkedDocs(doc, function(doc) {
                return attachLocalSpans(doc, histChange, change.from.line, change.to.line + 1)
            }, !0), histChange
        }

        function clearSelectionEvents(array) {
            for (; array.length;) {
                var last = lst(array);
                if (!last.ranges) break;
                array.pop()
            }
        }

        function lastChangeEvent(hist, force) {
            return force ? (clearSelectionEvents(hist.done), lst(hist.done)) : hist.done.length && !lst(hist.done).ranges ? lst(hist.done) : hist.done.length > 1 && !hist.done[hist.done.length - 2].ranges ? (hist.done.pop(), lst(hist.done)) : void 0
        }

        function addChangeToHistory(doc, change, selAfter, opId) {
            var hist = doc.history;
            hist.undone.length = 0;
            var cur, last, time = +new Date;
            if ((hist.lastOp == opId || hist.lastOrigin == change.origin && change.origin && ("+" == change.origin.charAt(0) && hist.lastModTime > time - (doc.cm ? doc.cm.options.historyEventDelay : 500) || "*" == change.origin.charAt(0))) && (cur = lastChangeEvent(hist, hist.lastOp == opId))) last = lst(cur.changes), 0 == cmp(change.from, change.to) && 0 == cmp(change.from, last.to) ? last.to = changeEnd(change) : cur.changes.push(historyChangeFromChange(doc, change));
            else {
                var before = lst(hist.done);
                for (before && before.ranges || pushSelectionToHistory(doc.sel, hist.done), cur = {
                        changes: [historyChangeFromChange(doc, change)],
                        generation: hist.generation
                    }, hist.done.push(cur); hist.done.length > hist.undoDepth;) hist.done.shift(), hist.done[0].ranges || hist.done.shift()
            }
            hist.done.push(selAfter), hist.generation = ++hist.maxGeneration, hist.lastModTime = hist.lastSelTime = time, hist.lastOp = hist.lastSelOp = opId, hist.lastOrigin = hist.lastSelOrigin = change.origin, last || signal(doc, "historyAdded")
        }

        function selectionEventCanBeMerged(doc, origin, prev, sel) {
            var ch = origin.charAt(0);
            return "*" == ch || "+" == ch && prev.ranges.length == sel.ranges.length && prev.somethingSelected() == sel.somethingSelected() && new Date - doc.history.lastSelTime <= (doc.cm ? doc.cm.options.historyEventDelay : 500)
        }

        function addSelectionToHistory(doc, sel, opId, options) {
            var hist = doc.history,
                origin = options && options.origin;
            opId == hist.lastSelOp || origin && hist.lastSelOrigin == origin && (hist.lastModTime == hist.lastSelTime && hist.lastOrigin == origin || selectionEventCanBeMerged(doc, origin, lst(hist.done), sel)) ? hist.done[hist.done.length - 1] = sel : pushSelectionToHistory(sel, hist.done), hist.lastSelTime = +new Date, hist.lastSelOrigin = origin, hist.lastSelOp = opId, options && options.clearRedo !== !1 && clearSelectionEvents(hist.undone)
        }

        function pushSelectionToHistory(sel, dest) {
            var top = lst(dest);
            top && top.ranges && top.equals(sel) || dest.push(sel)
        }

        function attachLocalSpans(doc, change, from, to) {
            var existing = change["spans_" + doc.id],
                n = 0;
            doc.iter(Math.max(doc.first, from), Math.min(doc.first + doc.size, to), function(line) {
                line.markedSpans && ((existing || (existing = change["spans_" + doc.id] = {}))[n] = line.markedSpans), ++n
            })
        }

        function removeClearedSpans(spans) {
            if (!spans) return null;
            for (var out, i = 0; i < spans.length; ++i) spans[i].marker.explicitlyCleared ? out || (out = spans.slice(0, i)) : out && out.push(spans[i]);
            return out ? out.length ? out : null : spans
        }

        function getOldSpans(doc, change) {
            var found = change["spans_" + doc.id];
            if (!found) return null;
            for (var nw = [], i = 0; i < change.text.length; ++i) nw.push(removeClearedSpans(found[i]));
            return nw
        }

        function mergeOldSpans(doc, change) {
            var old = getOldSpans(doc, change),
                stretched = stretchSpansOverChange(doc, change);
            if (!old) return stretched;
            if (!stretched) return old;
            for (var i = 0; i < old.length; ++i) {
                var oldCur = old[i],
                    stretchCur = stretched[i];
                if (oldCur && stretchCur) spans: for (var j = 0; j < stretchCur.length; ++j) {
                    for (var span = stretchCur[j], k = 0; k < oldCur.length; ++k)
                        if (oldCur[k].marker == span.marker) continue spans;
                    oldCur.push(span)
                } else stretchCur && (old[i] = stretchCur)
            }
            return old
        }

        function copyHistoryArray(events, newGroup, instantiateSel) {
            for (var copy = [], i = 0; i < events.length; ++i) {
                var event = events[i];
                if (event.ranges) copy.push(instantiateSel ? Selection.prototype.deepCopy.call(event) : event);
                else {
                    var changes = event.changes,
                        newChanges = [];
                    copy.push({
                        changes: newChanges
                    });
                    for (var j = 0; j < changes.length; ++j) {
                        var change = changes[j],
                            m = void 0;
                        if (newChanges.push({
                                from: change.from,
                                to: change.to,
                                text: change.text
                            }), newGroup)
                            for (var prop in change)(m = prop.match(/^spans_(\d+)$/)) && indexOf(newGroup, Number(m[1])) > -1 && (lst(newChanges)[prop] = change[prop], delete change[prop])
                    }
                }
            }
            return copy
        }

        function extendRange(range, head, other, extend) {
            if (extend) {
                var anchor = range.anchor;
                if (other) {
                    var posBefore = cmp(head, anchor) < 0;
                    posBefore != cmp(other, anchor) < 0 ? (anchor = head, head = other) : posBefore != cmp(head, other) < 0 && (head = other)
                }
                return new Range(anchor, head)
            }
            return new Range(other || head, head)
        }

        function extendSelection(doc, head, other, options, extend) {
            null == extend && (extend = doc.cm && (doc.cm.display.shift || doc.extend)), setSelection(doc, new Selection([extendRange(doc.sel.primary(), head, other, extend)], 0), options)
        }

        function extendSelections(doc, heads, options) {
            for (var out = [], extend = doc.cm && (doc.cm.display.shift || doc.extend), i = 0; i < doc.sel.ranges.length; i++) out[i] = extendRange(doc.sel.ranges[i], heads[i], null, extend);
            var newSel = normalizeSelection(out, doc.sel.primIndex);
            setSelection(doc, newSel, options)
        }

        function replaceOneSelection(doc, i, range, options) {
            var ranges = doc.sel.ranges.slice(0);
            ranges[i] = range, setSelection(doc, normalizeSelection(ranges, doc.sel.primIndex), options)
        }

        function setSimpleSelection(doc, anchor, head, options) {
            setSelection(doc, simpleSelection(anchor, head), options)
        }

        function filterSelectionChange(doc, sel, options) {
            var obj = {
                ranges: sel.ranges,
                update: function(ranges) {
                    var this$1 = this;
                    this.ranges = [];
                    for (var i = 0; i < ranges.length; i++) this$1.ranges[i] = new Range(_clipPos(doc, ranges[i].anchor), _clipPos(doc, ranges[i].head))
                },
                origin: options && options.origin
            };
            return signal(doc, "beforeSelectionChange", doc, obj), doc.cm && signal(doc.cm, "beforeSelectionChange", doc.cm, obj), obj.ranges != sel.ranges ? normalizeSelection(obj.ranges, obj.ranges.length - 1) : sel
        }

        function setSelectionReplaceHistory(doc, sel, options) {
            var done = doc.history.done,
                last = lst(done);
            last && last.ranges ? (done[done.length - 1] = sel, setSelectionNoUndo(doc, sel, options)) : setSelection(doc, sel, options)
        }

        function setSelection(doc, sel, options) {
            setSelectionNoUndo(doc, sel, options), addSelectionToHistory(doc, doc.sel, doc.cm ? doc.cm.curOp.id : NaN, options)
        }

        function setSelectionNoUndo(doc, sel, options) {
            (hasHandler(doc, "beforeSelectionChange") || doc.cm && hasHandler(doc.cm, "beforeSelectionChange")) && (sel = filterSelectionChange(doc, sel, options));
            var bias = options && options.bias || (cmp(sel.primary().head, doc.sel.primary().head) < 0 ? -1 : 1);
            setSelectionInner(doc, skipAtomicInSelection(doc, sel, bias, !0)), options && options.scroll === !1 || !doc.cm || ensureCursorVisible(doc.cm)
        }

        function setSelectionInner(doc, sel) {
            sel.equals(doc.sel) || (doc.sel = sel, doc.cm && (doc.cm.curOp.updateInput = doc.cm.curOp.selectionChanged = !0, signalCursorActivity(doc.cm)), signalLater(doc, "cursorActivity", doc))
        }

        function reCheckSelection(doc) {
            setSelectionInner(doc, skipAtomicInSelection(doc, doc.sel, null, !1))
        }

        function skipAtomicInSelection(doc, sel, bias, mayClear) {
            for (var out, i = 0; i < sel.ranges.length; i++) {
                var range = sel.ranges[i],
                    old = sel.ranges.length == doc.sel.ranges.length && doc.sel.ranges[i],
                    newAnchor = skipAtomic(doc, range.anchor, old && old.anchor, bias, mayClear),
                    newHead = skipAtomic(doc, range.head, old && old.head, bias, mayClear);
                (out || newAnchor != range.anchor || newHead != range.head) && (out || (out = sel.ranges.slice(0, i)), out[i] = new Range(newAnchor, newHead))
            }
            return out ? normalizeSelection(out, sel.primIndex) : sel
        }

        function skipAtomicInner(doc, pos, oldPos, dir, mayClear) {
            var line = getLine(doc, pos.line);
            if (line.markedSpans)
                for (var i = 0; i < line.markedSpans.length; ++i) {
                    var sp = line.markedSpans[i],
                        m = sp.marker;
                    if ((null == sp.from || (m.inclusiveLeft ? sp.from <= pos.ch : sp.from < pos.ch)) && (null == sp.to || (m.inclusiveRight ? sp.to >= pos.ch : sp.to > pos.ch))) {
                        if (mayClear && (signal(m, "beforeCursorEnter"), m.explicitlyCleared)) {
                            if (line.markedSpans) {
                                --i;
                                continue
                            }
                            break
                        }
                        if (!m.atomic) continue;
                        if (oldPos) {
                            var near = m.find(dir < 0 ? 1 : -1),
                                diff = void 0;
                            if ((dir < 0 ? m.inclusiveRight : m.inclusiveLeft) && (near = movePos(doc, near, -dir, near && near.line == pos.line ? line : null)), near && near.line == pos.line && (diff = cmp(near, oldPos)) && (dir < 0 ? diff < 0 : diff > 0)) return skipAtomicInner(doc, near, pos, dir, mayClear)
                        }
                        var far = m.find(dir < 0 ? -1 : 1);
                        return (dir < 0 ? m.inclusiveLeft : m.inclusiveRight) && (far = movePos(doc, far, dir, far.line == pos.line ? line : null)), far ? skipAtomicInner(doc, far, pos, dir, mayClear) : null
                    }
                }
            return pos
        }

        function skipAtomic(doc, pos, oldPos, bias, mayClear) {
            var dir = bias || 1,
                found = skipAtomicInner(doc, pos, oldPos, dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, dir, !0) || skipAtomicInner(doc, pos, oldPos, -dir, mayClear) || !mayClear && skipAtomicInner(doc, pos, oldPos, -dir, !0);
            return found ? found : (doc.cantEdit = !0, Pos(doc.first, 0))
        }

        function movePos(doc, pos, dir, line) {
            return dir < 0 && 0 == pos.ch ? pos.line > doc.first ? _clipPos(doc, Pos(pos.line - 1)) : null : dir > 0 && pos.ch == (line || getLine(doc, pos.line)).text.length ? pos.line < doc.first + doc.size - 1 ? Pos(pos.line + 1, 0) : null : new Pos(pos.line, pos.ch + dir)
        }

        function selectAll(cm) {
            cm.setSelection(Pos(cm.firstLine(), 0), Pos(cm.lastLine()), sel_dontScroll)
        }

        function filterChange(doc, change, update) {
            var obj = {
                canceled: !1,
                from: change.from,
                to: change.to,
                text: change.text,
                origin: change.origin,
                cancel: function() {
                    return obj.canceled = !0
                }
            };
            return update && (obj.update = function(from, to, text, origin) {
                from && (obj.from = _clipPos(doc, from)), to && (obj.to = _clipPos(doc, to)), text && (obj.text = text), void 0 !== origin && (obj.origin = origin)
            }), signal(doc, "beforeChange", doc, obj), doc.cm && signal(doc.cm, "beforeChange", doc.cm, obj), obj.canceled ? null : {
                from: obj.from,
                to: obj.to,
                text: obj.text,
                origin: obj.origin
            }
        }

        function makeChange(doc, change, ignoreReadOnly) {
            if (doc.cm) {
                if (!doc.cm.curOp) return operation(doc.cm, makeChange)(doc, change, ignoreReadOnly);
                if (doc.cm.state.suppressEdits) return
            }
            if (!(hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange")) || (change = filterChange(doc, change, !0))) {
                var split = sawReadOnlySpans && !ignoreReadOnly && removeReadOnlyRanges(doc, change.from, change.to);
                if (split)
                    for (var i = split.length - 1; i >= 0; --i) makeChangeInner(doc, {
                        from: split[i].from,
                        to: split[i].to,
                        text: i ? [""] : change.text,
                        origin: change.origin
                    });
                else makeChangeInner(doc, change)
            }
        }

        function makeChangeInner(doc, change) {
            if (1 != change.text.length || "" != change.text[0] || 0 != cmp(change.from, change.to)) {
                var selAfter = computeSelAfterChange(doc, change);
                addChangeToHistory(doc, change, selAfter, doc.cm ? doc.cm.curOp.id : NaN), makeChangeSingleDoc(doc, change, selAfter, stretchSpansOverChange(doc, change));
                var rebased = [];
                linkedDocs(doc, function(doc, sharedHist) {
                    sharedHist || indexOf(rebased, doc.history) != -1 || (rebaseHist(doc.history, change), rebased.push(doc.history)), makeChangeSingleDoc(doc, change, null, stretchSpansOverChange(doc, change))
                })
            }
        }

        function makeChangeFromHistory(doc, type, allowSelectionOnly) {
            var suppress = doc.cm && doc.cm.state.suppressEdits;
            if (!suppress || allowSelectionOnly) {
                for (var event, hist = doc.history, selAfter = doc.sel, source = "undo" == type ? hist.done : hist.undone, dest = "undo" == type ? hist.undone : hist.done, i = 0; i < source.length && (event = source[i], allowSelectionOnly ? !event.ranges || event.equals(doc.sel) : event.ranges); i++);
                if (i != source.length) {
                    for (hist.lastOrigin = hist.lastSelOrigin = null;;) {
                        if (event = source.pop(), !event.ranges) {
                            if (suppress) return void source.push(event);
                            break
                        }
                        if (pushSelectionToHistory(event, dest), allowSelectionOnly && !event.equals(doc.sel)) return void setSelection(doc, event, {
                            clearRedo: !1
                        });
                        selAfter = event
                    }
                    var antiChanges = [];
                    pushSelectionToHistory(selAfter, dest), dest.push({
                        changes: antiChanges,
                        generation: hist.generation
                    }), hist.generation = event.generation || ++hist.maxGeneration;
                    for (var filter = hasHandler(doc, "beforeChange") || doc.cm && hasHandler(doc.cm, "beforeChange"), loop = function(i) {
                            var change = event.changes[i];
                            if (change.origin = type, filter && !filterChange(doc, change, !1)) return source.length = 0, {};
                            antiChanges.push(historyChangeFromChange(doc, change));
                            var after = i ? computeSelAfterChange(doc, change) : lst(source);
                            makeChangeSingleDoc(doc, change, after, mergeOldSpans(doc, change)), !i && doc.cm && doc.cm.scrollIntoView({
                                from: change.from,
                                to: changeEnd(change)
                            });
                            var rebased = [];
                            linkedDocs(doc, function(doc, sharedHist) {
                                sharedHist || indexOf(rebased, doc.history) != -1 || (rebaseHist(doc.history, change), rebased.push(doc.history)), makeChangeSingleDoc(doc, change, null, mergeOldSpans(doc, change))
                            })
                        }, i$1 = event.changes.length - 1; i$1 >= 0; --i$1) {
                        var returned = loop(i$1);
                        if (returned) return returned.v
                    }
                }
            }
        }

        function shiftDoc(doc, distance) {
            if (0 != distance && (doc.first += distance, doc.sel = new Selection(map(doc.sel.ranges, function(range) {
                    return new Range(Pos(range.anchor.line + distance, range.anchor.ch), Pos(range.head.line + distance, range.head.ch))
                }), doc.sel.primIndex), doc.cm)) {
                regChange(doc.cm, doc.first, doc.first - distance, distance);
                for (var d = doc.cm.display, l = d.viewFrom; l < d.viewTo; l++) regLineChange(doc.cm, l, "gutter")
            }
        }

        function makeChangeSingleDoc(doc, change, selAfter, spans) {
            if (doc.cm && !doc.cm.curOp) return operation(doc.cm, makeChangeSingleDoc)(doc, change, selAfter, spans);
            if (change.to.line < doc.first) return void shiftDoc(doc, change.text.length - 1 - (change.to.line - change.from.line));
            if (!(change.from.line > doc.lastLine())) {
                if (change.from.line < doc.first) {
                    var shift = change.text.length - 1 - (doc.first - change.from.line);
                    shiftDoc(doc, shift), change = {
                        from: Pos(doc.first, 0),
                        to: Pos(change.to.line + shift, change.to.ch),
                        text: [lst(change.text)],
                        origin: change.origin
                    }
                }
                var last = doc.lastLine();
                change.to.line > last && (change = {
                    from: change.from,
                    to: Pos(last, getLine(doc, last).text.length),
                    text: [change.text[0]],
                    origin: change.origin
                }), change.removed = getBetween(doc, change.from, change.to), selAfter || (selAfter = computeSelAfterChange(doc, change)), doc.cm ? makeChangeSingleDocInEditor(doc.cm, change, spans) : updateDoc(doc, change, spans), setSelectionNoUndo(doc, selAfter, sel_dontScroll)
            }
        }

        function makeChangeSingleDocInEditor(cm, change, spans) {
            var doc = cm.doc,
                display = cm.display,
                from = change.from,
                to = change.to,
                recomputeMaxLength = !1,
                checkWidthStart = from.line;
            cm.options.lineWrapping || (checkWidthStart = lineNo(visualLine(getLine(doc, from.line))), doc.iter(checkWidthStart, to.line + 1, function(line) {
                if (line == display.maxLine) return recomputeMaxLength = !0, !0
            })), doc.sel.contains(change.from, change.to) > -1 && signalCursorActivity(cm), updateDoc(doc, change, spans, estimateHeight(cm)), cm.options.lineWrapping || (doc.iter(checkWidthStart, from.line + change.text.length, function(line) {
                var len = lineLength(line);
                len > display.maxLineLength && (display.maxLine = line, display.maxLineLength = len, display.maxLineChanged = !0, recomputeMaxLength = !1)
            }), recomputeMaxLength && (cm.curOp.updateMaxLine = !0)), retreatFrontier(doc, from.line), startWorker(cm, 400);
            var lendiff = change.text.length - (to.line - from.line) - 1;
            change.full ? regChange(cm) : from.line != to.line || 1 != change.text.length || isWholeLineUpdate(cm.doc, change) ? regChange(cm, from.line, to.line + 1, lendiff) : regLineChange(cm, from.line, "text");
            var changesHandler = hasHandler(cm, "changes"),
                changeHandler = hasHandler(cm, "change");
            if (changeHandler || changesHandler) {
                var obj = {
                    from: from,
                    to: to,
                    text: change.text,
                    removed: change.removed,
                    origin: change.origin
                };
                changeHandler && signalLater(cm, "change", cm, obj), changesHandler && (cm.curOp.changeObjs || (cm.curOp.changeObjs = [])).push(obj)
            }
            cm.display.selForContextMenu = null
        }

        function _replaceRange(doc, code, from, to, origin) {
            if (to || (to = from), cmp(to, from) < 0) {
                var assign;
                assign = [to, from], from = assign[0], to = assign[1]
            }
            "string" == typeof code && (code = doc.splitLines(code)), makeChange(doc, {
                from: from,
                to: to,
                text: code,
                origin: origin
            })
        }

        function rebaseHistSelSingle(pos, from, to, diff) {
            to < pos.line ? pos.line += diff : from < pos.line && (pos.line = from, pos.ch = 0)
        }

        function rebaseHistArray(array, from, to, diff) {
            for (var i = 0; i < array.length; ++i) {
                var sub = array[i],
                    ok = !0;
                if (sub.ranges) {
                    sub.copied || (sub = array[i] = sub.deepCopy(), sub.copied = !0);
                    for (var j = 0; j < sub.ranges.length; j++) rebaseHistSelSingle(sub.ranges[j].anchor, from, to, diff), rebaseHistSelSingle(sub.ranges[j].head, from, to, diff)
                } else {
                    for (var j$1 = 0; j$1 < sub.changes.length; ++j$1) {
                        var cur = sub.changes[j$1];
                        if (to < cur.from.line) cur.from = Pos(cur.from.line + diff, cur.from.ch), cur.to = Pos(cur.to.line + diff, cur.to.ch);
                        else if (from <= cur.to.line) {
                            ok = !1;
                            break
                        }
                    }
                    ok || (array.splice(0, i + 1), i = 0)
                }
            }
        }

        function rebaseHist(hist, change) {
            var from = change.from.line,
                to = change.to.line,
                diff = change.text.length - (to - from) - 1;
            rebaseHistArray(hist.done, from, to, diff), rebaseHistArray(hist.undone, from, to, diff)
        }

        function changeLine(doc, handle, changeType, op) {
            var no = handle,
                line = handle;
            return "number" == typeof handle ? line = getLine(doc, clipLine(doc, handle)) : no = lineNo(handle), null == no ? null : (op(line, no) && doc.cm && regLineChange(doc.cm, no, changeType), line)
        }

        function LeafChunk(lines) {
            var this$1 = this;
            this.lines = lines, this.parent = null;
            for (var height = 0, i = 0; i < lines.length; ++i) lines[i].parent = this$1, height += lines[i].height;
            this.height = height
        }

        function BranchChunk(children) {
            var this$1 = this;
            this.children = children;
            for (var size = 0, height = 0, i = 0; i < children.length; ++i) {
                var ch = children[i];
                size += ch.chunkSize(), height += ch.height, ch.parent = this$1
            }
            this.size = size, this.height = height, this.parent = null
        }

        function adjustScrollWhenAboveVisible(cm, line, diff) {
            _heightAtLine(line) < (cm.curOp && cm.curOp.scrollTop || cm.doc.scrollTop) && addToScrollTop(cm, diff)
        }

        function addLineWidget(doc, handle, node, options) {
            var widget = new LineWidget(doc, node, options),
                cm = doc.cm;
            return cm && widget.noHScroll && (cm.display.alignWidgets = !0), changeLine(doc, handle, "widget", function(line) {
                var widgets = line.widgets || (line.widgets = []);
                if (null == widget.insertAt ? widgets.push(widget) : widgets.splice(Math.min(widgets.length - 1, Math.max(0, widget.insertAt)), 0, widget), widget.line = line, cm && !lineIsHidden(doc, line)) {
                    var aboveVisible = _heightAtLine(line) < doc.scrollTop;
                    updateLineHeight(line, line.height + widgetHeight(widget)), aboveVisible && addToScrollTop(cm, widget.height), cm.curOp.forceUpdate = !0
                }
                return !0
            }), cm && signalLater(cm, "lineWidgetAdded", cm, widget, "number" == typeof handle ? handle : lineNo(handle)), widget
        }

        function _markText(doc, from, to, options, type) {
            if (options && options.shared) return markTextShared(doc, from, to, options, type);
            if (doc.cm && !doc.cm.curOp) return operation(doc.cm, _markText)(doc, from, to, options, type);
            var marker = new TextMarker(doc, type),
                diff = cmp(from, to);
            if (options && copyObj(options, marker, !1), diff > 0 || 0 == diff && marker.clearWhenEmpty !== !1) return marker;
            if (marker.replacedWith && (marker.collapsed = !0, marker.widgetNode = eltP("span", [marker.replacedWith], "CodeMirror-widget"), options.handleMouseEvents || marker.widgetNode.setAttribute("cm-ignore-events", "true"), options.insertLeft && (marker.widgetNode.insertLeft = !0)), marker.collapsed) {
                if (conflictingCollapsedRange(doc, from.line, from, to, marker) || from.line != to.line && conflictingCollapsedRange(doc, to.line, from, to, marker)) throw new Error("Inserting collapsed marker partially overlapping an existing one");
                seeCollapsedSpans()
            }
            marker.addToHistory && addChangeToHistory(doc, {
                from: from,
                to: to,
                origin: "markText"
            }, doc.sel, NaN);
            var updateMaxLine, curLine = from.line,
                cm = doc.cm;
            if (doc.iter(curLine, to.line + 1, function(line) {
                    cm && marker.collapsed && !cm.options.lineWrapping && visualLine(line) == cm.display.maxLine && (updateMaxLine = !0), marker.collapsed && curLine != from.line && updateLineHeight(line, 0), addMarkedSpan(line, new MarkedSpan(marker, curLine == from.line ? from.ch : null, curLine == to.line ? to.ch : null)), ++curLine
                }), marker.collapsed && doc.iter(from.line, to.line + 1, function(line) {
                    lineIsHidden(doc, line) && updateLineHeight(line, 0)
                }), marker.clearOnEnter && on(marker, "beforeCursorEnter", function() {
                    return marker.clear()
                }), marker.readOnly && (seeReadOnlySpans(), (doc.history.done.length || doc.history.undone.length) && doc.clearHistory()), marker.collapsed && (marker.id = ++nextMarkerId, marker.atomic = !0), cm) {
                if (updateMaxLine && (cm.curOp.updateMaxLine = !0), marker.collapsed) regChange(cm, from.line, to.line + 1);
                else if (marker.className || marker.title || marker.startStyle || marker.endStyle || marker.css)
                    for (var i = from.line; i <= to.line; i++) regLineChange(cm, i, "text");
                marker.atomic && reCheckSelection(cm.doc), signalLater(cm, "markerAdded", cm, marker)
            }
            return marker
        }

        function markTextShared(doc, from, to, options, type) {
            options = copyObj(options), options.shared = !1;
            var markers = [_markText(doc, from, to, options, type)],
                primary = markers[0],
                widget = options.widgetNode;
            return linkedDocs(doc, function(doc) {
                widget && (options.widgetNode = widget.cloneNode(!0)), markers.push(_markText(doc, _clipPos(doc, from), _clipPos(doc, to), options, type));
                for (var i = 0; i < doc.linked.length; ++i)
                    if (doc.linked[i].isParent) return;
                primary = lst(markers)
            }), new SharedTextMarker(markers, primary)
        }

        function findSharedMarkers(doc) {
            return doc.findMarks(Pos(doc.first, 0), doc.clipPos(Pos(doc.lastLine())), function(m) {
                return m.parent
            })
        }

        function copySharedMarkers(doc, markers) {
            for (var i = 0; i < markers.length; i++) {
                var marker = markers[i],
                    pos = marker.find(),
                    mFrom = doc.clipPos(pos.from),
                    mTo = doc.clipPos(pos.to);
                if (cmp(mFrom, mTo)) {
                    var subMark = _markText(doc, mFrom, mTo, marker.primary, marker.primary.type);
                    marker.markers.push(subMark), subMark.parent = marker
                }
            }
        }

        function detachSharedMarkers(markers) {
            for (var loop = function(i) {
                    var marker = markers[i],
                        linked = [marker.primary.doc];
                    linkedDocs(marker.primary.doc, function(d) {
                        return linked.push(d)
                    });
                    for (var j = 0; j < marker.markers.length; j++) {
                        var subMarker = marker.markers[j];
                        indexOf(linked, subMarker.doc) == -1 && (subMarker.parent = null, marker.markers.splice(j--, 1))
                    }
                }, i = 0; i < markers.length; i++) loop(i)
        }

        function onDrop(e) {
            var cm = this;
            if (clearDragCursor(cm), !signalDOMEvent(cm, e) && !eventInWidget(cm.display, e)) {
                e_preventDefault(e), ie && (lastDrop = +new Date);
                var pos = posFromMouse(cm, e, !0),
                    files = e.dataTransfer.files;
                if (pos && !cm.isReadOnly())
                    if (files && files.length && window.FileReader && window.File)
                        for (var n = files.length, text = Array(n), read = 0, loadFile = function(file, i) {
                                if (!cm.options.allowDropFileTypes || indexOf(cm.options.allowDropFileTypes, file.type) != -1) {
                                    var reader = new FileReader;
                                    reader.onload = operation(cm, function() {
                                        var content = reader.result;
                                        if (/[\x00-\x08\x0e-\x1f]{2}/.test(content) && (content = ""), text[i] = content, ++read == n) {
                                            pos = _clipPos(cm.doc, pos);
                                            var change = {
                                                from: pos,
                                                to: pos,
                                                text: cm.doc.splitLines(text.join(cm.doc.lineSeparator())),
                                                origin: "paste"
                                            };
                                            makeChange(cm.doc, change), setSelectionReplaceHistory(cm.doc, simpleSelection(pos, changeEnd(change)))
                                        }
                                    }), reader.readAsText(file)
                                }
                            }, i = 0; i < n; ++i) loadFile(files[i], i);
                    else {
                        if (cm.state.draggingText && cm.doc.sel.contains(pos) > -1) return cm.state.draggingText(e), void setTimeout(function() {
                            return cm.display.input.focus()
                        }, 20);
                        try {
                            var text$1 = e.dataTransfer.getData("Text");
                            if (text$1) {
                                var selected;
                                if (cm.state.draggingText && !cm.state.draggingText.copy && (selected = cm.listSelections()), setSelectionNoUndo(cm.doc, simpleSelection(pos, pos)), selected)
                                    for (var i$1 = 0; i$1 < selected.length; ++i$1) _replaceRange(cm.doc, "", selected[i$1].anchor, selected[i$1].head, "drag");
                                cm.replaceSelection(text$1, "around", "paste"), cm.display.input.focus()
                            }
                        } catch (e) {}
                    }
            }
        }

        function onDragStart(cm, e) {
            if (ie && (!cm.state.draggingText || +new Date - lastDrop < 100)) return void e_stop(e);
            if (!signalDOMEvent(cm, e) && !eventInWidget(cm.display, e) && (e.dataTransfer.setData("Text", cm.getSelection()), e.dataTransfer.effectAllowed = "copyMove", e.dataTransfer.setDragImage && !safari)) {
                var img = elt("img", null, null, "position: fixed; left: 0; top: 0;");
                img.src = "data:image/gif;base64,R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==", presto && (img.width = img.height = 1, cm.display.wrapper.appendChild(img), img._top = img.offsetTop), e.dataTransfer.setDragImage(img, 0, 0), presto && img.parentNode.removeChild(img)
            }
        }

        function onDragOver(cm, e) {
            var pos = posFromMouse(cm, e);
            if (pos) {
                var frag = document.createDocumentFragment();
                drawSelectionCursor(cm, pos, frag), cm.display.dragCursor || (cm.display.dragCursor = elt("div", null, "CodeMirror-cursors CodeMirror-dragcursors"), cm.display.lineSpace.insertBefore(cm.display.dragCursor, cm.display.cursorDiv)), removeChildrenAndAdd(cm.display.dragCursor, frag)
            }
        }

        function clearDragCursor(cm) {
            cm.display.dragCursor && (cm.display.lineSpace.removeChild(cm.display.dragCursor), cm.display.dragCursor = null)
        }

        function forEachCodeMirror(f) {
            if (document.getElementsByClassName)
                for (var byClass = document.getElementsByClassName("CodeMirror"), i = 0; i < byClass.length; i++) {
                    var cm = byClass[i].CodeMirror;
                    cm && f(cm)
                }
        }

        function ensureGlobalHandlers() {
            globalsRegistered || (registerGlobalHandlers(), globalsRegistered = !0)
        }

        function registerGlobalHandlers() {
            var resizeTimer;
            on(window, "resize", function() {
                null == resizeTimer && (resizeTimer = setTimeout(function() {
                    resizeTimer = null, forEachCodeMirror(onResize)
                }, 100))
            }), on(window, "blur", function() {
                return forEachCodeMirror(onBlur)
            })
        }

        function onResize(cm) {
            var d = cm.display;
            d.lastWrapHeight == d.wrapper.clientHeight && d.lastWrapWidth == d.wrapper.clientWidth || (d.cachedCharWidth = d.cachedTextHeight = d.cachedPaddingH = null, d.scrollbarsClipped = !1, cm.setSize())
        }

        function normalizeKeyName(name) {
            var parts = name.split(/-(?!$)/);
            name = parts[parts.length - 1];
            for (var alt, ctrl, shift, cmd, i = 0; i < parts.length - 1; i++) {
                var mod = parts[i];
                if (/^(cmd|meta|m)$/i.test(mod)) cmd = !0;
                else if (/^a(lt)?$/i.test(mod)) alt = !0;
                else if (/^(c|ctrl|control)$/i.test(mod)) ctrl = !0;
                else {
                    if (!/^s(hift)?$/i.test(mod)) throw new Error("Unrecognized modifier name: " + mod);
                    shift = !0
                }
            }
            return alt && (name = "Alt-" + name), ctrl && (name = "Ctrl-" + name), cmd && (name = "Cmd-" + name), shift && (name = "Shift-" + name), name
        }

        function normalizeKeyMap(keymap) {
            var copy = {};
            for (var keyname in keymap)
                if (keymap.hasOwnProperty(keyname)) {
                    var value = keymap[keyname];
                    if (/^(name|fallthrough|(de|at)tach)$/.test(keyname)) continue;
                    if ("..." == value) {
                        delete keymap[keyname];
                        continue
                    }
                    for (var keys = map(keyname.split(" "), normalizeKeyName), i = 0; i < keys.length; i++) {
                        var val = void 0,
                            name = void 0;
                        i == keys.length - 1 ? (name = keys.join(" "), val = value) : (name = keys.slice(0, i + 1).join(" "), val = "...");
                        var prev = copy[name];
                        if (prev) {
                            if (prev != val) throw new Error("Inconsistent bindings for " + name)
                        } else copy[name] = val
                    }
                    delete keymap[keyname]
                } for (var prop in copy) keymap[prop] = copy[prop];
            return keymap
        }

        function lookupKey(key, map$$1, handle, context) {
            map$$1 = getKeyMap(map$$1);
            var found = map$$1.call ? map$$1.call(key, context) : map$$1[key];
            if (found === !1) return "nothing";
            if ("..." === found) return "multi";
            if (null != found && handle(found)) return "handled";
            if (map$$1.fallthrough) {
                if ("[object Array]" != Object.prototype.toString.call(map$$1.fallthrough)) return lookupKey(key, map$$1.fallthrough, handle, context);
                for (var i = 0; i < map$$1.fallthrough.length; i++) {
                    var result = lookupKey(key, map$$1.fallthrough[i], handle, context);
                    if (result) return result
                }
            }
        }

        function isModifierKey(value) {
            var name = "string" == typeof value ? value : keyNames[value.keyCode];
            return "Ctrl" == name || "Alt" == name || "Shift" == name || "Mod" == name
        }

        function addModifierNames(name, event, noShift) {
            var base = name;
            return event.altKey && "Alt" != base && (name = "Alt-" + name), (flipCtrlCmd ? event.metaKey : event.ctrlKey) && "Ctrl" != base && (name = "Ctrl-" + name), (flipCtrlCmd ? event.ctrlKey : event.metaKey) && "Cmd" != base && (name = "Cmd-" + name), !noShift && event.shiftKey && "Shift" != base && (name = "Shift-" + name), name
        }

        function keyName(event, noShift) {
            if (presto && 34 == event.keyCode && event.char) return !1;
            var name = keyNames[event.keyCode];
            return null != name && !event.altGraphKey && (3 == event.keyCode && event.code && (name = event.code), addModifierNames(name, event, noShift))
        }

        function getKeyMap(val) {
            return "string" == typeof val ? keyMap[val] : val
        }

        function deleteNearSelection(cm, compute) {
            for (var ranges = cm.doc.sel.ranges, kill = [], i = 0; i < ranges.length; i++) {
                for (var toKill = compute(ranges[i]); kill.length && cmp(toKill.from, lst(kill).to) <= 0;) {
                    var replaced = kill.pop();
                    if (cmp(replaced.from, toKill.from) < 0) {
                        toKill.from = replaced.from;
                        break
                    }
                }
                kill.push(toKill)
            }
            runInOp(cm, function() {
                for (var i = kill.length - 1; i >= 0; i--) _replaceRange(cm.doc, "", kill[i].from, kill[i].to, "+delete");
                ensureCursorVisible(cm)
            })
        }

        function moveCharLogically(line, ch, dir) {
            var target = skipExtendingChars(line.text, ch + dir, dir);
            return target < 0 || target > line.text.length ? null : target
        }

        function moveLogically(line, start, dir) {
            var ch = moveCharLogically(line, start.ch, dir);
            return null == ch ? null : new Pos(start.line, ch, dir < 0 ? "after" : "before")
        }

        function endOfLine(visually, cm, lineObj, lineNo, dir) {
            if (visually) {
                var order = getOrder(lineObj, cm.doc.direction);
                if (order) {
                    var ch, part = dir < 0 ? lst(order) : order[0],
                        moveInStorageOrder = dir < 0 == (1 == part.level),
                        sticky = moveInStorageOrder ? "after" : "before";
                    if (part.level > 0 || "rtl" == cm.doc.direction) {
                        var prep = prepareMeasureForLine(cm, lineObj);
                        ch = dir < 0 ? lineObj.text.length - 1 : 0;
                        var targetTop = measureCharPrepared(cm, prep, ch).top;
                        ch = findFirst(function(ch) {
                            return measureCharPrepared(cm, prep, ch).top == targetTop
                        }, dir < 0 == (1 == part.level) ? part.from : part.to - 1, ch), "before" == sticky && (ch = moveCharLogically(lineObj, ch, 1))
                    } else ch = dir < 0 ? part.to : part.from;
                    return new Pos(lineNo, ch, sticky)
                }
            }
            return new Pos(lineNo, dir < 0 ? lineObj.text.length : 0, dir < 0 ? "before" : "after")
        }

        function moveVisually(cm, line, start, dir) {
            var bidi = getOrder(line, cm.doc.direction);
            if (!bidi) return moveLogically(line, start, dir);
            start.ch >= line.text.length ? (start.ch = line.text.length, start.sticky = "before") : start.ch <= 0 && (start.ch = 0, start.sticky = "after");
            var partPos = getBidiPartAt(bidi, start.ch, start.sticky),
                part = bidi[partPos];
            if ("ltr" == cm.doc.direction && part.level % 2 == 0 && (dir > 0 ? part.to > start.ch : part.from < start.ch)) return moveLogically(line, start, dir);
            var prep, mv = function(pos, dir) {
                    return moveCharLogically(line, pos instanceof Pos ? pos.ch : pos, dir)
                },
                getWrappedLineExtent = function(ch) {
                    return cm.options.lineWrapping ? (prep = prep || prepareMeasureForLine(cm, line), wrappedLineExtentChar(cm, line, prep, ch)) : {
                        begin: 0,
                        end: line.text.length
                    }
                },
                wrappedLineExtent = getWrappedLineExtent("before" == start.sticky ? mv(start, -1) : start.ch);
            if ("rtl" == cm.doc.direction || 1 == part.level) {
                var moveInStorageOrder = 1 == part.level == dir < 0,
                    ch = mv(start, moveInStorageOrder ? 1 : -1);
                if (null != ch && (moveInStorageOrder ? ch <= part.to && ch <= wrappedLineExtent.end : ch >= part.from && ch >= wrappedLineExtent.begin)) {
                    var sticky = moveInStorageOrder ? "before" : "after";
                    return new Pos(start.line, ch, sticky)
                }
            }
            var searchInVisualLine = function(partPos, dir, wrappedLineExtent) {
                    for (var getRes = function(ch, moveInStorageOrder) {
                            return moveInStorageOrder ? new Pos(start.line, mv(ch, 1), "before") : new Pos(start.line, ch, "after")
                        }; partPos >= 0 && partPos < bidi.length; partPos += dir) {
                        var part = bidi[partPos],
                            moveInStorageOrder = dir > 0 == (1 != part.level),
                            ch = moveInStorageOrder ? wrappedLineExtent.begin : mv(wrappedLineExtent.end, -1);
                        if (part.from <= ch && ch < part.to) return getRes(ch, moveInStorageOrder);
                        if (ch = moveInStorageOrder ? part.from : mv(part.to, -1), wrappedLineExtent.begin <= ch && ch < wrappedLineExtent.end) return getRes(ch, moveInStorageOrder)
                    }
                },
                res = searchInVisualLine(partPos + dir, dir, wrappedLineExtent);
            if (res) return res;
            var nextCh = dir > 0 ? wrappedLineExtent.end : mv(wrappedLineExtent.begin, -1);
            return null == nextCh || dir > 0 && nextCh == line.text.length || !(res = searchInVisualLine(dir > 0 ? 0 : bidi.length - 1, dir, getWrappedLineExtent(nextCh))) ? null : res
        }

        function lineStart(cm, lineN) {
            var line = getLine(cm.doc, lineN),
                visual = visualLine(line);
            return visual != line && (lineN = lineNo(visual)), endOfLine(!0, cm, visual, lineN, 1)
        }

        function lineEnd(cm, lineN) {
            var line = getLine(cm.doc, lineN),
                visual = visualLineEnd(line);
            return visual != line && (lineN = lineNo(visual)), endOfLine(!0, cm, line, lineN, -1)
        }

        function lineStartSmart(cm, pos) {
            var start = lineStart(cm, pos.line),
                line = getLine(cm.doc, start.line),
                order = getOrder(line, cm.doc.direction);
            if (!order || 0 == order[0].level) {
                var firstNonWS = Math.max(0, line.text.search(/\S/)),
                    inWS = pos.line == start.line && pos.ch <= firstNonWS && pos.ch;
                return Pos(start.line, inWS ? 0 : firstNonWS, start.sticky)
            }
            return start
        }

        function doHandleBinding(cm, bound, dropShift) {
            if ("string" == typeof bound && (bound = commands[bound], !bound)) return !1;
            cm.display.input.ensurePolled();
            var prevShift = cm.display.shift,
                done = !1;
            try {
                cm.isReadOnly() && (cm.state.suppressEdits = !0), dropShift && (cm.display.shift = !1), done = bound(cm) != Pass
            } finally {
                cm.display.shift = prevShift, cm.state.suppressEdits = !1
            }
            return done
        }

        function lookupKeyForEditor(cm, name, handle) {
            for (var i = 0; i < cm.state.keyMaps.length; i++) {
                var result = lookupKey(name, cm.state.keyMaps[i], handle, cm);
                if (result) return result
            }
            return cm.options.extraKeys && lookupKey(name, cm.options.extraKeys, handle, cm) || lookupKey(name, cm.options.keyMap, handle, cm)
        }

        function dispatchKey(cm, name, e, handle) {
            var seq = cm.state.keySeq;
            if (seq) {
                if (isModifierKey(name)) return "handled";
                if (/\'$/.test(name) ? cm.state.keySeq = null : stopSeq.set(50, function() {
                        cm.state.keySeq == seq && (cm.state.keySeq = null, cm.display.input.reset())
                    }), dispatchKeyInner(cm, seq + " " + name, e, handle)) return !0
            }
            return dispatchKeyInner(cm, name, e, handle)
        }

        function dispatchKeyInner(cm, name, e, handle) {
            var result = lookupKeyForEditor(cm, name, handle);
            return "multi" == result && (cm.state.keySeq = name), "handled" == result && signalLater(cm, "keyHandled", cm, name, e), "handled" != result && "multi" != result || (e_preventDefault(e), restartBlink(cm)), !!result
        }

        function handleKeyBinding(cm, e) {
            var name = keyName(e, !0);
            return !!name && (e.shiftKey && !cm.state.keySeq ? dispatchKey(cm, "Shift-" + name, e, function(b) {
                return doHandleBinding(cm, b, !0)
            }) || dispatchKey(cm, name, e, function(b) {
                if ("string" == typeof b ? /^go[A-Z]/.test(b) : b.motion) return doHandleBinding(cm, b)
            }) : dispatchKey(cm, name, e, function(b) {
                return doHandleBinding(cm, b)
            }))
        }

        function handleCharBinding(cm, e, ch) {
            return dispatchKey(cm, "'" + ch + "'", e, function(b) {
                return doHandleBinding(cm, b, !0)
            })
        }

        function onKeyDown(e) {
            var cm = this;
            if (cm.curOp.focus = activeElt(), !signalDOMEvent(cm, e)) {
                ie && ie_version < 11 && 27 == e.keyCode && (e.returnValue = !1);
                var code = e.keyCode;
                cm.display.shift = 16 == code || e.shiftKey;
                var handled = handleKeyBinding(cm, e);
                presto && (lastStoppedKey = handled ? code : null, !handled && 88 == code && !hasCopyEvent && (mac ? e.metaKey : e.ctrlKey) && cm.replaceSelection("", null, "cut")), 18 != code || /\bCodeMirror-crosshair\b/.test(cm.display.lineDiv.className) || showCrossHair(cm)
            }
        }

        function showCrossHair(cm) {
            function up(e) {
                18 != e.keyCode && e.altKey || (rmClass(lineDiv, "CodeMirror-crosshair"), off(document, "keyup", up), off(document, "mouseover", up))
            }
            var lineDiv = cm.display.lineDiv;
            addClass(lineDiv, "CodeMirror-crosshair"), on(document, "keyup", up), on(document, "mouseover", up)
        }

        function onKeyUp(e) {
            16 == e.keyCode && (this.doc.sel.shift = !1), signalDOMEvent(this, e)
        }

        function onKeyPress(e) {
            var cm = this;
            if (!(eventInWidget(cm.display, e) || signalDOMEvent(cm, e) || e.ctrlKey && !e.altKey || mac && e.metaKey)) {
                var keyCode = e.keyCode,
                    charCode = e.charCode;
                if (presto && keyCode == lastStoppedKey) return lastStoppedKey = null, void e_preventDefault(e);
                if (!presto || e.which && !(e.which < 10) || !handleKeyBinding(cm, e)) {
                    var ch = String.fromCharCode(null == charCode ? keyCode : charCode);
                    "\b" != ch && (handleCharBinding(cm, e, ch) || cm.display.input.onKeyPress(e))
                }
            }
        }

        function clickRepeat(pos, button) {
            var now = +new Date;
            return lastDoubleClick && lastDoubleClick.compare(now, pos, button) ? (lastClick = lastDoubleClick = null, "triple") : lastClick && lastClick.compare(now, pos, button) ? (lastDoubleClick = new PastClick(now, pos, button), lastClick = null, "double") : (lastClick = new PastClick(now, pos, button), lastDoubleClick = null, "single")
        }

        function onMouseDown(e) {
            var cm = this,
                display = cm.display;
            if (!(signalDOMEvent(cm, e) || display.activeTouch && display.input.supportsTouch())) {
                if (display.input.ensurePolled(), display.shift = e.shiftKey, eventInWidget(display, e)) return void(webkit || (display.scroller.draggable = !1, setTimeout(function() {
                    return display.scroller.draggable = !0
                }, 100)));
                if (!clickInGutter(cm, e)) {
                    var pos = posFromMouse(cm, e),
                        button = e_button(e),
                        repeat = pos ? clickRepeat(pos, button) : "single";
                    window.focus(), 1 == button && cm.state.selectingText && cm.state.selectingText(e), pos && handleMappedButton(cm, button, pos, repeat, e) || (1 == button ? pos ? leftButtonDown(cm, pos, repeat, e) : e_target(e) == display.scroller && e_preventDefault(e) : 2 == button ? (pos && extendSelection(cm.doc, pos), setTimeout(function() {
                        return display.input.focus()
                    }, 20)) : 3 == button && (captureRightClick ? onContextMenu(cm, e) : delayBlurEvent(cm)))
                }
            }
        }

        function handleMappedButton(cm, button, pos, repeat, event) {
            var name = "Click";
            return "double" == repeat ? name = "Double" + name : "triple" == repeat && (name = "Triple" + name), name = (1 == button ? "Left" : 2 == button ? "Middle" : "Right") + name, dispatchKey(cm, addModifierNames(name, event), event, function(bound) {
                if ("string" == typeof bound && (bound = commands[bound]), !bound) return !1;
                var done = !1;
                try {
                    cm.isReadOnly() && (cm.state.suppressEdits = !0), done = bound(cm, pos) != Pass
                } finally {
                    cm.state.suppressEdits = !1
                }
                return done
            })
        }

        function configureMouse(cm, repeat, event) {
            var option = cm.getOption("configureMouse"),
                value = option ? option(cm, repeat, event) : {};
            if (null == value.unit) {
                var rect = chromeOS ? event.shiftKey && event.metaKey : event.altKey;
                value.unit = rect ? "rectangle" : "single" == repeat ? "char" : "double" == repeat ? "word" : "line"
            }
            return (null == value.extend || cm.doc.extend) && (value.extend = cm.doc.extend || event.shiftKey), null == value.addNew && (value.addNew = mac ? event.metaKey : event.ctrlKey), null == value.moveOnDrag && (value.moveOnDrag = !(mac ? event.altKey : event.ctrlKey)), value
        }

        function leftButtonDown(cm, pos, repeat, event) {
            ie ? setTimeout(bind(ensureFocus, cm), 0) : cm.curOp.focus = activeElt();
            var contained, behavior = configureMouse(cm, repeat, event),
                sel = cm.doc.sel;
            cm.options.dragDrop && dragAndDrop && !cm.isReadOnly() && "single" == repeat && (contained = sel.contains(pos)) > -1 && (cmp((contained = sel.ranges[contained]).from(), pos) < 0 || pos.xRel > 0) && (cmp(contained.to(), pos) > 0 || pos.xRel < 0) ? leftButtonStartDrag(cm, event, pos, behavior) : leftButtonSelect(cm, event, pos, behavior)
        }

        function leftButtonStartDrag(cm, event, pos, behavior) {
            var display = cm.display,
                moved = !1,
                dragEnd = operation(cm, function(e) {
                    webkit && (display.scroller.draggable = !1), cm.state.draggingText = !1, off(display.wrapper.ownerDocument, "mouseup", dragEnd), off(display.wrapper.ownerDocument, "mousemove", mouseMove), off(display.scroller, "dragstart", dragStart), off(display.scroller, "drop", dragEnd), moved || (e_preventDefault(e), behavior.addNew || extendSelection(cm.doc, pos, null, null, behavior.extend), webkit || ie && 9 == ie_version ? setTimeout(function() {
                        display.wrapper.ownerDocument.body.focus(), display.input.focus()
                    }, 20) : display.input.focus())
                }),
                mouseMove = function(e2) {
                    moved = moved || Math.abs(event.clientX - e2.clientX) + Math.abs(event.clientY - e2.clientY) >= 10
                },
                dragStart = function() {
                    return moved = !0
                };
            webkit && (display.scroller.draggable = !0), cm.state.draggingText = dragEnd, dragEnd.copy = !behavior.moveOnDrag, display.scroller.dragDrop && display.scroller.dragDrop(), on(display.wrapper.ownerDocument, "mouseup", dragEnd), on(display.wrapper.ownerDocument, "mousemove", mouseMove), on(display.scroller, "dragstart", dragStart), on(display.scroller, "drop", dragEnd), delayBlurEvent(cm), setTimeout(function() {
                return display.input.focus()
            }, 20)
        }

        function rangeForUnit(cm, pos, unit) {
            if ("char" == unit) return new Range(pos, pos);
            if ("word" == unit) return cm.findWordAt(pos);
            if ("line" == unit) return new Range(Pos(pos.line, 0), _clipPos(cm.doc, Pos(pos.line + 1, 0)));
            var result = unit(cm, pos);
            return new Range(result.from, result.to)
        }

        function leftButtonSelect(cm, event, start, behavior) {
            function extendTo(pos) {
                if (0 != cmp(lastPos, pos))
                    if (lastPos = pos, "rectangle" == behavior.unit) {
                        for (var ranges = [], tabSize = cm.options.tabSize, startCol = countColumn(getLine(doc, start.line).text, start.ch, tabSize), posCol = countColumn(getLine(doc, pos.line).text, pos.ch, tabSize), left = Math.min(startCol, posCol), right = Math.max(startCol, posCol), line = Math.min(start.line, pos.line), end = Math.min(cm.lastLine(), Math.max(start.line, pos.line)); line <= end; line++) {
                            var text = getLine(doc, line).text,
                                leftPos = findColumn(text, left, tabSize);
                            left == right ? ranges.push(new Range(Pos(line, leftPos), Pos(line, leftPos))) : text.length > leftPos && ranges.push(new Range(Pos(line, leftPos), Pos(line, findColumn(text, right, tabSize))))
                        }
                        ranges.length || ranges.push(new Range(start, start)), setSelection(doc, normalizeSelection(startSel.ranges.slice(0, ourIndex).concat(ranges), ourIndex), {
                            origin: "*mouse",
                            scroll: !1
                        }), cm.scrollIntoView(pos)
                    } else {
                        var head, oldRange = ourRange,
                            range$$1 = rangeForUnit(cm, pos, behavior.unit),
                            anchor = oldRange.anchor;
                        cmp(range$$1.anchor, anchor) > 0 ? (head = range$$1.head, anchor = minPos(oldRange.from(), range$$1.anchor)) : (head = range$$1.anchor, anchor = maxPos(oldRange.to(), range$$1.head));
                        var ranges$1 = startSel.ranges.slice(0);
                        ranges$1[ourIndex] = bidiSimplify(cm, new Range(_clipPos(doc, anchor), head)), setSelection(doc, normalizeSelection(ranges$1, ourIndex), sel_mouse)
                    }
            }

            function extend(e) {
                var curCount = ++counter,
                    cur = posFromMouse(cm, e, !0, "rectangle" == behavior.unit);
                if (cur)
                    if (0 != cmp(cur, lastPos)) {
                        cm.curOp.focus = activeElt(), extendTo(cur);
                        var visible = visibleLines(display, doc);
                        (cur.line >= visible.to || cur.line < visible.from) && setTimeout(operation(cm, function() {
                            counter == curCount && extend(e)
                        }), 150)
                    } else {
                        var outside = e.clientY < editorSize.top ? -20 : e.clientY > editorSize.bottom ? 20 : 0;
                        outside && setTimeout(operation(cm, function() {
                            counter == curCount && (display.scroller.scrollTop += outside, extend(e))
                        }), 50)
                    }
            }

            function done(e) {
                cm.state.selectingText = !1, counter = 1 / 0, e_preventDefault(e), display.input.focus(), off(display.wrapper.ownerDocument, "mousemove", move), off(display.wrapper.ownerDocument, "mouseup", up), doc.history.lastSelOrigin = null
            }
            var display = cm.display,
                doc = cm.doc;
            e_preventDefault(event);
            var ourRange, ourIndex, startSel = doc.sel,
                ranges = startSel.ranges;
            if (behavior.addNew && !behavior.extend ? (ourIndex = doc.sel.contains(start), ourRange = ourIndex > -1 ? ranges[ourIndex] : new Range(start, start)) : (ourRange = doc.sel.primary(), ourIndex = doc.sel.primIndex), "rectangle" == behavior.unit) behavior.addNew || (ourRange = new Range(start, start)), start = posFromMouse(cm, event, !0, !0), ourIndex = -1;
            else {
                var range$$1 = rangeForUnit(cm, start, behavior.unit);
                ourRange = behavior.extend ? extendRange(ourRange, range$$1.anchor, range$$1.head, behavior.extend) : range$$1
            }
            behavior.addNew ? ourIndex == -1 ? (ourIndex = ranges.length, setSelection(doc, normalizeSelection(ranges.concat([ourRange]), ourIndex), {
                scroll: !1,
                origin: "*mouse"
            })) : ranges.length > 1 && ranges[ourIndex].empty() && "char" == behavior.unit && !behavior.extend ? (setSelection(doc, normalizeSelection(ranges.slice(0, ourIndex).concat(ranges.slice(ourIndex + 1)), 0), {
                scroll: !1,
                origin: "*mouse"
            }), startSel = doc.sel) : replaceOneSelection(doc, ourIndex, ourRange, sel_mouse) : (ourIndex = 0, setSelection(doc, new Selection([ourRange], 0), sel_mouse), startSel = doc.sel);
            var lastPos = start,
                editorSize = display.wrapper.getBoundingClientRect(),
                counter = 0,
                move = operation(cm, function(e) {
                    e_button(e) ? extend(e) : done(e)
                }),
                up = operation(cm, done);
            cm.state.selectingText = up, on(display.wrapper.ownerDocument, "mousemove", move), on(display.wrapper.ownerDocument, "mouseup", up)
        }

        function bidiSimplify(cm, range$$1) {
            var anchor = range$$1.anchor,
                head = range$$1.head,
                anchorLine = getLine(cm.doc, anchor.line);
            if (0 == cmp(anchor, head) && anchor.sticky == head.sticky) return range$$1;
            var order = getOrder(anchorLine);
            if (!order) return range$$1;
            var index = getBidiPartAt(order, anchor.ch, anchor.sticky),
                part = order[index];
            if (part.from != anchor.ch && part.to != anchor.ch) return range$$1;
            var boundary = index + (part.from == anchor.ch == (1 != part.level) ? 0 : 1);
            if (0 == boundary || boundary == order.length) return range$$1;
            var leftSide;
            if (head.line != anchor.line) leftSide = (head.line - anchor.line) * ("ltr" == cm.doc.direction ? 1 : -1) > 0;
            else {
                var headIndex = getBidiPartAt(order, head.ch, head.sticky),
                    dir = headIndex - index || (head.ch - anchor.ch) * (1 == part.level ? -1 : 1);
                leftSide = headIndex == boundary - 1 || headIndex == boundary ? dir < 0 : dir > 0
            }
            var usePart = order[boundary + (leftSide ? -1 : 0)],
                from = leftSide == (1 == usePart.level),
                ch = from ? usePart.from : usePart.to,
                sticky = from ? "after" : "before";
            return anchor.ch == ch && anchor.sticky == sticky ? range$$1 : new Range(new Pos(anchor.line, ch, sticky), head)
        }

        function gutterEvent(cm, e, type, prevent) {
            var mX, mY;
            if (e.touches) mX = e.touches[0].clientX, mY = e.touches[0].clientY;
            else try {
                mX = e.clientX, mY = e.clientY
            } catch (e) {
                return !1
            }
            if (mX >= Math.floor(cm.display.gutters.getBoundingClientRect().right)) return !1;
            prevent && e_preventDefault(e);
            var display = cm.display,
                lineBox = display.lineDiv.getBoundingClientRect();
            if (mY > lineBox.bottom || !hasHandler(cm, type)) return e_defaultPrevented(e);
            mY -= lineBox.top - display.viewOffset;
            for (var i = 0; i < cm.options.gutters.length; ++i) {
                var g = display.gutters.childNodes[i];
                if (g && g.getBoundingClientRect().right >= mX) {
                    var line = _lineAtHeight(cm.doc, mY),
                        gutter = cm.options.gutters[i];
                    return signal(cm, type, cm, line, gutter, e), e_defaultPrevented(e)
                }
            }
        }

        function clickInGutter(cm, e) {
            return gutterEvent(cm, e, "gutterClick", !0)
        }

        function onContextMenu(cm, e) {
            eventInWidget(cm.display, e) || contextMenuInGutter(cm, e) || signalDOMEvent(cm, e, "contextmenu") || cm.display.input.onContextMenu(e)
        }

        function contextMenuInGutter(cm, e) {
            return !!hasHandler(cm, "gutterContextMenu") && gutterEvent(cm, e, "gutterContextMenu", !1)
        }

        function themeChanged(cm) {
            cm.display.wrapper.className = cm.display.wrapper.className.replace(/\s*cm-s-\S+/g, "") + cm.options.theme.replace(/(^|\s)\s*/g, " cm-s-"), clearCaches(cm)
        }

        function defineOptions(CodeMirror) {
            function option(name, deflt, handle, notOnInit) {
                CodeMirror.defaults[name] = deflt, handle && (optionHandlers[name] = notOnInit ? function(cm, val, old) {
                    old != Init && handle(cm, val, old)
                } : handle)
            }
            var optionHandlers = CodeMirror.optionHandlers;
            CodeMirror.defineOption = option, CodeMirror.Init = Init, option("value", "", function(cm, val) {
                return cm.setValue(val)
            }, !0), option("mode", null, function(cm, val) {
                cm.doc.modeOption = val, loadMode(cm)
            }, !0), option("indentUnit", 2, loadMode, !0), option("indentWithTabs", !1), option("smartIndent", !0), option("tabSize", 4, function(cm) {
                resetModeState(cm), clearCaches(cm), regChange(cm)
            }, !0), option("lineSeparator", null, function(cm, val) {
                if (cm.doc.lineSep = val, val) {
                    var newBreaks = [],
                        lineNo = cm.doc.first;
                    cm.doc.iter(function(line) {
                        for (var pos = 0;;) {
                            var found = line.text.indexOf(val, pos);
                            if (found == -1) break;
                            pos = found + val.length, newBreaks.push(Pos(lineNo, found))
                        }
                        lineNo++
                    });
                    for (var i = newBreaks.length - 1; i >= 0; i--) _replaceRange(cm.doc, val, newBreaks[i], Pos(newBreaks[i].line, newBreaks[i].ch + val.length))
                }
            }), option("specialChars", /[\u0000-\u001f\u007f-\u009f\u00ad\u061c\u200b-\u200f\u2028\u2029\ufeff]/g, function(cm, val, old) {
                cm.state.specialChars = new RegExp(val.source + (val.test("\t") ? "" : "|\t"), "g"), old != Init && cm.refresh()
            }), option("specialCharPlaceholder", defaultSpecialCharPlaceholder, function(cm) {
                return cm.refresh()
            }, !0), option("electricChars", !0), option("inputStyle", mobile ? "contenteditable" : "textarea", function() {
                throw new Error("inputStyle can not (yet) be changed in a running editor")
            }, !0), option("spellcheck", !1, function(cm, val) {
                return cm.getInputField().spellcheck = val
            }, !0), option("rtlMoveVisually", !windows), option("wholeLineUpdateBefore", !0), option("theme", "default", function(cm) {
                themeChanged(cm), guttersChanged(cm)
            }, !0), option("keyMap", "default", function(cm, val, old) {
                var next = getKeyMap(val),
                    prev = old != Init && getKeyMap(old);
                prev && prev.detach && prev.detach(cm, next), next.attach && next.attach(cm, prev || null)
            }), option("extraKeys", null), option("configureMouse", null), option("lineWrapping", !1, wrappingChanged, !0), option("gutters", [], function(cm) {
                setGuttersForLineNumbers(cm.options), guttersChanged(cm)
            }, !0), option("fixedGutter", !0, function(cm, val) {
                cm.display.gutters.style.left = val ? compensateForHScroll(cm.display) + "px" : "0", cm.refresh()
            }, !0), option("coverGutterNextToScrollbar", !1, function(cm) {
                return updateScrollbars(cm)
            }, !0), option("scrollbarStyle", "native", function(cm) {
                initScrollbars(cm), updateScrollbars(cm), cm.display.scrollbars.setScrollTop(cm.doc.scrollTop), cm.display.scrollbars.setScrollLeft(cm.doc.scrollLeft)
            }, !0), option("lineNumbers", !1, function(cm) {
                setGuttersForLineNumbers(cm.options), guttersChanged(cm)
            }, !0), option("firstLineNumber", 1, guttersChanged, !0), option("lineNumberFormatter", function(integer) {
                return integer
            }, guttersChanged, !0), option("showCursorWhenSelecting", !1, updateSelection, !0), option("resetSelectionOnContextMenu", !0), option("lineWiseCopyCut", !0), option("pasteLinesPerSelection", !0), option("readOnly", !1, function(cm, val) {
                "nocursor" == val && (onBlur(cm), cm.display.input.blur()), cm.display.input.readOnlyChanged(val)
            }), option("disableInput", !1, function(cm, val) {
                val || cm.display.input.reset()
            }, !0), option("dragDrop", !0, dragDropChanged), option("allowDropFileTypes", null), option("cursorBlinkRate", 530), option("cursorScrollMargin", 0), option("cursorHeight", 1, updateSelection, !0), option("singleCursorHeightPerLine", !0, updateSelection, !0), option("workTime", 100), option("workDelay", 100), option("flattenSpans", !0, resetModeState, !0), option("addModeClass", !1, resetModeState, !0), option("pollInterval", 100), option("undoDepth", 200, function(cm, val) {
                return cm.doc.history.undoDepth = val
            }), option("historyEventDelay", 1250), option("viewportMargin", 10, function(cm) {
                return cm.refresh()
            }, !0), option("maxHighlightLength", 1e4, resetModeState, !0), option("moveInputWithCursor", !0, function(cm, val) {
                val || cm.display.input.resetPosition()
            }), option("tabindex", null, function(cm, val) {
                return cm.display.input.getField().tabIndex = val || ""
            }), option("autofocus", null), option("direction", "ltr", function(cm, val) {
                return cm.doc.setDirection(val)
            }, !0)
        }

        function guttersChanged(cm) {
            updateGutters(cm), regChange(cm), alignHorizontally(cm)
        }

        function dragDropChanged(cm, value, old) {
            var wasOn = old && old != Init;
            if (!value != !wasOn) {
                var funcs = cm.display.dragFunctions,
                    toggle = value ? on : off;
                toggle(cm.display.scroller, "dragstart", funcs.start), toggle(cm.display.scroller, "dragenter", funcs.enter), toggle(cm.display.scroller, "dragover", funcs.over), toggle(cm.display.scroller, "dragleave", funcs.leave), toggle(cm.display.scroller, "drop", funcs.drop)
            }
        }

        function wrappingChanged(cm) {
            cm.options.lineWrapping ? (addClass(cm.display.wrapper, "CodeMirror-wrap"), cm.display.sizer.style.minWidth = "", cm.display.sizerWidth = null) : (rmClass(cm.display.wrapper, "CodeMirror-wrap"), findMaxLine(cm)), estimateLineHeights(cm), regChange(cm), clearCaches(cm), setTimeout(function() {
                return updateScrollbars(cm)
            }, 100)
        }

        function CodeMirror$1(place, options) {
            var this$1 = this;
            if (!(this instanceof CodeMirror$1)) return new CodeMirror$1(place, options);
            this.options = options = options ? copyObj(options) : {}, copyObj(defaults, options, !1), setGuttersForLineNumbers(options);
            var doc = options.value;
            "string" == typeof doc && (doc = new Doc(doc, options.mode, null, options.lineSeparator, options.direction)), this.doc = doc;
            var input = new CodeMirror$1.inputStyles[options.inputStyle](this),
                display = this.display = new Display(place, doc, input);
            display.wrapper.CodeMirror = this, updateGutters(this), themeChanged(this), options.lineWrapping && (this.display.wrapper.className += " CodeMirror-wrap"), initScrollbars(this), this.state = {
                keyMaps: [],
                overlays: [],
                modeGen: 0,
                overwrite: !1,
                delayingBlurEvent: !1,
                focused: !1,
                suppressEdits: !1,
                pasteIncoming: !1,
                cutIncoming: !1,
                selectingText: !1,
                draggingText: !1,
                highlight: new Delayed,
                keySeq: null,
                specialChars: null
            }, options.autofocus && !mobile && display.input.focus(), ie && ie_version < 11 && setTimeout(function() {
                return this$1.display.input.reset(!0)
            }, 20), registerEventHandlers(this), ensureGlobalHandlers(), _startOperation(this), this.curOp.forceUpdate = !0, attachDoc(this, doc), options.autofocus && !mobile || this.hasFocus() ? setTimeout(bind(onFocus, this), 20) : onBlur(this);
            for (var opt in optionHandlers) optionHandlers.hasOwnProperty(opt) && optionHandlers[opt](this$1, options[opt], Init);
            maybeUpdateLineNumberWidth(this), options.finishInit && options.finishInit(this);
            for (var i = 0; i < initHooks.length; ++i) initHooks[i](this$1);
            _endOperation(this), webkit && options.lineWrapping && "optimizelegibility" == getComputedStyle(display.lineDiv).textRendering && (display.lineDiv.style.textRendering = "auto")
        }

        function registerEventHandlers(cm) {
            function finishTouch() {
                d.activeTouch && (touchFinished = setTimeout(function() {
                    return d.activeTouch = null
                }, 1e3), prevTouch = d.activeTouch, prevTouch.end = +new Date)
            }

            function isMouseLikeTouchEvent(e) {
                if (1 != e.touches.length) return !1;
                var touch = e.touches[0];
                return touch.radiusX <= 1 && touch.radiusY <= 1
            }

            function farAway(touch, other) {
                if (null == other.left) return !0;
                var dx = other.left - touch.left,
                    dy = other.top - touch.top;
                return dx * dx + dy * dy > 400
            }
            var d = cm.display;
            on(d.scroller, "mousedown", operation(cm, onMouseDown)), ie && ie_version < 11 ? on(d.scroller, "dblclick", operation(cm, function(e) {
                if (!signalDOMEvent(cm, e)) {
                    var pos = posFromMouse(cm, e);
                    if (pos && !clickInGutter(cm, e) && !eventInWidget(cm.display, e)) {
                        e_preventDefault(e);
                        var word = cm.findWordAt(pos);
                        extendSelection(cm.doc, word.anchor, word.head)
                    }
                }
            })) : on(d.scroller, "dblclick", function(e) {
                return signalDOMEvent(cm, e) || e_preventDefault(e)
            }), captureRightClick || on(d.scroller, "contextmenu", function(e) {
                return onContextMenu(cm, e)
            });
            var touchFinished, prevTouch = {
                end: 0
            };
            on(d.scroller, "touchstart", function(e) {
                if (!signalDOMEvent(cm, e) && !isMouseLikeTouchEvent(e) && !clickInGutter(cm, e)) {
                    d.input.ensurePolled(), clearTimeout(touchFinished);
                    var now = +new Date;
                    d.activeTouch = {
                        start: now,
                        moved: !1,
                        prev: now - prevTouch.end <= 300 ? prevTouch : null
                    }, 1 == e.touches.length && (d.activeTouch.left = e.touches[0].pageX, d.activeTouch.top = e.touches[0].pageY)
                }
            }), on(d.scroller, "touchmove", function() {
                d.activeTouch && (d.activeTouch.moved = !0)
            }), on(d.scroller, "touchend", function(e) {
                var touch = d.activeTouch;
                if (touch && !eventInWidget(d, e) && null != touch.left && !touch.moved && new Date - touch.start < 300) {
                    var range, pos = cm.coordsChar(d.activeTouch, "page");
                    range = !touch.prev || farAway(touch, touch.prev) ? new Range(pos, pos) : !touch.prev.prev || farAway(touch, touch.prev.prev) ? cm.findWordAt(pos) : new Range(Pos(pos.line, 0), _clipPos(cm.doc, Pos(pos.line + 1, 0))), cm.setSelection(range.anchor, range.head), cm.focus(), e_preventDefault(e)
                }
                finishTouch()
            }), on(d.scroller, "touchcancel", finishTouch), on(d.scroller, "scroll", function() {
                d.scroller.clientHeight && (updateScrollTop(cm, d.scroller.scrollTop), setScrollLeft(cm, d.scroller.scrollLeft, !0), signal(cm, "scroll", cm))
            }), on(d.scroller, "mousewheel", function(e) {
                return onScrollWheel(cm, e)
            }), on(d.scroller, "DOMMouseScroll", function(e) {
                return onScrollWheel(cm, e)
            }), on(d.wrapper, "scroll", function() {
                return d.wrapper.scrollTop = d.wrapper.scrollLeft = 0
            }), d.dragFunctions = {
                enter: function(e) {
                    signalDOMEvent(cm, e) || e_stop(e)
                },
                over: function(e) {
                    signalDOMEvent(cm, e) || (onDragOver(cm, e), e_stop(e))
                },
                start: function(e) {
                    return onDragStart(cm, e)
                },
                drop: operation(cm, onDrop),
                leave: function(e) {
                    signalDOMEvent(cm, e) || clearDragCursor(cm)
                }
            };
            var inp = d.input.getField();
            on(inp, "keyup", function(e) {
                return onKeyUp.call(cm, e)
            }), on(inp, "keydown", operation(cm, onKeyDown)), on(inp, "keypress", operation(cm, onKeyPress)), on(inp, "focus", function(e) {
                return onFocus(cm, e)
            }), on(inp, "blur", function(e) {
                return onBlur(cm, e)
            })
        }

        function indentLine(cm, n, how, aggressive) {
            var state, doc = cm.doc;
            null == how && (how = "add"), "smart" == how && (doc.mode.indent ? state = getContextBefore(cm, n).state : how = "prev");
            var tabSize = cm.options.tabSize,
                line = getLine(doc, n),
                curSpace = countColumn(line.text, null, tabSize);
            line.stateAfter && (line.stateAfter = null);
            var indentation, curSpaceString = line.text.match(/^\s*/)[0];
            if (aggressive || /\S/.test(line.text)) {
                if ("smart" == how && (indentation = doc.mode.indent(state, line.text.slice(curSpaceString.length), line.text), indentation == Pass || indentation > 150)) {
                    if (!aggressive) return;
                    how = "prev"
                }
            } else indentation = 0, how = "not";
            "prev" == how ? indentation = n > doc.first ? countColumn(getLine(doc, n - 1).text, null, tabSize) : 0 : "add" == how ? indentation = curSpace + cm.options.indentUnit : "subtract" == how ? indentation = curSpace - cm.options.indentUnit : "number" == typeof how && (indentation = curSpace + how), indentation = Math.max(0, indentation);
            var indentString = "",
                pos = 0;
            if (cm.options.indentWithTabs)
                for (var i = Math.floor(indentation / tabSize); i; --i) pos += tabSize, indentString += "\t";
            if (pos < indentation && (indentString += spaceStr(indentation - pos)), indentString != curSpaceString) return _replaceRange(doc, indentString, Pos(n, 0), Pos(n, curSpaceString.length), "+input"), line.stateAfter = null, !0;
            for (var i$1 = 0; i$1 < doc.sel.ranges.length; i$1++) {
                var range = doc.sel.ranges[i$1];
                if (range.head.line == n && range.head.ch < curSpaceString.length) {
                    var pos$1 = Pos(n, curSpaceString.length);
                    replaceOneSelection(doc, i$1, new Range(pos$1, pos$1));
                    break
                }
            }
        }

        function setLastCopied(newLastCopied) {
            lastCopied = newLastCopied
        }

        function applyTextInput(cm, inserted, deleted, sel, origin) {
            var doc = cm.doc;
            cm.display.shift = !1, sel || (sel = doc.sel);
            var paste = cm.state.pasteIncoming || "paste" == origin,
                textLines = splitLinesAuto(inserted),
                multiPaste = null;
            if (paste && sel.ranges.length > 1)
                if (lastCopied && lastCopied.text.join("\n") == inserted) {
                    if (sel.ranges.length % lastCopied.text.length == 0) {
                        multiPaste = [];
                        for (var i = 0; i < lastCopied.text.length; i++) multiPaste.push(doc.splitLines(lastCopied.text[i]))
                    }
                } else textLines.length == sel.ranges.length && cm.options.pasteLinesPerSelection && (multiPaste = map(textLines, function(l) {
                    return [l]
                }));
            for (var updateInput, i$1 = sel.ranges.length - 1; i$1 >= 0; i$1--) {
                var range$$1 = sel.ranges[i$1],
                    from = range$$1.from(),
                    to = range$$1.to();
                range$$1.empty() && (deleted && deleted > 0 ? from = Pos(from.line, from.ch - deleted) : cm.state.overwrite && !paste ? to = Pos(to.line, Math.min(getLine(doc, to.line).text.length, to.ch + lst(textLines).length)) : lastCopied && lastCopied.lineWise && lastCopied.text.join("\n") == inserted && (from = to = Pos(from.line, 0))), updateInput = cm.curOp.updateInput;
                var changeEvent = {
                    from: from,
                    to: to,
                    text: multiPaste ? multiPaste[i$1 % multiPaste.length] : textLines,
                    origin: origin || (paste ? "paste" : cm.state.cutIncoming ? "cut" : "+input")
                };
                makeChange(cm.doc, changeEvent), signalLater(cm, "inputRead", cm, changeEvent)
            }
            inserted && !paste && triggerElectric(cm, inserted), ensureCursorVisible(cm), cm.curOp.updateInput = updateInput, cm.curOp.typing = !0, cm.state.pasteIncoming = cm.state.cutIncoming = !1
        }

        function handlePaste(e, cm) {
            var pasted = e.clipboardData && e.clipboardData.getData("Text");
            if (pasted) return e.preventDefault(), cm.isReadOnly() || cm.options.disableInput || runInOp(cm, function() {
                return applyTextInput(cm, pasted, 0, null, "paste")
            }), !0
        }

        function triggerElectric(cm, inserted) {
            if (cm.options.electricChars && cm.options.smartIndent)
                for (var sel = cm.doc.sel, i = sel.ranges.length - 1; i >= 0; i--) {
                    var range$$1 = sel.ranges[i];
                    if (!(range$$1.head.ch > 100 || i && sel.ranges[i - 1].head.line == range$$1.head.line)) {
                        var mode = cm.getModeAt(range$$1.head),
                            indented = !1;
                        if (mode.electricChars) {
                            for (var j = 0; j < mode.electricChars.length; j++)
                                if (inserted.indexOf(mode.electricChars.charAt(j)) > -1) {
                                    indented = indentLine(cm, range$$1.head.line, "smart");
                                    break
                                }
                        } else mode.electricInput && mode.electricInput.test(getLine(cm.doc, range$$1.head.line).text.slice(0, range$$1.head.ch)) && (indented = indentLine(cm, range$$1.head.line, "smart"));
                        indented && signalLater(cm, "electricInput", cm, range$$1.head.line)
                    }
                }
        }

        function copyableRanges(cm) {
            for (var text = [], ranges = [], i = 0; i < cm.doc.sel.ranges.length; i++) {
                var line = cm.doc.sel.ranges[i].head.line,
                    lineRange = {
                        anchor: Pos(line, 0),
                        head: Pos(line + 1, 0)
                    };
                ranges.push(lineRange), text.push(cm.getRange(lineRange.anchor, lineRange.head))
            }
            return {
                text: text,
                ranges: ranges
            }
        }

        function disableBrowserMagic(field, spellcheck) {
            field.setAttribute("autocorrect", "off"), field.setAttribute("autocapitalize", "off"), field.setAttribute("spellcheck", !!spellcheck)
        }

        function hiddenTextarea() {
            var te = elt("textarea", null, null, "position: absolute; bottom: -1em; padding: 0; width: 1px; height: 1em; outline: none"),
                div = elt("div", [te], null, "overflow: hidden; position: relative; width: 3px; height: 0px;");
            return webkit ? te.style.width = "1000px" : te.setAttribute("wrap", "off"), ios && (te.style.border = "1px solid black"), disableBrowserMagic(te), div
        }

        function _findPosH(doc, pos, dir, unit, visually) {
            function findNextLine() {
                var l = pos.line + dir;
                return !(l < doc.first || l >= doc.first + doc.size) && (pos = new Pos(l, pos.ch, pos.sticky), lineObj = getLine(doc, l))
            }

            function moveOnce(boundToLine) {
                var next;
                if (next = visually ? moveVisually(doc.cm, lineObj, pos, dir) : moveLogically(lineObj, pos, dir), null == next) {
                    if (boundToLine || !findNextLine()) return !1;
                    pos = endOfLine(visually, doc.cm, lineObj, pos.line, dir)
                } else pos = next;
                return !0
            }
            var oldPos = pos,
                origDir = dir,
                lineObj = getLine(doc, pos.line);
            if ("char" == unit) moveOnce();
            else if ("column" == unit) moveOnce(!0);
            else if ("word" == unit || "group" == unit)
                for (var sawType = null, group = "group" == unit, helper = doc.cm && doc.cm.getHelper(pos, "wordChars"), first = !0; !(dir < 0) || moveOnce(!first); first = !1) {
                    var cur = lineObj.text.charAt(pos.ch) || "\n",
                        type = isWordChar(cur, helper) ? "w" : group && "\n" == cur ? "n" : !group || /\s/.test(cur) ? null : "p";
                    if (!group || first || type || (type = "s"), sawType && sawType != type) {
                        dir < 0 && (dir = 1, moveOnce(), pos.sticky = "after");
                        break
                    }
                    if (type && (sawType = type), dir > 0 && !moveOnce(!first)) break
                }
            var result = skipAtomic(doc, pos, oldPos, origDir, !0);
            return equalCursorPos(oldPos, result) && (result.hitSide = !0), result
        }

        function _findPosV(cm, pos, dir, unit) {
            var y, doc = cm.doc,
                x = pos.left;
            if ("page" == unit) {
                var pageSize = Math.min(cm.display.wrapper.clientHeight, window.innerHeight || document.documentElement.clientHeight),
                    moveAmount = Math.max(pageSize - .5 * textHeight(cm.display), 3);
                y = (dir > 0 ? pos.bottom : pos.top) + dir * moveAmount
            } else "line" == unit && (y = dir > 0 ? pos.bottom + 3 : pos.top - 3);
            for (var target; target = _coordsChar(cm, x, y), target.outside;) {
                if (dir < 0 ? y <= 0 : y >= doc.height) {
                    target.hitSide = !0;
                    break
                }
                y += 5 * dir
            }
            return target
        }

        function posToDOM(cm, pos) {
            var view = findViewForLine(cm, pos.line);
            if (!view || view.hidden) return null;
            var line = getLine(cm.doc, pos.line),
                info = mapFromLineView(view, line, pos.line),
                order = getOrder(line, cm.doc.direction),
                side = "left";
            if (order) {
                var partPos = getBidiPartAt(order, pos.ch);
                side = partPos % 2 ? "right" : "left"
            }
            var result = nodeAndOffsetInLineMap(info.map, pos.ch, side);
            return result.offset = "right" == result.collapse ? result.end : result.start, result
        }

        function isInGutter(node) {
            for (var scan = node; scan; scan = scan.parentNode)
                if (/CodeMirror-gutter-wrapper/.test(scan.className)) return !0;
            return !1
        }

        function badPos(pos, bad) {
            return bad && (pos.bad = !0), pos
        }

        function domTextBetween(cm, from, to, fromLine, toLine) {
            function recognizeMarker(id) {
                return function(marker) {
                    return marker.id == id
                }
            }

            function close() {
                closing && (text += lineSep, closing = !1)
            }

            function addText(str) {
                str && (close(), text += str)
            }

            function walk(node) {
                if (1 == node.nodeType) {
                    var cmText = node.getAttribute("cm-text");
                    if (null != cmText) return void addText(cmText || node.textContent.replace(/\u200b/g, ""));
                    var range$$1, markerID = node.getAttribute("cm-marker");
                    if (markerID) {
                        var found = cm.findMarks(Pos(fromLine, 0), Pos(toLine + 1, 0), recognizeMarker(+markerID));
                        return void(found.length && (range$$1 = found[0].find(0)) && addText(getBetween(cm.doc, range$$1.from, range$$1.to).join(lineSep)))
                    }
                    if ("false" == node.getAttribute("contenteditable")) return;
                    var isBlock = /^(pre|div|p)$/i.test(node.nodeName);
                    isBlock && close();
                    for (var i = 0; i < node.childNodes.length; i++) walk(node.childNodes[i]);
                    isBlock && (closing = !0)
                } else 3 == node.nodeType && addText(node.nodeValue)
            }
            for (var text = "", closing = !1, lineSep = cm.doc.lineSeparator(); walk(from), from != to;) from = from.nextSibling;
            return text
        }

        function domToPos(cm, node, offset) {
            var lineNode;
            if (node == cm.display.lineDiv) {
                if (lineNode = cm.display.lineDiv.childNodes[offset], !lineNode) return badPos(cm.clipPos(Pos(cm.display.viewTo - 1)), !0);
                node = null, offset = 0
            } else
                for (lineNode = node;; lineNode = lineNode.parentNode) {
                    if (!lineNode || lineNode == cm.display.lineDiv) return null;
                    if (lineNode.parentNode && lineNode.parentNode == cm.display.lineDiv) break
                }
            for (var i = 0; i < cm.display.view.length; i++) {
                var lineView = cm.display.view[i];
                if (lineView.node == lineNode) return locateNodeInLineView(lineView, node, offset)
            }
        }

        function locateNodeInLineView(lineView, node, offset) {
            function find(textNode, topNode, offset) {
                for (var i = -1; i < (maps ? maps.length : 0); i++)
                    for (var map$$1 = i < 0 ? measure.map : maps[i], j = 0; j < map$$1.length; j += 3) {
                        var curNode = map$$1[j + 2];
                        if (curNode == textNode || curNode == topNode) {
                            var line = lineNo(i < 0 ? lineView.line : lineView.rest[i]),
                                ch = map$$1[j] + offset;
                            return (offset < 0 || curNode != textNode) && (ch = map$$1[j + (offset ? 1 : 0)]), Pos(line, ch)
                        }
                    }
            }
            var wrapper = lineView.text.firstChild,
                bad = !1;
            if (!node || !contains(wrapper, node)) return badPos(Pos(lineNo(lineView.line), 0), !0);
            if (node == wrapper && (bad = !0, node = wrapper.childNodes[offset], offset = 0, !node)) {
                var line = lineView.rest ? lst(lineView.rest) : lineView.line;
                return badPos(Pos(lineNo(line), line.text.length), bad)
            }
            var textNode = 3 == node.nodeType ? node : null,
                topNode = node;
            for (textNode || 1 != node.childNodes.length || 3 != node.firstChild.nodeType || (textNode = node.firstChild, offset && (offset = textNode.nodeValue.length)); topNode.parentNode != wrapper;) topNode = topNode.parentNode;
            var measure = lineView.measure,
                maps = measure.maps,
                found = find(textNode, topNode, offset);
            if (found) return badPos(found, bad);
            for (var after = topNode.nextSibling, dist = textNode ? textNode.nodeValue.length - offset : 0; after; after = after.nextSibling) {
                if (found = find(after, after.firstChild, 0)) return badPos(Pos(found.line, found.ch - dist), bad);
                dist += after.textContent.length
            }
            for (var before = topNode.previousSibling, dist$1 = offset; before; before = before.previousSibling) {
                if (found = find(before, before.firstChild, -1)) return badPos(Pos(found.line, found.ch + dist$1), bad);
                dist$1 += before.textContent.length
            }
        }

        function fromTextArea(textarea, options) {
            function save() {
                textarea.value = cm.getValue()
            }
            if (options = options ? copyObj(options) : {}, options.value = textarea.value, !options.tabindex && textarea.tabIndex && (options.tabindex = textarea.tabIndex), !options.placeholder && textarea.placeholder && (options.placeholder = textarea.placeholder), null == options.autofocus) {
                var hasFocus = activeElt();
                options.autofocus = hasFocus == textarea || null != textarea.getAttribute("autofocus") && hasFocus == document.body
            }
            var realSubmit;
            if (textarea.form && (on(textarea.form, "submit", save), !options.leaveSubmitMethodAlone)) {
                var form = textarea.form;
                realSubmit = form.submit;
                try {
                    var wrappedSubmit = form.submit = function() {
                        save(), form.submit = realSubmit, form.submit(), form.submit = wrappedSubmit
                    }
                } catch (e) {}
            }
            options.finishInit = function(cm) {
                cm.save = save, cm.getTextArea = function() {
                    return textarea
                }, cm.toTextArea = function() {
                    cm.toTextArea = isNaN, save(), textarea.parentNode.removeChild(cm.getWrapperElement()), textarea.style.display = "", textarea.form && (off(textarea.form, "submit", save), "function" == typeof textarea.form.submit && (textarea.form.submit = realSubmit))
                }
            }, textarea.style.display = "none";
            var cm = CodeMirror$1(function(node) {
                return textarea.parentNode.insertBefore(node, textarea.nextSibling)
            }, options);
            return cm
        }

        function addLegacyProps(CodeMirror) {
            CodeMirror.off = off, CodeMirror.on = on, CodeMirror.wheelEventPixels = wheelEventPixels, CodeMirror.Doc = Doc, CodeMirror.splitLines = splitLinesAuto, CodeMirror.countColumn = countColumn, CodeMirror.findColumn = findColumn, CodeMirror.isWordChar = isWordCharBasic, CodeMirror.Pass = Pass, CodeMirror.signal = signal, CodeMirror.Line = Line, CodeMirror.changeEnd = changeEnd, CodeMirror.scrollbarModel = scrollbarModel, CodeMirror.Pos = Pos, CodeMirror.cmpPos = cmp, CodeMirror.modes = modes, CodeMirror.mimeModes = mimeModes, CodeMirror.resolveMode = resolveMode, CodeMirror.getMode = getMode, CodeMirror.modeExtensions = modeExtensions, CodeMirror.extendMode = extendMode, CodeMirror.copyState = copyState, CodeMirror.startState = startState, CodeMirror.innerMode = innerMode, CodeMirror.commands = commands, CodeMirror.keyMap = keyMap, CodeMirror.keyName = keyName, CodeMirror.isModifierKey = isModifierKey, CodeMirror.lookupKey = lookupKey, CodeMirror.normalizeKeyMap = normalizeKeyMap, CodeMirror.StringStream = StringStream, CodeMirror.SharedTextMarker = SharedTextMarker, CodeMirror.TextMarker = TextMarker, CodeMirror.LineWidget = LineWidget, CodeMirror.e_preventDefault = e_preventDefault, CodeMirror.e_stopPropagation = e_stopPropagation, CodeMirror.e_stop = e_stop, CodeMirror.addClass = addClass, CodeMirror.contains = contains, CodeMirror.rmClass = rmClass, CodeMirror.keyNames = keyNames
        }
        var userAgent = navigator.userAgent,
            platform = navigator.platform,
            gecko = /gecko\/\d/i.test(userAgent),
            ie_upto10 = /MSIE \d/.test(userAgent),
            ie_11up = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(userAgent),
            edge = /Edge\/(\d+)/.exec(userAgent),
            ie = ie_upto10 || ie_11up || edge,
            ie_version = ie && (ie_upto10 ? document.documentMode || 6 : +(edge || ie_11up)[1]),
            webkit = !edge && /WebKit\//.test(userAgent),
            qtwebkit = webkit && /Qt\/\d+\.\d+/.test(userAgent),
            chrome = !edge && /Chrome\//.test(userAgent),
            presto = /Opera\//.test(userAgent),
            safari = /Apple Computer/.test(navigator.vendor),
            mac_geMountainLion = /Mac OS X 1\d\D([8-9]|\d\d)\D/.test(userAgent),
            phantom = /PhantomJS/.test(userAgent),
            ios = !edge && /AppleWebKit/.test(userAgent) && /Mobile\/\w+/.test(userAgent),
            android = /Android/.test(userAgent),
            mobile = ios || android || /webOS|BlackBerry|Opera Mini|Opera Mobi|IEMobile/i.test(userAgent),
            mac = ios || /Mac/.test(platform),
            chromeOS = /\bCrOS\b/.test(userAgent),
            windows = /win/i.test(platform),
            presto_version = presto && userAgent.match(/Version\/(\d*\.\d*)/);
        presto_version && (presto_version = Number(presto_version[1])), presto_version && presto_version >= 15 && (presto = !1, webkit = !0);
        var range, flipCtrlCmd = mac && (qtwebkit || presto && (null == presto_version || presto_version < 12.11)),
            captureRightClick = gecko || ie && ie_version >= 9,
            rmClass = function(node, cls) {
                var current = node.className,
                    match = classTest(cls).exec(current);
                if (match) {
                    var after = current.slice(match.index + match[0].length);
                    node.className = current.slice(0, match.index) + (after ? match[1] + after : "")
                }
            };
        range = document.createRange ? function(node, start, end, endNode) {
            var r = document.createRange();
            return r.setEnd(endNode || node, end), r.setStart(node, start), r
        } : function(node, start, end) {
            var r = document.body.createTextRange();
            try {
                r.moveToElementText(node.parentNode)
            } catch (e) {
                return r
            }
            return r.collapse(!0), r.moveEnd("character", end), r.moveStart("character", start), r
        };
        var selectInput = function(node) {
            node.select()
        };
        ios ? selectInput = function(node) {
            node.selectionStart = 0, node.selectionEnd = node.value.length
        } : ie && (selectInput = function(node) {
            try {
                node.select()
            } catch (_e) {}
        });
        var Delayed = function() {
            this.id = null
        };
        Delayed.prototype.set = function(ms, f) {
            clearTimeout(this.id), this.id = setTimeout(f, ms)
        };
        var zwspSupported, badBidiRects, scrollerGap = 30,
            Pass = {
                toString: function() {
                    return "CodeMirror.Pass"
                }
            },
            sel_dontScroll = {
                scroll: !1
            },
            sel_mouse = {
                origin: "*mouse"
            },
            sel_move = {
                origin: "+move"
            },
            spaceStrs = [""],
            nonASCIISingleCaseWordChar = /[\u00df\u0587\u0590-\u05f4\u0600-\u06ff\u3040-\u309f\u30a0-\u30ff\u3400-\u4db5\u4e00-\u9fcc\uac00-\ud7af]/,
            extendingChars = /[\u0300-\u036f\u0483-\u0489\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065e\u0670\u06d6-\u06dc\u06de-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0900-\u0902\u093c\u0941-\u0948\u094d\u0951-\u0955\u0962\u0963\u0981\u09bc\u09be\u09c1-\u09c4\u09cd\u09d7\u09e2\u09e3\u0a01\u0a02\u0a3c\u0a41\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81\u0a82\u0abc\u0ac1-\u0ac5\u0ac7\u0ac8\u0acd\u0ae2\u0ae3\u0b01\u0b3c\u0b3e\u0b3f\u0b41-\u0b44\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe\u0bc0\u0bcd\u0bd7\u0c3e-\u0c40\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0cbc\u0cbf\u0cc2\u0cc6\u0ccc\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d3e\u0d41-\u0d44\u0d4d\u0d57\u0d62\u0d63\u0dca\u0dcf\u0dd2-\u0dd4\u0dd6\u0ddf\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f71-\u0f7e\u0f80-\u0f84\u0f86\u0f87\u0f90-\u0f97\u0f99-\u0fbc\u0fc6\u102d-\u1030\u1032-\u1037\u1039\u103a\u103d\u103e\u1058\u1059\u105e-\u1060\u1071-\u1074\u1082\u1085\u1086\u108d\u109d\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b7-\u17bd\u17c6\u17c9-\u17d3\u17dd\u180b-\u180d\u18a9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193b\u1a17\u1a18\u1a56\u1a58-\u1a5e\u1a60\u1a62\u1a65-\u1a6c\u1a73-\u1a7c\u1a7f\u1b00-\u1b03\u1b34\u1b36-\u1b3a\u1b3c\u1b42\u1b6b-\u1b73\u1b80\u1b81\u1ba2-\u1ba5\u1ba8\u1ba9\u1c2c-\u1c33\u1c36\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce0\u1ce2-\u1ce8\u1ced\u1dc0-\u1de6\u1dfd-\u1dff\u200c\u200d\u20d0-\u20f0\u2cef-\u2cf1\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f-\ua672\ua67c\ua67d\ua6f0\ua6f1\ua802\ua806\ua80b\ua825\ua826\ua8c4\ua8e0-\ua8f1\ua926-\ua92d\ua947-\ua951\ua980-\ua982\ua9b3\ua9b6-\ua9b9\ua9bc\uaa29-\uaa2e\uaa31\uaa32\uaa35\uaa36\uaa43\uaa4c\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uabe5\uabe8\uabed\udc00-\udfff\ufb1e\ufe00-\ufe0f\ufe20-\ufe26\uff9e\uff9f]/,
            sawReadOnlySpans = !1,
            sawCollapsedSpans = !1,
            bidiOther = null,
            bidiOrdering = function() {
                function charType(code) {
                    return code <= 247 ? lowTypes.charAt(code) : 1424 <= code && code <= 1524 ? "R" : 1536 <= code && code <= 1785 ? arabicTypes.charAt(code - 1536) : 1774 <= code && code <= 2220 ? "r" : 8192 <= code && code <= 8203 ? "w" : 8204 == code ? "b" : "L"
                }

                function BidiSpan(level, from, to) {
                    this.level = level, this.from = from, this.to = to
                }
                var lowTypes = "bbbbbbbbbtstwsbbbbbbbbbbbbbbssstwNN%%%NNNNNN,N,N1111111111NNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNNNLLLLLLLLLLLLLLLLLLLLLLLLLLNNNNbbbbbbsbbbbbbbbbbbbbbbbbbbbbbbbbb,N%%%%NNNNLNNNNN%%11NLNNN1LNNNNNLLLLLLLLLLLLLLLLLLLLLLLNLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLN",
                    arabicTypes = "nnnnnnNNr%%r,rNNmmmmmmmmmmmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnn%nnrrrmrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrmmmmmmmnNmmmmmmrrmmNmmmmrr1111111111",
                    bidiRE = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/,
                    isNeutral = /[stwN]/,
                    isStrong = /[LRr]/,
                    countsAsLeft = /[Lb1n]/,
                    countsAsNum = /[1n]/;
                return function(str, direction) {
                    var outerType = "ltr" == direction ? "L" : "R";
                    if (0 == str.length || "ltr" == direction && !bidiRE.test(str)) return !1;
                    for (var len = str.length, types = [], i = 0; i < len; ++i) types.push(charType(str.charCodeAt(i)));
                    for (var i$1 = 0, prev = outerType; i$1 < len; ++i$1) {
                        var type = types[i$1];
                        "m" == type ? types[i$1] = prev : prev = type
                    }
                    for (var i$2 = 0, cur = outerType; i$2 < len; ++i$2) {
                        var type$1 = types[i$2];
                        "1" == type$1 && "r" == cur ? types[i$2] = "n" : isStrong.test(type$1) && (cur = type$1, "r" == type$1 && (types[i$2] = "R"))
                    }
                    for (var i$3 = 1, prev$1 = types[0]; i$3 < len - 1; ++i$3) {
                        var type$2 = types[i$3];
                        "+" == type$2 && "1" == prev$1 && "1" == types[i$3 + 1] ? types[i$3] = "1" : "," != type$2 || prev$1 != types[i$3 + 1] || "1" != prev$1 && "n" != prev$1 || (types[i$3] = prev$1), prev$1 = type$2
                    }
                    for (var i$4 = 0; i$4 < len; ++i$4) {
                        var type$3 = types[i$4];
                        if ("," == type$3) types[i$4] = "N";
                        else if ("%" == type$3) {
                            var end = void 0;
                            for (end = i$4 + 1; end < len && "%" == types[end]; ++end);
                            for (var replace = i$4 && "!" == types[i$4 - 1] || end < len && "1" == types[end] ? "1" : "N", j = i$4; j < end; ++j) types[j] = replace;
                            i$4 = end - 1
                        }
                    }
                    for (var i$5 = 0, cur$1 = outerType; i$5 < len; ++i$5) {
                        var type$4 = types[i$5];
                        "L" == cur$1 && "1" == type$4 ? types[i$5] = "L" : isStrong.test(type$4) && (cur$1 = type$4)
                    }
                    for (var i$6 = 0; i$6 < len; ++i$6)
                        if (isNeutral.test(types[i$6])) {
                            var end$1 = void 0;
                            for (end$1 = i$6 + 1; end$1 < len && isNeutral.test(types[end$1]); ++end$1);
                            for (var before = "L" == (i$6 ? types[i$6 - 1] : outerType), after = "L" == (end$1 < len ? types[end$1] : outerType), replace$1 = before == after ? before ? "L" : "R" : outerType, j$1 = i$6; j$1 < end$1; ++j$1) types[j$1] = replace$1;
                            i$6 = end$1 - 1
                        } for (var m, order = [], i$7 = 0; i$7 < len;)
                        if (countsAsLeft.test(types[i$7])) {
                            var start = i$7;
                            for (++i$7; i$7 < len && countsAsLeft.test(types[i$7]); ++i$7);
                            order.push(new BidiSpan(0, start, i$7))
                        } else {
                            var pos = i$7,
                                at = order.length;
                            for (++i$7; i$7 < len && "L" != types[i$7]; ++i$7);
                            for (var j$2 = pos; j$2 < i$7;)
                                if (countsAsNum.test(types[j$2])) {
                                    pos < j$2 && order.splice(at, 0, new BidiSpan(1, pos, j$2));
                                    var nstart = j$2;
                                    for (++j$2; j$2 < i$7 && countsAsNum.test(types[j$2]); ++j$2);
                                    order.splice(at, 0, new BidiSpan(2, nstart, j$2)), pos = j$2
                                } else ++j$2;
                            pos < i$7 && order.splice(at, 0, new BidiSpan(1, pos, i$7))
                        } return "ltr" == direction && (1 == order[0].level && (m = str.match(/^\s+/)) && (order[0].from = m[0].length, order.unshift(new BidiSpan(0, 0, m[0].length))), 1 == lst(order).level && (m = str.match(/\s+$/)) && (lst(order).to -= m[0].length, order.push(new BidiSpan(0, len - m[0].length, len)))), "rtl" == direction ? order.reverse() : order
                }
            }(),
            noHandlers = [],
            on = function(emitter, type, f) {
                if (emitter.addEventListener) emitter.addEventListener(type, f, !1);
                else if (emitter.attachEvent) emitter.attachEvent("on" + type, f);
                else {
                    var map$$1 = emitter._handlers || (emitter._handlers = {});
                    map$$1[type] = (map$$1[type] || noHandlers).concat(f)
                }
            },
            dragAndDrop = function() {
                if (ie && ie_version < 9) return !1;
                var div = elt("div");
                return "draggable" in div || "dragDrop" in div
            }(),
            splitLinesAuto = 3 != "\n\nb".split(/\n/).length ? function(string) {
                for (var pos = 0, result = [], l = string.length; pos <= l;) {
                    var nl = string.indexOf("\n", pos);
                    nl == -1 && (nl = string.length);
                    var line = string.slice(pos, "\r" == string.charAt(nl - 1) ? nl - 1 : nl),
                        rt = line.indexOf("\r");
                    rt != -1 ? (result.push(line.slice(0, rt)), pos += rt + 1) : (result.push(line), pos = nl + 1)
                }
                return result
            } : function(string) {
                return string.split(/\r\n?|\n/)
            },
            hasSelection = window.getSelection ? function(te) {
                try {
                    return te.selectionStart != te.selectionEnd
                } catch (e) {
                    return !1
                }
            } : function(te) {
                var range$$1;
                try {
                    range$$1 = te.ownerDocument.selection.createRange()
                } catch (e) {}
                return !(!range$$1 || range$$1.parentElement() != te) && 0 != range$$1.compareEndPoints("StartToEnd", range$$1)
            },
            hasCopyEvent = function() {
                var e = elt("div");
                return "oncopy" in e || (e.setAttribute("oncopy", "return;"), "function" == typeof e.oncopy)
            }(),
            badZoomedRects = null,
            modes = {},
            mimeModes = {},
            modeExtensions = {},
            StringStream = function(string, tabSize, lineOracle) {
                this.pos = this.start = 0, this.string = string, this.tabSize = tabSize || 8, this.lastColumnPos = this.lastColumnValue = 0, this.lineStart = 0, this.lineOracle = lineOracle
            };
        StringStream.prototype.eol = function() {
            return this.pos >= this.string.length
        }, StringStream.prototype.sol = function() {
            return this.pos == this.lineStart
        }, StringStream.prototype.peek = function() {
            return this.string.charAt(this.pos) || void 0
        }, StringStream.prototype.next = function() {
            if (this.pos < this.string.length) return this.string.charAt(this.pos++)
        }, StringStream.prototype.eat = function(match) {
            var ok, ch = this.string.charAt(this.pos);
            if (ok = "string" == typeof match ? ch == match : ch && (match.test ? match.test(ch) : match(ch))) return ++this.pos, ch
        }, StringStream.prototype.eatWhile = function(match) {
            for (var start = this.pos; this.eat(match););
            return this.pos > start
        }, StringStream.prototype.eatSpace = function() {
            for (var this$1 = this, start = this.pos;
                /[\s\u00a0]/.test(this.string.charAt(this.pos));) ++this$1.pos;
            return this.pos > start
        }, StringStream.prototype.skipToEnd = function() {
            this.pos = this.string.length
        }, StringStream.prototype.skipTo = function(ch) {
            var found = this.string.indexOf(ch, this.pos);
            if (found > -1) return this.pos = found, !0
        }, StringStream.prototype.backUp = function(n) {
            this.pos -= n
        }, StringStream.prototype.column = function() {
            return this.lastColumnPos < this.start && (this.lastColumnValue = countColumn(this.string, this.start, this.tabSize, this.lastColumnPos, this.lastColumnValue), this.lastColumnPos = this.start), this.lastColumnValue - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
        }, StringStream.prototype.indentation = function() {
            return countColumn(this.string, null, this.tabSize) - (this.lineStart ? countColumn(this.string, this.lineStart, this.tabSize) : 0)
        }, StringStream.prototype.match = function(pattern, consume, caseInsensitive) {
            if ("string" != typeof pattern) {
                var match = this.string.slice(this.pos).match(pattern);
                return match && match.index > 0 ? null : (match && consume !== !1 && (this.pos += match[0].length), match)
            }
            var cased = function(str) {
                    return caseInsensitive ? str.toLowerCase() : str
                },
                substr = this.string.substr(this.pos, pattern.length);
            if (cased(substr) == cased(pattern)) return consume !== !1 && (this.pos += pattern.length), !0
        }, StringStream.prototype.current = function() {
            return this.string.slice(this.start, this.pos)
        }, StringStream.prototype.hideFirstChars = function(n, inner) {
            this.lineStart += n;
            try {
                return inner()
            } finally {
                this.lineStart -= n
            }
        }, StringStream.prototype.lookAhead = function(n) {
            var oracle = this.lineOracle;
            return oracle && oracle.lookAhead(n)
        }, StringStream.prototype.baseToken = function() {
            var oracle = this.lineOracle;
            return oracle && oracle.baseToken(this.pos)
        };
        var SavedContext = function(state, lookAhead) {
                this.state = state, this.lookAhead = lookAhead
            },
            Context = function(doc, state, line, lookAhead) {
                this.state = state, this.doc = doc, this.line = line, this.maxLookAhead = lookAhead || 0, this.baseTokens = null, this.baseTokenPos = 1
            };
        Context.prototype.lookAhead = function(n) {
            var line = this.doc.getLine(this.line + n);
            return null != line && n > this.maxLookAhead && (this.maxLookAhead = n), line
        }, Context.prototype.baseToken = function(n) {
            var this$1 = this;
            if (!this.baseTokens) return null;
            for (; this.baseTokens[this.baseTokenPos] <= n;) this$1.baseTokenPos += 2;
            var type = this.baseTokens[this.baseTokenPos + 1];
            return {
                type: type && type.replace(/( |^)overlay .*/, ""),
                size: this.baseTokens[this.baseTokenPos] - n
            }
        }, Context.prototype.nextLine = function() {
            this.line++, this.maxLookAhead > 0 && this.maxLookAhead--
        }, Context.fromSaved = function(doc, saved, line) {
            return saved instanceof SavedContext ? new Context(doc, copyState(doc.mode, saved.state), line, saved.lookAhead) : new Context(doc, copyState(doc.mode, saved), line)
        }, Context.prototype.save = function(copy) {
            var state = copy !== !1 ? copyState(this.doc.mode, this.state) : this.state;
            return this.maxLookAhead > 0 ? new SavedContext(state, this.maxLookAhead) : state
        };
        var Token = function(stream, type, state) {
                this.start = stream.start, this.end = stream.pos, this.string = stream.current(), this.type = type || null, this.state = state
            },
            Line = function(text, markedSpans, estimateHeight) {
                this.text = text, attachMarkedSpans(this, markedSpans), this.height = estimateHeight ? estimateHeight(this) : 1
            };
        Line.prototype.lineNo = function() {
            return lineNo(this)
        }, eventMixin(Line);
        var measureText, styleToClassCache = {},
            styleToClassCacheWithMode = {},
            operationGroup = null,
            orphanDelayedCallbacks = null,
            nullRect = {
                left: 0,
                right: 0,
                top: 0,
                bottom: 0
            },
            NativeScrollbars = function(place, scroll, cm) {
                this.cm = cm;
                var vert = this.vert = elt("div", [elt("div", null, null, "min-width: 1px")], "CodeMirror-vscrollbar"),
                    horiz = this.horiz = elt("div", [elt("div", null, null, "height: 100%; min-height: 1px")], "CodeMirror-hscrollbar");
                place(vert), place(horiz), on(vert, "scroll", function() {
                    vert.clientHeight && scroll(vert.scrollTop, "vertical")
                }), on(horiz, "scroll", function() {
                    horiz.clientWidth && scroll(horiz.scrollLeft, "horizontal")
                }), this.checkedZeroWidth = !1, ie && ie_version < 8 && (this.horiz.style.minHeight = this.vert.style.minWidth = "18px")
            };
        NativeScrollbars.prototype.update = function(measure) {
            var needsH = measure.scrollWidth > measure.clientWidth + 1,
                needsV = measure.scrollHeight > measure.clientHeight + 1,
                sWidth = measure.nativeBarWidth;
            if (needsV) {
                this.vert.style.display = "block", this.vert.style.bottom = needsH ? sWidth + "px" : "0";
                var totalHeight = measure.viewHeight - (needsH ? sWidth : 0);
                this.vert.firstChild.style.height = Math.max(0, measure.scrollHeight - measure.clientHeight + totalHeight) + "px"
            } else this.vert.style.display = "", this.vert.firstChild.style.height = "0";
            if (needsH) {
                this.horiz.style.display = "block", this.horiz.style.right = needsV ? sWidth + "px" : "0", this.horiz.style.left = measure.barLeft + "px";
                var totalWidth = measure.viewWidth - measure.barLeft - (needsV ? sWidth : 0);
                this.horiz.firstChild.style.width = Math.max(0, measure.scrollWidth - measure.clientWidth + totalWidth) + "px"
            } else this.horiz.style.display = "", this.horiz.firstChild.style.width = "0";
            return !this.checkedZeroWidth && measure.clientHeight > 0 && (0 == sWidth && this.zeroWidthHack(), this.checkedZeroWidth = !0), {
                right: needsV ? sWidth : 0,
                bottom: needsH ? sWidth : 0
            }
        }, NativeScrollbars.prototype.setScrollLeft = function(pos) {
            this.horiz.scrollLeft != pos && (this.horiz.scrollLeft = pos), this.disableHoriz && this.enableZeroWidthBar(this.horiz, this.disableHoriz, "horiz")
        }, NativeScrollbars.prototype.setScrollTop = function(pos) {
            this.vert.scrollTop != pos && (this.vert.scrollTop = pos), this.disableVert && this.enableZeroWidthBar(this.vert, this.disableVert, "vert")
        }, NativeScrollbars.prototype.zeroWidthHack = function() {
            var w = mac && !mac_geMountainLion ? "12px" : "18px";
            this.horiz.style.height = this.vert.style.width = w, this.horiz.style.pointerEvents = this.vert.style.pointerEvents = "none", this.disableHoriz = new Delayed, this.disableVert = new Delayed
        }, NativeScrollbars.prototype.enableZeroWidthBar = function(bar, delay, type) {
            function maybeDisable() {
                var box = bar.getBoundingClientRect(),
                    elt$$1 = "vert" == type ? document.elementFromPoint(box.right - 1, (box.top + box.bottom) / 2) : document.elementFromPoint((box.right + box.left) / 2, box.bottom - 1);
                elt$$1 != bar ? bar.style.pointerEvents = "none" : delay.set(1e3, maybeDisable)
            }
            bar.style.pointerEvents = "auto", delay.set(1e3, maybeDisable)
        }, NativeScrollbars.prototype.clear = function() {
            var parent = this.horiz.parentNode;
            parent.removeChild(this.horiz), parent.removeChild(this.vert)
        };
        var NullScrollbars = function() {};
        NullScrollbars.prototype.update = function() {
            return {
                bottom: 0,
                right: 0
            }
        }, NullScrollbars.prototype.setScrollLeft = function() {}, NullScrollbars.prototype.setScrollTop = function() {}, NullScrollbars.prototype.clear = function() {};
        var scrollbarModel = {
                native: NativeScrollbars,
                null: NullScrollbars
            },
            nextOpId = 0,
            DisplayUpdate = function(cm, viewport, force) {
                var display = cm.display;
                this.viewport = viewport, this.visible = visibleLines(display, cm.doc, viewport), this.editorIsHidden = !display.wrapper.offsetWidth, this.wrapperHeight = display.wrapper.clientHeight, this.wrapperWidth = display.wrapper.clientWidth, this.oldDisplayWidth = displayWidth(cm), this.force = force, this.dims = getDimensions(cm), this.events = []
            };
        DisplayUpdate.prototype.signal = function(emitter, type) {
            hasHandler(emitter, type) && this.events.push(arguments)
        }, DisplayUpdate.prototype.finish = function() {
            for (var this$1 = this, i = 0; i < this.events.length; i++) signal.apply(null, this$1.events[i])
        };
        var wheelSamples = 0,
            wheelPixelsPerUnit = null;
        ie ? wheelPixelsPerUnit = -.53 : gecko ? wheelPixelsPerUnit = 15 : chrome ? wheelPixelsPerUnit = -.7 : safari && (wheelPixelsPerUnit = -1 / 3);
        var Selection = function(ranges, primIndex) {
            this.ranges = ranges, this.primIndex = primIndex
        };
        Selection.prototype.primary = function() {
            return this.ranges[this.primIndex]
        }, Selection.prototype.equals = function(other) {
            var this$1 = this;
            if (other == this) return !0;
            if (other.primIndex != this.primIndex || other.ranges.length != this.ranges.length) return !1;
            for (var i = 0; i < this.ranges.length; i++) {
                var here = this$1.ranges[i],
                    there = other.ranges[i];
                if (!equalCursorPos(here.anchor, there.anchor) || !equalCursorPos(here.head, there.head)) return !1
            }
            return !0
        }, Selection.prototype.deepCopy = function() {
            for (var this$1 = this, out = [], i = 0; i < this.ranges.length; i++) out[i] = new Range(copyPos(this$1.ranges[i].anchor), copyPos(this$1.ranges[i].head));
            return new Selection(out, this.primIndex)
        }, Selection.prototype.somethingSelected = function() {
            for (var this$1 = this, i = 0; i < this.ranges.length; i++)
                if (!this$1.ranges[i].empty()) return !0;
            return !1
        }, Selection.prototype.contains = function(pos, end) {
            var this$1 = this;
            end || (end = pos);
            for (var i = 0; i < this.ranges.length; i++) {
                var range = this$1.ranges[i];
                if (cmp(end, range.from()) >= 0 && cmp(pos, range.to()) <= 0) return i
            }
            return -1
        };
        var Range = function(anchor, head) {
            this.anchor = anchor, this.head = head
        };
        Range.prototype.from = function() {
            return minPos(this.anchor, this.head)
        }, Range.prototype.to = function() {
            return maxPos(this.anchor, this.head)
        }, Range.prototype.empty = function() {
            return this.head.line == this.anchor.line && this.head.ch == this.anchor.ch
        }, LeafChunk.prototype = {
            chunkSize: function() {
                return this.lines.length
            },
            removeInner: function(at, n) {
                for (var this$1 = this, i = at, e = at + n; i < e; ++i) {
                    var line = this$1.lines[i];
                    this$1.height -= line.height, cleanUpLine(line), signalLater(line, "delete")
                }
                this.lines.splice(at, n)
            },
            collapse: function(lines) {
                lines.push.apply(lines, this.lines)
            },
            insertInner: function(at, lines, height) {
                var this$1 = this;
                this.height += height, this.lines = this.lines.slice(0, at).concat(lines).concat(this.lines.slice(at));
                for (var i = 0; i < lines.length; ++i) lines[i].parent = this$1
            },
            iterN: function(at, n, op) {
                for (var this$1 = this, e = at + n; at < e; ++at)
                    if (op(this$1.lines[at])) return !0
            }
        }, BranchChunk.prototype = {
            chunkSize: function() {
                return this.size
            },
            removeInner: function(at, n) {
                var this$1 = this;
                this.size -= n;
                for (var i = 0; i < this.children.length; ++i) {
                    var child = this$1.children[i],
                        sz = child.chunkSize();
                    if (at < sz) {
                        var rm = Math.min(n, sz - at),
                            oldHeight = child.height;
                        if (child.removeInner(at, rm), this$1.height -= oldHeight - child.height, sz == rm && (this$1.children.splice(i--, 1), child.parent = null), 0 == (n -= rm)) break;
                        at = 0
                    } else at -= sz
                }
                if (this.size - n < 25 && (this.children.length > 1 || !(this.children[0] instanceof LeafChunk))) {
                    var lines = [];
                    this.collapse(lines), this.children = [new LeafChunk(lines)], this.children[0].parent = this
                }
            },
            collapse: function(lines) {
                for (var this$1 = this, i = 0; i < this.children.length; ++i) this$1.children[i].collapse(lines)
            },
            insertInner: function(at, lines, height) {
                var this$1 = this;
                this.size += lines.length, this.height += height;
                for (var i = 0; i < this.children.length; ++i) {
                    var child = this$1.children[i],
                        sz = child.chunkSize();
                    if (at <= sz) {
                        if (child.insertInner(at, lines, height), child.lines && child.lines.length > 50) {
                            for (var remaining = child.lines.length % 25 + 25, pos = remaining; pos < child.lines.length;) {
                                var leaf = new LeafChunk(child.lines.slice(pos, pos += 25));
                                child.height -= leaf.height, this$1.children.splice(++i, 0, leaf), leaf.parent = this$1
                            }
                            child.lines = child.lines.slice(0, remaining), this$1.maybeSpill()
                        }
                        break
                    }
                    at -= sz
                }
            },
            maybeSpill: function() {
                if (!(this.children.length <= 10)) {
                    var me = this;
                    do {
                        var spilled = me.children.splice(me.children.length - 5, 5),
                            sibling = new BranchChunk(spilled);
                        if (me.parent) {
                            me.size -= sibling.size, me.height -= sibling.height;
                            var myIndex = indexOf(me.parent.children, me);
                            me.parent.children.splice(myIndex + 1, 0, sibling)
                        } else {
                            var copy = new BranchChunk(me.children);
                            copy.parent = me, me.children = [copy, sibling], me = copy
                        }
                        sibling.parent = me.parent
                    } while (me.children.length > 10);
                    me.parent.maybeSpill()
                }
            },
            iterN: function(at, n, op) {
                for (var this$1 = this, i = 0; i < this.children.length; ++i) {
                    var child = this$1.children[i],
                        sz = child.chunkSize();
                    if (at < sz) {
                        var used = Math.min(n, sz - at);
                        if (child.iterN(at, used, op)) return !0;
                        if (0 == (n -= used)) break;
                        at = 0
                    } else at -= sz
                }
            }
        };
        var LineWidget = function(doc, node, options) {
            var this$1 = this;
            if (options)
                for (var opt in options) options.hasOwnProperty(opt) && (this$1[opt] = options[opt]);
            this.doc = doc, this.node = node
        };
        LineWidget.prototype.clear = function() {
            var this$1 = this,
                cm = this.doc.cm,
                ws = this.line.widgets,
                line = this.line,
                no = lineNo(line);
            if (null != no && ws) {
                for (var i = 0; i < ws.length; ++i) ws[i] == this$1 && ws.splice(i--, 1);
                ws.length || (line.widgets = null);
                var height = widgetHeight(this);
                updateLineHeight(line, Math.max(0, line.height - height)), cm && (runInOp(cm, function() {
                    adjustScrollWhenAboveVisible(cm, line, -height), regLineChange(cm, no, "widget")
                }), signalLater(cm, "lineWidgetCleared", cm, this, no))
            }
        }, LineWidget.prototype.changed = function() {
            var this$1 = this,
                oldH = this.height,
                cm = this.doc.cm,
                line = this.line;
            this.height = null;
            var diff = widgetHeight(this) - oldH;
            diff && (updateLineHeight(line, line.height + diff), cm && runInOp(cm, function() {
                cm.curOp.forceUpdate = !0, adjustScrollWhenAboveVisible(cm, line, diff), signalLater(cm, "lineWidgetChanged", cm, this$1, lineNo(line))
            }))
        }, eventMixin(LineWidget);
        var nextMarkerId = 0,
            TextMarker = function(doc, type) {
                this.lines = [], this.type = type, this.doc = doc, this.id = ++nextMarkerId
            };
        TextMarker.prototype.clear = function() {
            var this$1 = this;
            if (!this.explicitlyCleared) {
                var cm = this.doc.cm,
                    withOp = cm && !cm.curOp;
                if (withOp && _startOperation(cm), hasHandler(this, "clear")) {
                    var found = this.find();
                    found && signalLater(this, "clear", found.from, found.to)
                }
                for (var min = null, max = null, i = 0; i < this.lines.length; ++i) {
                    var line = this$1.lines[i],
                        span = getMarkedSpanFor(line.markedSpans, this$1);
                    cm && !this$1.collapsed ? regLineChange(cm, lineNo(line), "text") : cm && (null != span.to && (max = lineNo(line)), null != span.from && (min = lineNo(line))), line.markedSpans = removeMarkedSpan(line.markedSpans, span), null == span.from && this$1.collapsed && !lineIsHidden(this$1.doc, line) && cm && updateLineHeight(line, textHeight(cm.display))
                }
                if (cm && this.collapsed && !cm.options.lineWrapping)
                    for (var i$1 = 0; i$1 < this.lines.length; ++i$1) {
                        var visual = visualLine(this$1.lines[i$1]),
                            len = lineLength(visual);
                        len > cm.display.maxLineLength && (cm.display.maxLine = visual, cm.display.maxLineLength = len, cm.display.maxLineChanged = !0)
                    }
                null != min && cm && this.collapsed && regChange(cm, min, max + 1), this.lines.length = 0, this.explicitlyCleared = !0, this.atomic && this.doc.cantEdit && (this.doc.cantEdit = !1, cm && reCheckSelection(cm.doc)), cm && signalLater(cm, "markerCleared", cm, this, min, max), withOp && _endOperation(cm), this.parent && this.parent.clear()
            }
        }, TextMarker.prototype.find = function(side, lineObj) {
            var this$1 = this;
            null == side && "bookmark" == this.type && (side = 1);
            for (var from, to, i = 0; i < this.lines.length; ++i) {
                var line = this$1.lines[i],
                    span = getMarkedSpanFor(line.markedSpans, this$1);
                if (null != span.from && (from = Pos(lineObj ? line : lineNo(line), span.from), side == -1)) return from;
                if (null != span.to && (to = Pos(lineObj ? line : lineNo(line), span.to), 1 == side)) return to
            }
            return from && {
                from: from,
                to: to
            }
        }, TextMarker.prototype.changed = function() {
            var this$1 = this,
                pos = this.find(-1, !0),
                widget = this,
                cm = this.doc.cm;
            pos && cm && runInOp(cm, function() {
                var line = pos.line,
                    lineN = lineNo(pos.line),
                    view = findViewForLine(cm, lineN);
                if (view && (clearLineMeasurementCacheFor(view), cm.curOp.selectionChanged = cm.curOp.forceUpdate = !0), cm.curOp.updateMaxLine = !0, !lineIsHidden(widget.doc, line) && null != widget.height) {
                    var oldHeight = widget.height;
                    widget.height = null;
                    var dHeight = widgetHeight(widget) - oldHeight;
                    dHeight && updateLineHeight(line, line.height + dHeight)
                }
                signalLater(cm, "markerChanged", cm, this$1)
            })
        }, TextMarker.prototype.attachLine = function(line) {
            if (!this.lines.length && this.doc.cm) {
                var op = this.doc.cm.curOp;
                op.maybeHiddenMarkers && indexOf(op.maybeHiddenMarkers, this) != -1 || (op.maybeUnhiddenMarkers || (op.maybeUnhiddenMarkers = [])).push(this)
            }
            this.lines.push(line)
        }, TextMarker.prototype.detachLine = function(line) {
            if (this.lines.splice(indexOf(this.lines, line), 1), !this.lines.length && this.doc.cm) {
                var op = this.doc.cm.curOp;
                (op.maybeHiddenMarkers || (op.maybeHiddenMarkers = [])).push(this)
            }
        }, eventMixin(TextMarker);
        var SharedTextMarker = function(markers, primary) {
            var this$1 = this;
            this.markers = markers, this.primary = primary;
            for (var i = 0; i < markers.length; ++i) markers[i].parent = this$1
        };
        SharedTextMarker.prototype.clear = function() {
            var this$1 = this;
            if (!this.explicitlyCleared) {
                this.explicitlyCleared = !0;
                for (var i = 0; i < this.markers.length; ++i) this$1.markers[i].clear();
                signalLater(this, "clear")
            }
        }, SharedTextMarker.prototype.find = function(side, lineObj) {
            return this.primary.find(side, lineObj)
        }, eventMixin(SharedTextMarker);
        var nextDocId = 0,
            Doc = function Doc(text, mode, firstLine, lineSep, direction) {
                if (!(this instanceof Doc)) return new Doc(text, mode, firstLine, lineSep, direction);
                null == firstLine && (firstLine = 0), BranchChunk.call(this, [new LeafChunk([new Line("", null)])]), this.first = firstLine, this.scrollTop = this.scrollLeft = 0, this.cantEdit = !1, this.cleanGeneration = 1, this.modeFrontier = this.highlightFrontier = firstLine;
                var start = Pos(firstLine, 0);
                this.sel = simpleSelection(start), this.history = new History(null), this.id = ++nextDocId, this.modeOption = mode, this.lineSep = lineSep, this.direction = "rtl" == direction ? "rtl" : "ltr", this.extend = !1, "string" == typeof text && (text = this.splitLines(text)), updateDoc(this, {
                    from: start,
                    to: start,
                    text: text
                }), setSelection(this, simpleSelection(start), sel_dontScroll)
            };
        Doc.prototype = createObj(BranchChunk.prototype, {
            constructor: Doc,
            iter: function(from, to, op) {
                op ? this.iterN(from - this.first, to - from, op) : this.iterN(this.first, this.first + this.size, from)
            },
            insert: function(at, lines) {
                for (var height = 0, i = 0; i < lines.length; ++i) height += lines[i].height;
                this.insertInner(at - this.first, lines, height)
            },
            remove: function(at, n) {
                this.removeInner(at - this.first, n)
            },
            getValue: function(lineSep) {
                var lines = getLines(this, this.first, this.first + this.size);
                return lineSep === !1 ? lines : lines.join(lineSep || this.lineSeparator())
            },
            setValue: docMethodOp(function(code) {
                var top = Pos(this.first, 0),
                    last = this.first + this.size - 1;
                makeChange(this, {
                    from: top,
                    to: Pos(last, getLine(this, last).text.length),
                    text: this.splitLines(code),
                    origin: "setValue",
                    full: !0
                }, !0), this.cm && scrollToCoords(this.cm, 0, 0), setSelection(this, simpleSelection(top), sel_dontScroll)
            }),
            replaceRange: function(code, from, to, origin) {
                from = _clipPos(this, from), to = to ? _clipPos(this, to) : from, _replaceRange(this, code, from, to, origin)
            },
            getRange: function(from, to, lineSep) {
                var lines = getBetween(this, _clipPos(this, from), _clipPos(this, to));
                return lineSep === !1 ? lines : lines.join(lineSep || this.lineSeparator())
            },
            getLine: function(line) {
                var l = this.getLineHandle(line);
                return l && l.text
            },
            getLineHandle: function(line) {
                if (isLine(this, line)) return getLine(this, line)
            },
            getLineNumber: function(line) {
                return lineNo(line)
            },
            getLineHandleVisualStart: function(line) {
                return "number" == typeof line && (line = getLine(this, line)), visualLine(line)
            },
            lineCount: function() {
                return this.size
            },
            firstLine: function() {
                return this.first
            },
            lastLine: function() {
                return this.first + this.size - 1
            },
            clipPos: function(pos) {
                return _clipPos(this, pos)
            },
            getCursor: function(start) {
                var pos, range$$1 = this.sel.primary();
                return pos = null == start || "head" == start ? range$$1.head : "anchor" == start ? range$$1.anchor : "end" == start || "to" == start || start === !1 ? range$$1.to() : range$$1.from()
            },
            listSelections: function() {
                return this.sel.ranges
            },
            somethingSelected: function() {
                return this.sel.somethingSelected()
            },
            setCursor: docMethodOp(function(line, ch, options) {
                setSimpleSelection(this, _clipPos(this, "number" == typeof line ? Pos(line, ch || 0) : line), null, options)
            }),
            setSelection: docMethodOp(function(anchor, head, options) {
                setSimpleSelection(this, _clipPos(this, anchor), _clipPos(this, head || anchor), options)
            }),
            extendSelection: docMethodOp(function(head, other, options) {
                extendSelection(this, _clipPos(this, head), other && _clipPos(this, other), options)
            }),
            extendSelections: docMethodOp(function(heads, options) {
                extendSelections(this, clipPosArray(this, heads), options)
            }),
            extendSelectionsBy: docMethodOp(function(f, options) {
                var heads = map(this.sel.ranges, f);
                extendSelections(this, clipPosArray(this, heads), options)
            }),
            setSelections: docMethodOp(function(ranges, primary, options) {
                var this$1 = this;
                if (ranges.length) {
                    for (var out = [], i = 0; i < ranges.length; i++) out[i] = new Range(_clipPos(this$1, ranges[i].anchor), _clipPos(this$1, ranges[i].head));
                    null == primary && (primary = Math.min(ranges.length - 1, this.sel.primIndex)), setSelection(this, normalizeSelection(out, primary), options)
                }
            }),
            addSelection: docMethodOp(function(anchor, head, options) {
                var ranges = this.sel.ranges.slice(0);
                ranges.push(new Range(_clipPos(this, anchor), _clipPos(this, head || anchor))), setSelection(this, normalizeSelection(ranges, ranges.length - 1), options)
            }),
            getSelection: function(lineSep) {
                for (var lines, this$1 = this, ranges = this.sel.ranges, i = 0; i < ranges.length; i++) {
                    var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
                    lines = lines ? lines.concat(sel) : sel
                }
                return lineSep === !1 ? lines : lines.join(lineSep || this.lineSeparator())
            },
            getSelections: function(lineSep) {
                for (var this$1 = this, parts = [], ranges = this.sel.ranges, i = 0; i < ranges.length; i++) {
                    var sel = getBetween(this$1, ranges[i].from(), ranges[i].to());
                    lineSep !== !1 && (sel = sel.join(lineSep || this$1.lineSeparator())), parts[i] = sel
                }
                return parts
            },
            replaceSelection: function(code, collapse, origin) {
                for (var dup = [], i = 0; i < this.sel.ranges.length; i++) dup[i] = code;
                this.replaceSelections(dup, collapse, origin || "+input")
            },
            replaceSelections: docMethodOp(function(code, collapse, origin) {
                for (var this$1 = this, changes = [], sel = this.sel, i = 0; i < sel.ranges.length; i++) {
                    var range$$1 = sel.ranges[i];
                    changes[i] = {
                        from: range$$1.from(),
                        to: range$$1.to(),
                        text: this$1.splitLines(code[i]),
                        origin: origin
                    }
                }
                for (var newSel = collapse && "end" != collapse && computeReplacedSel(this, changes, collapse), i$1 = changes.length - 1; i$1 >= 0; i$1--) makeChange(this$1, changes[i$1]);
                newSel ? setSelectionReplaceHistory(this, newSel) : this.cm && ensureCursorVisible(this.cm)
            }),
            undo: docMethodOp(function() {
                makeChangeFromHistory(this, "undo")
            }),
            redo: docMethodOp(function() {
                makeChangeFromHistory(this, "redo")
            }),
            undoSelection: docMethodOp(function() {
                makeChangeFromHistory(this, "undo", !0)
            }),
            redoSelection: docMethodOp(function() {
                makeChangeFromHistory(this, "redo", !0)
            }),
            setExtending: function(val) {
                this.extend = val
            },
            getExtending: function() {
                return this.extend
            },
            historySize: function() {
                for (var hist = this.history, done = 0, undone = 0, i = 0; i < hist.done.length; i++) hist.done[i].ranges || ++done;
                for (var i$1 = 0; i$1 < hist.undone.length; i$1++) hist.undone[i$1].ranges || ++undone;
                return {
                    undo: done,
                    redo: undone
                }
            },
            clearHistory: function() {
                this.history = new History(this.history.maxGeneration)
            },
            markClean: function() {
                this.cleanGeneration = this.changeGeneration(!0)
            },
            changeGeneration: function(forceSplit) {
                return forceSplit && (this.history.lastOp = this.history.lastSelOp = this.history.lastOrigin = null), this.history.generation
            },
            isClean: function(gen) {
                return this.history.generation == (gen || this.cleanGeneration)
            },
            getHistory: function() {
                return {
                    done: copyHistoryArray(this.history.done),
                    undone: copyHistoryArray(this.history.undone)
                }
            },
            setHistory: function(histData) {
                var hist = this.history = new History(this.history.maxGeneration);
                hist.done = copyHistoryArray(histData.done.slice(0), null, !0), hist.undone = copyHistoryArray(histData.undone.slice(0), null, !0)
            },
            setGutterMarker: docMethodOp(function(line, gutterID, value) {
                return changeLine(this, line, "gutter", function(line) {
                    var markers = line.gutterMarkers || (line.gutterMarkers = {});
                    return markers[gutterID] = value, !value && isEmpty(markers) && (line.gutterMarkers = null), !0
                })
            }),
            clearGutter: docMethodOp(function(gutterID) {
                var this$1 = this;
                this.iter(function(line) {
                    line.gutterMarkers && line.gutterMarkers[gutterID] && changeLine(this$1, line, "gutter", function() {
                        return line.gutterMarkers[gutterID] = null, isEmpty(line.gutterMarkers) && (line.gutterMarkers = null), !0
                    })
                })
            }),
            lineInfo: function(line) {
                var n;
                if ("number" == typeof line) {
                    if (!isLine(this, line)) return null;
                    if (n = line, line = getLine(this, line), !line) return null
                } else if (n = lineNo(line), null == n) return null;
                return {
                    line: n,
                    handle: line,
                    text: line.text,
                    gutterMarkers: line.gutterMarkers,
                    textClass: line.textClass,
                    bgClass: line.bgClass,
                    wrapClass: line.wrapClass,
                    widgets: line.widgets
                }
            },
            addLineClass: docMethodOp(function(handle, where, cls) {
                return changeLine(this, handle, "gutter" == where ? "gutter" : "class", function(line) {
                    var prop = "text" == where ? "textClass" : "background" == where ? "bgClass" : "gutter" == where ? "gutterClass" : "wrapClass";
                    if (line[prop]) {
                        if (classTest(cls).test(line[prop])) return !1;
                        line[prop] += " " + cls
                    } else line[prop] = cls;
                    return !0
                })
            }),
            removeLineClass: docMethodOp(function(handle, where, cls) {
                return changeLine(this, handle, "gutter" == where ? "gutter" : "class", function(line) {
                    var prop = "text" == where ? "textClass" : "background" == where ? "bgClass" : "gutter" == where ? "gutterClass" : "wrapClass",
                        cur = line[prop];
                    if (!cur) return !1;
                    if (null == cls) line[prop] = null;
                    else {
                        var found = cur.match(classTest(cls));
                        if (!found) return !1;
                        var end = found.index + found[0].length;
                        line[prop] = cur.slice(0, found.index) + (found.index && end != cur.length ? " " : "") + cur.slice(end) || null
                    }
                    return !0
                })
            }),
            addLineWidget: docMethodOp(function(handle, node, options) {
                return addLineWidget(this, handle, node, options)
            }),
            removeLineWidget: function(widget) {
                widget.clear()
            },
            markText: function(from, to, options) {
                return _markText(this, _clipPos(this, from), _clipPos(this, to), options, options && options.type || "range")
            },
            setBookmark: function(pos, options) {
                var realOpts = {
                    replacedWith: options && (null == options.nodeType ? options.widget : options),
                    insertLeft: options && options.insertLeft,
                    clearWhenEmpty: !1,
                    shared: options && options.shared,
                    handleMouseEvents: options && options.handleMouseEvents
                };
                return pos = _clipPos(this, pos), _markText(this, pos, pos, realOpts, "bookmark")
            },
            findMarksAt: function(pos) {
                pos = _clipPos(this, pos);
                var markers = [],
                    spans = getLine(this, pos.line).markedSpans;
                if (spans)
                    for (var i = 0; i < spans.length; ++i) {
                        var span = spans[i];
                        (null == span.from || span.from <= pos.ch) && (null == span.to || span.to >= pos.ch) && markers.push(span.marker.parent || span.marker)
                    }
                return markers
            },
            findMarks: function(from, to, filter) {
                from = _clipPos(this, from), to = _clipPos(this, to);
                var found = [],
                    lineNo$$1 = from.line;
                return this.iter(from.line, to.line + 1, function(line) {
                    var spans = line.markedSpans;
                    if (spans)
                        for (var i = 0; i < spans.length; i++) {
                            var span = spans[i];
                            null != span.to && lineNo$$1 == from.line && from.ch >= span.to || null == span.from && lineNo$$1 != from.line || null != span.from && lineNo$$1 == to.line && span.from >= to.ch || filter && !filter(span.marker) || found.push(span.marker.parent || span.marker)
                        }++lineNo$$1
                }), found
            },
            getAllMarks: function() {
                var markers = [];
                return this.iter(function(line) {
                    var sps = line.markedSpans;
                    if (sps)
                        for (var i = 0; i < sps.length; ++i) null != sps[i].from && markers.push(sps[i].marker)
                }), markers
            },
            posFromIndex: function(off) {
                var ch, lineNo$$1 = this.first,
                    sepSize = this.lineSeparator().length;
                return this.iter(function(line) {
                    var sz = line.text.length + sepSize;
                    return sz > off ? (ch = off, !0) : (off -= sz, void++lineNo$$1)
                }), _clipPos(this, Pos(lineNo$$1, ch))
            },
            indexFromPos: function(coords) {
                coords = _clipPos(this, coords);
                var index = coords.ch;
                if (coords.line < this.first || coords.ch < 0) return 0;
                var sepSize = this.lineSeparator().length;
                return this.iter(this.first, coords.line, function(line) {
                    index += line.text.length + sepSize
                }), index
            },
            copy: function(copyHistory) {
                var doc = new Doc(getLines(this, this.first, this.first + this.size), this.modeOption, this.first, this.lineSep, this.direction);
                return doc.scrollTop = this.scrollTop, doc.scrollLeft = this.scrollLeft, doc.sel = this.sel, doc.extend = !1, copyHistory && (doc.history.undoDepth = this.history.undoDepth, doc.setHistory(this.getHistory())), doc
            },
            linkedDoc: function(options) {
                options || (options = {});
                var from = this.first,
                    to = this.first + this.size;
                null != options.from && options.from > from && (from = options.from), null != options.to && options.to < to && (to = options.to);
                var copy = new Doc(getLines(this, from, to), options.mode || this.modeOption, from, this.lineSep, this.direction);
                return options.sharedHist && (copy.history = this.history), (this.linked || (this.linked = [])).push({
                    doc: copy,
                    sharedHist: options.sharedHist
                }), copy.linked = [{
                    doc: this,
                    isParent: !0,
                    sharedHist: options.sharedHist
                }], copySharedMarkers(copy, findSharedMarkers(this)), copy
            },
            unlinkDoc: function(other) {
                var this$1 = this;
                if (other instanceof CodeMirror$1 && (other = other.doc), this.linked)
                    for (var i = 0; i < this.linked.length; ++i) {
                        var link = this$1.linked[i];
                        if (link.doc == other) {
                            this$1.linked.splice(i, 1), other.unlinkDoc(this$1), detachSharedMarkers(findSharedMarkers(this$1));
                            break
                        }
                    }
                if (other.history == this.history) {
                    var splitIds = [other.id];
                    linkedDocs(other, function(doc) {
                        return splitIds.push(doc.id)
                    }, !0), other.history = new History(null), other.history.done = copyHistoryArray(this.history.done, splitIds), other.history.undone = copyHistoryArray(this.history.undone, splitIds)
                }
            },
            iterLinkedDocs: function(f) {
                linkedDocs(this, f)
            },
            getMode: function() {
                return this.mode
            },
            getEditor: function() {
                return this.cm
            },
            splitLines: function(str) {
                return this.lineSep ? str.split(this.lineSep) : splitLinesAuto(str)
            },
            lineSeparator: function() {
                return this.lineSep || "\n"
            },
            setDirection: docMethodOp(function(dir) {
                "rtl" != dir && (dir = "ltr"), dir != this.direction && (this.direction = dir, this.iter(function(line) {
                    return line.order = null
                }), this.cm && directionChanged(this.cm))
            })
        }), Doc.prototype.eachLine = Doc.prototype.iter;
        for (var lastDrop = 0, globalsRegistered = !1, keyNames = {
                3: "Pause",
                8: "Backspace",
                9: "Tab",
                13: "Enter",
                16: "Shift",
                17: "Ctrl",
                18: "Alt",
                19: "Pause",
                20: "CapsLock",
                27: "Esc",
                32: "Space",
                33: "PageUp",
                34: "PageDown",
                35: "End",
                36: "Home",
                37: "Left",
                38: "Up",
                39: "Right",
                40: "Down",
                44: "PrintScrn",
                45: "Insert",
                46: "Delete",
                59: ";",
                61: "=",
                91: "Mod",
                92: "Mod",
                93: "Mod",
                106: "*",
                107: "=",
                109: "-",
                110: ".",
                111: "/",
                127: "Delete",
                145: "ScrollLock",
                173: "-",
                186: ";",
                187: "=",
                188: ",",
                189: "-",
                190: ".",
                191: "/",
                192: "`",
                219: "[",
                220: "\\",
                221: "]",
                222: "'",
                63232: "Up",
                63233: "Down",
                63234: "Left",
                63235: "Right",
                63272: "Delete",
                63273: "Home",
                63275: "End",
                63276: "PageUp",
                63277: "PageDown",
                63302: "Insert"
            }, i = 0; i < 10; i++) keyNames[i + 48] = keyNames[i + 96] = String(i);
        for (var i$1 = 65; i$1 <= 90; i$1++) keyNames[i$1] = String.fromCharCode(i$1);
        for (var i$2 = 1; i$2 <= 12; i$2++) keyNames[i$2 + 111] = keyNames[i$2 + 63235] = "F" + i$2;
        var keyMap = {};
        keyMap.basic = {
            Left: "goCharLeft",
            Right: "goCharRight",
            Up: "goLineUp",
            Down: "goLineDown",
            End: "goLineEnd",
            Home: "goLineStartSmart",
            PageUp: "goPageUp",
            PageDown: "goPageDown",
            Delete: "delCharAfter",
            Backspace: "delCharBefore",
            "Shift-Backspace": "delCharBefore",
            Tab: "defaultTab",
            "Shift-Tab": "indentAuto",
            Enter: "newlineAndIndent",
            Insert: "toggleOverwrite",
            Esc: "singleSelection"
        }, keyMap.pcDefault = {
            "Ctrl-A": "selectAll",
            "Ctrl-D": "deleteLine",
            "Ctrl-Z": "undo",
            "Shift-Ctrl-Z": "redo",
            "Ctrl-Y": "redo",
            "Ctrl-Home": "goDocStart",
            "Ctrl-End": "goDocEnd",
            "Ctrl-Up": "goLineUp",
            "Ctrl-Down": "goLineDown",
            "Ctrl-Left": "goGroupLeft",
            "Ctrl-Right": "goGroupRight",
            "Alt-Left": "goLineStart",
            "Alt-Right": "goLineEnd",
            "Ctrl-Backspace": "delGroupBefore",
            "Ctrl-Delete": "delGroupAfter",
            "Ctrl-S": "save",
            "Ctrl-F": "find",
            "Ctrl-G": "findNext",
            "Shift-Ctrl-G": "findPrev",
            "Shift-Ctrl-F": "replace",
            "Shift-Ctrl-R": "replaceAll",
            "Ctrl-[": "indentLess",
            "Ctrl-]": "indentMore",
            "Ctrl-U": "undoSelection",
            "Shift-Ctrl-U": "redoSelection",
            "Alt-U": "redoSelection",
            fallthrough: "basic"
        }, keyMap.emacsy = {
            "Ctrl-F": "goCharRight",
            "Ctrl-B": "goCharLeft",
            "Ctrl-P": "goLineUp",
            "Ctrl-N": "goLineDown",
            "Alt-F": "goWordRight",
            "Alt-B": "goWordLeft",
            "Ctrl-A": "goLineStart",
            "Ctrl-E": "goLineEnd",
            "Ctrl-V": "goPageDown",
            "Shift-Ctrl-V": "goPageUp",
            "Ctrl-D": "delCharAfter",
            "Ctrl-H": "delCharBefore",
            "Alt-D": "delWordAfter",
            "Alt-Backspace": "delWordBefore",
            "Ctrl-K": "killLine",
            "Ctrl-T": "transposeChars",
            "Ctrl-O": "openLine"
        }, keyMap.macDefault = {
            "Cmd-A": "selectAll",
            "Cmd-D": "deleteLine",
            "Cmd-Z": "undo",
            "Shift-Cmd-Z": "redo",
            "Cmd-Y": "redo",
            "Cmd-Home": "goDocStart",
            "Cmd-Up": "goDocStart",
            "Cmd-End": "goDocEnd",
            "Cmd-Down": "goDocEnd",
            "Alt-Left": "goGroupLeft",
            "Alt-Right": "goGroupRight",
            "Cmd-Left": "goLineLeft",
            "Cmd-Right": "goLineRight",
            "Alt-Backspace": "delGroupBefore",
            "Ctrl-Alt-Backspace": "delGroupAfter",
            "Alt-Delete": "delGroupAfter",
            "Cmd-S": "save",
            "Cmd-F": "find",
            "Cmd-G": "findNext",
            "Shift-Cmd-G": "findPrev",
            "Cmd-Alt-F": "replace",
            "Shift-Cmd-Alt-F": "replaceAll",
            "Cmd-[": "indentLess",
            "Cmd-]": "indentMore",
            "Cmd-Backspace": "delWrappedLineLeft",
            "Cmd-Delete": "delWrappedLineRight",
            "Cmd-U": "undoSelection",
            "Shift-Cmd-U": "redoSelection",
            "Ctrl-Up": "goDocStart",
            "Ctrl-Down": "goDocEnd",
            fallthrough: ["basic", "emacsy"]
        }, keyMap.default = mac ? keyMap.macDefault : keyMap.pcDefault;
        var commands = {
                selectAll: selectAll,
                singleSelection: function(cm) {
                    return cm.setSelection(cm.getCursor("anchor"), cm.getCursor("head"), sel_dontScroll)
                },
                killLine: function(cm) {
                    return deleteNearSelection(cm, function(range) {
                        if (range.empty()) {
                            var len = getLine(cm.doc, range.head.line).text.length;
                            return range.head.ch == len && range.head.line < cm.lastLine() ? {
                                from: range.head,
                                to: Pos(range.head.line + 1, 0)
                            } : {
                                from: range.head,
                                to: Pos(range.head.line, len)
                            }
                        }
                        return {
                            from: range.from(),
                            to: range.to()
                        }
                    })
                },
                deleteLine: function(cm) {
                    return deleteNearSelection(cm, function(range) {
                        return {
                            from: Pos(range.from().line, 0),
                            to: _clipPos(cm.doc, Pos(range.to().line + 1, 0))
                        }
                    })
                },
                delLineLeft: function(cm) {
                    return deleteNearSelection(cm, function(range) {
                        return {
                            from: Pos(range.from().line, 0),
                            to: range.from()
                        }
                    })
                },
                delWrappedLineLeft: function(cm) {
                    return deleteNearSelection(cm, function(range) {
                        var top = cm.charCoords(range.head, "div").top + 5,
                            leftPos = cm.coordsChar({
                                left: 0,
                                top: top
                            }, "div");
                        return {
                            from: leftPos,
                            to: range.from()
                        }
                    })
                },
                delWrappedLineRight: function(cm) {
                    return deleteNearSelection(cm, function(range) {
                        var top = cm.charCoords(range.head, "div").top + 5,
                            rightPos = cm.coordsChar({
                                left: cm.display.lineDiv.offsetWidth + 100,
                                top: top
                            }, "div");
                        return {
                            from: range.from(),
                            to: rightPos
                        }
                    })
                },
                undo: function(cm) {
                    return cm.undo()
                },
                redo: function(cm) {
                    return cm.redo()
                },
                undoSelection: function(cm) {
                    return cm.undoSelection()
                },
                redoSelection: function(cm) {
                    return cm.redoSelection()
                },
                goDocStart: function(cm) {
                    return cm.extendSelection(Pos(cm.firstLine(), 0))
                },
                goDocEnd: function(cm) {
                    return cm.extendSelection(Pos(cm.lastLine()))
                },
                goLineStart: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        return lineStart(cm, range.head.line)
                    }, {
                        origin: "+move",
                        bias: 1
                    })
                },
                goLineStartSmart: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        return lineStartSmart(cm, range.head)
                    }, {
                        origin: "+move",
                        bias: 1
                    })
                },
                goLineEnd: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        return lineEnd(cm, range.head.line)
                    }, {
                        origin: "+move",
                        bias: -1
                    })
                },
                goLineRight: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        var top = cm.cursorCoords(range.head, "div").top + 5;
                        return cm.coordsChar({
                            left: cm.display.lineDiv.offsetWidth + 100,
                            top: top
                        }, "div")
                    }, sel_move)
                },
                goLineLeft: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        var top = cm.cursorCoords(range.head, "div").top + 5;
                        return cm.coordsChar({
                            left: 0,
                            top: top
                        }, "div")
                    }, sel_move)
                },
                goLineLeftSmart: function(cm) {
                    return cm.extendSelectionsBy(function(range) {
                        var top = cm.cursorCoords(range.head, "div").top + 5,
                            pos = cm.coordsChar({
                                left: 0,
                                top: top
                            }, "div");
                        return pos.ch < cm.getLine(pos.line).search(/\S/) ? lineStartSmart(cm, range.head) : pos
                    }, sel_move)
                },
                goLineUp: function(cm) {
                    return cm.moveV(-1, "line")
                },
                goLineDown: function(cm) {
                    return cm.moveV(1, "line")
                },
                goPageUp: function(cm) {
                    return cm.moveV(-1, "page")
                },
                goPageDown: function(cm) {
                    return cm.moveV(1, "page")
                },
                goCharLeft: function(cm) {
                    return cm.moveH(-1, "char")
                },
                goCharRight: function(cm) {
                    return cm.moveH(1, "char")
                },
                goColumnLeft: function(cm) {
                    return cm.moveH(-1, "column")
                },
                goColumnRight: function(cm) {
                    return cm.moveH(1, "column")
                },
                goWordLeft: function(cm) {
                    return cm.moveH(-1, "word")
                },
                goGroupRight: function(cm) {
                    return cm.moveH(1, "group")
                },
                goGroupLeft: function(cm) {
                    return cm.moveH(-1, "group")
                },
                goWordRight: function(cm) {
                    return cm.moveH(1, "word")
                },
                delCharBefore: function(cm) {
                    return cm.deleteH(-1, "char")
                },
                delCharAfter: function(cm) {
                    return cm.deleteH(1, "char")
                },
                delWordBefore: function(cm) {
                    return cm.deleteH(-1, "word")
                },
                delWordAfter: function(cm) {
                    return cm.deleteH(1, "word")
                },
                delGroupBefore: function(cm) {
                    return cm.deleteH(-1, "group")
                },
                delGroupAfter: function(cm) {
                    return cm.deleteH(1, "group")
                },
                indentAuto: function(cm) {
                    return cm.indentSelection("smart")
                },
                indentMore: function(cm) {
                    return cm.indentSelection("add")
                },
                indentLess: function(cm) {
                    return cm.indentSelection("subtract")
                },
                insertTab: function(cm) {
                    return cm.replaceSelection("\t")
                },
                insertSoftTab: function(cm) {
                    for (var spaces = [], ranges = cm.listSelections(), tabSize = cm.options.tabSize, i = 0; i < ranges.length; i++) {
                        var pos = ranges[i].from(),
                            col = countColumn(cm.getLine(pos.line), pos.ch, tabSize);
                        spaces.push(spaceStr(tabSize - col % tabSize))
                    }
                    cm.replaceSelections(spaces)
                },
                defaultTab: function(cm) {
                    cm.somethingSelected() ? cm.indentSelection("add") : cm.execCommand("insertTab")
                },
                transposeChars: function(cm) {
                    return runInOp(cm, function() {
                        for (var ranges = cm.listSelections(), newSel = [], i = 0; i < ranges.length; i++)
                            if (ranges[i].empty()) {
                                var cur = ranges[i].head,
                                    line = getLine(cm.doc, cur.line).text;
                                if (line)
                                    if (cur.ch == line.length && (cur = new Pos(cur.line, cur.ch - 1)), cur.ch > 0) cur = new Pos(cur.line, cur.ch + 1), cm.replaceRange(line.charAt(cur.ch - 1) + line.charAt(cur.ch - 2), Pos(cur.line, cur.ch - 2), cur, "+transpose");
                                    else if (cur.line > cm.doc.first) {
                                    var prev = getLine(cm.doc, cur.line - 1).text;
                                    prev && (cur = new Pos(cur.line, 1), cm.replaceRange(line.charAt(0) + cm.doc.lineSeparator() + prev.charAt(prev.length - 1), Pos(cur.line - 1, prev.length - 1), cur, "+transpose"))
                                }
                                newSel.push(new Range(cur, cur))
                            } cm.setSelections(newSel)
                    })
                },
                newlineAndIndent: function(cm) {
                    return runInOp(cm, function() {
                        for (var sels = cm.listSelections(), i = sels.length - 1; i >= 0; i--) cm.replaceRange(cm.doc.lineSeparator(), sels[i].anchor, sels[i].head, "+input");
                        sels = cm.listSelections();
                        for (var i$1 = 0; i$1 < sels.length; i$1++) cm.indentLine(sels[i$1].from().line, null, !0);
                        ensureCursorVisible(cm)
                    })
                },
                openLine: function(cm) {
                    return cm.replaceSelection("\n", "start")
                },
                toggleOverwrite: function(cm) {
                    return cm.toggleOverwrite()
                }
            },
            stopSeq = new Delayed,
            lastStoppedKey = null,
            DOUBLECLICK_DELAY = 400,
            PastClick = function(time, pos, button) {
                this.time = time, this.pos = pos, this.button = button
            };
        PastClick.prototype.compare = function(time, pos, button) {
            return this.time + DOUBLECLICK_DELAY > time && 0 == cmp(pos, this.pos) && button == this.button
        };
        var lastClick, lastDoubleClick, Init = {
                toString: function() {
                    return "CodeMirror.Init"
                }
            },
            defaults = {},
            optionHandlers = {};
        CodeMirror$1.defaults = defaults, CodeMirror$1.optionHandlers = optionHandlers;
        var initHooks = [];
        CodeMirror$1.defineInitHook = function(f) {
            return initHooks.push(f)
        };
        var lastCopied = null,
            addEditorMethods = function(CodeMirror) {
                var optionHandlers = CodeMirror.optionHandlers,
                    helpers = CodeMirror.helpers = {};
                CodeMirror.prototype = {
                    constructor: CodeMirror,
                    focus: function() {
                        window.focus(), this.display.input.focus()
                    },
                    setOption: function(option, value) {
                        var options = this.options,
                            old = options[option];
                        options[option] == value && "mode" != option || (options[option] = value, optionHandlers.hasOwnProperty(option) && operation(this, optionHandlers[option])(this, value, old), signal(this, "optionChange", this, option))
                    },
                    getOption: function(option) {
                        return this.options[option]
                    },
                    getDoc: function() {
                        return this.doc
                    },
                    addKeyMap: function(map$$1, bottom) {
                        this.state.keyMaps[bottom ? "push" : "unshift"](getKeyMap(map$$1))
                    },
                    removeKeyMap: function(map$$1) {
                        for (var maps = this.state.keyMaps, i = 0; i < maps.length; ++i)
                            if (maps[i] == map$$1 || maps[i].name == map$$1) return maps.splice(i, 1), !0
                    },
                    addOverlay: methodOp(function(spec, options) {
                        var mode = spec.token ? spec : CodeMirror.getMode(this.options, spec);
                        if (mode.startState) throw new Error("Overlays may not be stateful.");
                        insertSorted(this.state.overlays, {
                            mode: mode,
                            modeSpec: spec,
                            opaque: options && options.opaque,
                            priority: options && options.priority || 0
                        }, function(overlay) {
                            return overlay.priority
                        }), this.state.modeGen++, regChange(this)
                    }),
                    removeOverlay: methodOp(function(spec) {
                        for (var this$1 = this, overlays = this.state.overlays, i = 0; i < overlays.length; ++i) {
                            var cur = overlays[i].modeSpec;
                            if (cur == spec || "string" == typeof spec && cur.name == spec) return overlays.splice(i, 1), this$1.state.modeGen++, void regChange(this$1)
                        }
                    }),
                    indentLine: methodOp(function(n, dir, aggressive) {
                        "string" != typeof dir && "number" != typeof dir && (dir = null == dir ? this.options.smartIndent ? "smart" : "prev" : dir ? "add" : "subtract"), isLine(this.doc, n) && indentLine(this, n, dir, aggressive)
                    }),
                    indentSelection: methodOp(function(how) {
                        for (var this$1 = this, ranges = this.doc.sel.ranges, end = -1, i = 0; i < ranges.length; i++) {
                            var range$$1 = ranges[i];
                            if (range$$1.empty()) range$$1.head.line > end && (indentLine(this$1, range$$1.head.line, how, !0), end = range$$1.head.line, i == this$1.doc.sel.primIndex && ensureCursorVisible(this$1));
                            else {
                                var from = range$$1.from(),
                                    to = range$$1.to(),
                                    start = Math.max(end, from.line);
                                end = Math.min(this$1.lastLine(), to.line - (to.ch ? 0 : 1)) + 1;
                                for (var j = start; j < end; ++j) indentLine(this$1, j, how);
                                var newRanges = this$1.doc.sel.ranges;
                                0 == from.ch && ranges.length == newRanges.length && newRanges[i].from().ch > 0 && replaceOneSelection(this$1.doc, i, new Range(from, newRanges[i].to()), sel_dontScroll)
                            }
                        }
                    }),
                    getTokenAt: function(pos, precise) {
                        return takeToken(this, pos, precise)
                    },
                    getLineTokens: function(line, precise) {
                        return takeToken(this, Pos(line), precise, !0)
                    },
                    getTokenTypeAt: function(pos) {
                        pos = _clipPos(this.doc, pos);
                        var type, styles = getLineStyles(this, getLine(this.doc, pos.line)),
                            before = 0,
                            after = (styles.length - 1) / 2,
                            ch = pos.ch;
                        if (0 == ch) type = styles[2];
                        else
                            for (;;) {
                                var mid = before + after >> 1;
                                if ((mid ? styles[2 * mid - 1] : 0) >= ch) after = mid;
                                else {
                                    if (!(styles[2 * mid + 1] < ch)) {
                                        type = styles[2 * mid + 2];
                                        break
                                    }
                                    before = mid + 1
                                }
                            }
                        var cut = type ? type.indexOf("overlay ") : -1;
                        return cut < 0 ? type : 0 == cut ? null : type.slice(0, cut - 1)
                    },
                    getModeAt: function(pos) {
                        var mode = this.doc.mode;
                        return mode.innerMode ? CodeMirror.innerMode(mode, this.getTokenAt(pos).state).mode : mode
                    },
                    getHelper: function(pos, type) {
                        return this.getHelpers(pos, type)[0]
                    },
                    getHelpers: function(pos, type) {
                        var this$1 = this,
                            found = [];
                        if (!helpers.hasOwnProperty(type)) return found;
                        var help = helpers[type],
                            mode = this.getModeAt(pos);
                        if ("string" == typeof mode[type]) help[mode[type]] && found.push(help[mode[type]]);
                        else if (mode[type])
                            for (var i = 0; i < mode[type].length; i++) {
                                var val = help[mode[type][i]];
                                val && found.push(val)
                            } else mode.helperType && help[mode.helperType] ? found.push(help[mode.helperType]) : help[mode.name] && found.push(help[mode.name]);
                        for (var i$1 = 0; i$1 < help._global.length; i$1++) {
                            var cur = help._global[i$1];
                            cur.pred(mode, this$1) && indexOf(found, cur.val) == -1 && found.push(cur.val)
                        }
                        return found
                    },
                    getStateAfter: function(line, precise) {
                        var doc = this.doc;
                        return line = clipLine(doc, null == line ? doc.first + doc.size - 1 : line), getContextBefore(this, line + 1, precise).state
                    },
                    cursorCoords: function(start, mode) {
                        var pos, range$$1 = this.doc.sel.primary();
                        return pos = null == start ? range$$1.head : "object" == _typeof2(start) ? _clipPos(this.doc, start) : start ? range$$1.from() : range$$1.to(), _cursorCoords(this, pos, mode || "page")
                    },
                    charCoords: function(pos, mode) {
                        return _charCoords(this, _clipPos(this.doc, pos), mode || "page")
                    },
                    coordsChar: function(coords, mode) {
                        return coords = fromCoordSystem(this, coords, mode || "page"), _coordsChar(this, coords.left, coords.top)
                    },
                    lineAtHeight: function(height, mode) {
                        return height = fromCoordSystem(this, {
                            top: height,
                            left: 0
                        }, mode || "page").top, _lineAtHeight(this.doc, height + this.display.viewOffset)
                    },
                    heightAtLine: function(line, mode, includeWidgets) {
                        var lineObj, end = !1;
                        if ("number" == typeof line) {
                            var last = this.doc.first + this.doc.size - 1;
                            line < this.doc.first ? line = this.doc.first : line > last && (line = last, end = !0), lineObj = getLine(this.doc, line)
                        } else lineObj = line;
                        return intoCoordSystem(this, lineObj, {
                            top: 0,
                            left: 0
                        }, mode || "page", includeWidgets || end).top + (end ? this.doc.height - _heightAtLine(lineObj) : 0)
                    },
                    defaultTextHeight: function() {
                        return textHeight(this.display)
                    },
                    defaultCharWidth: function() {
                        return charWidth(this.display)
                    },
                    getViewport: function() {
                        return {
                            from: this.display.viewFrom,
                            to: this.display.viewTo
                        }
                    },
                    addWidget: function(pos, node, scroll, vert, horiz) {
                        var display = this.display;
                        pos = _cursorCoords(this, _clipPos(this.doc, pos));
                        var top = pos.bottom,
                            left = pos.left;
                        if (node.style.position = "absolute", node.setAttribute("cm-ignore-events", "true"), this.display.input.setUneditable(node), display.sizer.appendChild(node), "over" == vert) top = pos.top;
                        else if ("above" == vert || "near" == vert) {
                            var vspace = Math.max(display.wrapper.clientHeight, this.doc.height),
                                hspace = Math.max(display.sizer.clientWidth, display.lineSpace.clientWidth);
                            ("above" == vert || pos.bottom + node.offsetHeight > vspace) && pos.top > node.offsetHeight ? top = pos.top - node.offsetHeight : pos.bottom + node.offsetHeight <= vspace && (top = pos.bottom), left + node.offsetWidth > hspace && (left = hspace - node.offsetWidth)
                        }
                        node.style.top = top + "px", node.style.left = node.style.right = "", "right" == horiz ? (left = display.sizer.clientWidth - node.offsetWidth, node.style.right = "0px") : ("left" == horiz ? left = 0 : "middle" == horiz && (left = (display.sizer.clientWidth - node.offsetWidth) / 2), node.style.left = left + "px"), scroll && scrollIntoView(this, {
                            left: left,
                            top: top,
                            right: left + node.offsetWidth,
                            bottom: top + node.offsetHeight
                        })
                    },
                    triggerOnKeyDown: methodOp(onKeyDown),
                    triggerOnKeyPress: methodOp(onKeyPress),
                    triggerOnKeyUp: onKeyUp,
                    triggerOnMouseDown: methodOp(onMouseDown),
                    execCommand: function(cmd) {
                        if (commands.hasOwnProperty(cmd)) return commands[cmd].call(null, this)
                    },
                    triggerElectric: methodOp(function(text) {
                        triggerElectric(this, text)
                    }),
                    findPosH: function(from, amount, unit, visually) {
                        var this$1 = this,
                            dir = 1;
                        amount < 0 && (dir = -1, amount = -amount);
                        for (var cur = _clipPos(this.doc, from), i = 0; i < amount && (cur = _findPosH(this$1.doc, cur, dir, unit, visually), !cur.hitSide); ++i);
                        return cur
                    },
                    moveH: methodOp(function(dir, unit) {
                        var this$1 = this;
                        this.extendSelectionsBy(function(range$$1) {
                            return this$1.display.shift || this$1.doc.extend || range$$1.empty() ? _findPosH(this$1.doc, range$$1.head, dir, unit, this$1.options.rtlMoveVisually) : dir < 0 ? range$$1.from() : range$$1.to()
                        }, sel_move)
                    }),
                    deleteH: methodOp(function(dir, unit) {
                        var sel = this.doc.sel,
                            doc = this.doc;
                        sel.somethingSelected() ? doc.replaceSelection("", null, "+delete") : deleteNearSelection(this, function(range$$1) {
                            var other = _findPosH(doc, range$$1.head, dir, unit, !1);
                            return dir < 0 ? {
                                from: other,
                                to: range$$1.head
                            } : {
                                from: range$$1.head,
                                to: other
                            }
                        })
                    }),
                    findPosV: function(from, amount, unit, goalColumn) {
                        var this$1 = this,
                            dir = 1,
                            x = goalColumn;
                        amount < 0 && (dir = -1, amount = -amount);
                        for (var cur = _clipPos(this.doc, from), i = 0; i < amount; ++i) {
                            var coords = _cursorCoords(this$1, cur, "div");
                            if (null == x ? x = coords.left : coords.left = x, cur = _findPosV(this$1, coords, dir, unit), cur.hitSide) break
                        }
                        return cur
                    },
                    moveV: methodOp(function(dir, unit) {
                        var this$1 = this,
                            doc = this.doc,
                            goals = [],
                            collapse = !this.display.shift && !doc.extend && doc.sel.somethingSelected();
                        if (doc.extendSelectionsBy(function(range$$1) {
                                if (collapse) return dir < 0 ? range$$1.from() : range$$1.to();
                                var headPos = _cursorCoords(this$1, range$$1.head, "div");
                                null != range$$1.goalColumn && (headPos.left = range$$1.goalColumn), goals.push(headPos.left);
                                var pos = _findPosV(this$1, headPos, dir, unit);
                                return "page" == unit && range$$1 == doc.sel.primary() && addToScrollTop(this$1, _charCoords(this$1, pos, "div").top - headPos.top), pos
                            }, sel_move), goals.length)
                            for (var i = 0; i < doc.sel.ranges.length; i++) doc.sel.ranges[i].goalColumn = goals[i]
                    }),
                    findWordAt: function(pos) {
                        var doc = this.doc,
                            line = getLine(doc, pos.line).text,
                            start = pos.ch,
                            end = pos.ch;
                        if (line) {
                            var helper = this.getHelper(pos, "wordChars");
                            "before" != pos.sticky && end != line.length || !start ? ++end : --start;
                            for (var startChar = line.charAt(start), check = isWordChar(startChar, helper) ? function(ch) {
                                    return isWordChar(ch, helper)
                                } : /\s/.test(startChar) ? function(ch) {
                                    return /\s/.test(ch)
                                } : function(ch) {
                                    return !/\s/.test(ch) && !isWordChar(ch)
                                }; start > 0 && check(line.charAt(start - 1));) --start;
                            for (; end < line.length && check(line.charAt(end));) ++end
                        }
                        return new Range(Pos(pos.line, start), Pos(pos.line, end))
                    },
                    toggleOverwrite: function(value) {
                        null != value && value == this.state.overwrite || ((this.state.overwrite = !this.state.overwrite) ? addClass(this.display.cursorDiv, "CodeMirror-overwrite") : rmClass(this.display.cursorDiv, "CodeMirror-overwrite"), signal(this, "overwriteToggle", this, this.state.overwrite))
                    },
                    hasFocus: function() {
                        return this.display.input.getField() == activeElt()
                    },
                    isReadOnly: function() {
                        return !(!this.options.readOnly && !this.doc.cantEdit)
                    },
                    scrollTo: methodOp(function(x, y) {
                        scrollToCoords(this, x, y)
                    }),
                    getScrollInfo: function() {
                        var scroller = this.display.scroller;
                        return {
                            left: scroller.scrollLeft,
                            top: scroller.scrollTop,
                            height: scroller.scrollHeight - scrollGap(this) - this.display.barHeight,
                            width: scroller.scrollWidth - scrollGap(this) - this.display.barWidth,
                            clientHeight: displayHeight(this),
                            clientWidth: displayWidth(this)
                        }
                    },
                    scrollIntoView: methodOp(function(range$$1, margin) {
                        null == range$$1 ? (range$$1 = {
                            from: this.doc.sel.primary().head,
                            to: null
                        }, null == margin && (margin = this.options.cursorScrollMargin)) : "number" == typeof range$$1 ? range$$1 = {
                            from: Pos(range$$1, 0),
                            to: null
                        } : null == range$$1.from && (range$$1 = {
                            from: range$$1,
                            to: null
                        }), range$$1.to || (range$$1.to = range$$1.from), range$$1.margin = margin || 0, null != range$$1.from.line ? scrollToRange(this, range$$1) : scrollToCoordsRange(this, range$$1.from, range$$1.to, range$$1.margin)
                    }),
                    setSize: methodOp(function(width, height) {
                        var this$1 = this,
                            interpret = function(val) {
                                return "number" == typeof val || /^\d+$/.test(String(val)) ? val + "px" : val
                            };
                        null != width && (this.display.wrapper.style.width = interpret(width)), null != height && (this.display.wrapper.style.height = interpret(height)), this.options.lineWrapping && clearLineMeasurementCache(this);
                        var lineNo$$1 = this.display.viewFrom;
                        this.doc.iter(lineNo$$1, this.display.viewTo, function(line) {
                            if (line.widgets)
                                for (var i = 0; i < line.widgets.length; i++)
                                    if (line.widgets[i].noHScroll) {
                                        regLineChange(this$1, lineNo$$1, "widget");
                                        break
                                    }++ lineNo$$1
                        }), this.curOp.forceUpdate = !0, signal(this, "refresh", this)
                    }),
                    operation: function(f) {
                        return runInOp(this, f)
                    },
                    startOperation: function() {
                        return _startOperation(this)
                    },
                    endOperation: function() {
                        return _endOperation(this)
                    },
                    refresh: methodOp(function() {
                        var oldHeight = this.display.cachedTextHeight;
                        regChange(this), this.curOp.forceUpdate = !0, clearCaches(this), scrollToCoords(this, this.doc.scrollLeft, this.doc.scrollTop), updateGutterSpace(this), (null == oldHeight || Math.abs(oldHeight - textHeight(this.display)) > .5) && estimateLineHeights(this), signal(this, "refresh", this)
                    }),
                    swapDoc: methodOp(function(doc) {
                        var old = this.doc;
                        return old.cm = null, attachDoc(this, doc), clearCaches(this), this.display.input.reset(), scrollToCoords(this, doc.scrollLeft, doc.scrollTop), this.curOp.forceScroll = !0, signalLater(this, "swapDoc", this, old), old
                    }),
                    getInputField: function() {
                        return this.display.input.getField()
                    },
                    getWrapperElement: function() {
                        return this.display.wrapper
                    },
                    getScrollerElement: function() {
                        return this.display.scroller
                    },
                    getGutterElement: function() {
                        return this.display.gutters
                    }
                }, eventMixin(CodeMirror), CodeMirror.registerHelper = function(type, name, value) {
                    helpers.hasOwnProperty(type) || (helpers[type] = CodeMirror[type] = {
                        _global: []
                    }), helpers[type][name] = value
                }, CodeMirror.registerGlobalHelper = function(type, name, predicate, value) {
                    CodeMirror.registerHelper(type, name, value), helpers[type]._global.push({
                        pred: predicate,
                        val: value
                    })
                }
            },
            ContentEditableInput = function(cm) {
                this.cm = cm, this.lastAnchorNode = this.lastAnchorOffset = this.lastFocusNode = this.lastFocusOffset = null, this.polling = new Delayed, this.composing = null, this.gracePeriod = !1, this.readDOMTimeout = null
            };
        ContentEditableInput.prototype.init = function(display) {
            function onCopyCut(e) {
                if (!signalDOMEvent(cm, e)) {
                    if (cm.somethingSelected()) setLastCopied({
                        lineWise: !1,
                        text: cm.getSelections()
                    }), "cut" == e.type && cm.replaceSelection("", null, "cut");
                    else {
                        if (!cm.options.lineWiseCopyCut) return;
                        var ranges = copyableRanges(cm);
                        setLastCopied({
                            lineWise: !0,
                            text: ranges.text
                        }), "cut" == e.type && cm.operation(function() {
                            cm.setSelections(ranges.ranges, 0, sel_dontScroll), cm.replaceSelection("", null, "cut")
                        })
                    }
                    if (e.clipboardData) {
                        e.clipboardData.clearData();
                        var content = lastCopied.text.join("\n");
                        if (e.clipboardData.setData("Text", content), e.clipboardData.getData("Text") == content) return void e.preventDefault()
                    }
                    var kludge = hiddenTextarea(),
                        te = kludge.firstChild;
                    cm.display.lineSpace.insertBefore(kludge, cm.display.lineSpace.firstChild), te.value = lastCopied.text.join("\n");
                    var hadFocus = document.activeElement;
                    selectInput(te), setTimeout(function() {
                        cm.display.lineSpace.removeChild(kludge), hadFocus.focus(), hadFocus == div && input.showPrimarySelection()
                    }, 50)
                }
            }
            var this$1 = this,
                input = this,
                cm = input.cm,
                div = input.div = display.lineDiv;
            disableBrowserMagic(div, cm.options.spellcheck), on(div, "paste", function(e) {
                signalDOMEvent(cm, e) || handlePaste(e, cm) || ie_version <= 11 && setTimeout(operation(cm, function() {
                    return this$1.updateFromDOM()
                }), 20)
            }), on(div, "compositionstart", function(e) {
                this$1.composing = {
                    data: e.data,
                    done: !1
                }
            }), on(div, "compositionupdate", function(e) {
                this$1.composing || (this$1.composing = {
                    data: e.data,
                    done: !1
                })
            }), on(div, "compositionend", function(e) {
                this$1.composing && (e.data != this$1.composing.data && this$1.readFromDOMSoon(), this$1.composing.done = !0)
            }), on(div, "touchstart", function() {
                return input.forceCompositionEnd()
            }), on(div, "input", function() {
                this$1.composing || this$1.readFromDOMSoon()
            }), on(div, "copy", onCopyCut), on(div, "cut", onCopyCut)
        }, ContentEditableInput.prototype.prepareSelection = function() {
            var result = prepareSelection(this.cm, !1);
            return result.focus = this.cm.state.focused, result
        }, ContentEditableInput.prototype.showSelection = function(info, takeFocus) {
            info && this.cm.display.view.length && ((info.focus || takeFocus) && this.showPrimarySelection(), this.showMultipleSelections(info))
        }, ContentEditableInput.prototype.showPrimarySelection = function() {
            var sel = window.getSelection(),
                cm = this.cm,
                prim = cm.doc.sel.primary(),
                from = prim.from(),
                to = prim.to();
            if (cm.display.viewTo == cm.display.viewFrom || from.line >= cm.display.viewTo || to.line < cm.display.viewFrom) return void sel.removeAllRanges();
            var curAnchor = domToPos(cm, sel.anchorNode, sel.anchorOffset),
                curFocus = domToPos(cm, sel.focusNode, sel.focusOffset);
            if (!curAnchor || curAnchor.bad || !curFocus || curFocus.bad || 0 != cmp(minPos(curAnchor, curFocus), from) || 0 != cmp(maxPos(curAnchor, curFocus), to)) {
                var view = cm.display.view,
                    start = from.line >= cm.display.viewFrom && posToDOM(cm, from) || {
                        node: view[0].measure.map[2],
                        offset: 0
                    },
                    end = to.line < cm.display.viewTo && posToDOM(cm, to);
                if (!end) {
                    var measure = view[view.length - 1].measure,
                        map$$1 = measure.maps ? measure.maps[measure.maps.length - 1] : measure.map;
                    end = {
                        node: map$$1[map$$1.length - 1],
                        offset: map$$1[map$$1.length - 2] - map$$1[map$$1.length - 3]
                    }
                }
                if (!start || !end) return void sel.removeAllRanges();
                var rng, old = sel.rangeCount && sel.getRangeAt(0);
                try {
                    rng = range(start.node, start.offset, end.offset, end.node)
                } catch (e) {}
                rng && (!gecko && cm.state.focused ? (sel.collapse(start.node, start.offset), rng.collapsed || (sel.removeAllRanges(), sel.addRange(rng))) : (sel.removeAllRanges(), sel.addRange(rng)), old && null == sel.anchorNode ? sel.addRange(old) : gecko && this.startGracePeriod()), this.rememberSelection()
            }
        }, ContentEditableInput.prototype.startGracePeriod = function() {
            var this$1 = this;
            clearTimeout(this.gracePeriod), this.gracePeriod = setTimeout(function() {
                this$1.gracePeriod = !1, this$1.selectionChanged() && this$1.cm.operation(function() {
                    return this$1.cm.curOp.selectionChanged = !0
                })
            }, 20)
        }, ContentEditableInput.prototype.showMultipleSelections = function(info) {
            removeChildrenAndAdd(this.cm.display.cursorDiv, info.cursors), removeChildrenAndAdd(this.cm.display.selectionDiv, info.selection)
        }, ContentEditableInput.prototype.rememberSelection = function() {
            var sel = window.getSelection();
            this.lastAnchorNode = sel.anchorNode, this.lastAnchorOffset = sel.anchorOffset, this.lastFocusNode = sel.focusNode, this.lastFocusOffset = sel.focusOffset
        }, ContentEditableInput.prototype.selectionInEditor = function() {
            var sel = window.getSelection();
            if (!sel.rangeCount) return !1;
            var node = sel.getRangeAt(0).commonAncestorContainer;
            return contains(this.div, node)
        }, ContentEditableInput.prototype.focus = function() {
            "nocursor" != this.cm.options.readOnly && (this.selectionInEditor() || this.showSelection(this.prepareSelection(), !0), this.div.focus())
        }, ContentEditableInput.prototype.blur = function() {
            this.div.blur()
        }, ContentEditableInput.prototype.getField = function() {
            return this.div
        }, ContentEditableInput.prototype.supportsTouch = function() {
            return !0
        }, ContentEditableInput.prototype.receivedFocus = function() {
            function poll() {
                input.cm.state.focused && (input.pollSelection(), input.polling.set(input.cm.options.pollInterval, poll))
            }
            var input = this;
            this.selectionInEditor() ? this.pollSelection() : runInOp(this.cm, function() {
                return input.cm.curOp.selectionChanged = !0
            }), this.polling.set(this.cm.options.pollInterval, poll)
        }, ContentEditableInput.prototype.selectionChanged = function() {
            var sel = window.getSelection();
            return sel.anchorNode != this.lastAnchorNode || sel.anchorOffset != this.lastAnchorOffset || sel.focusNode != this.lastFocusNode || sel.focusOffset != this.lastFocusOffset
        }, ContentEditableInput.prototype.pollSelection = function() {
            if (null == this.readDOMTimeout && !this.gracePeriod && this.selectionChanged()) {
                var sel = window.getSelection(),
                    cm = this.cm;
                if (android && chrome && this.cm.options.gutters.length && isInGutter(sel.anchorNode)) return this.cm.triggerOnKeyDown({
                    type: "keydown",
                    keyCode: 8,
                    preventDefault: Math.abs
                }), this.blur(), void this.focus();
                if (!this.composing) {
                    this.rememberSelection();
                    var anchor = domToPos(cm, sel.anchorNode, sel.anchorOffset),
                        head = domToPos(cm, sel.focusNode, sel.focusOffset);
                    anchor && head && runInOp(cm, function() {
                        setSelection(cm.doc, simpleSelection(anchor, head), sel_dontScroll), (anchor.bad || head.bad) && (cm.curOp.selectionChanged = !0)
                    })
                }
            }
        }, ContentEditableInput.prototype.pollContent = function() {
            null != this.readDOMTimeout && (clearTimeout(this.readDOMTimeout), this.readDOMTimeout = null);
            var cm = this.cm,
                display = cm.display,
                sel = cm.doc.sel.primary(),
                from = sel.from(),
                to = sel.to();
            if (0 == from.ch && from.line > cm.firstLine() && (from = Pos(from.line - 1, getLine(cm.doc, from.line - 1).length)), to.ch == getLine(cm.doc, to.line).text.length && to.line < cm.lastLine() && (to = Pos(to.line + 1, 0)), from.line < display.viewFrom || to.line > display.viewTo - 1) return !1;
            var fromIndex, fromLine, fromNode;
            from.line == display.viewFrom || 0 == (fromIndex = findViewIndex(cm, from.line)) ? (fromLine = lineNo(display.view[0].line), fromNode = display.view[0].node) : (fromLine = lineNo(display.view[fromIndex].line), fromNode = display.view[fromIndex - 1].node.nextSibling);
            var toLine, toNode, toIndex = findViewIndex(cm, to.line);
            if (toIndex == display.view.length - 1 ? (toLine = display.viewTo - 1, toNode = display.lineDiv.lastChild) : (toLine = lineNo(display.view[toIndex + 1].line) - 1, toNode = display.view[toIndex + 1].node.previousSibling), !fromNode) return !1;
            for (var newText = cm.doc.splitLines(domTextBetween(cm, fromNode, toNode, fromLine, toLine)), oldText = getBetween(cm.doc, Pos(fromLine, 0), Pos(toLine, getLine(cm.doc, toLine).text.length)); newText.length > 1 && oldText.length > 1;)
                if (lst(newText) == lst(oldText)) newText.pop(), oldText.pop(), toLine--;
                else {
                    if (newText[0] != oldText[0]) break;
                    newText.shift(), oldText.shift(), fromLine++
                } for (var cutFront = 0, cutEnd = 0, newTop = newText[0], oldTop = oldText[0], maxCutFront = Math.min(newTop.length, oldTop.length); cutFront < maxCutFront && newTop.charCodeAt(cutFront) == oldTop.charCodeAt(cutFront);) ++cutFront;
            for (var newBot = lst(newText), oldBot = lst(oldText), maxCutEnd = Math.min(newBot.length - (1 == newText.length ? cutFront : 0), oldBot.length - (1 == oldText.length ? cutFront : 0)); cutEnd < maxCutEnd && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1);) ++cutEnd;
            if (1 == newText.length && 1 == oldText.length && fromLine == from.line)
                for (; cutFront && cutFront > from.ch && newBot.charCodeAt(newBot.length - cutEnd - 1) == oldBot.charCodeAt(oldBot.length - cutEnd - 1);) cutFront--, cutEnd++;
            newText[newText.length - 1] = newBot.slice(0, newBot.length - cutEnd).replace(/^\u200b+/, ""), newText[0] = newText[0].slice(cutFront).replace(/\u200b+$/, "");
            var chFrom = Pos(fromLine, cutFront),
                chTo = Pos(toLine, oldText.length ? lst(oldText).length - cutEnd : 0);
            return newText.length > 1 || newText[0] || cmp(chFrom, chTo) ? (_replaceRange(cm.doc, newText, chFrom, chTo, "+input"), !0) : void 0
        }, ContentEditableInput.prototype.ensurePolled = function() {
            this.forceCompositionEnd()
        }, ContentEditableInput.prototype.reset = function() {
            this.forceCompositionEnd()
        }, ContentEditableInput.prototype.forceCompositionEnd = function() {
            this.composing && (clearTimeout(this.readDOMTimeout), this.composing = null, this.updateFromDOM(), this.div.blur(), this.div.focus())
        }, ContentEditableInput.prototype.readFromDOMSoon = function() {
            var this$1 = this;
            null == this.readDOMTimeout && (this.readDOMTimeout = setTimeout(function() {
                if (this$1.readDOMTimeout = null, this$1.composing) {
                    if (!this$1.composing.done) return;
                    this$1.composing = null
                }
                this$1.updateFromDOM()
            }, 80))
        }, ContentEditableInput.prototype.updateFromDOM = function() {
            var this$1 = this;
            !this.cm.isReadOnly() && this.pollContent() || runInOp(this.cm, function() {
                return regChange(this$1.cm)
            })
        }, ContentEditableInput.prototype.setUneditable = function(node) {
            node.contentEditable = "false"
        }, ContentEditableInput.prototype.onKeyPress = function(e) {
            0 == e.charCode || this.composing || (e.preventDefault(), this.cm.isReadOnly() || operation(this.cm, applyTextInput)(this.cm, String.fromCharCode(null == e.charCode ? e.keyCode : e.charCode), 0))
        }, ContentEditableInput.prototype.readOnlyChanged = function(val) {
            this.div.contentEditable = String("nocursor" != val)
        }, ContentEditableInput.prototype.onContextMenu = function() {}, ContentEditableInput.prototype.resetPosition = function() {}, ContentEditableInput.prototype.needsContentAttribute = !0;
        var TextareaInput = function(cm) {
            this.cm = cm, this.prevInput = "", this.pollingFast = !1, this.polling = new Delayed, this.hasSelection = !1, this.composing = null
        };
        TextareaInput.prototype.init = function(display) {
            function prepareCopyCut(e) {
                if (!signalDOMEvent(cm, e)) {
                    if (cm.somethingSelected()) setLastCopied({
                        lineWise: !1,
                        text: cm.getSelections()
                    });
                    else {
                        if (!cm.options.lineWiseCopyCut) return;
                        var ranges = copyableRanges(cm);
                        setLastCopied({
                            lineWise: !0,
                            text: ranges.text
                        }), "cut" == e.type ? cm.setSelections(ranges.ranges, null, sel_dontScroll) : (input.prevInput = "", te.value = ranges.text.join("\n"), selectInput(te))
                    }
                    "cut" == e.type && (cm.state.cutIncoming = !0)
                }
            }
            var this$1 = this,
                input = this,
                cm = this.cm;
            this.createField(display);
            var te = this.textarea;
            display.wrapper.insertBefore(this.wrapper, display.wrapper.firstChild), ios && (te.style.width = "0px"), on(te, "input", function() {
                ie && ie_version >= 9 && this$1.hasSelection && (this$1.hasSelection = null), input.poll()
            }), on(te, "paste", function(e) {
                signalDOMEvent(cm, e) || handlePaste(e, cm) || (cm.state.pasteIncoming = !0, input.fastPoll())
            }), on(te, "cut", prepareCopyCut), on(te, "copy", prepareCopyCut), on(display.scroller, "paste", function(e) {
                eventInWidget(display, e) || signalDOMEvent(cm, e) || (cm.state.pasteIncoming = !0, input.focus())
            }), on(display.lineSpace, "selectstart", function(e) {
                eventInWidget(display, e) || e_preventDefault(e)
            }), on(te, "compositionstart", function() {
                var start = cm.getCursor("from");
                input.composing && input.composing.range.clear(), input.composing = {
                    start: start,
                    range: cm.markText(start, cm.getCursor("to"), {
                        className: "CodeMirror-composing"
                    })
                }
            }), on(te, "compositionend", function() {
                input.composing && (input.poll(), input.composing.range.clear(), input.composing = null)
            })
        }, TextareaInput.prototype.createField = function(_display) {
            this.wrapper = hiddenTextarea(), this.textarea = this.wrapper.firstChild
        }, TextareaInput.prototype.prepareSelection = function() {
            var cm = this.cm,
                display = cm.display,
                doc = cm.doc,
                result = prepareSelection(cm);
            if (cm.options.moveInputWithCursor) {
                var headPos = _cursorCoords(cm, doc.sel.primary().head, "div"),
                    wrapOff = display.wrapper.getBoundingClientRect(),
                    lineOff = display.lineDiv.getBoundingClientRect();
                result.teTop = Math.max(0, Math.min(display.wrapper.clientHeight - 10, headPos.top + lineOff.top - wrapOff.top)), result.teLeft = Math.max(0, Math.min(display.wrapper.clientWidth - 10, headPos.left + lineOff.left - wrapOff.left))
            }
            return result
        }, TextareaInput.prototype.showSelection = function(drawn) {
            var cm = this.cm,
                display = cm.display;
            removeChildrenAndAdd(display.cursorDiv, drawn.cursors), removeChildrenAndAdd(display.selectionDiv, drawn.selection), null != drawn.teTop && (this.wrapper.style.top = drawn.teTop + "px", this.wrapper.style.left = drawn.teLeft + "px")
        }, TextareaInput.prototype.reset = function(typing) {
            if (!this.contextMenuPending && !this.composing) {
                var cm = this.cm;
                if (cm.somethingSelected()) {
                    this.prevInput = "";
                    var content = cm.getSelection();
                    this.textarea.value = content, cm.state.focused && selectInput(this.textarea), ie && ie_version >= 9 && (this.hasSelection = content)
                } else typing || (this.prevInput = this.textarea.value = "", ie && ie_version >= 9 && (this.hasSelection = null))
            }
        }, TextareaInput.prototype.getField = function() {
            return this.textarea
        }, TextareaInput.prototype.supportsTouch = function() {
            return !1
        }, TextareaInput.prototype.focus = function() {
            if ("nocursor" != this.cm.options.readOnly && (!mobile || activeElt() != this.textarea)) try {
                this.textarea.focus()
            } catch (e) {}
        }, TextareaInput.prototype.blur = function() {
            this.textarea.blur()
        }, TextareaInput.prototype.resetPosition = function() {
            this.wrapper.style.top = this.wrapper.style.left = 0
        }, TextareaInput.prototype.receivedFocus = function() {
            this.slowPoll()
        }, TextareaInput.prototype.slowPoll = function() {
            var this$1 = this;
            this.pollingFast || this.polling.set(this.cm.options.pollInterval, function() {
                this$1.poll(), this$1.cm.state.focused && this$1.slowPoll()
            })
        }, TextareaInput.prototype.fastPoll = function() {
            function p() {
                var changed = input.poll();
                changed || missed ? (input.pollingFast = !1, input.slowPoll()) : (missed = !0, input.polling.set(60, p))
            }
            var missed = !1,
                input = this;
            input.pollingFast = !0, input.polling.set(20, p)
        }, TextareaInput.prototype.poll = function() {
            var this$1 = this,
                cm = this.cm,
                input = this.textarea,
                prevInput = this.prevInput;
            if (this.contextMenuPending || !cm.state.focused || hasSelection(input) && !prevInput && !this.composing || cm.isReadOnly() || cm.options.disableInput || cm.state.keySeq) return !1;
            var text = input.value;
            if (text == prevInput && !cm.somethingSelected()) return !1;
            if (ie && ie_version >= 9 && this.hasSelection === text || mac && /[\uf700-\uf7ff]/.test(text)) return cm.display.input.reset(), !1;
            if (cm.doc.sel == cm.display.selForContextMenu) {
                var first = text.charCodeAt(0);
                if (8203 != first || prevInput || (prevInput = ""), 8666 == first) return this.reset(), this.cm.execCommand("undo")
            }
            for (var same = 0, l = Math.min(prevInput.length, text.length); same < l && prevInput.charCodeAt(same) == text.charCodeAt(same);) ++same;
            return runInOp(cm, function() {
                applyTextInput(cm, text.slice(same), prevInput.length - same, null, this$1.composing ? "*compose" : null), text.length > 1e3 || text.indexOf("\n") > -1 ? input.value = this$1.prevInput = "" : this$1.prevInput = text, this$1.composing && (this$1.composing.range.clear(), this$1.composing.range = cm.markText(this$1.composing.start, cm.getCursor("to"), {
                    className: "CodeMirror-composing"
                }))
            }), !0
        }, TextareaInput.prototype.ensurePolled = function() {
            this.pollingFast && this.poll() && (this.pollingFast = !1)
        }, TextareaInput.prototype.onKeyPress = function() {
            ie && ie_version >= 9 && (this.hasSelection = null), this.fastPoll()
        }, TextareaInput.prototype.onContextMenu = function(e) {
            function prepareSelectAllHack() {
                if (null != te.selectionStart) {
                    var selected = cm.somethingSelected(),
                        extval = "" + (selected ? te.value : "");
                    te.value = "", te.value = extval, input.prevInput = selected ? "" : "", te.selectionStart = 1, te.selectionEnd = extval.length, display.selForContextMenu = cm.doc.sel
                }
            }

            function rehide() {
                if (input.contextMenuPending = !1, input.wrapper.style.cssText = oldWrapperCSS, te.style.cssText = oldCSS, ie && ie_version < 9 && display.scrollbars.setScrollTop(display.scroller.scrollTop = scrollPos), null != te.selectionStart) {
                    (!ie || ie && ie_version < 9) && prepareSelectAllHack();
                    var i = 0,
                        poll = function poll() {
                            display.selForContextMenu == cm.doc.sel && 0 == te.selectionStart && te.selectionEnd > 0 && "" == input.prevInput ? operation(cm, selectAll)(cm) : i++ < 10 ? display.detectingSelectAll = setTimeout(poll, 500) : (display.selForContextMenu = null, display.input.reset())
                        };
                    display.detectingSelectAll = setTimeout(poll, 200)
                }
            }
            var input = this,
                cm = input.cm,
                display = cm.display,
                te = input.textarea,
                pos = posFromMouse(cm, e),
                scrollPos = display.scroller.scrollTop;
            if (pos && !presto) {
                var reset = cm.options.resetSelectionOnContextMenu;
                reset && cm.doc.sel.contains(pos) == -1 && operation(cm, setSelection)(cm.doc, simpleSelection(pos), sel_dontScroll);
                var oldCSS = te.style.cssText,
                    oldWrapperCSS = input.wrapper.style.cssText;
                input.wrapper.style.cssText = "position: absolute";
                var wrapperBox = input.wrapper.getBoundingClientRect();
                te.style.cssText = "position: absolute; width: 30px; height: 30px;\n      top: " + (e.clientY - wrapperBox.top - 5) + "px; left: " + (e.clientX - wrapperBox.left - 5) + "px;\n      z-index: 1000; background: " + (ie ? "rgba(255, 255, 255, .05)" : "transparent") + ";\n      outline: none; border-width: 0; outline: none; overflow: hidden; opacity: .05; filter: alpha(opacity=5);";
                var oldScrollY;
                if (webkit && (oldScrollY = window.scrollY), display.input.focus(), webkit && window.scrollTo(null, oldScrollY), display.input.reset(), cm.somethingSelected() || (te.value = input.prevInput = " "), input.contextMenuPending = !0, display.selForContextMenu = cm.doc.sel, clearTimeout(display.detectingSelectAll), ie && ie_version >= 9 && prepareSelectAllHack(), captureRightClick) {
                    e_stop(e);
                    var mouseup = function mouseup() {
                        off(window, "mouseup", mouseup), setTimeout(rehide, 20)
                    };
                    on(window, "mouseup", mouseup)
                } else setTimeout(rehide, 50)
            }
        }, TextareaInput.prototype.readOnlyChanged = function(val) {
            val || this.reset(), this.textarea.disabled = "nocursor" == val
        }, TextareaInput.prototype.setUneditable = function() {}, TextareaInput.prototype.needsContentAttribute = !1, defineOptions(CodeMirror$1), addEditorMethods(CodeMirror$1);
        var dontDelegate = "iter insert remove copy getEditor constructor".split(" ");
        for (var prop in Doc.prototype) Doc.prototype.hasOwnProperty(prop) && indexOf(dontDelegate, prop) < 0 && (CodeMirror$1.prototype[prop] = function(method) {
            return function() {
                return method.apply(this.doc, arguments)
            }
        }(Doc.prototype[prop]));
        return eventMixin(Doc), CodeMirror$1.inputStyles = {
            textarea: TextareaInput,
            contenteditable: ContentEditableInput
        }, CodeMirror$1.defineMode = function(name) {
            CodeMirror$1.defaults.mode || "null" == name || (CodeMirror$1.defaults.mode = name), defineMode.apply(this, arguments)
        }, CodeMirror$1.defineMIME = defineMIME, CodeMirror$1.defineMode("null", function() {
            return {
                token: function(stream) {
                    return stream.skipToEnd()
                }
            }
        }), CodeMirror$1.defineMIME("text/plain", "null"), CodeMirror$1.defineExtension = function(name, func) {
            CodeMirror$1.prototype[name] = func
        }, CodeMirror$1.defineDocExtension = function(name, func) {
            Doc.prototype[name] = func
        }, CodeMirror$1.fromTextArea = fromTextArea, addLegacyProps(CodeMirror$1), CodeMirror$1.version = "5.37.0", CodeMirror$1
    }),
    function(mod) {
        "object" == ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "object" == ("undefined" == typeof module ? "undefined" : _typeof2(module)) ? mod(require("../../lib/codemirror")): "function" == typeof define && define.amd ? define(["../../lib/codemirror"], mod) : mod(CodeMirror)
    }(function(CodeMirror) {
        "use strict";

        function keySet(array) {
            for (var keys = {}, i = 0; i < array.length; ++i) keys[array[i].toLowerCase()] = !0;
            return keys
        }

        function tokenCComment(stream, state) {
            for (var ch, maybeEnd = !1; null != (ch = stream.next());) {
                if (maybeEnd && "/" == ch) {
                    state.tokenize = null;
                    break
                }
                maybeEnd = "*" == ch
            }
            return ["comment", "comment"]
        }
        CodeMirror.defineMode("css", function(config, parserConfig) {
            function ret(style, tp) {
                return type = tp, style
            }

            function tokenBase(stream, state) {
                var ch = stream.next();
                if (tokenHooks[ch]) {
                    var result = tokenHooks[ch](stream, state);
                    if (result !== !1) return result
                }
                return "@" == ch ? (stream.eatWhile(/[\w\\\-]/), ret("def", stream.current())) : "=" == ch || ("~" == ch || "|" == ch) && stream.eat("=") ? ret(null, "compare") : '"' == ch || "'" == ch ? (state.tokenize = tokenString(ch), state.tokenize(stream, state)) : "#" == ch ? (stream.eatWhile(/[\w\\\-]/), ret("atom", "hash")) : "!" == ch ? (stream.match(/^\s*\w*/), ret("keyword", "important")) : /\d/.test(ch) || "." == ch && stream.eat(/\d/) ? (stream.eatWhile(/[\w.%]/), ret("number", "unit")) : "-" !== ch ? /[,+>*\/]/.test(ch) ? ret(null, "select-op") : "." == ch && stream.match(/^-?[_a-z][_a-z0-9-]*/i) ? ret("qualifier", "qualifier") : /[:;{}\[\]\(\)]/.test(ch) ? ret(null, ch) : ("u" == ch || "U" == ch) && stream.match(/rl(-prefix)?\(/i) || ("d" == ch || "D" == ch) && stream.match("omain(", !0, !0) || ("r" == ch || "R" == ch) && stream.match("egexp(", !0, !0) ? (stream.backUp(1), state.tokenize = tokenParenthesized, ret("property", "word")) : /[\w\\\-]/.test(ch) ? (stream.eatWhile(/[\w\\\-]/), ret("property", "word")) : ret(null, null) : /[\d.]/.test(stream.peek()) ? (stream.eatWhile(/[\w.%]/), ret("number", "unit")) : stream.match(/^-[\w\\\-]+/) ? (stream.eatWhile(/[\w\\\-]/), stream.match(/^\s*:/, !1) ? ret("variable-2", "variable-definition") : ret("variable-2", "variable")) : stream.match(/^\w+-/) ? ret("meta", "meta") : void 0
            }

            function tokenString(quote) {
                return function(stream, state) {
                    for (var ch, escaped = !1; null != (ch = stream.next());) {
                        if (ch == quote && !escaped) {
                            ")" == quote && stream.backUp(1);
                            break
                        }
                        escaped = !escaped && "\\" == ch
                    }
                    return (ch == quote || !escaped && ")" != quote) && (state.tokenize = null), ret("string", "string")
                }
            }

            function tokenParenthesized(stream, state) {
                return stream.next(), stream.match(/\s*[\"\')]/, !1) ? state.tokenize = null : state.tokenize = tokenString(")"), ret(null, "(")
            }

            function Context(type, indent, prev) {
                this.type = type, this.indent = indent, this.prev = prev
            }

            function pushContext(state, stream, type, indent) {
                return state.context = new Context(type, stream.indentation() + (indent === !1 ? 0 : indentUnit), state.context), type
            }

            function popContext(state) {
                return state.context.prev && (state.context = state.context.prev), state.context.type
            }

            function pass(type, stream, state) {
                return states[state.context.type](type, stream, state)
            }

            function popAndPass(type, stream, state, n) {
                for (var i = n || 1; i > 0; i--) state.context = state.context.prev;
                return pass(type, stream, state)
            }

            function wordAsValue(stream) {
                var word = stream.current().toLowerCase();
                override = valueKeywords.hasOwnProperty(word) ? "atom" : colorKeywords.hasOwnProperty(word) ? "keyword" : "variable"
            }
            var inline = parserConfig.inline;
            parserConfig.propertyKeywords || (parserConfig = CodeMirror.resolveMode("text/css"));
            var type, override, indentUnit = config.indentUnit,
                tokenHooks = parserConfig.tokenHooks,
                documentTypes = parserConfig.documentTypes || {},
                mediaTypes = parserConfig.mediaTypes || {},
                mediaFeatures = parserConfig.mediaFeatures || {},
                mediaValueKeywords = parserConfig.mediaValueKeywords || {},
                propertyKeywords = parserConfig.propertyKeywords || {},
                nonStandardPropertyKeywords = parserConfig.nonStandardPropertyKeywords || {},
                fontProperties = parserConfig.fontProperties || {},
                counterDescriptors = parserConfig.counterDescriptors || {},
                colorKeywords = parserConfig.colorKeywords || {},
                valueKeywords = parserConfig.valueKeywords || {},
                allowNested = parserConfig.allowNested,
                lineComment = parserConfig.lineComment,
                supportsAtComponent = parserConfig.supportsAtComponent === !0,
                states = {};
            return states.top = function(type, stream, state) {
                if ("{" == type) return pushContext(state, stream, "block");
                if ("}" == type && state.context.prev) return popContext(state);
                if (supportsAtComponent && /@component/i.test(type)) return pushContext(state, stream, "atComponentBlock");
                if (/^@(-moz-)?document$/i.test(type)) return pushContext(state, stream, "documentTypes");
                if (/^@(media|supports|(-moz-)?document|import)$/i.test(type)) return pushContext(state, stream, "atBlock");
                if (/^@(font-face|counter-style)/i.test(type)) return state.stateArg = type, "restricted_atBlock_before";
                if (/^@(-(moz|ms|o|webkit)-)?keyframes$/i.test(type)) return "keyframes";
                if (type && "@" == type.charAt(0)) return pushContext(state, stream, "at");
                if ("hash" == type) override = "builtin";
                else if ("word" == type) override = "tag";
                else {
                    if ("variable-definition" == type) return "maybeprop";
                    if ("interpolation" == type) return pushContext(state, stream, "interpolation");
                    if (":" == type) return "pseudo";
                    if (allowNested && "(" == type) return pushContext(state, stream, "parens")
                }
                return state.context.type
            }, states.block = function(type, stream, state) {
                if ("word" == type) {
                    var word = stream.current().toLowerCase();
                    return propertyKeywords.hasOwnProperty(word) ? (override = "property", "maybeprop") : nonStandardPropertyKeywords.hasOwnProperty(word) ? (override = "string-2", "maybeprop") : allowNested ? (override = stream.match(/^\s*:(?:\s|$)/, !1) ? "property" : "tag", "block") : (override += " error", "maybeprop")
                }
                return "meta" == type ? "block" : allowNested || "hash" != type && "qualifier" != type ? states.top(type, stream, state) : (override = "error", "block")
            }, states.maybeprop = function(type, stream, state) {
                return ":" == type ? pushContext(state, stream, "prop") : pass(type, stream, state)
            }, states.prop = function(type, stream, state) {
                if (";" == type) return popContext(state);
                if ("{" == type && allowNested) return pushContext(state, stream, "propBlock");
                if ("}" == type || "{" == type) return popAndPass(type, stream, state);
                if ("(" == type) return pushContext(state, stream, "parens");
                if ("hash" != type || /^#([0-9a-fA-f]{3,4}|[0-9a-fA-f]{6}|[0-9a-fA-f]{8})$/.test(stream.current())) {
                    if ("word" == type) wordAsValue(stream);
                    else if ("interpolation" == type) return pushContext(state, stream, "interpolation")
                } else override += " error";
                return "prop"
            }, states.propBlock = function(type, _stream, state) {
                return "}" == type ? popContext(state) : "word" == type ? (override = "property", "maybeprop") : state.context.type
            }, states.parens = function(type, stream, state) {
                return "{" == type || "}" == type ? popAndPass(type, stream, state) : ")" == type ? popContext(state) : "(" == type ? pushContext(state, stream, "parens") : "interpolation" == type ? pushContext(state, stream, "interpolation") : ("word" == type && wordAsValue(stream), "parens")
            }, states.pseudo = function(type, stream, state) {
                return "meta" == type ? "pseudo" : "word" == type ? (override = "variable-3", state.context.type) : pass(type, stream, state)
            }, states.documentTypes = function(type, stream, state) {
                return "word" == type && documentTypes.hasOwnProperty(stream.current()) ? (override = "tag", state.context.type) : states.atBlock(type, stream, state)
            }, states.atBlock = function(type, stream, state) {
                if ("(" == type) return pushContext(state, stream, "atBlock_parens");
                if ("}" == type || ";" == type) return popAndPass(type, stream, state);
                if ("{" == type) return popContext(state) && pushContext(state, stream, allowNested ? "block" : "top");
                if ("interpolation" == type) return pushContext(state, stream, "interpolation");
                if ("word" == type) {
                    var word = stream.current().toLowerCase();
                    override = "only" == word || "not" == word || "and" == word || "or" == word ? "keyword" : mediaTypes.hasOwnProperty(word) ? "attribute" : mediaFeatures.hasOwnProperty(word) ? "property" : mediaValueKeywords.hasOwnProperty(word) ? "keyword" : propertyKeywords.hasOwnProperty(word) ? "property" : nonStandardPropertyKeywords.hasOwnProperty(word) ? "string-2" : valueKeywords.hasOwnProperty(word) ? "atom" : colorKeywords.hasOwnProperty(word) ? "keyword" : "error"
                }
                return state.context.type
            }, states.atComponentBlock = function(type, stream, state) {
                return "}" == type ? popAndPass(type, stream, state) : "{" == type ? popContext(state) && pushContext(state, stream, allowNested ? "block" : "top", !1) : ("word" == type && (override = "error"), state.context.type)
            }, states.atBlock_parens = function(type, stream, state) {
                return ")" == type ? popContext(state) : "{" == type || "}" == type ? popAndPass(type, stream, state, 2) : states.atBlock(type, stream, state)
            }, states.restricted_atBlock_before = function(type, stream, state) {
                return "{" == type ? pushContext(state, stream, "restricted_atBlock") : "word" == type && "@counter-style" == state.stateArg ? (override = "variable", "restricted_atBlock_before") : pass(type, stream, state)
            }, states.restricted_atBlock = function(type, stream, state) {
                return "}" == type ? (state.stateArg = null, popContext(state)) : "word" == type ? (override = "@font-face" == state.stateArg && !fontProperties.hasOwnProperty(stream.current().toLowerCase()) || "@counter-style" == state.stateArg && !counterDescriptors.hasOwnProperty(stream.current().toLowerCase()) ? "error" : "property",
                    "maybeprop") : "restricted_atBlock"
            }, states.keyframes = function(type, stream, state) {
                return "word" == type ? (override = "variable", "keyframes") : "{" == type ? pushContext(state, stream, "top") : pass(type, stream, state)
            }, states.at = function(type, stream, state) {
                return ";" == type ? popContext(state) : "{" == type || "}" == type ? popAndPass(type, stream, state) : ("word" == type ? override = "tag" : "hash" == type && (override = "builtin"), "at")
            }, states.interpolation = function(type, stream, state) {
                return "}" == type ? popContext(state) : "{" == type || ";" == type ? popAndPass(type, stream, state) : ("word" == type ? override = "variable" : "variable" != type && "(" != type && ")" != type && (override = "error"), "interpolation")
            }, {
                startState: function(base) {
                    return {
                        tokenize: null,
                        state: inline ? "block" : "top",
                        stateArg: null,
                        context: new Context(inline ? "block" : "top", base || 0, null)
                    }
                },
                token: function(stream, state) {
                    if (!state.tokenize && stream.eatSpace()) return null;
                    var style = (state.tokenize || tokenBase)(stream, state);
                    return style && "object" == _typeof2(style) && (type = style[1], style = style[0]), override = style, "comment" != type && (state.state = states[state.state](type, stream, state)), override
                },
                indent: function indent(state, textAfter) {
                    var cx = state.context,
                        ch = textAfter && textAfter.charAt(0),
                        indent = cx.indent;
                    return "prop" != cx.type || "}" != ch && ")" != ch || (cx = cx.prev), cx.prev && ("}" != ch || "block" != cx.type && "top" != cx.type && "interpolation" != cx.type && "restricted_atBlock" != cx.type ? (")" != ch || "parens" != cx.type && "atBlock_parens" != cx.type) && ("{" != ch || "at" != cx.type && "atBlock" != cx.type) || (indent = Math.max(0, cx.indent - indentUnit)) : (cx = cx.prev, indent = cx.indent)), indent
                },
                electricChars: "}",
                blockCommentStart: "/*",
                blockCommentEnd: "*/",
                blockCommentContinue: " * ",
                lineComment: lineComment,
                fold: "brace"
            }
        });
        var documentTypes_ = ["domain", "regexp", "url", "url-prefix"],
            documentTypes = keySet(documentTypes_),
            mediaTypes_ = ["all", "aural", "braille", "handheld", "print", "projection", "screen", "tty", "tv", "embossed"],
            mediaTypes = keySet(mediaTypes_),
            mediaFeatures_ = ["width", "min-width", "max-width", "height", "min-height", "max-height", "device-width", "min-device-width", "max-device-width", "device-height", "min-device-height", "max-device-height", "aspect-ratio", "min-aspect-ratio", "max-aspect-ratio", "device-aspect-ratio", "min-device-aspect-ratio", "max-device-aspect-ratio", "color", "min-color", "max-color", "color-index", "min-color-index", "max-color-index", "monochrome", "min-monochrome", "max-monochrome", "resolution", "min-resolution", "max-resolution", "scan", "grid", "orientation", "device-pixel-ratio", "min-device-pixel-ratio", "max-device-pixel-ratio", "pointer", "any-pointer", "hover", "any-hover"],
            mediaFeatures = keySet(mediaFeatures_),
            mediaValueKeywords_ = ["landscape", "portrait", "none", "coarse", "fine", "on-demand", "hover", "interlace", "progressive"],
            mediaValueKeywords = keySet(mediaValueKeywords_),
            propertyKeywords_ = ["align-content", "align-items", "align-self", "alignment-adjust", "alignment-baseline", "anchor-point", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "appearance", "azimuth", "backface-visibility", "background", "background-attachment", "background-blend-mode", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "baseline-shift", "binding", "bleed", "bookmark-label", "bookmark-level", "bookmark-state", "bookmark-target", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "bottom", "box-decoration-break", "box-shadow", "box-sizing", "break-after", "break-before", "break-inside", "caption-side", "caret-color", "clear", "clip", "color", "color-profile", "column-count", "column-fill", "column-gap", "column-rule", "column-rule-color", "column-rule-style", "column-rule-width", "column-span", "column-width", "columns", "content", "counter-increment", "counter-reset", "crop", "cue", "cue-after", "cue-before", "cursor", "direction", "display", "dominant-baseline", "drop-initial-after-adjust", "drop-initial-after-align", "drop-initial-before-adjust", "drop-initial-before-align", "drop-initial-size", "drop-initial-value", "elevation", "empty-cells", "fit", "fit-position", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "float", "float-offset", "flow-from", "flow-into", "font", "font-feature-settings", "font-family", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "grid", "grid-area", "grid-auto-columns", "grid-auto-flow", "grid-auto-rows", "grid-column", "grid-column-end", "grid-column-gap", "grid-column-start", "grid-gap", "grid-row", "grid-row-end", "grid-row-gap", "grid-row-start", "grid-template", "grid-template-areas", "grid-template-columns", "grid-template-rows", "hanging-punctuation", "height", "hyphens", "icon", "image-orientation", "image-rendering", "image-resolution", "inline-box-align", "justify-content", "justify-items", "justify-self", "left", "letter-spacing", "line-break", "line-height", "line-stacking", "line-stacking-ruby", "line-stacking-shift", "line-stacking-strategy", "list-style", "list-style-image", "list-style-position", "list-style-type", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marks", "marquee-direction", "marquee-loop", "marquee-play-count", "marquee-speed", "marquee-style", "max-height", "max-width", "min-height", "min-width", "move-to", "nav-down", "nav-index", "nav-left", "nav-right", "nav-up", "object-fit", "object-position", "opacity", "order", "orphans", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "overflow", "overflow-style", "overflow-wrap", "overflow-x", "overflow-y", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "page", "page-break-after", "page-break-before", "page-break-inside", "page-policy", "pause", "pause-after", "pause-before", "perspective", "perspective-origin", "pitch", "pitch-range", "place-content", "place-items", "place-self", "play-during", "position", "presentation-level", "punctuation-trim", "quotes", "region-break-after", "region-break-before", "region-break-inside", "region-fragment", "rendering-intent", "resize", "rest", "rest-after", "rest-before", "richness", "right", "rotation", "rotation-point", "ruby-align", "ruby-overhang", "ruby-position", "ruby-span", "shape-image-threshold", "shape-inside", "shape-margin", "shape-outside", "size", "speak", "speak-as", "speak-header", "speak-numeral", "speak-punctuation", "speech-rate", "stress", "string-set", "tab-size", "table-layout", "target", "target-name", "target-new", "target-position", "text-align", "text-align-last", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-skip", "text-decoration-style", "text-emphasis", "text-emphasis-color", "text-emphasis-position", "text-emphasis-style", "text-height", "text-indent", "text-justify", "text-outline", "text-overflow", "text-shadow", "text-size-adjust", "text-space-collapse", "text-transform", "text-underline-position", "text-wrap", "top", "transform", "transform-origin", "transform-style", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "unicode-bidi", "user-select", "vertical-align", "visibility", "voice-balance", "voice-duration", "voice-family", "voice-pitch", "voice-range", "voice-rate", "voice-stress", "voice-volume", "volume", "white-space", "widows", "width", "will-change", "word-break", "word-spacing", "word-wrap", "z-index", "clip-path", "clip-rule", "mask", "enable-background", "filter", "flood-color", "flood-opacity", "lighting-color", "stop-color", "stop-opacity", "pointer-events", "color-interpolation", "color-interpolation-filters", "color-rendering", "fill", "fill-opacity", "fill-rule", "image-rendering", "marker", "marker-end", "marker-mid", "marker-start", "shape-rendering", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "text-rendering", "baseline-shift", "dominant-baseline", "glyph-orientation-horizontal", "glyph-orientation-vertical", "text-anchor", "writing-mode"],
            propertyKeywords = keySet(propertyKeywords_),
            nonStandardPropertyKeywords_ = ["scrollbar-arrow-color", "scrollbar-base-color", "scrollbar-dark-shadow-color", "scrollbar-face-color", "scrollbar-highlight-color", "scrollbar-shadow-color", "scrollbar-3d-light-color", "scrollbar-track-color", "shape-inside", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "zoom"],
            nonStandardPropertyKeywords = keySet(nonStandardPropertyKeywords_),
            fontProperties_ = ["font-family", "src", "unicode-range", "font-variant", "font-feature-settings", "font-stretch", "font-weight", "font-style"],
            fontProperties = keySet(fontProperties_),
            counterDescriptors_ = ["additive-symbols", "fallback", "negative", "pad", "prefix", "range", "speak-as", "suffix", "symbols", "system"],
            counterDescriptors = keySet(counterDescriptors_),
            colorKeywords_ = ["aliceblue", "antiquewhite", "aqua", "aquamarine", "azure", "beige", "bisque", "black", "blanchedalmond", "blue", "blueviolet", "brown", "burlywood", "cadetblue", "chartreuse", "chocolate", "coral", "cornflowerblue", "cornsilk", "crimson", "cyan", "darkblue", "darkcyan", "darkgoldenrod", "darkgray", "darkgreen", "darkkhaki", "darkmagenta", "darkolivegreen", "darkorange", "darkorchid", "darkred", "darksalmon", "darkseagreen", "darkslateblue", "darkslategray", "darkturquoise", "darkviolet", "deeppink", "deepskyblue", "dimgray", "dodgerblue", "firebrick", "floralwhite", "forestgreen", "fuchsia", "gainsboro", "ghostwhite", "gold", "goldenrod", "gray", "grey", "green", "greenyellow", "honeydew", "hotpink", "indianred", "indigo", "ivory", "khaki", "lavender", "lavenderblush", "lawngreen", "lemonchiffon", "lightblue", "lightcoral", "lightcyan", "lightgoldenrodyellow", "lightgray", "lightgreen", "lightpink", "lightsalmon", "lightseagreen", "lightskyblue", "lightslategray", "lightsteelblue", "lightyellow", "lime", "limegreen", "linen", "magenta", "maroon", "mediumaquamarine", "mediumblue", "mediumorchid", "mediumpurple", "mediumseagreen", "mediumslateblue", "mediumspringgreen", "mediumturquoise", "mediumvioletred", "midnightblue", "mintcream", "mistyrose", "moccasin", "navajowhite", "navy", "oldlace", "olive", "olivedrab", "orange", "orangered", "orchid", "palegoldenrod", "palegreen", "paleturquoise", "palevioletred", "papayawhip", "peachpuff", "peru", "pink", "plum", "powderblue", "purple", "rebeccapurple", "red", "rosybrown", "royalblue", "saddlebrown", "salmon", "sandybrown", "seagreen", "seashell", "sienna", "silver", "skyblue", "slateblue", "slategray", "snow", "springgreen", "steelblue", "tan", "teal", "thistle", "tomato", "turquoise", "violet", "wheat", "white", "whitesmoke", "yellow", "yellowgreen"],
            colorKeywords = keySet(colorKeywords_),
            valueKeywords_ = ["above", "absolute", "activeborder", "additive", "activecaption", "afar", "after-white-space", "ahead", "alias", "all", "all-scroll", "alphabetic", "alternate", "always", "amharic", "amharic-abegede", "antialiased", "appworkspace", "arabic-indic", "armenian", "asterisks", "attr", "auto", "auto-flow", "avoid", "avoid-column", "avoid-page", "avoid-region", "background", "backwards", "baseline", "below", "bidi-override", "binary", "bengali", "blink", "block", "block-axis", "bold", "bolder", "border", "border-box", "both", "bottom", "break", "break-all", "break-word", "bullets", "button", "button-bevel", "buttonface", "buttonhighlight", "buttonshadow", "buttontext", "calc", "cambodian", "capitalize", "caps-lock-indicator", "caption", "captiontext", "caret", "cell", "center", "checkbox", "circle", "cjk-decimal", "cjk-earthly-branch", "cjk-heavenly-stem", "cjk-ideographic", "clear", "clip", "close-quote", "col-resize", "collapse", "color", "color-burn", "color-dodge", "column", "column-reverse", "compact", "condensed", "contain", "content", "contents", "content-box", "context-menu", "continuous", "copy", "counter", "counters", "cover", "crop", "cross", "crosshair", "currentcolor", "cursive", "cyclic", "darken", "dashed", "decimal", "decimal-leading-zero", "default", "default-button", "dense", "destination-atop", "destination-in", "destination-out", "destination-over", "devanagari", "difference", "disc", "discard", "disclosure-closed", "disclosure-open", "document", "dot-dash", "dot-dot-dash", "dotted", "double", "down", "e-resize", "ease", "ease-in", "ease-in-out", "ease-out", "element", "ellipse", "ellipsis", "embed", "end", "ethiopic", "ethiopic-abegede", "ethiopic-abegede-am-et", "ethiopic-abegede-gez", "ethiopic-abegede-ti-er", "ethiopic-abegede-ti-et", "ethiopic-halehame-aa-er", "ethiopic-halehame-aa-et", "ethiopic-halehame-am-et", "ethiopic-halehame-gez", "ethiopic-halehame-om-et", "ethiopic-halehame-sid-et", "ethiopic-halehame-so-et", "ethiopic-halehame-ti-er", "ethiopic-halehame-ti-et", "ethiopic-halehame-tig", "ethiopic-numeric", "ew-resize", "exclusion", "expanded", "extends", "extra-condensed", "extra-expanded", "fantasy", "fast", "fill", "fixed", "flat", "flex", "flex-end", "flex-start", "footnotes", "forwards", "from", "geometricPrecision", "georgian", "graytext", "grid", "groove", "gujarati", "gurmukhi", "hand", "hangul", "hangul-consonant", "hard-light", "hebrew", "help", "hidden", "hide", "higher", "highlight", "highlighttext", "hiragana", "hiragana-iroha", "horizontal", "hsl", "hsla", "hue", "icon", "ignore", "inactiveborder", "inactivecaption", "inactivecaptiontext", "infinite", "infobackground", "infotext", "inherit", "initial", "inline", "inline-axis", "inline-block", "inline-flex", "inline-grid", "inline-table", "inset", "inside", "intrinsic", "invert", "italic", "japanese-formal", "japanese-informal", "justify", "kannada", "katakana", "katakana-iroha", "keep-all", "khmer", "korean-hangul-formal", "korean-hanja-formal", "korean-hanja-informal", "landscape", "lao", "large", "larger", "left", "level", "lighter", "lighten", "line-through", "linear", "linear-gradient", "lines", "list-item", "listbox", "listitem", "local", "logical", "loud", "lower", "lower-alpha", "lower-armenian", "lower-greek", "lower-hexadecimal", "lower-latin", "lower-norwegian", "lower-roman", "lowercase", "ltr", "luminosity", "malayalam", "match", "matrix", "matrix3d", "media-controls-background", "media-current-time-display", "media-fullscreen-button", "media-mute-button", "media-play-button", "media-return-to-realtime-button", "media-rewind-button", "media-seek-back-button", "media-seek-forward-button", "media-slider", "media-sliderthumb", "media-time-remaining-display", "media-volume-slider", "media-volume-slider-container", "media-volume-sliderthumb", "medium", "menu", "menulist", "menulist-button", "menulist-text", "menulist-textfield", "menutext", "message-box", "middle", "min-intrinsic", "mix", "mongolian", "monospace", "move", "multiple", "multiply", "myanmar", "n-resize", "narrower", "ne-resize", "nesw-resize", "no-close-quote", "no-drop", "no-open-quote", "no-repeat", "none", "normal", "not-allowed", "nowrap", "ns-resize", "numbers", "numeric", "nw-resize", "nwse-resize", "oblique", "octal", "opacity", "open-quote", "optimizeLegibility", "optimizeSpeed", "oriya", "oromo", "outset", "outside", "outside-shape", "overlay", "overline", "padding", "padding-box", "painted", "page", "paused", "persian", "perspective", "plus-darker", "plus-lighter", "pointer", "polygon", "portrait", "pre", "pre-line", "pre-wrap", "preserve-3d", "progress", "push-button", "radial-gradient", "radio", "read-only", "read-write", "read-write-plaintext-only", "rectangle", "region", "relative", "repeat", "repeating-linear-gradient", "repeating-radial-gradient", "repeat-x", "repeat-y", "reset", "reverse", "rgb", "rgba", "ridge", "right", "rotate", "rotate3d", "rotateX", "rotateY", "rotateZ", "round", "row", "row-resize", "row-reverse", "rtl", "run-in", "running", "s-resize", "sans-serif", "saturation", "scale", "scale3d", "scaleX", "scaleY", "scaleZ", "screen", "scroll", "scrollbar", "scroll-position", "se-resize", "searchfield", "searchfield-cancel-button", "searchfield-decoration", "searchfield-results-button", "searchfield-results-decoration", "self-start", "self-end", "semi-condensed", "semi-expanded", "separate", "serif", "show", "sidama", "simp-chinese-formal", "simp-chinese-informal", "single", "skew", "skewX", "skewY", "skip-white-space", "slide", "slider-horizontal", "slider-vertical", "sliderthumb-horizontal", "sliderthumb-vertical", "slow", "small", "small-caps", "small-caption", "smaller", "soft-light", "solid", "somali", "source-atop", "source-in", "source-out", "source-over", "space", "space-around", "space-between", "space-evenly", "spell-out", "square", "square-button", "start", "static", "status-bar", "stretch", "stroke", "sub", "subpixel-antialiased", "super", "sw-resize", "symbolic", "symbols", "system-ui", "table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row", "table-row-group", "tamil", "telugu", "text", "text-bottom", "text-top", "textarea", "textfield", "thai", "thick", "thin", "threeddarkshadow", "threedface", "threedhighlight", "threedlightshadow", "threedshadow", "tibetan", "tigre", "tigrinya-er", "tigrinya-er-abegede", "tigrinya-et", "tigrinya-et-abegede", "to", "top", "trad-chinese-formal", "trad-chinese-informal", "transform", "translate", "translate3d", "translateX", "translateY", "translateZ", "transparent", "ultra-condensed", "ultra-expanded", "underline", "unset", "up", "upper-alpha", "upper-armenian", "upper-greek", "upper-hexadecimal", "upper-latin", "upper-norwegian", "upper-roman", "uppercase", "urdu", "url", "var", "vertical", "vertical-text", "visible", "visibleFill", "visiblePainted", "visibleStroke", "visual", "w-resize", "wait", "wave", "wider", "window", "windowframe", "windowtext", "words", "wrap", "wrap-reverse", "x-large", "x-small", "xor", "xx-large", "xx-small"],
            valueKeywords = keySet(valueKeywords_),
            allWords = documentTypes_.concat(mediaTypes_).concat(mediaFeatures_).concat(mediaValueKeywords_).concat(propertyKeywords_).concat(nonStandardPropertyKeywords_).concat(colorKeywords_).concat(valueKeywords_);
        CodeMirror.registerHelper("hintWords", "css", allWords), CodeMirror.defineMIME("text/css", {
            documentTypes: documentTypes,
            mediaTypes: mediaTypes,
            mediaFeatures: mediaFeatures,
            mediaValueKeywords: mediaValueKeywords,
            propertyKeywords: propertyKeywords,
            nonStandardPropertyKeywords: nonStandardPropertyKeywords,
            fontProperties: fontProperties,
            counterDescriptors: counterDescriptors,
            colorKeywords: colorKeywords,
            valueKeywords: valueKeywords,
            tokenHooks: {
                "/": function(stream, state) {
                    return !!stream.eat("*") && (state.tokenize = tokenCComment, tokenCComment(stream, state))
                }
            },
            name: "css"
        }), CodeMirror.defineMIME("text/x-scss", {
            mediaTypes: mediaTypes,
            mediaFeatures: mediaFeatures,
            mediaValueKeywords: mediaValueKeywords,
            propertyKeywords: propertyKeywords,
            nonStandardPropertyKeywords: nonStandardPropertyKeywords,
            colorKeywords: colorKeywords,
            valueKeywords: valueKeywords,
            fontProperties: fontProperties,
            allowNested: !0,
            lineComment: "//",
            tokenHooks: {
                "/": function(stream, state) {
                    return stream.eat("/") ? (stream.skipToEnd(), ["comment", "comment"]) : stream.eat("*") ? (state.tokenize = tokenCComment, tokenCComment(stream, state)) : ["operator", "operator"]
                },
                ":": function(stream) {
                    return !!stream.match(/\s*\{/, !1) && [null, null]
                },
                $: function(stream) {
                    return stream.match(/^[\w-]+/), stream.match(/^\s*:/, !1) ? ["variable-2", "variable-definition"] : ["variable-2", "variable"]
                },
                "#": function(stream) {
                    return !!stream.eat("{") && [null, "interpolation"]
                }
            },
            name: "css",
            helperType: "scss"
        }), CodeMirror.defineMIME("text/x-less", {
            mediaTypes: mediaTypes,
            mediaFeatures: mediaFeatures,
            mediaValueKeywords: mediaValueKeywords,
            propertyKeywords: propertyKeywords,
            nonStandardPropertyKeywords: nonStandardPropertyKeywords,
            colorKeywords: colorKeywords,
            valueKeywords: valueKeywords,
            fontProperties: fontProperties,
            allowNested: !0,
            lineComment: "//",
            tokenHooks: {
                "/": function(stream, state) {
                    return stream.eat("/") ? (stream.skipToEnd(), ["comment", "comment"]) : stream.eat("*") ? (state.tokenize = tokenCComment, tokenCComment(stream, state)) : ["operator", "operator"]
                },
                "@": function(stream) {
                    return stream.eat("{") ? [null, "interpolation"] : !stream.match(/^(charset|document|font-face|import|(-(moz|ms|o|webkit)-)?keyframes|media|namespace|page|supports)\b/i, !1) && (stream.eatWhile(/[\w\\\-]/), stream.match(/^\s*:/, !1) ? ["variable-2", "variable-definition"] : ["variable-2", "variable"])
                },
                "&": function() {
                    return ["atom", "atom"]
                }
            },
            name: "css",
            helperType: "less"
        }), CodeMirror.defineMIME("text/x-gss", {
            documentTypes: documentTypes,
            mediaTypes: mediaTypes,
            mediaFeatures: mediaFeatures,
            propertyKeywords: propertyKeywords,
            nonStandardPropertyKeywords: nonStandardPropertyKeywords,
            fontProperties: fontProperties,
            counterDescriptors: counterDescriptors,
            colorKeywords: colorKeywords,
            valueKeywords: valueKeywords,
            supportsAtComponent: !0,
            tokenHooks: {
                "/": function(stream, state) {
                    return !!stream.eat("*") && (state.tokenize = tokenCComment, tokenCComment(stream, state))
                }
            },
            name: "css",
            helperType: "gss"
        })
    }),
    function(mod) {
        "object" == ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "object" == ("undefined" == typeof module ? "undefined" : _typeof2(module)) ? mod(require("../../lib/codemirror")): "function" == typeof define && define.amd ? define(["../../lib/codemirror"], mod) : mod(CodeMirror)
    }(function(CodeMirror) {
        "use strict";
        var htmlConfig = {
                autoSelfClosers: {
                    area: !0,
                    base: !0,
                    br: !0,
                    col: !0,
                    command: !0,
                    embed: !0,
                    frame: !0,
                    hr: !0,
                    img: !0,
                    input: !0,
                    keygen: !0,
                    link: !0,
                    meta: !0,
                    param: !0,
                    source: !0,
                    track: !0,
                    wbr: !0,
                    menuitem: !0
                },
                implicitlyClosed: {
                    dd: !0,
                    li: !0,
                    optgroup: !0,
                    option: !0,
                    p: !0,
                    rp: !0,
                    rt: !0,
                    tbody: !0,
                    td: !0,
                    tfoot: !0,
                    th: !0,
                    tr: !0
                },
                contextGrabbers: {
                    dd: {
                        dd: !0,
                        dt: !0
                    },
                    dt: {
                        dd: !0,
                        dt: !0
                    },
                    li: {
                        li: !0
                    },
                    option: {
                        option: !0,
                        optgroup: !0
                    },
                    optgroup: {
                        optgroup: !0
                    },
                    p: {
                        address: !0,
                        article: !0,
                        aside: !0,
                        blockquote: !0,
                        dir: !0,
                        div: !0,
                        dl: !0,
                        fieldset: !0,
                        footer: !0,
                        form: !0,
                        h1: !0,
                        h2: !0,
                        h3: !0,
                        h4: !0,
                        h5: !0,
                        h6: !0,
                        header: !0,
                        hgroup: !0,
                        hr: !0,
                        menu: !0,
                        nav: !0,
                        ol: !0,
                        p: !0,
                        pre: !0,
                        section: !0,
                        table: !0,
                        ul: !0
                    },
                    rp: {
                        rp: !0,
                        rt: !0
                    },
                    rt: {
                        rp: !0,
                        rt: !0
                    },
                    tbody: {
                        tbody: !0,
                        tfoot: !0
                    },
                    td: {
                        td: !0,
                        th: !0
                    },
                    tfoot: {
                        tbody: !0
                    },
                    th: {
                        td: !0,
                        th: !0
                    },
                    thead: {
                        tbody: !0,
                        tfoot: !0
                    },
                    tr: {
                        tr: !0
                    }
                },
                doNotIndent: {
                    pre: !0
                },
                allowUnquoted: !0,
                allowMissing: !0,
                caseFold: !0
            },
            xmlConfig = {
                autoSelfClosers: {},
                implicitlyClosed: {},
                contextGrabbers: {},
                doNotIndent: {},
                allowUnquoted: !1,
                allowMissing: !1,
                allowMissingTagName: !1,
                caseFold: !1
            };
        CodeMirror.defineMode("xml", function(editorConf, config_) {
            function inText(stream, state) {
                function chain(parser) {
                    return state.tokenize = parser, parser(stream, state)
                }
                var ch = stream.next();
                if ("<" == ch) return stream.eat("!") ? stream.eat("[") ? stream.match("CDATA[") ? chain(inBlock("atom", "]]>")) : null : stream.match("--") ? chain(inBlock("comment", "-->")) : stream.match("DOCTYPE", !0, !0) ? (stream.eatWhile(/[\w\._\-]/), chain(doctype(1))) : null : stream.eat("?") ? (stream.eatWhile(/[\w\._\-]/), state.tokenize = inBlock("meta", "?>"), "meta") : (type = stream.eat("/") ? "closeTag" : "openTag", state.tokenize = inTag, "tag bracket");
                if ("&" == ch) {
                    var ok;
                    return ok = stream.eat("#") ? stream.eat("x") ? stream.eatWhile(/[a-fA-F\d]/) && stream.eat(";") : stream.eatWhile(/[\d]/) && stream.eat(";") : stream.eatWhile(/[\w\.\-:]/) && stream.eat(";"), ok ? "atom" : "error"
                }
                return stream.eatWhile(/[^&<]/), null
            }

            function inTag(stream, state) {
                var ch = stream.next();
                if (">" == ch || "/" == ch && stream.eat(">")) return state.tokenize = inText, type = ">" == ch ? "endTag" : "selfcloseTag", "tag bracket";
                if ("=" == ch) return type = "equals", null;
                if ("<" == ch) {
                    state.tokenize = inText, state.state = baseState, state.tagName = state.tagStart = null;
                    var next = state.tokenize(stream, state);
                    return next ? next + " tag error" : "tag error"
                }
                return /[\'\"]/.test(ch) ? (state.tokenize = inAttribute(ch), state.stringStartCol = stream.column(), state.tokenize(stream, state)) : (stream.match(/^[^\s\u00a0=<>\"\']*[^\s\u00a0=<>\"\'\/]/), "word")
            }

            function inAttribute(quote) {
                var closure = function(stream, state) {
                    for (; !stream.eol();)
                        if (stream.next() == quote) {
                            state.tokenize = inTag;
                            break
                        } return "string"
                };
                return closure.isInAttribute = !0, closure
            }

            function inBlock(style, terminator) {
                return function(stream, state) {
                    for (; !stream.eol();) {
                        if (stream.match(terminator)) {
                            state.tokenize = inText;
                            break
                        }
                        stream.next()
                    }
                    return style
                }
            }

            function doctype(depth) {
                return function(stream, state) {
                    for (var ch; null != (ch = stream.next());) {
                        if ("<" == ch) return state.tokenize = doctype(depth + 1), state.tokenize(stream, state);
                        if (">" == ch) {
                            if (1 == depth) {
                                state.tokenize = inText;
                                break
                            }
                            return state.tokenize = doctype(depth - 1), state.tokenize(stream, state)
                        }
                    }
                    return "meta"
                }
            }

            function Context(state, tagName, startOfLine) {
                this.prev = state.context, this.tagName = tagName, this.indent = state.indented, this.startOfLine = startOfLine, (config.doNotIndent.hasOwnProperty(tagName) || state.context && state.context.noIndent) && (this.noIndent = !0)
            }

            function popContext(state) {
                state.context && (state.context = state.context.prev)
            }

            function maybePopContext(state, nextTagName) {
                for (var parentTagName;;) {
                    if (!state.context) return;
                    if (parentTagName = state.context.tagName, !config.contextGrabbers.hasOwnProperty(parentTagName) || !config.contextGrabbers[parentTagName].hasOwnProperty(nextTagName)) return;
                    popContext(state)
                }
            }

            function baseState(type, stream, state) {
                return "openTag" == type ? (state.tagStart = stream.column(), tagNameState) : "closeTag" == type ? closeTagNameState : baseState
            }

            function tagNameState(type, stream, state) {
                return "word" == type ? (state.tagName = stream.current(), setStyle = "tag", attrState) : config.allowMissingTagName && "endTag" == type ? (setStyle = "tag bracket", attrState(type, stream, state)) : (setStyle = "error", tagNameState)
            }

            function closeTagNameState(type, stream, state) {
                if ("word" == type) {
                    var tagName = stream.current();
                    return state.context && state.context.tagName != tagName && config.implicitlyClosed.hasOwnProperty(state.context.tagName) && popContext(state), state.context && state.context.tagName == tagName || config.matchClosing === !1 ? (setStyle = "tag", closeState) : (setStyle = "tag error", closeStateErr)
                }
                return config.allowMissingTagName && "endTag" == type ? (setStyle = "tag bracket", closeState(type, stream, state)) : (setStyle = "error", closeStateErr)
            }

            function closeState(type, _stream, state) {
                return "endTag" != type ? (setStyle = "error", closeState) : (popContext(state), baseState)
            }

            function closeStateErr(type, stream, state) {
                return setStyle = "error", closeState(type, stream, state)
            }

            function attrState(type, _stream, state) {
                if ("word" == type) return setStyle = "attribute", attrEqState;
                if ("endTag" == type || "selfcloseTag" == type) {
                    var tagName = state.tagName,
                        tagStart = state.tagStart;
                    return state.tagName = state.tagStart = null, "selfcloseTag" == type || config.autoSelfClosers.hasOwnProperty(tagName) ? maybePopContext(state, tagName) : (maybePopContext(state, tagName), state.context = new Context(state, tagName, tagStart == state.indented)), baseState
                }
                return setStyle = "error", attrState
            }

            function attrEqState(type, stream, state) {
                return "equals" == type ? attrValueState : (config.allowMissing || (setStyle = "error"), attrState(type, stream, state))
            }

            function attrValueState(type, stream, state) {
                return "string" == type ? attrContinuedState : "word" == type && config.allowUnquoted ? (setStyle = "string", attrState) : (setStyle = "error", attrState(type, stream, state))
            }

            function attrContinuedState(type, stream, state) {
                return "string" == type ? attrContinuedState : attrState(type, stream, state)
            }
            var indentUnit = editorConf.indentUnit,
                config = {},
                defaults = config_.htmlMode ? htmlConfig : xmlConfig;
            for (var prop in defaults) config[prop] = defaults[prop];
            for (var prop in config_) config[prop] = config_[prop];
            var type, setStyle;
            return inText.isInText = !0, {
                startState: function(baseIndent) {
                    var state = {
                        tokenize: inText,
                        state: baseState,
                        indented: baseIndent || 0,
                        tagName: null,
                        tagStart: null,
                        context: null
                    };
                    return null != baseIndent && (state.baseIndent = baseIndent), state
                },
                token: function(stream, state) {
                    if (!state.tagName && stream.sol() && (state.indented = stream.indentation()), stream.eatSpace()) return null;
                    type = null;
                    var style = state.tokenize(stream, state);
                    return (style || type) && "comment" != style && (setStyle = null, state.state = state.state(type || style, stream, state), setStyle && (style = "error" == setStyle ? style + " error" : setStyle)), style
                },
                indent: function(state, textAfter, fullLine) {
                    var context = state.context;
                    if (state.tokenize.isInAttribute) return state.tagStart == state.indented ? state.stringStartCol + 1 : state.indented + indentUnit;
                    if (context && context.noIndent) return CodeMirror.Pass;
                    if (state.tokenize != inTag && state.tokenize != inText) return fullLine ? fullLine.match(/^(\s*)/)[0].length : 0;
                    if (state.tagName) return config.multilineTagIndentPastTag !== !1 ? state.tagStart + state.tagName.length + 2 : state.tagStart + indentUnit * (config.multilineTagIndentFactor || 1);
                    if (config.alignCDATA && /<!\[CDATA\[/.test(textAfter)) return 0;
                    var tagAfter = textAfter && /^<(\/)?([\w_:\.-]*)/.exec(textAfter);
                    if (tagAfter && tagAfter[1])
                        for (; context;) {
                            if (context.tagName == tagAfter[2]) {
                                context = context.prev;
                                break
                            }
                            if (!config.implicitlyClosed.hasOwnProperty(context.tagName)) break;
                            context = context.prev
                        } else if (tagAfter)
                            for (; context;) {
                                var grabbers = config.contextGrabbers[context.tagName];
                                if (!grabbers || !grabbers.hasOwnProperty(tagAfter[2])) break;
                                context = context.prev
                            }
                    for (; context && context.prev && !context.startOfLine;) context = context.prev;
                    return context ? context.indent + indentUnit : state.baseIndent || 0
                },
                electricInput: /<\/[\s\w:]+>$/,
                blockCommentStart: "<!--",
                blockCommentEnd: "-->",
                configuration: config.htmlMode ? "html" : "xml",
                helperType: config.htmlMode ? "html" : "xml",
                skipAttribute: function(state) {
                    state.state == attrValueState && (state.state = attrState)
                }
            }
        }), CodeMirror.defineMIME("text/xml", "xml"), CodeMirror.defineMIME("application/xml", "xml"), CodeMirror.mimeModes.hasOwnProperty("text/html") || CodeMirror.defineMIME("text/html", {
            name: "xml",
            htmlMode: !0
        })
    }),
    function(mod) {
        "object" == ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "object" == ("undefined" == typeof module ? "undefined" : _typeof2(module)) ? mod(require("../../lib/codemirror"), require("../xml/xml"), require("../meta")): "function" == typeof define && define.amd ? define(["../../lib/codemirror", "../xml/xml", "../meta"], mod) : mod(CodeMirror)
    }(function(CodeMirror) {
        "use strict";
        CodeMirror.defineMode("markdown", function(cmCfg, modeCfg) {
            function getMode(name) {
                if (CodeMirror.findModeByName) {
                    var found = CodeMirror.findModeByName(name);
                    found && (name = found.mime || found.mimes[0])
                }
                var mode = CodeMirror.getMode(cmCfg, name);
                return "null" == mode.name ? null : mode
            }

            function switchInline(stream, state, f) {
                return state.f = state.inline = f, f(stream, state)
            }

            function switchBlock(stream, state, f) {
                return state.f = state.block = f, f(stream, state)
            }

            function lineIsEmpty(line) {
                return !line || !/\S/.test(line.string)
            }

            function blankLine(state) {
                return state.linkTitle = !1, state.linkHref = !1, state.linkText = !1, state.em = !1, state.strong = !1, state.strikethrough = !1, state.quote = 0, state.indentedCode = !1, state.f == htmlBlock && (state.f = inlineNormal, state.block = blockNormal), state.trailingSpace = 0, state.trailingSpaceNewLine = !1, state.prevLine = state.thisLine, state.thisLine = {
                    stream: null
                }, null
            }

            function blockNormal(stream, state) {
                var firstTokenOnLine = stream.column() === state.indentation,
                    prevLineLineIsEmpty = lineIsEmpty(state.prevLine.stream),
                    prevLineIsIndentedCode = state.indentedCode,
                    prevLineIsHr = state.prevLine.hr,
                    prevLineIsList = state.list !== !1,
                    maxNonCodeIndentation = (state.listStack[state.listStack.length - 1] || 0) + 3;
                state.indentedCode = !1;
                var lineIndentation = state.indentation;
                if (null === state.indentationDiff && (state.indentationDiff = state.indentation, prevLineIsList)) {
                    for (state.em = !1, state.strong = !1, state.code = !1, state.strikethrough = !1, state.list = null; lineIndentation < state.listStack[state.listStack.length - 1];) state.listStack.pop(), state.listStack.length ? state.indentation = state.listStack[state.listStack.length - 1] : state.list = !1;
                    state.list !== !1 && (state.indentationDiff = lineIndentation - state.listStack[state.listStack.length - 1])
                }
                var allowsInlineContinuation = !(prevLineLineIsEmpty || prevLineIsHr || state.prevLine.header || prevLineIsList && prevLineIsIndentedCode || state.prevLine.fencedCodeEnd),
                    isHr = (state.list === !1 || prevLineIsHr || prevLineLineIsEmpty) && state.indentation <= maxNonCodeIndentation && stream.match(hrRE),
                    match = null;
                if (state.indentationDiff >= 4 && (prevLineIsIndentedCode || state.prevLine.fencedCodeEnd || state.prevLine.header || prevLineLineIsEmpty)) return stream.skipToEnd(), state.indentedCode = !0, tokenTypes.code;
                if (stream.eatSpace()) return null;
                if (firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(atxHeaderRE)) && match[1].length <= 6) return state.quote = 0,
                    state.header = match[1].length, state.thisLine.header = !0, modeCfg.highlightFormatting && (state.formatting = "header"), state.f = state.inline, getType(state);
                if (state.indentation <= maxNonCodeIndentation && stream.eat(">")) return state.quote = firstTokenOnLine ? 1 : state.quote + 1, modeCfg.highlightFormatting && (state.formatting = "quote"), stream.eatSpace(), getType(state);
                if (!isHr && !state.setext && firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(listRE))) {
                    var listType = match[1] ? "ol" : "ul";
                    return state.indentation = lineIndentation + stream.current().length, state.list = !0, state.quote = 0, state.listStack.push(state.indentation), modeCfg.taskLists && stream.match(taskListRE, !1) && (state.taskList = !0), state.f = state.inline, modeCfg.highlightFormatting && (state.formatting = ["list", "list-" + listType]), getType(state)
                }
                return firstTokenOnLine && state.indentation <= maxNonCodeIndentation && (match = stream.match(fencedCodeRE, !0)) ? (state.quote = 0, state.fencedEndRE = new RegExp(match[1] + "+ *$"), state.localMode = modeCfg.fencedCodeBlockHighlighting && getMode(match[2]), state.localMode && (state.localState = CodeMirror.startState(state.localMode)), state.f = state.block = local, modeCfg.highlightFormatting && (state.formatting = "code-block"), state.code = -1, getType(state)) : state.setext || !(allowsInlineContinuation && prevLineIsList || state.quote || state.list !== !1 || state.code || isHr || linkDefRE.test(stream.string)) && (match = stream.lookAhead(1)) && (match = match.match(setextHeaderRE)) ? (state.setext ? (state.header = state.setext, state.setext = 0, stream.skipToEnd(), modeCfg.highlightFormatting && (state.formatting = "header")) : (state.header = "=" == match[0].charAt(0) ? 1 : 2, state.setext = state.header), state.thisLine.header = !0, state.f = state.inline, getType(state)) : isHr ? (stream.skipToEnd(), state.hr = !0, state.thisLine.hr = !0, tokenTypes.hr) : "[" === stream.peek() ? switchInline(stream, state, footnoteLink) : switchInline(stream, state, state.inline)
            }

            function htmlBlock(stream, state) {
                var style = htmlMode.token(stream, state.htmlState);
                if (!htmlModeMissing) {
                    var inner = CodeMirror.innerMode(htmlMode, state.htmlState);
                    ("xml" == inner.mode.name && null === inner.state.tagStart && !inner.state.context && inner.state.tokenize.isInText || state.md_inside && stream.current().indexOf(">") > -1) && (state.f = inlineNormal, state.block = blockNormal, state.htmlState = null)
                }
                return style
            }

            function local(stream, state) {
                var currListInd = state.listStack[state.listStack.length - 1] || 0,
                    hasExitedList = state.indentation < currListInd,
                    maxFencedEndInd = currListInd + 3;
                if (state.fencedEndRE && state.indentation <= maxFencedEndInd && (hasExitedList || stream.match(state.fencedEndRE))) {
                    modeCfg.highlightFormatting && (state.formatting = "code-block");
                    var returnType;
                    return hasExitedList || (returnType = getType(state)), state.localMode = state.localState = null, state.block = blockNormal, state.f = inlineNormal, state.fencedEndRE = null, state.code = 0, state.thisLine.fencedCodeEnd = !0, hasExitedList ? switchBlock(stream, state, state.block) : returnType
                }
                return state.localMode ? state.localMode.token(stream, state.localState) : (stream.skipToEnd(), tokenTypes.code)
            }

            function getType(state) {
                var styles = [];
                if (state.formatting) {
                    styles.push(tokenTypes.formatting), "string" == typeof state.formatting && (state.formatting = [state.formatting]);
                    for (var i = 0; i < state.formatting.length; i++) styles.push(tokenTypes.formatting + "-" + state.formatting[i]), "header" === state.formatting[i] && styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.header), "quote" === state.formatting[i] && (!modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote ? styles.push(tokenTypes.formatting + "-" + state.formatting[i] + "-" + state.quote) : styles.push("error"))
                }
                if (state.taskOpen) return styles.push("meta"), styles.length ? styles.join(" ") : null;
                if (state.taskClosed) return styles.push("property"), styles.length ? styles.join(" ") : null;
                if (state.linkHref ? styles.push(tokenTypes.linkHref, "url") : (state.strong && styles.push(tokenTypes.strong), state.em && styles.push(tokenTypes.em), state.strikethrough && styles.push(tokenTypes.strikethrough), state.emoji && styles.push(tokenTypes.emoji), state.linkText && styles.push(tokenTypes.linkText), state.code && styles.push(tokenTypes.code), state.image && styles.push(tokenTypes.image), state.imageAltText && styles.push(tokenTypes.imageAltText, "link"), state.imageMarker && styles.push(tokenTypes.imageMarker)), state.header && styles.push(tokenTypes.header, tokenTypes.header + "-" + state.header), state.quote && (styles.push(tokenTypes.quote), !modeCfg.maxBlockquoteDepth || modeCfg.maxBlockquoteDepth >= state.quote ? styles.push(tokenTypes.quote + "-" + state.quote) : styles.push(tokenTypes.quote + "-" + modeCfg.maxBlockquoteDepth)), state.list !== !1) {
                    var listMod = (state.listStack.length - 1) % 3;
                    listMod ? 1 === listMod ? styles.push(tokenTypes.list2) : styles.push(tokenTypes.list3) : styles.push(tokenTypes.list1)
                }
                return state.trailingSpaceNewLine ? styles.push("trailing-space-new-line") : state.trailingSpace && styles.push("trailing-space-" + (state.trailingSpace % 2 ? "a" : "b")), styles.length ? styles.join(" ") : null
            }

            function handleText(stream, state) {
                if (stream.match(textRE, !0)) return getType(state)
            }

            function inlineNormal(stream, state) {
                var style = state.text(stream, state);
                if ("undefined" != typeof style) return style;
                if (state.list) return state.list = null, getType(state);
                if (state.taskList) {
                    var taskOpen = " " === stream.match(taskListRE, !0)[1];
                    return taskOpen ? state.taskOpen = !0 : state.taskClosed = !0, modeCfg.highlightFormatting && (state.formatting = "task"), state.taskList = !1, getType(state)
                }
                if (state.taskOpen = !1, state.taskClosed = !1, state.header && stream.match(/^#+$/, !0)) return modeCfg.highlightFormatting && (state.formatting = "header"), getType(state);
                var ch = stream.next();
                if (state.linkTitle) {
                    state.linkTitle = !1;
                    var matchCh = ch;
                    "(" === ch && (matchCh = ")"), matchCh = (matchCh + "").replace(/([.?*+^\[\]\\(){}|-])/g, "\\$1");
                    var regex = "^\\s*(?:[^" + matchCh + "\\\\]+|\\\\\\\\|\\\\.)" + matchCh;
                    if (stream.match(new RegExp(regex), !0)) return tokenTypes.linkHref
                }
                if ("`" === ch) {
                    var previousFormatting = state.formatting;
                    modeCfg.highlightFormatting && (state.formatting = "code"), stream.eatWhile("`");
                    var count = stream.current().length;
                    if (0 != state.code || state.quote && 1 != count) {
                        if (count == state.code) {
                            var t = getType(state);
                            return state.code = 0, t
                        }
                        return state.formatting = previousFormatting, getType(state)
                    }
                    return state.code = count, getType(state)
                }
                if (state.code) return getType(state);
                if ("\\" === ch && (stream.next(), modeCfg.highlightFormatting)) {
                    var type = getType(state),
                        formattingEscape = tokenTypes.formatting + "-escape";
                    return type ? type + " " + formattingEscape : formattingEscape
                }
                if ("!" === ch && stream.match(/\[[^\]]*\] ?(?:\(|\[)/, !1)) return state.imageMarker = !0, state.image = !0, modeCfg.highlightFormatting && (state.formatting = "image"), getType(state);
                if ("[" === ch && state.imageMarker && stream.match(/[^\]]*\](\(.*?\)| ?\[.*?\])/, !1)) return state.imageMarker = !1, state.imageAltText = !0, modeCfg.highlightFormatting && (state.formatting = "image"), getType(state);
                if ("]" === ch && state.imageAltText) {
                    modeCfg.highlightFormatting && (state.formatting = "image");
                    var type = getType(state);
                    return state.imageAltText = !1, state.image = !1, state.inline = state.f = linkHref, type
                }
                if ("[" === ch && !state.image) return state.linkText = !0, modeCfg.highlightFormatting && (state.formatting = "link"), getType(state);
                if ("]" === ch && state.linkText) {
                    modeCfg.highlightFormatting && (state.formatting = "link");
                    var type = getType(state);
                    return state.linkText = !1, state.inline = state.f = stream.match(/\(.*?\)| ?\[.*?\]/, !1) ? linkHref : inlineNormal, type
                }
                if ("<" === ch && stream.match(/^(https?|ftps?):\/\/(?:[^\\>]|\\.)+>/, !1)) {
                    state.f = state.inline = linkInline, modeCfg.highlightFormatting && (state.formatting = "link");
                    var type = getType(state);
                    return type ? type += " " : type = "", type + tokenTypes.linkInline
                }
                if ("<" === ch && stream.match(/^[^> \\]+@(?:[^\\>]|\\.)+>/, !1)) {
                    state.f = state.inline = linkInline, modeCfg.highlightFormatting && (state.formatting = "link");
                    var type = getType(state);
                    return type ? type += " " : type = "", type + tokenTypes.linkEmail
                }
                if (modeCfg.xml && "<" === ch && stream.match(/^(!--|[a-z][a-z0-9-]*(?:\s+[a-z_:.\-]+(?:\s*=\s*[^>]+)?)*\s*>)/i, !1)) {
                    var end = stream.string.indexOf(">", stream.pos);
                    if (end != -1) {
                        var atts = stream.string.substring(stream.start, end);
                        /markdown\s*=\s*('|"){0,1}1('|"){0,1}/.test(atts) && (state.md_inside = !0)
                    }
                    return stream.backUp(1), state.htmlState = CodeMirror.startState(htmlMode), switchBlock(stream, state, htmlBlock)
                }
                if (modeCfg.xml && "<" === ch && stream.match(/^\/\w*?>/)) return state.md_inside = !1, "tag";
                if ("*" === ch || "_" === ch) {
                    for (var len = 1, before = 1 == stream.pos ? " " : stream.string.charAt(stream.pos - 2); len < 3 && stream.eat(ch);) len++;
                    var after = stream.peek() || " ",
                        leftFlanking = !/\s/.test(after) && (!punctuation.test(after) || /\s/.test(before) || punctuation.test(before)),
                        rightFlanking = !/\s/.test(before) && (!punctuation.test(before) || /\s/.test(after) || punctuation.test(after)),
                        setEm = null,
                        setStrong = null;
                    if (len % 2 && (state.em || !leftFlanking || "*" !== ch && rightFlanking && !punctuation.test(before) ? state.em != ch || !rightFlanking || "*" !== ch && leftFlanking && !punctuation.test(after) || (setEm = !1) : setEm = !0), len > 1 && (state.strong || !leftFlanking || "*" !== ch && rightFlanking && !punctuation.test(before) ? state.strong != ch || !rightFlanking || "*" !== ch && leftFlanking && !punctuation.test(after) || (setStrong = !1) : setStrong = !0), null != setStrong || null != setEm) {
                        modeCfg.highlightFormatting && (state.formatting = null == setEm ? "strong" : null == setStrong ? "em" : "strong em"), setEm === !0 && (state.em = ch), setStrong === !0 && (state.strong = ch);
                        var t = getType(state);
                        return setEm === !1 && (state.em = !1), setStrong === !1 && (state.strong = !1), t
                    }
                } else if (" " === ch && (stream.eat("*") || stream.eat("_"))) {
                    if (" " === stream.peek()) return getType(state);
                    stream.backUp(1)
                }
                if (modeCfg.strikethrough)
                    if ("~" === ch && stream.eatWhile(ch)) {
                        if (state.strikethrough) {
                            modeCfg.highlightFormatting && (state.formatting = "strikethrough");
                            var t = getType(state);
                            return state.strikethrough = !1, t
                        }
                        if (stream.match(/^[^\s]/, !1)) return state.strikethrough = !0, modeCfg.highlightFormatting && (state.formatting = "strikethrough"), getType(state)
                    } else if (" " === ch && stream.match(/^~~/, !0)) {
                    if (" " === stream.peek()) return getType(state);
                    stream.backUp(2)
                }
                if (modeCfg.emoji && ":" === ch && stream.match(/^[a-z_\d+-]+:/)) {
                    state.emoji = !0, modeCfg.highlightFormatting && (state.formatting = "emoji");
                    var retType = getType(state);
                    return state.emoji = !1, retType
                }
                return " " === ch && (stream.match(/ +$/, !1) ? state.trailingSpace++ : state.trailingSpace && (state.trailingSpaceNewLine = !0)), getType(state)
            }

            function linkInline(stream, state) {
                var ch = stream.next();
                if (">" === ch) {
                    state.f = state.inline = inlineNormal, modeCfg.highlightFormatting && (state.formatting = "link");
                    var type = getType(state);
                    return type ? type += " " : type = "", type + tokenTypes.linkInline
                }
                return stream.match(/^[^>]+/, !0), tokenTypes.linkInline
            }

            function linkHref(stream, state) {
                if (stream.eatSpace()) return null;
                var ch = stream.next();
                return "(" === ch || "[" === ch ? (state.f = state.inline = getLinkHrefInside("(" === ch ? ")" : "]"), modeCfg.highlightFormatting && (state.formatting = "link-string"), state.linkHref = !0, getType(state)) : "error"
            }

            function getLinkHrefInside(endChar) {
                return function(stream, state) {
                    var ch = stream.next();
                    if (ch === endChar) {
                        state.f = state.inline = inlineNormal, modeCfg.highlightFormatting && (state.formatting = "link-string");
                        var returnState = getType(state);
                        return state.linkHref = !1, returnState
                    }
                    return stream.match(linkRE[endChar]), state.linkHref = !0, getType(state)
                }
            }

            function footnoteLink(stream, state) {
                return stream.match(/^([^\]\\]|\\.)*\]:/, !1) ? (state.f = footnoteLinkInside, stream.next(), modeCfg.highlightFormatting && (state.formatting = "link"), state.linkText = !0, getType(state)) : switchInline(stream, state, inlineNormal)
            }

            function footnoteLinkInside(stream, state) {
                if (stream.match(/^\]:/, !0)) {
                    state.f = state.inline = footnoteUrl, modeCfg.highlightFormatting && (state.formatting = "link");
                    var returnType = getType(state);
                    return state.linkText = !1, returnType
                }
                return stream.match(/^([^\]\\]|\\.)+/, !0), tokenTypes.linkText
            }

            function footnoteUrl(stream, state) {
                return stream.eatSpace() ? null : (stream.match(/^[^\s]+/, !0), void 0 === stream.peek() ? state.linkTitle = !0 : stream.match(/^(?:\s+(?:"(?:[^"\\]|\\\\|\\.)+"|'(?:[^'\\]|\\\\|\\.)+'|\((?:[^)\\]|\\\\|\\.)+\)))?/, !0), state.f = state.inline = inlineNormal, tokenTypes.linkHref + " url")
            }
            var htmlMode = CodeMirror.getMode(cmCfg, "text/html"),
                htmlModeMissing = "null" == htmlMode.name;
            void 0 === modeCfg.highlightFormatting && (modeCfg.highlightFormatting = !1), void 0 === modeCfg.maxBlockquoteDepth && (modeCfg.maxBlockquoteDepth = 0), void 0 === modeCfg.taskLists && (modeCfg.taskLists = !1), void 0 === modeCfg.strikethrough && (modeCfg.strikethrough = !1), void 0 === modeCfg.emoji && (modeCfg.emoji = !1), void 0 === modeCfg.fencedCodeBlockHighlighting && (modeCfg.fencedCodeBlockHighlighting = !0), void 0 === modeCfg.xml && (modeCfg.xml = !0), void 0 === modeCfg.tokenTypeOverrides && (modeCfg.tokenTypeOverrides = {});
            var tokenTypes = {
                header: "header",
                code: "comment",
                quote: "quote",
                list1: "variable-2",
                list2: "variable-3",
                list3: "keyword",
                hr: "hr",
                image: "image",
                imageAltText: "image-alt-text",
                imageMarker: "image-marker",
                formatting: "formatting",
                linkInline: "link",
                linkEmail: "link",
                linkText: "link",
                linkHref: "string",
                em: "em",
                strong: "strong",
                strikethrough: "strikethrough",
                emoji: "builtin"
            };
            for (var tokenType in tokenTypes) tokenTypes.hasOwnProperty(tokenType) && modeCfg.tokenTypeOverrides[tokenType] && (tokenTypes[tokenType] = modeCfg.tokenTypeOverrides[tokenType]);
            var hrRE = /^([*\-_])(?:\s*\1){2,}\s*$/,
                listRE = /^(?:[*\-+]|^[0-9]+([.)]))\s+/,
                taskListRE = /^\[(x| )\](?=\s)/i,
                atxHeaderRE = modeCfg.allowAtxHeaderWithoutSpace ? /^(#+)/ : /^(#+)(?: |$)/,
                setextHeaderRE = /^ *(?:\={1,}|-{1,})\s*$/,
                textRE = /^[^#!\[\]*_\\<>` "'(~:]+/,
                fencedCodeRE = /^(~~~+|```+)[ \t]*([\w+#-]*)[^\n`]*$/,
                linkDefRE = /^\s*\[[^\]]+?\]:.*$/,
                punctuation = /[!\"#$%&\'()*+,\-\.\/:;<=>?@\[\\\]^_`{|}~]/,
                expandedTab = "    ",
                linkRE = {
                    ")": /^(?:[^\\\(\)]|\\.|\((?:[^\\\(\)]|\\.)*\))*?(?=\))/,
                    "]": /^(?:[^\\\[\]]|\\.|\[(?:[^\\\[\]]|\\.)*\])*?(?=\])/
                },
                mode = {
                    startState: function() {
                        return {
                            f: blockNormal,
                            prevLine: {
                                stream: null
                            },
                            thisLine: {
                                stream: null
                            },
                            block: blockNormal,
                            htmlState: null,
                            indentation: 0,
                            inline: inlineNormal,
                            text: handleText,
                            formatting: !1,
                            linkText: !1,
                            linkHref: !1,
                            linkTitle: !1,
                            code: 0,
                            em: !1,
                            strong: !1,
                            header: 0,
                            setext: 0,
                            hr: !1,
                            taskList: !1,
                            list: !1,
                            listStack: [],
                            quote: 0,
                            trailingSpace: 0,
                            trailingSpaceNewLine: !1,
                            strikethrough: !1,
                            emoji: !1,
                            fencedEndRE: null
                        }
                    },
                    copyState: function(s) {
                        return {
                            f: s.f,
                            prevLine: s.prevLine,
                            thisLine: s.thisLine,
                            block: s.block,
                            htmlState: s.htmlState && CodeMirror.copyState(htmlMode, s.htmlState),
                            indentation: s.indentation,
                            localMode: s.localMode,
                            localState: s.localMode ? CodeMirror.copyState(s.localMode, s.localState) : null,
                            inline: s.inline,
                            text: s.text,
                            formatting: !1,
                            linkText: s.linkText,
                            linkTitle: s.linkTitle,
                            linkHref: s.linkHref,
                            code: s.code,
                            em: s.em,
                            strong: s.strong,
                            strikethrough: s.strikethrough,
                            emoji: s.emoji,
                            header: s.header,
                            setext: s.setext,
                            hr: s.hr,
                            taskList: s.taskList,
                            list: s.list,
                            listStack: s.listStack.slice(0),
                            quote: s.quote,
                            indentedCode: s.indentedCode,
                            trailingSpace: s.trailingSpace,
                            trailingSpaceNewLine: s.trailingSpaceNewLine,
                            md_inside: s.md_inside,
                            fencedEndRE: s.fencedEndRE
                        }
                    },
                    token: function(stream, state) {
                        if (state.formatting = !1, stream != state.thisLine.stream) {
                            if (state.header = 0, state.hr = !1, stream.match(/^\s*$/, !0)) return blankLine(state), null;
                            if (state.prevLine = state.thisLine, state.thisLine = {
                                    stream: stream
                                }, state.taskList = !1, state.trailingSpace = 0, state.trailingSpaceNewLine = !1, !state.localState && (state.f = state.block, state.f != htmlBlock)) {
                                var indentation = stream.match(/^\s*/, !0)[0].replace(/\t/g, expandedTab).length;
                                if (state.indentation = indentation, state.indentationDiff = null, indentation > 0) return null
                            }
                        }
                        return state.f(stream, state)
                    },
                    innerMode: function(state) {
                        return state.block == htmlBlock ? {
                            state: state.htmlState,
                            mode: htmlMode
                        } : state.localState ? {
                            state: state.localState,
                            mode: state.localMode
                        } : {
                            state: state,
                            mode: mode
                        }
                    },
                    indent: function(state, textAfter, line) {
                        return state.block == htmlBlock && htmlMode.indent ? htmlMode.indent(state.htmlState, textAfter, line) : state.localState && state.localMode.indent ? state.localMode.indent(state.localState, textAfter, line) : CodeMirror.Pass
                    },
                    blankLine: blankLine,
                    getType: getType,
                    closeBrackets: "()[]{}''\"\"``",
                    fold: "markdown"
                };
            return mode
        }, "xml"), CodeMirror.defineMIME("text/markdown", "markdown"), CodeMirror.defineMIME("text/x-markdown", "markdown")
    }),
    function(mod) {
        "object" == ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "object" == ("undefined" == typeof module ? "undefined" : _typeof2(module)) ? mod(require("../../lib/codemirror"), require("../xml/xml"), require("../javascript/javascript"), require("../css/css")): "function" == typeof define && define.amd ? define(["../../lib/codemirror", "../xml/xml", "../javascript/javascript", "../css/css"], mod) : mod(CodeMirror)
    }(function(CodeMirror) {
        "use strict";

        function maybeBackup(stream, pat, style) {
            var cur = stream.current(),
                close = cur.search(pat);
            return close > -1 ? stream.backUp(cur.length - close) : cur.match(/<\/?$/) && (stream.backUp(cur.length), stream.match(pat, !1) || stream.match(cur)), style
        }

        function getAttrRegexp(attr) {
            var regexp = attrRegexpCache[attr];
            return regexp ? regexp : attrRegexpCache[attr] = new RegExp("\\s+" + attr + "\\s*=\\s*('|\")?([^'\"]+)('|\")?\\s*")
        }

        function getAttrValue(text, attr) {
            var match = text.match(getAttrRegexp(attr));
            return match ? /^\s*(.*?)\s*$/.exec(match[2])[1] : ""
        }

        function getTagRegexp(tagName, anchored) {
            return new RegExp((anchored ? "^" : "") + "</s*" + tagName + "s*>", "i")
        }

        function addTags(from, to) {
            for (var tag in from)
                for (var dest = to[tag] || (to[tag] = []), source = from[tag], i = source.length - 1; i >= 0; i--) dest.unshift(source[i])
        }

        function findMatchingMode(tagInfo, tagText) {
            for (var i = 0; i < tagInfo.length; i++) {
                var spec = tagInfo[i];
                if (!spec[0] || spec[1].test(getAttrValue(tagText, spec[0]))) return spec[2]
            }
        }
        var defaultTags = {
                script: [
                    ["lang", /(javascript|babel)/i, "javascript"],
                    ["type", /^(?:text|application)\/(?:x-)?(?:java|ecma)script$|^module$|^$/i, "javascript"],
                    ["type", /./, "text/plain"],
                    [null, null, "javascript"]
                ],
                style: [
                    ["lang", /^css$/i, "css"],
                    ["type", /^(text\/)?(x-)?(stylesheet|css)$/i, "css"],
                    ["type", /./, "text/plain"],
                    [null, null, "css"]
                ]
            },
            attrRegexpCache = {};
        CodeMirror.defineMode("htmlmixed", function(config, parserConfig) {
            function html(stream, state) {
                var tagName, style = htmlMode.token(stream, state.htmlState),
                    tag = /\btag\b/.test(style);
                if (tag && !/[<>\s\/]/.test(stream.current()) && (tagName = state.htmlState.tagName && state.htmlState.tagName.toLowerCase()) && tags.hasOwnProperty(tagName)) state.inTag = tagName + " ";
                else if (state.inTag && tag && />$/.test(stream.current())) {
                    var inTag = /^([\S]+) (.*)/.exec(state.inTag);
                    state.inTag = null;
                    var modeSpec = ">" == stream.current() && findMatchingMode(tags[inTag[1]], inTag[2]),
                        mode = CodeMirror.getMode(config, modeSpec),
                        endTagA = getTagRegexp(inTag[1], !0),
                        endTag = getTagRegexp(inTag[1], !1);
                    state.token = function(stream, state) {
                        return stream.match(endTagA, !1) ? (state.token = html, state.localState = state.localMode = null, null) : maybeBackup(stream, endTag, state.localMode.token(stream, state.localState))
                    }, state.localMode = mode, state.localState = CodeMirror.startState(mode, htmlMode.indent(state.htmlState, ""))
                } else state.inTag && (state.inTag += stream.current(), stream.eol() && (state.inTag += " "));
                return style
            }
            var htmlMode = CodeMirror.getMode(config, {
                    name: "xml",
                    htmlMode: !0,
                    multilineTagIndentFactor: parserConfig.multilineTagIndentFactor,
                    multilineTagIndentPastTag: parserConfig.multilineTagIndentPastTag
                }),
                tags = {},
                configTags = parserConfig && parserConfig.tags,
                configScript = parserConfig && parserConfig.scriptTypes;
            if (addTags(defaultTags, tags), configTags && addTags(configTags, tags), configScript)
                for (var i = configScript.length - 1; i >= 0; i--) tags.script.unshift(["type", configScript[i].matches, configScript[i].mode]);
            return {
                startState: function() {
                    var state = CodeMirror.startState(htmlMode);
                    return {
                        token: html,
                        inTag: null,
                        localMode: null,
                        localState: null,
                        htmlState: state
                    }
                },
                copyState: function(state) {
                    var local;
                    return state.localState && (local = CodeMirror.copyState(state.localMode, state.localState)), {
                        token: state.token,
                        inTag: state.inTag,
                        localMode: state.localMode,
                        localState: local,
                        htmlState: CodeMirror.copyState(htmlMode, state.htmlState)
                    }
                },
                token: function(stream, state) {
                    return state.token(stream, state)
                },
                indent: function(state, textAfter, line) {
                    return !state.localMode || /^\s*<\//.test(textAfter) ? htmlMode.indent(state.htmlState, textAfter) : state.localMode.indent ? state.localMode.indent(state.localState, textAfter, line) : CodeMirror.Pass
                },
                innerMode: function(state) {
                    return {
                        state: state.localState || state.htmlState,
                        mode: state.localMode || htmlMode
                    }
                }
            }
        }, "xml", "javascript", "css"), CodeMirror.defineMIME("text/html", "htmlmixed")
    }),
    function(mod) {
        "object" == ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "object" == ("undefined" == typeof module ? "undefined" : _typeof2(module)) ? mod(require("../../lib/codemirror")): "function" == typeof define && define.amd ? define(["../../lib/codemirror"], mod) : mod(CodeMirror)
    }(function(CodeMirror) {
        "use strict";
        CodeMirror.defineMode("javascript", function(config, parserConfig) {
            function readRegexp(stream) {
                for (var next, escaped = !1, inSet = !1; null != (next = stream.next());) {
                    if (!escaped) {
                        if ("/" == next && !inSet) return;
                        "[" == next ? inSet = !0 : inSet && "]" == next && (inSet = !1)
                    }
                    escaped = !escaped && "\\" == next
                }
            }

            function ret(tp, style, cont) {
                return type = tp, content = cont, style
            }

            function tokenBase(stream, state) {
                var ch = stream.next();
                if ('"' == ch || "'" == ch) return state.tokenize = tokenString(ch), state.tokenize(stream, state);
                if ("." == ch && stream.match(/^\d+(?:[eE][+\-]?\d+)?/)) return ret("number", "number");
                if ("." == ch && stream.match("..")) return ret("spread", "meta");
                if (/[\[\]{}\(\),;\:\.]/.test(ch)) return ret(ch);
                if ("=" == ch && stream.eat(">")) return ret("=>", "operator");
                if ("0" == ch && stream.eat(/x/i)) return stream.eatWhile(/[\da-f]/i), ret("number", "number");
                if ("0" == ch && stream.eat(/o/i)) return stream.eatWhile(/[0-7]/i), ret("number", "number");
                if ("0" == ch && stream.eat(/b/i)) return stream.eatWhile(/[01]/i), ret("number", "number");
                if (/\d/.test(ch)) return stream.match(/^\d*(?:\.\d*)?(?:[eE][+\-]?\d+)?/), ret("number", "number");
                if ("/" == ch) return stream.eat("*") ? (state.tokenize = tokenComment, tokenComment(stream, state)) : stream.eat("/") ? (stream.skipToEnd(), ret("comment", "comment")) : expressionAllowed(stream, state, 1) ? (readRegexp(stream), stream.match(/^\b(([gimyu])(?![gimyu]*\2))+\b/), ret("regexp", "string-2")) : (stream.eat("="), ret("operator", "operator", stream.current()));
                if ("`" == ch) return state.tokenize = tokenQuasi, tokenQuasi(stream, state);
                if ("#" == ch) return stream.skipToEnd(), ret("error", "error");
                if (isOperatorChar.test(ch)) return ">" == ch && state.lexical && ">" == state.lexical.type || (stream.eat("=") ? "!" != ch && "=" != ch || stream.eat("=") : /[<>*+\-]/.test(ch) && (stream.eat(ch), ">" == ch && stream.eat(ch))), ret("operator", "operator", stream.current());
                if (wordRE.test(ch)) {
                    stream.eatWhile(wordRE);
                    var word = stream.current();
                    if ("." != state.lastType) {
                        if (keywords.propertyIsEnumerable(word)) {
                            var kw = keywords[word];
                            return ret(kw.type, kw.style, word)
                        }
                        if ("async" == word && stream.match(/^(\s|\/\*.*?\*\/)*[\[\(\w]/, !1)) return ret("async", "keyword", word)
                    }
                    return ret("variable", "variable", word)
                }
            }

            function tokenString(quote) {
                return function(stream, state) {
                    var next, escaped = !1;
                    if (jsonldMode && "@" == stream.peek() && stream.match(isJsonldKeyword)) return state.tokenize = tokenBase, ret("jsonld-keyword", "meta");
                    for (; null != (next = stream.next()) && (next != quote || escaped);) escaped = !escaped && "\\" == next;
                    return escaped || (state.tokenize = tokenBase), ret("string", "string")
                }
            }

            function tokenComment(stream, state) {
                for (var ch, maybeEnd = !1; ch = stream.next();) {
                    if ("/" == ch && maybeEnd) {
                        state.tokenize = tokenBase;
                        break
                    }
                    maybeEnd = "*" == ch
                }
                return ret("comment", "comment")
            }

            function tokenQuasi(stream, state) {
                for (var next, escaped = !1; null != (next = stream.next());) {
                    if (!escaped && ("`" == next || "$" == next && stream.eat("{"))) {
                        state.tokenize = tokenBase;
                        break
                    }
                    escaped = !escaped && "\\" == next
                }
                return ret("quasi", "string-2", stream.current())
            }

            function findFatArrow(stream, state) {
                state.fatArrowAt && (state.fatArrowAt = null);
                var arrow = stream.string.indexOf("=>", stream.start);
                if (!(arrow < 0)) {
                    if (isTS) {
                        var m = /:\s*(?:\w+(?:<[^>]*>|\[\])?|\{[^}]*\})\s*$/.exec(stream.string.slice(stream.start, arrow));
                        m && (arrow = m.index)
                    }
                    for (var depth = 0, sawSomething = !1, pos = arrow - 1; pos >= 0; --pos) {
                        var ch = stream.string.charAt(pos),
                            bracket = brackets.indexOf(ch);
                        if (bracket >= 0 && bracket < 3) {
                            if (!depth) {
                                ++pos;
                                break
                            }
                            if (0 == --depth) {
                                "(" == ch && (sawSomething = !0);
                                break
                            }
                        } else if (bracket >= 3 && bracket < 6) ++depth;
                        else if (wordRE.test(ch)) sawSomething = !0;
                        else {
                            if (/["'\/]/.test(ch)) return;
                            if (sawSomething && !depth) {
                                ++pos;
                                break
                            }
                        }
                    }
                    sawSomething && !depth && (state.fatArrowAt = pos)
                }
            }

            function JSLexical(indented, column, type, align, prev, info) {
                this.indented = indented, this.column = column, this.type = type, this.prev = prev, this.info = info, null != align && (this.align = align)
            }

            function inScope(state, varname) {
                for (var v = state.localVars; v; v = v.next)
                    if (v.name == varname) return !0;
                for (var cx = state.context; cx; cx = cx.prev)
                    for (var v = cx.vars; v; v = v.next)
                        if (v.name == varname) return !0
            }

            function parseJS(state, style, type, content, stream) {
                var cc = state.cc;
                for (cx.state = state, cx.stream = stream, cx.marked = null, cx.cc = cc, cx.style = style, state.lexical.hasOwnProperty("align") || (state.lexical.align = !0);;) {
                    var combinator = cc.length ? cc.pop() : jsonMode ? expression : statement;
                    if (combinator(type, content)) {
                        for (; cc.length && cc[cc.length - 1].lex;) cc.pop()();
                        return cx.marked ? cx.marked : "variable" == type && inScope(state, content) ? "variable-2" : style
                    }
                }
            }

            function pass() {
                for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i])
            }

            function cont() {
                return pass.apply(null, arguments), !0
            }

            function register(varname) {
                function inList(list) {
                    for (var v = list; v; v = v.next)
                        if (v.name == varname) return !0;
                    return !1
                }
                var state = cx.state;
                if (cx.marked = "def", state.context) {
                    if (inList(state.localVars)) return;
                    state.localVars = {
                        name: varname,
                        next: state.localVars
                    }
                } else {
                    if (inList(state.globalVars)) return;
                    parserConfig.globalVars && (state.globalVars = {
                        name: varname,
                        next: state.globalVars
                    })
                }
            }

            function isModifier(name) {
                return "public" == name || "private" == name || "protected" == name || "abstract" == name || "readonly" == name
            }

            function pushcontext() {
                cx.state.context = {
                    prev: cx.state.context,
                    vars: cx.state.localVars
                }, cx.state.localVars = defaultVars
            }

            function popcontext() {
                cx.state.localVars = cx.state.context.vars, cx.state.context = cx.state.context.prev
            }

            function pushlex(type, info) {
                var result = function() {
                    var state = cx.state,
                        indent = state.indented;
                    if ("stat" == state.lexical.type) indent = state.lexical.indented;
                    else
                        for (var outer = state.lexical; outer && ")" == outer.type && outer.align; outer = outer.prev) indent = outer.indented;
                    state.lexical = new JSLexical(indent, cx.stream.column(), type, null, state.lexical, info)
                };
                return result.lex = !0, result
            }

            function poplex() {
                var state = cx.state;
                state.lexical.prev && (")" == state.lexical.type && (state.indented = state.lexical.indented), state.lexical = state.lexical.prev)
            }

            function expect(wanted) {
                function exp(type) {
                    return type == wanted ? cont() : ";" == wanted ? pass() : cont(exp)
                }
                return exp
            }

            function statement(type, value) {
                return "var" == type ? cont(pushlex("vardef", value.length), vardef, expect(";"), poplex) : "keyword a" == type ? cont(pushlex("form"), parenExpr, statement, poplex) : "keyword b" == type ? cont(pushlex("form"), statement, poplex) : "keyword d" == type ? cx.stream.match(/^\s*$/, !1) ? cont() : cont(pushlex("stat"), maybeexpression, expect(";"), poplex) : "debugger" == type ? cont(expect(";")) : "{" == type ? cont(pushlex("}"), block, poplex) : ";" == type ? cont() : "if" == type ? ("else" == cx.state.lexical.info && cx.state.cc[cx.state.cc.length - 1] == poplex && cx.state.cc.pop()(), cont(pushlex("form"), parenExpr, statement, poplex, maybeelse)) : "function" == type ? cont(functiondef) : "for" == type ? cont(pushlex("form"), forspec, statement, poplex) : "class" == type || isTS && "interface" == value ? (cx.marked = "keyword", cont(pushlex("form"), className, poplex)) : "variable" == type ? isTS && "declare" == value ? (cx.marked = "keyword", cont(statement)) : isTS && ("module" == value || "enum" == value || "type" == value) && cx.stream.match(/^\s*\w/, !1) ? (cx.marked = "keyword", "enum" == value ? cont(enumdef) : "type" == value ? cont(typeexpr, expect("operator"), typeexpr, expect(";")) : cont(pushlex("form"), pattern, expect("{"), pushlex("}"), block, poplex, poplex)) : isTS && "namespace" == value ? (cx.marked = "keyword", cont(pushlex("form"), expression, block, poplex)) : isTS && "abstract" == value ? (cx.marked = "keyword", cont(statement)) : cont(pushlex("stat"), maybelabel) : "switch" == type ? cont(pushlex("form"), parenExpr, expect("{"), pushlex("}", "switch"), block, poplex, poplex) : "case" == type ? cont(expression, expect(":")) : "default" == type ? cont(expect(":")) : "catch" == type ? cont(pushlex("form"), pushcontext, expect("("), funarg, expect(")"), statement, poplex, popcontext) : "export" == type ? cont(pushlex("stat"), afterExport, poplex) : "import" == type ? cont(pushlex("stat"), afterImport, poplex) : "async" == type ? cont(statement) : "@" == value ? cont(expression, statement) : pass(pushlex("stat"), expression, expect(";"), poplex)
            }

            function expression(type, value) {
                return expressionInner(type, value, !1)
            }

            function expressionNoComma(type, value) {
                return expressionInner(type, value, !0)
            }

            function parenExpr(type) {
                return "(" != type ? pass() : cont(pushlex(")"), expression, expect(")"), poplex)
            }

            function expressionInner(type, value, noComma) {
                if (cx.state.fatArrowAt == cx.stream.start) {
                    var body = noComma ? arrowBodyNoComma : arrowBody;
                    if ("(" == type) return cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, expect("=>"), body, popcontext);
                    if ("variable" == type) return pass(pushcontext, pattern, expect("=>"), body, popcontext)
                }
                var maybeop = noComma ? maybeoperatorNoComma : maybeoperatorComma;
                return atomicTypes.hasOwnProperty(type) ? cont(maybeop) : "function" == type ? cont(functiondef, maybeop) : "class" == type || isTS && "interface" == value ? (cx.marked = "keyword", cont(pushlex("form"), classExpression, poplex)) : "keyword c" == type || "async" == type ? cont(noComma ? expressionNoComma : expression) : "(" == type ? cont(pushlex(")"), maybeexpression, expect(")"), poplex, maybeop) : "operator" == type || "spread" == type ? cont(noComma ? expressionNoComma : expression) : "[" == type ? cont(pushlex("]"), arrayLiteral, poplex, maybeop) : "{" == type ? contCommasep(objprop, "}", null, maybeop) : "quasi" == type ? pass(quasi, maybeop) : "new" == type ? cont(maybeTarget(noComma)) : "import" == type ? cont(expression) : cont()
            }

            function maybeexpression(type) {
                return type.match(/[;\}\)\],]/) ? pass() : pass(expression)
            }

            function maybeoperatorComma(type, value) {
                return "," == type ? cont(expression) : maybeoperatorNoComma(type, value, !1)
            }

            function maybeoperatorNoComma(type, value, noComma) {
                var me = 0 == noComma ? maybeoperatorComma : maybeoperatorNoComma,
                    expr = 0 == noComma ? expression : expressionNoComma;
                return "=>" == type ? cont(pushcontext, noComma ? arrowBodyNoComma : arrowBody, popcontext) : "operator" == type ? /\+\+|--/.test(value) || isTS && "!" == value ? cont(me) : isTS && "<" == value && cx.stream.match(/^([^>]|<.*?>)*>\s*\(/, !1) ? cont(pushlex(">"), commasep(typeexpr, ">"), poplex, me) : "?" == value ? cont(expression, expect(":"), expr) : cont(expr) : "quasi" == type ? pass(quasi, me) : ";" != type ? "(" == type ? contCommasep(expressionNoComma, ")", "call", me) : "." == type ? cont(property, me) : "[" == type ? cont(pushlex("]"), maybeexpression, expect("]"), poplex, me) : isTS && "as" == value ? (cx.marked = "keyword", cont(typeexpr, me)) : "regexp" == type ? (cx.state.lastType = cx.marked = "operator", cx.stream.backUp(cx.stream.pos - cx.stream.start - 1), cont(expr)) : void 0 : void 0
            }

            function quasi(type, value) {
                return "quasi" != type ? pass() : "${" != value.slice(value.length - 2) ? cont(quasi) : cont(expression, continueQuasi)
            }

            function continueQuasi(type) {
                if ("}" == type) return cx.marked = "string-2", cx.state.tokenize = tokenQuasi, cont(quasi)
            }

            function arrowBody(type) {
                return findFatArrow(cx.stream, cx.state), pass("{" == type ? statement : expression)
            }

            function arrowBodyNoComma(type) {
                return findFatArrow(cx.stream, cx.state), pass("{" == type ? statement : expressionNoComma)
            }

            function maybeTarget(noComma) {
                return function(type) {
                    return "." == type ? cont(noComma ? targetNoComma : target) : "variable" == type && isTS ? cont(maybeTypeArgs, noComma ? maybeoperatorNoComma : maybeoperatorComma) : pass(noComma ? expressionNoComma : expression)
                }
            }

            function target(_, value) {
                if ("target" == value) return cx.marked = "keyword", cont(maybeoperatorComma)
            }

            function targetNoComma(_, value) {
                if ("target" == value) return cx.marked = "keyword", cont(maybeoperatorNoComma)
            }

            function maybelabel(type) {
                return ":" == type ? cont(poplex, statement) : pass(maybeoperatorComma, expect(";"), poplex)
            }

            function property(type) {
                if ("variable" == type) return cx.marked = "property", cont()
            }

            function objprop(type, value) {
                if ("async" == type) return cx.marked = "property", cont(objprop);
                if ("variable" == type || "keyword" == cx.style) {
                    if (cx.marked = "property", "get" == value || "set" == value) return cont(getterSetter);
                    var m;
                    return isTS && cx.state.fatArrowAt == cx.stream.start && (m = cx.stream.match(/^\s*:\s*/, !1)) && (cx.state.fatArrowAt = cx.stream.pos + m[0].length), cont(afterprop)
                }
                return "number" == type || "string" == type ? (cx.marked = jsonldMode ? "property" : cx.style + " property", cont(afterprop)) : "jsonld-keyword" == type ? cont(afterprop) : isTS && isModifier(value) ? (cx.marked = "keyword",
                    cont(objprop)) : "[" == type ? cont(expression, maybetype, expect("]"), afterprop) : "spread" == type ? cont(expressionNoComma, afterprop) : "*" == value ? (cx.marked = "keyword", cont(objprop)) : ":" == type ? pass(afterprop) : void 0
            }

            function getterSetter(type) {
                return "variable" != type ? pass(afterprop) : (cx.marked = "property", cont(functiondef))
            }

            function afterprop(type) {
                return ":" == type ? cont(expressionNoComma) : "(" == type ? pass(functiondef) : void 0
            }

            function commasep(what, end, sep) {
                function proceed(type, value) {
                    if (sep ? sep.indexOf(type) > -1 : "," == type) {
                        var lex = cx.state.lexical;
                        return "call" == lex.info && (lex.pos = (lex.pos || 0) + 1), cont(function(type, value) {
                            return type == end || value == end ? pass() : pass(what)
                        }, proceed)
                    }
                    return type == end || value == end ? cont() : cont(expect(end))
                }
                return function(type, value) {
                    return type == end || value == end ? cont() : pass(what, proceed)
                }
            }

            function contCommasep(what, end, info) {
                for (var i = 3; i < arguments.length; i++) cx.cc.push(arguments[i]);
                return cont(pushlex(end, info), commasep(what, end), poplex)
            }

            function block(type) {
                return "}" == type ? cont() : pass(statement, block)
            }

            function maybetype(type, value) {
                if (isTS) {
                    if (":" == type) return cont(typeexpr);
                    if ("?" == value) return cont(maybetype)
                }
            }

            function mayberettype(type) {
                if (isTS && ":" == type) return cx.stream.match(/^\s*\w+\s+is\b/, !1) ? cont(expression, isKW, typeexpr) : cont(typeexpr)
            }

            function isKW(_, value) {
                if ("is" == value) return cx.marked = "keyword", cont()
            }

            function typeexpr(type, value) {
                return "keyof" == value || "typeof" == value ? (cx.marked = "keyword", cont("keyof" == value ? typeexpr : expressionNoComma)) : "variable" == type || "void" == value ? (cx.marked = "type", cont(afterType)) : "string" == type || "number" == type || "atom" == type ? cont(afterType) : "[" == type ? cont(pushlex("]"), commasep(typeexpr, "]", ","), poplex, afterType) : "{" == type ? cont(pushlex("}"), commasep(typeprop, "}", ",;"), poplex, afterType) : "(" == type ? cont(commasep(typearg, ")"), maybeReturnType) : "<" == type ? cont(commasep(typeexpr, ">"), typeexpr) : void 0
            }

            function maybeReturnType(type) {
                if ("=>" == type) return cont(typeexpr)
            }

            function typeprop(type, value) {
                return "variable" == type || "keyword" == cx.style ? (cx.marked = "property", cont(typeprop)) : "?" == value ? cont(typeprop) : ":" == type ? cont(typeexpr) : "[" == type ? cont(expression, maybetype, expect("]"), typeprop) : void 0
            }

            function typearg(type, value) {
                return "variable" == type && cx.stream.match(/^\s*[?:]/, !1) || "?" == value ? cont(typearg) : ":" == type ? cont(typeexpr) : pass(typeexpr)
            }

            function afterType(type, value) {
                return "<" == value ? cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType) : "|" == value || "." == type || "&" == value ? cont(typeexpr) : "[" == type ? cont(expect("]"), afterType) : "extends" == value || "implements" == value ? (cx.marked = "keyword", cont(typeexpr)) : void 0
            }

            function maybeTypeArgs(_, value) {
                if ("<" == value) return cont(pushlex(">"), commasep(typeexpr, ">"), poplex, afterType)
            }

            function typeparam() {
                return pass(typeexpr, maybeTypeDefault)
            }

            function maybeTypeDefault(_, value) {
                if ("=" == value) return cont(typeexpr)
            }

            function vardef(_, value) {
                return "enum" == value ? (cx.marked = "keyword", cont(enumdef)) : pass(pattern, maybetype, maybeAssign, vardefCont)
            }

            function pattern(type, value) {
                return isTS && isModifier(value) ? (cx.marked = "keyword", cont(pattern)) : "variable" == type ? (register(value), cont()) : "spread" == type ? cont(pattern) : "[" == type ? contCommasep(pattern, "]") : "{" == type ? contCommasep(proppattern, "}") : void 0
            }

            function proppattern(type, value) {
                return "variable" != type || cx.stream.match(/^\s*:/, !1) ? ("variable" == type && (cx.marked = "property"), "spread" == type ? cont(pattern) : "}" == type ? pass() : cont(expect(":"), pattern, maybeAssign)) : (register(value), cont(maybeAssign))
            }

            function maybeAssign(_type, value) {
                if ("=" == value) return cont(expressionNoComma)
            }

            function vardefCont(type) {
                if ("," == type) return cont(vardef)
            }

            function maybeelse(type, value) {
                if ("keyword b" == type && "else" == value) return cont(pushlex("form", "else"), statement, poplex)
            }

            function forspec(type, value) {
                return "await" == value ? cont(forspec) : "(" == type ? cont(pushlex(")"), forspec1, expect(")"), poplex) : void 0
            }

            function forspec1(type) {
                return "var" == type ? cont(vardef, expect(";"), forspec2) : ";" == type ? cont(forspec2) : "variable" == type ? cont(formaybeinof) : pass(expression, expect(";"), forspec2)
            }

            function formaybeinof(_type, value) {
                return "in" == value || "of" == value ? (cx.marked = "keyword", cont(expression)) : cont(maybeoperatorComma, forspec2)
            }

            function forspec2(type, value) {
                return ";" == type ? cont(forspec3) : "in" == value || "of" == value ? (cx.marked = "keyword", cont(expression)) : pass(expression, expect(";"), forspec3)
            }

            function forspec3(type) {
                ")" != type && cont(expression)
            }

            function functiondef(type, value) {
                return "*" == value ? (cx.marked = "keyword", cont(functiondef)) : "variable" == type ? (register(value), cont(functiondef)) : "(" == type ? cont(pushcontext, pushlex(")"), commasep(funarg, ")"), poplex, mayberettype, statement, popcontext) : isTS && "<" == value ? cont(pushlex(">"), commasep(typeparam, ">"), poplex, functiondef) : void 0
            }

            function funarg(type, value) {
                return "@" == value && cont(expression, funarg), "spread" == type ? cont(funarg) : isTS && isModifier(value) ? (cx.marked = "keyword", cont(funarg)) : pass(pattern, maybetype, maybeAssign)
            }

            function classExpression(type, value) {
                return "variable" == type ? className(type, value) : classNameAfter(type, value)
            }

            function className(type, value) {
                if ("variable" == type) return register(value), cont(classNameAfter)
            }

            function classNameAfter(type, value) {
                return "<" == value ? cont(pushlex(">"), commasep(typeparam, ">"), poplex, classNameAfter) : "extends" == value || "implements" == value || isTS && "," == type ? ("implements" == value && (cx.marked = "keyword"), cont(isTS ? typeexpr : expression, classNameAfter)) : "{" == type ? cont(pushlex("}"), classBody, poplex) : void 0
            }

            function classBody(type, value) {
                return "async" == type || "variable" == type && ("static" == value || "get" == value || "set" == value || isTS && isModifier(value)) && cx.stream.match(/^\s+[\w$\xa1-\uffff]/, !1) ? (cx.marked = "keyword", cont(classBody)) : "variable" == type || "keyword" == cx.style ? (cx.marked = "property", cont(isTS ? classfield : functiondef, classBody)) : "[" == type ? cont(expression, maybetype, expect("]"), isTS ? classfield : functiondef, classBody) : "*" == value ? (cx.marked = "keyword", cont(classBody)) : ";" == type ? cont(classBody) : "}" == type ? cont() : "@" == value ? cont(expression, classBody) : void 0
            }

            function classfield(type, value) {
                return "?" == value ? cont(classfield) : ":" == type ? cont(typeexpr, maybeAssign) : "=" == value ? cont(expressionNoComma) : pass(functiondef)
            }

            function afterExport(type, value) {
                return "*" == value ? (cx.marked = "keyword", cont(maybeFrom, expect(";"))) : "default" == value ? (cx.marked = "keyword", cont(expression, expect(";"))) : "{" == type ? cont(commasep(exportField, "}"), maybeFrom, expect(";")) : pass(statement)
            }

            function exportField(type, value) {
                return "as" == value ? (cx.marked = "keyword", cont(expect("variable"))) : "variable" == type ? pass(expressionNoComma, exportField) : void 0
            }

            function afterImport(type) {
                return "string" == type ? cont() : "(" == type ? pass(expression) : pass(importSpec, maybeMoreImports, maybeFrom)
            }

            function importSpec(type, value) {
                return "{" == type ? contCommasep(importSpec, "}") : ("variable" == type && register(value), "*" == value && (cx.marked = "keyword"), cont(maybeAs))
            }

            function maybeMoreImports(type) {
                if ("," == type) return cont(importSpec, maybeMoreImports)
            }

            function maybeAs(_type, value) {
                if ("as" == value) return cx.marked = "keyword", cont(importSpec)
            }

            function maybeFrom(_type, value) {
                if ("from" == value) return cx.marked = "keyword", cont(expression)
            }

            function arrayLiteral(type) {
                return "]" == type ? cont() : pass(commasep(expressionNoComma, "]"))
            }

            function enumdef() {
                return pass(pushlex("form"), pattern, expect("{"), pushlex("}"), commasep(enummember, "}"), poplex, poplex)
            }

            function enummember() {
                return pass(pattern, maybeAssign)
            }

            function isContinuedStatement(state, textAfter) {
                return "operator" == state.lastType || "," == state.lastType || isOperatorChar.test(textAfter.charAt(0)) || /[,.]/.test(textAfter.charAt(0))
            }

            function expressionAllowed(stream, state, backUp) {
                return state.tokenize == tokenBase && /^(?:operator|sof|keyword [bcd]|case|new|export|default|spread|[\[{}\(,;:]|=>)$/.test(state.lastType) || "quasi" == state.lastType && /\{\s*$/.test(stream.string.slice(0, stream.pos - (backUp || 0)))
            }
            var type, content, indentUnit = config.indentUnit,
                statementIndent = parserConfig.statementIndent,
                jsonldMode = parserConfig.jsonld,
                jsonMode = parserConfig.json || jsonldMode,
                isTS = parserConfig.typescript,
                wordRE = parserConfig.wordCharacters || /[\w$\xa1-\uffff]/,
                keywords = function() {
                    function kw(type) {
                        return {
                            type: type,
                            style: "keyword"
                        }
                    }
                    var A = kw("keyword a"),
                        B = kw("keyword b"),
                        C = kw("keyword c"),
                        D = kw("keyword d"),
                        operator = kw("operator"),
                        atom = {
                            type: "atom",
                            style: "atom"
                        };
                    return {
                        if: kw("if"),
                        while: A,
                        with: A,
                        else: B,
                        do: B,
                        try: B,
                        finally: B,
                        return: D,
                        break: D,
                        continue: D,
                        new: kw("new"),
                        delete: C,
                        void: C,
                        throw: C,
                        debugger: kw("debugger"),
                        var: kw("var"),
                        const: kw("var"),
                        let: kw("var"),
                        function: kw("function"),
                        catch: kw("catch"),
                        for: kw("for"),
                        switch: kw("switch"),
                        case: kw("case"),
                        default: kw("default"),
                        in: operator,
                        typeof: operator,
                        instanceof: operator,
                        true: atom,
                        false: atom,
                        null: atom,
                        undefined: atom,
                        NaN: atom,
                        Infinity: atom,
                        this: kw("this"),
                        class: kw("class"),
                        super: kw("atom"),
                        yield: C,
                        export: kw("export"),
                        import: kw("import"),
                        extends: C,
                        await: C
                    }
                }(),
                isOperatorChar = /[+\-*&%=<>!?|~^@]/,
                isJsonldKeyword = /^@(context|id|value|language|type|container|list|set|reverse|index|base|vocab|graph)"/,
                brackets = "([{}])",
                atomicTypes = {
                    atom: !0,
                    number: !0,
                    variable: !0,
                    string: !0,
                    regexp: !0,
                    this: !0,
                    "jsonld-keyword": !0
                },
                cx = {
                    state: null,
                    column: null,
                    marked: null,
                    cc: null
                },
                defaultVars = {
                    name: "this",
                    next: {
                        name: "arguments"
                    }
                };
            return poplex.lex = !0, {
                startState: function(basecolumn) {
                    var state = {
                        tokenize: tokenBase,
                        lastType: "sof",
                        cc: [],
                        lexical: new JSLexical((basecolumn || 0) - indentUnit, 0, "block", (!1)),
                        localVars: parserConfig.localVars,
                        context: parserConfig.localVars && {
                            vars: parserConfig.localVars
                        },
                        indented: basecolumn || 0
                    };
                    return parserConfig.globalVars && "object" == _typeof2(parserConfig.globalVars) && (state.globalVars = parserConfig.globalVars), state
                },
                token: function(stream, state) {
                    if (stream.sol() && (state.lexical.hasOwnProperty("align") || (state.lexical.align = !1), state.indented = stream.indentation(), findFatArrow(stream, state)), state.tokenize != tokenComment && stream.eatSpace()) return null;
                    var style = state.tokenize(stream, state);
                    return "comment" == type ? style : (state.lastType = "operator" != type || "++" != content && "--" != content ? type : "incdec", parseJS(state, style, type, content, stream))
                },
                indent: function(state, textAfter) {
                    if (state.tokenize == tokenComment) return CodeMirror.Pass;
                    if (state.tokenize != tokenBase) return 0;
                    var top, firstChar = textAfter && textAfter.charAt(0),
                        lexical = state.lexical;
                    if (!/^\s*else\b/.test(textAfter))
                        for (var i = state.cc.length - 1; i >= 0; --i) {
                            var c = state.cc[i];
                            if (c == poplex) lexical = lexical.prev;
                            else if (c != maybeelse) break
                        }
                    for (;
                        ("stat" == lexical.type || "form" == lexical.type) && ("}" == firstChar || (top = state.cc[state.cc.length - 1]) && (top == maybeoperatorComma || top == maybeoperatorNoComma) && !/^[,\.=+\-*:?[\(]/.test(textAfter));) lexical = lexical.prev;
                    statementIndent && ")" == lexical.type && "stat" == lexical.prev.type && (lexical = lexical.prev);
                    var type = lexical.type,
                        closing = firstChar == type;
                    return "vardef" == type ? lexical.indented + ("operator" == state.lastType || "," == state.lastType ? lexical.info + 1 : 0) : "form" == type && "{" == firstChar ? lexical.indented : "form" == type ? lexical.indented + indentUnit : "stat" == type ? lexical.indented + (isContinuedStatement(state, textAfter) ? statementIndent || indentUnit : 0) : "switch" != lexical.info || closing || 0 == parserConfig.doubleIndentSwitch ? lexical.align ? lexical.column + (closing ? 0 : 1) : lexical.indented + (closing ? 0 : indentUnit) : lexical.indented + (/^(?:case|default)\b/.test(textAfter) ? indentUnit : 2 * indentUnit)
                },
                electricInput: /^\s*(?:case .*?:|default:|\{|\})$/,
                blockCommentStart: jsonMode ? null : "/*",
                blockCommentEnd: jsonMode ? null : "*/",
                blockCommentContinue: jsonMode ? null : " * ",
                lineComment: jsonMode ? null : "//",
                fold: "brace",
                closeBrackets: "()[]{}''\"\"``",
                helperType: jsonMode ? "json" : "javascript",
                jsonldMode: jsonldMode,
                jsonMode: jsonMode,
                expressionAllowed: expressionAllowed,
                skipExpression: function(state) {
                    var top = state.cc[state.cc.length - 1];
                    top != expression && top != expressionNoComma || state.cc.pop()
                }
            }
        }), CodeMirror.registerHelper("wordChars", "javascript", /[\w$]/), CodeMirror.defineMIME("text/javascript", "javascript"), CodeMirror.defineMIME("text/ecmascript", "javascript"), CodeMirror.defineMIME("application/javascript", "javascript"), CodeMirror.defineMIME("application/x-javascript", "javascript"), CodeMirror.defineMIME("application/ecmascript", "javascript"), CodeMirror.defineMIME("application/json", {
            name: "javascript",
            json: !0
        }), CodeMirror.defineMIME("application/x-json", {
            name: "javascript",
            json: !0
        }), CodeMirror.defineMIME("application/ld+json", {
            name: "javascript",
            jsonld: !0
        }), CodeMirror.defineMIME("text/typescript", {
            name: "javascript",
            typescript: !0
        }), CodeMirror.defineMIME("application/typescript", {
            name: "javascript",
            typescript: !0
        })
    }),
    function(mod) {
        "object" == ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "object" == ("undefined" == typeof module ? "undefined" : _typeof2(module)) ? mod(require("../../lib/codemirror"), require("../xml/xml"), require("../javascript/javascript")): "function" == typeof define && define.amd ? define(["../../lib/codemirror", "../xml/xml", "../javascript/javascript"], mod) : mod(CodeMirror)
    }(function(CodeMirror) {
        "use strict";

        function Context(state, mode, depth, prev) {
            this.state = state, this.mode = mode, this.depth = depth, this.prev = prev
        }

        function copyContext(context) {
            return new Context(CodeMirror.copyState(context.mode, context.state), context.mode, context.depth, context.prev && copyContext(context.prev))
        }
        CodeMirror.defineMode("jsx", function(config, modeConfig) {
            function flatXMLIndent(state) {
                var tagName = state.tagName;
                state.tagName = null;
                var result = xmlMode.indent(state, "");
                return state.tagName = tagName, result
            }

            function token(stream, state) {
                return state.context.mode == xmlMode ? xmlToken(stream, state, state.context) : jsToken(stream, state, state.context)
            }

            function xmlToken(stream, state, cx) {
                if (2 == cx.depth) return stream.match(/^.*?\*\//) ? cx.depth = 1 : stream.skipToEnd(), "comment";
                if ("{" == stream.peek()) {
                    xmlMode.skipAttribute(cx.state);
                    var indent = flatXMLIndent(cx.state),
                        xmlContext = cx.state.context;
                    if (xmlContext && stream.match(/^[^>]*>\s*$/, !1)) {
                        for (; xmlContext.prev && !xmlContext.startOfLine;) xmlContext = xmlContext.prev;
                        xmlContext.startOfLine ? indent -= config.indentUnit : cx.prev.state.lexical && (indent = cx.prev.state.lexical.indented)
                    } else 1 == cx.depth && (indent += config.indentUnit);
                    return state.context = new Context(CodeMirror.startState(jsMode, indent), jsMode, 0, state.context), null
                }
                if (1 == cx.depth) {
                    if ("<" == stream.peek()) return xmlMode.skipAttribute(cx.state), state.context = new Context(CodeMirror.startState(xmlMode, flatXMLIndent(cx.state)), xmlMode, 0, state.context), null;
                    if (stream.match("//")) return stream.skipToEnd(), "comment";
                    if (stream.match("/*")) return cx.depth = 2, token(stream, state)
                }
                var stop, style = xmlMode.token(stream, cx.state),
                    cur = stream.current();
                return /\btag\b/.test(style) ? />$/.test(cur) ? cx.state.context ? cx.depth = 0 : state.context = state.context.prev : /^</.test(cur) && (cx.depth = 1) : !style && (stop = cur.indexOf("{")) > -1 && stream.backUp(cur.length - stop), style
            }

            function jsToken(stream, state, cx) {
                if ("<" == stream.peek() && jsMode.expressionAllowed(stream, cx.state)) return jsMode.skipExpression(cx.state), state.context = new Context(CodeMirror.startState(xmlMode, jsMode.indent(cx.state, "")), xmlMode, 0, state.context), null;
                var style = jsMode.token(stream, cx.state);
                if (!style && null != cx.depth) {
                    var cur = stream.current();
                    "{" == cur ? cx.depth++ : "}" == cur && 0 == --cx.depth && (state.context = state.context.prev)
                }
                return style
            }
            var xmlMode = CodeMirror.getMode(config, {
                    name: "xml",
                    allowMissing: !0,
                    multilineTagIndentPastTag: !1,
                    allowMissingTagName: !0
                }),
                jsMode = CodeMirror.getMode(config, modeConfig && modeConfig.base || "javascript");
            return {
                startState: function() {
                    return {
                        context: new Context(CodeMirror.startState(jsMode), jsMode)
                    }
                },
                copyState: function(state) {
                    return {
                        context: copyContext(state.context)
                    }
                },
                token: token,
                indent: function(state, textAfter, fullLine) {
                    return state.context.mode.indent(state.context.state, textAfter, fullLine)
                },
                innerMode: function(state) {
                    return state.context
                }
            }
        }, "xml", "javascript"), CodeMirror.defineMIME("text/jsx", "jsx"), CodeMirror.defineMIME("text/typescript-jsx", {
            name: "jsx",
            base: {
                name: "javascript",
                typescript: !0
            }
        })
    }),
    function(mod) {
        "object" == ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "object" == ("undefined" == typeof module ? "undefined" : _typeof2(module)) ? mod(require("../../lib/codemirror"), require("../htmlmixed/htmlmixed"), require("../clike/clike")): "function" == typeof define && define.amd ? define(["../../lib/codemirror", "../htmlmixed/htmlmixed", "../clike/clike"], mod) : mod(CodeMirror)
    }(function(CodeMirror) {
        "use strict";

        function keywords(str) {
            for (var obj = {}, words = str.split(" "), i = 0; i < words.length; ++i) obj[words[i]] = !0;
            return obj
        }

        function matchSequence(list, end, escapes) {
            return 0 == list.length ? phpString(end) : function(stream, state) {
                for (var patterns = list[0], i = 0; i < patterns.length; i++)
                    if (stream.match(patterns[i][0])) return state.tokenize = matchSequence(list.slice(1), end), patterns[i][1];
                return state.tokenize = phpString(end, escapes), "string"
            }
        }

        function phpString(closing, escapes) {
            return function(stream, state) {
                return phpString_(stream, state, closing, escapes)
            }
        }

        function phpString_(stream, state, closing, escapes) {
            if (escapes !== !1 && stream.match("${", !1) || stream.match("{$", !1)) return state.tokenize = null, "string";
            if (escapes !== !1 && stream.match(/^\$[a-zA-Z_][a-zA-Z0-9_]*/)) return stream.match("[", !1) && (state.tokenize = matchSequence([
                [
                    ["[", null]
                ],
                [
                    [/\d[\w\.]*/, "number"],
                    [/\$[a-zA-Z_][a-zA-Z0-9_]*/, "variable-2"],
                    [/[\w\$]+/, "variable"]
                ],
                [
                    ["]", null]
                ]
            ], closing, escapes)), stream.match(/\-\>\w/, !1) && (state.tokenize = matchSequence([
                [
                    ["->", null]
                ],
                [
                    [/[\w]+/, "variable"]
                ]
            ], closing, escapes)), "variable-2";
            for (var escaped = !1; !stream.eol() && (escaped || escapes === !1 || !stream.match("{$", !1) && !stream.match(/^(\$[a-zA-Z_][a-zA-Z0-9_]*|\$\{)/, !1));) {
                if (!escaped && stream.match(closing)) {
                    state.tokenize = null, state.tokStack.pop(), state.tokStack.pop();
                    break
                }
                escaped = "\\" == stream.next() && !escaped
            }
            return "string"
        }
        var phpKeywords = "abstract and array as break case catch class clone const continue declare default do else elseif enddeclare endfor endforeach endif endswitch endwhile extends final for foreach function global goto if implements interface instanceof namespace new or private protected public static switch throw trait try use var while xor die echo empty exit eval include include_once isset list require require_once return print unset __halt_compiler self static parent yield insteadof finally",
            phpAtoms = "true false null TRUE FALSE NULL __CLASS__ __DIR__ __FILE__ __LINE__ __METHOD__ __FUNCTION__ __NAMESPACE__ __TRAIT__",
            phpBuiltin = "func_num_args func_get_arg func_get_args strlen strcmp strncmp strcasecmp strncasecmp each error_reporting define defined trigger_error user_error set_error_handler restore_error_handler get_declared_classes get_loaded_extensions extension_loaded get_extension_funcs debug_backtrace constant bin2hex hex2bin sleep usleep time mktime gmmktime strftime gmstrftime strtotime date gmdate getdate localtime checkdate flush wordwrap htmlspecialchars htmlentities html_entity_decode md5 md5_file crc32 getimagesize image_type_to_mime_type phpinfo phpversion phpcredits strnatcmp strnatcasecmp substr_count strspn strcspn strtok strtoupper strtolower strpos strrpos strrev hebrev hebrevc nl2br basename dirname pathinfo stripslashes stripcslashes strstr stristr strrchr str_shuffle str_word_count strcoll substr substr_replace quotemeta ucfirst ucwords strtr addslashes addcslashes rtrim str_replace str_repeat count_chars chunk_split trim ltrim strip_tags similar_text explode implode setlocale localeconv parse_str str_pad chop strchr sprintf printf vprintf vsprintf sscanf fscanf parse_url urlencode urldecode rawurlencode rawurldecode readlink linkinfo link unlink exec system escapeshellcmd escapeshellarg passthru shell_exec proc_open proc_close rand srand getrandmax mt_rand mt_srand mt_getrandmax base64_decode base64_encode abs ceil floor round is_finite is_nan is_infinite bindec hexdec octdec decbin decoct dechex base_convert number_format fmod ip2long long2ip getenv putenv getopt microtime gettimeofday getrusage uniqid quoted_printable_decode set_time_limit get_cfg_var magic_quotes_runtime set_magic_quotes_runtime get_magic_quotes_gpc get_magic_quotes_runtime import_request_variables error_log serialize unserialize memory_get_usage var_dump var_export debug_zval_dump print_r highlight_file show_source highlight_string ini_get ini_get_all ini_set ini_alter ini_restore get_include_path set_include_path restore_include_path setcookie header headers_sent connection_aborted connection_status ignore_user_abort parse_ini_file is_uploaded_file move_uploaded_file intval floatval doubleval strval gettype settype is_null is_resource is_bool is_long is_float is_int is_integer is_double is_real is_numeric is_string is_array is_object is_scalar ereg ereg_replace eregi eregi_replace split spliti join sql_regcase dl pclose popen readfile rewind rmdir umask fclose feof fgetc fgets fgetss fread fopen fpassthru ftruncate fstat fseek ftell fflush fwrite fputs mkdir rename copy tempnam tmpfile file file_get_contents file_put_contents stream_select stream_context_create stream_context_set_params stream_context_set_option stream_context_get_options stream_filter_prepend stream_filter_append fgetcsv flock get_meta_tags stream_set_write_buffer set_file_buffer set_socket_blocking stream_set_blocking socket_set_blocking stream_get_meta_data stream_register_wrapper stream_wrapper_register stream_set_timeout socket_set_timeout socket_get_status realpath fnmatch fsockopen pfsockopen pack unpack get_browser crypt opendir closedir chdir getcwd rewinddir readdir dir glob fileatime filectime filegroup fileinode filemtime fileowner fileperms filesize filetype file_exists is_writable is_writeable is_readable is_executable is_file is_dir is_link stat lstat chown touch clearstatcache mail ob_start ob_flush ob_clean ob_end_flush ob_end_clean ob_get_flush ob_get_clean ob_get_length ob_get_level ob_get_status ob_get_contents ob_implicit_flush ob_list_handlers ksort krsort natsort natcasesort asort arsort sort rsort usort uasort uksort shuffle array_walk count end prev next reset current key min max in_array array_search extract compact array_fill range array_multisort array_push array_pop array_shift array_unshift array_splice array_slice array_merge array_merge_recursive array_keys array_values array_count_values array_reverse array_reduce array_pad array_flip array_change_key_case array_rand array_unique array_intersect array_intersect_assoc array_diff array_diff_assoc array_sum array_filter array_map array_chunk array_key_exists array_intersect_key array_combine array_column pos sizeof key_exists assert assert_options version_compare ftok str_rot13 aggregate session_name session_module_name session_save_path session_id session_regenerate_id session_decode session_register session_unregister session_is_registered session_encode session_start session_destroy session_unset session_set_save_handler session_cache_limiter session_cache_expire session_set_cookie_params session_get_cookie_params session_write_close preg_match preg_match_all preg_replace preg_replace_callback preg_split preg_quote preg_grep overload ctype_alnum ctype_alpha ctype_cntrl ctype_digit ctype_lower ctype_graph ctype_print ctype_punct ctype_space ctype_upper ctype_xdigit virtual apache_request_headers apache_note apache_lookup_uri apache_child_terminate apache_setenv apache_response_headers apache_get_version getallheaders mysql_connect mysql_pconnect mysql_close mysql_select_db mysql_create_db mysql_drop_db mysql_query mysql_unbuffered_query mysql_db_query mysql_list_dbs mysql_list_tables mysql_list_fields mysql_list_processes mysql_error mysql_errno mysql_affected_rows mysql_insert_id mysql_result mysql_num_rows mysql_num_fields mysql_fetch_row mysql_fetch_array mysql_fetch_assoc mysql_fetch_object mysql_data_seek mysql_fetch_lengths mysql_fetch_field mysql_field_seek mysql_free_result mysql_field_name mysql_field_table mysql_field_len mysql_field_type mysql_field_flags mysql_escape_string mysql_real_escape_string mysql_stat mysql_thread_id mysql_client_encoding mysql_get_client_info mysql_get_host_info mysql_get_proto_info mysql_get_server_info mysql_info mysql mysql_fieldname mysql_fieldtable mysql_fieldlen mysql_fieldtype mysql_fieldflags mysql_selectdb mysql_createdb mysql_dropdb mysql_freeresult mysql_numfields mysql_numrows mysql_listdbs mysql_listtables mysql_listfields mysql_db_name mysql_dbname mysql_tablename mysql_table_name pg_connect pg_pconnect pg_close pg_connection_status pg_connection_busy pg_connection_reset pg_host pg_dbname pg_port pg_tty pg_options pg_ping pg_query pg_send_query pg_cancel_query pg_fetch_result pg_fetch_row pg_fetch_assoc pg_fetch_array pg_fetch_object pg_fetch_all pg_affected_rows pg_get_result pg_result_seek pg_result_status pg_free_result pg_last_oid pg_num_rows pg_num_fields pg_field_name pg_field_num pg_field_size pg_field_type pg_field_prtlen pg_field_is_null pg_get_notify pg_get_pid pg_result_error pg_last_error pg_last_notice pg_put_line pg_end_copy pg_copy_to pg_copy_from pg_trace pg_untrace pg_lo_create pg_lo_unlink pg_lo_open pg_lo_close pg_lo_read pg_lo_write pg_lo_read_all pg_lo_import pg_lo_export pg_lo_seek pg_lo_tell pg_escape_string pg_escape_bytea pg_unescape_bytea pg_client_encoding pg_set_client_encoding pg_meta_data pg_convert pg_insert pg_update pg_delete pg_select pg_exec pg_getlastoid pg_cmdtuples pg_errormessage pg_numrows pg_numfields pg_fieldname pg_fieldsize pg_fieldtype pg_fieldnum pg_fieldprtlen pg_fieldisnull pg_freeresult pg_result pg_loreadall pg_locreate pg_lounlink pg_loopen pg_loclose pg_loread pg_lowrite pg_loimport pg_loexport http_response_code get_declared_traits getimagesizefromstring socket_import_stream stream_set_chunk_size trait_exists header_register_callback class_uses session_status session_register_shutdown echo print global static exit array empty eval isset unset die include require include_once require_once json_decode json_encode json_last_error json_last_error_msg curl_close curl_copy_handle curl_errno curl_error curl_escape curl_exec curl_file_create curl_getinfo curl_init curl_multi_add_handle curl_multi_close curl_multi_exec curl_multi_getcontent curl_multi_info_read curl_multi_init curl_multi_remove_handle curl_multi_select curl_multi_setopt curl_multi_strerror curl_pause curl_reset curl_setopt_array curl_setopt curl_share_close curl_share_init curl_share_setopt curl_strerror curl_unescape curl_version mysqli_affected_rows mysqli_autocommit mysqli_change_user mysqli_character_set_name mysqli_close mysqli_commit mysqli_connect_errno mysqli_connect_error mysqli_connect mysqli_data_seek mysqli_debug mysqli_dump_debug_info mysqli_errno mysqli_error_list mysqli_error mysqli_fetch_all mysqli_fetch_array mysqli_fetch_assoc mysqli_fetch_field_direct mysqli_fetch_field mysqli_fetch_fields mysqli_fetch_lengths mysqli_fetch_object mysqli_fetch_row mysqli_field_count mysqli_field_seek mysqli_field_tell mysqli_free_result mysqli_get_charset mysqli_get_client_info mysqli_get_client_stats mysqli_get_client_version mysqli_get_connection_stats mysqli_get_host_info mysqli_get_proto_info mysqli_get_server_info mysqli_get_server_version mysqli_info mysqli_init mysqli_insert_id mysqli_kill mysqli_more_results mysqli_multi_query mysqli_next_result mysqli_num_fields mysqli_num_rows mysqli_options mysqli_ping mysqli_prepare mysqli_query mysqli_real_connect mysqli_real_escape_string mysqli_real_query mysqli_reap_async_query mysqli_refresh mysqli_rollback mysqli_select_db mysqli_set_charset mysqli_set_local_infile_default mysqli_set_local_infile_handler mysqli_sqlstate mysqli_ssl_set mysqli_stat mysqli_stmt_init mysqli_store_result mysqli_thread_id mysqli_thread_safe mysqli_use_result mysqli_warning_count";
        CodeMirror.registerHelper("hintWords", "php", [phpKeywords, phpAtoms, phpBuiltin].join(" ").split(" ")), CodeMirror.registerHelper("wordChars", "php", /[\w$]/);
        var phpConfig = {
            name: "clike",
            helperType: "php",
            keywords: keywords(phpKeywords),
            blockKeywords: keywords("catch do else elseif for foreach if switch try while finally"),
            defKeywords: keywords("class function interface namespace trait"),
            atoms: keywords(phpAtoms),
            builtin: keywords(phpBuiltin),
            multiLineStrings: !0,
            hooks: {
                $: function(stream) {
                    return stream.eatWhile(/[\w\$_]/), "variable-2"
                },
                "<": function(stream, state) {
                    var before;
                    if (before = stream.match(/<<\s*/)) {
                        var quoted = stream.eat(/['"]/);
                        stream.eatWhile(/[\w\.]/);
                        var delim = stream.current().slice(before[0].length + (quoted ? 2 : 1));
                        if (quoted && stream.eat(quoted), delim) return (state.tokStack || (state.tokStack = [])).push(delim, 0), state.tokenize = phpString(delim, "'" != quoted), "string"
                    }
                    return !1
                },
                "#": function(stream) {
                    for (; !stream.eol() && !stream.match("?>", !1);) stream.next();
                    return "comment"
                },
                "/": function(stream) {
                    if (stream.eat("/")) {
                        for (; !stream.eol() && !stream.match("?>", !1);) stream.next();
                        return "comment"
                    }
                    return !1
                },
                '"': function(_stream, state) {
                    return (state.tokStack || (state.tokStack = [])).push('"', 0), state.tokenize = phpString('"'), "string"
                },
                "{": function(_stream, state) {
                    return state.tokStack && state.tokStack.length && state.tokStack[state.tokStack.length - 1]++, !1
                },
                "}": function(_stream, state) {
                    return state.tokStack && state.tokStack.length > 0 && !--state.tokStack[state.tokStack.length - 1] && (state.tokenize = phpString(state.tokStack[state.tokStack.length - 2])), !1
                }
            }
        };
        CodeMirror.defineMode("php", function(config, parserConfig) {
            function dispatch(stream, state) {
                var isPHP = state.curMode == phpMode;
                if (stream.sol() && state.pending && '"' != state.pending && "'" != state.pending && (state.pending = null), isPHP) return isPHP && null == state.php.tokenize && stream.match("?>") ? (state.curMode = htmlMode, state.curState = state.html, state.php.context.prev || (state.php = null), "meta") : phpMode.token(stream, state.curState);
                if (stream.match(/^<\?\w*/)) return state.curMode = phpMode, state.php || (state.php = CodeMirror.startState(phpMode, htmlMode.indent(state.html, ""))), state.curState = state.php, "meta";
                if ('"' == state.pending || "'" == state.pending) {
                    for (; !stream.eol() && stream.next() != state.pending;);
                    var style = "string"
                } else if (state.pending && stream.pos < state.pending.end) {
                    stream.pos = state.pending.end;
                    var style = state.pending.style
                } else var style = htmlMode.token(stream, state.curState);
                state.pending && (state.pending = null);
                var m, cur = stream.current(),
                    openPHP = cur.search(/<\?/);
                return openPHP != -1 && ("string" == style && (m = cur.match(/[\'\"]$/)) && !/\?>/.test(cur) ? state.pending = m[0] : state.pending = {
                    end: stream.pos,
                    style: style
                }, stream.backUp(cur.length - openPHP)), style
            }
            var htmlMode = CodeMirror.getMode(config, parserConfig && parserConfig.htmlMode || "text/html"),
                phpMode = CodeMirror.getMode(config, phpConfig);
            return {
                startState: function() {
                    var html = CodeMirror.startState(htmlMode),
                        php = parserConfig.startOpen ? CodeMirror.startState(phpMode) : null;
                    return {
                        html: html,
                        php: php,
                        curMode: parserConfig.startOpen ? phpMode : htmlMode,
                        curState: parserConfig.startOpen ? php : html,
                        pending: null
                    }
                },
                copyState: function(state) {
                    var cur, html = state.html,
                        htmlNew = CodeMirror.copyState(htmlMode, html),
                        php = state.php,
                        phpNew = php && CodeMirror.copyState(phpMode, php);
                    return cur = state.curMode == htmlMode ? htmlNew : phpNew, {
                        html: htmlNew,
                        php: phpNew,
                        curMode: state.curMode,
                        curState: cur,
                        pending: state.pending
                    }
                },
                token: dispatch,
                indent: function(state, textAfter) {
                    return state.curMode != phpMode && /^\s*<\//.test(textAfter) || state.curMode == phpMode && /^\?>/.test(textAfter) ? htmlMode.indent(state.html, textAfter) : state.curMode.indent(state.curState, textAfter)
                },
                blockCommentStart: "/*",
                blockCommentEnd: "*/",
                lineComment: "//",
                innerMode: function(state) {
                    return {
                        state: state.curState,
                        mode: state.curMode
                    }
                }
            }
        }, "htmlmixed", "clike"), CodeMirror.defineMIME("application/x-httpd-php", "php"), CodeMirror.defineMIME("application/x-httpd-php-open", {
            name: "php",
            startOpen: !0
        }), CodeMirror.defineMIME("text/x-php", phpConfig)
    }),
    function(mod) {
        "object" == ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "object" == ("undefined" == typeof module ? "undefined" : _typeof2(module)) ? mod(require("../../lib/codemirror")): "function" == typeof define && define.amd ? define(["../../lib/codemirror"], mod) : mod(CodeMirror)
    }(function(CodeMirror) {
        "use strict";

        function Context(indented, column, type, info, align, prev) {
            this.indented = indented, this.column = column, this.type = type, this.info = info, this.align = align, this.prev = prev
        }

        function pushContext(state, col, type, info) {
            var indent = state.indented;
            return state.context && "statement" == state.context.type && "statement" != type && (indent = state.context.indented),
                state.context = new Context(indent, col, type, info, null, state.context)
        }

        function popContext(state) {
            var t = state.context.type;
            return ")" != t && "]" != t && "}" != t || (state.indented = state.context.indented), state.context = state.context.prev
        }

        function typeBefore(stream, state, pos) {
            return "variable" == state.prevToken || "type" == state.prevToken || (!!/\S(?:[^- ]>|[*\]])\s*$|\*$/.test(stream.string.slice(0, pos)) || (!(!state.typeAtEndOfLine || stream.column() != stream.indentation()) || void 0))
        }

        function isTopScope(context) {
            for (;;) {
                if (!context || "top" == context.type) return !0;
                if ("}" == context.type && "namespace" != context.prev.info) return !1;
                context = context.prev
            }
        }

        function words(str) {
            for (var obj = {}, words = str.split(" "), i = 0; i < words.length; ++i) obj[words[i]] = !0;
            return obj
        }

        function contains(words, word) {
            return "function" == typeof words ? words(word) : words.propertyIsEnumerable(word)
        }

        function cppHook(stream, state) {
            if (!state.startOfLine) return !1;
            for (var ch, next = null; ch = stream.peek();) {
                if ("\\" == ch && stream.match(/^.$/)) {
                    next = cppHook;
                    break
                }
                if ("/" == ch && stream.match(/^\/[\/\*]/, !1)) break;
                stream.next()
            }
            return state.tokenize = next, "meta"
        }

        function pointerHook(_stream, state) {
            return "type" == state.prevToken && "type"
        }

        function cpp14Literal(stream) {
            return stream.eatWhile(/[\w\.']/), "number"
        }

        function cpp11StringHook(stream, state) {
            if (stream.backUp(1), stream.match(/(R|u8R|uR|UR|LR)/)) {
                var match = stream.match(/"([^\s\\()]{0,16})\(/);
                return !!match && (state.cpp11RawStringDelim = match[1], state.tokenize = tokenRawString, tokenRawString(stream, state))
            }
            return stream.match(/(u8|u|U|L)/) ? !!stream.match(/["']/, !1) && "string" : (stream.next(), !1)
        }

        function cppLooksLikeConstructor(word) {
            var lastTwo = /(\w+)::~?(\w+)$/.exec(word);
            return lastTwo && lastTwo[1] == lastTwo[2]
        }

        function tokenAtString(stream, state) {
            for (var next; null != (next = stream.next());)
                if ('"' == next && !stream.eat('"')) {
                    state.tokenize = null;
                    break
                } return "string"
        }

        function tokenRawString(stream, state) {
            var delim = state.cpp11RawStringDelim.replace(/[^\w\s]/g, "\\$&"),
                match = stream.match(new RegExp(".*?\\)" + delim + '"'));
            return match ? state.tokenize = null : stream.skipToEnd(), "string"
        }

        function def(mimes, mode) {
            function add(obj) {
                if (obj)
                    for (var prop in obj) obj.hasOwnProperty(prop) && words.push(prop)
            }
            "string" == typeof mimes && (mimes = [mimes]);
            var words = [];
            add(mode.keywords), add(mode.types), add(mode.builtin), add(mode.atoms), words.length && (mode.helperType = mimes[0], CodeMirror.registerHelper("hintWords", mimes[0], words));
            for (var i = 0; i < mimes.length; ++i) CodeMirror.defineMIME(mimes[i], mode)
        }

        function tokenTripleString(stream, state) {
            for (var escaped = !1; !stream.eol();) {
                if (!escaped && stream.match('"""')) {
                    state.tokenize = null;
                    break
                }
                escaped = "\\" == stream.next() && !escaped
            }
            return "string"
        }

        function tokenNestedComment(depth) {
            return function(stream, state) {
                for (var ch; ch = stream.next();) {
                    if ("*" == ch && stream.eat("/")) {
                        if (1 == depth) {
                            state.tokenize = null;
                            break
                        }
                        return state.tokenize = tokenNestedComment(depth - 1), state.tokenize(stream, state)
                    }
                    if ("/" == ch && stream.eat("*")) return state.tokenize = tokenNestedComment(depth + 1), state.tokenize(stream, state)
                }
                return "comment"
            }
        }

        function tokenKotlinString(tripleString) {
            return function(stream, state) {
                for (var next, escaped = !1, end = !1; !stream.eol();) {
                    if (!tripleString && !escaped && stream.match('"')) {
                        end = !0;
                        break
                    }
                    if (tripleString && stream.match('"""')) {
                        end = !0;
                        break
                    }
                    next = stream.next(), !escaped && "$" == next && stream.match("{") && stream.skipTo("}"), escaped = !escaped && "\\" == next && !tripleString
                }
                return !end && tripleString || (state.tokenize = null), "string"
            }
        }

        function tokenCeylonString(type) {
            return function(stream, state) {
                for (var next, escaped = !1, end = !1; !stream.eol();) {
                    if (!escaped && stream.match('"') && ("single" == type || stream.match('""'))) {
                        end = !0;
                        break
                    }
                    if (!escaped && stream.match("``")) {
                        stringTokenizer = tokenCeylonString(type), end = !0;
                        break
                    }
                    next = stream.next(), escaped = "single" == type && !escaped && "\\" == next
                }
                return end && (state.tokenize = null), "string"
            }
        }
        CodeMirror.defineMode("clike", function(config, parserConfig) {
            function tokenBase(stream, state) {
                var ch = stream.next();
                if (hooks[ch]) {
                    var result = hooks[ch](stream, state);
                    if (result !== !1) return result
                }
                if ('"' == ch || "'" == ch) return state.tokenize = tokenString(ch), state.tokenize(stream, state);
                if (isPunctuationChar.test(ch)) return curPunc = ch, null;
                if (numberStart.test(ch)) {
                    if (stream.backUp(1), stream.match(number)) return "number";
                    stream.next()
                }
                if ("/" == ch) {
                    if (stream.eat("*")) return state.tokenize = tokenComment, tokenComment(stream, state);
                    if (stream.eat("/")) return stream.skipToEnd(), "comment"
                }
                if (isOperatorChar.test(ch)) {
                    for (; !stream.match(/^\/[\/*]/, !1) && stream.eat(isOperatorChar););
                    return "operator"
                }
                if (stream.eatWhile(isIdentifierChar), namespaceSeparator)
                    for (; stream.match(namespaceSeparator);) stream.eatWhile(isIdentifierChar);
                var cur = stream.current();
                return contains(keywords, cur) ? (contains(blockKeywords, cur) && (curPunc = "newstatement"), contains(defKeywords, cur) && (isDefKeyword = !0), "keyword") : contains(types, cur) ? "type" : contains(builtin, cur) ? (contains(blockKeywords, cur) && (curPunc = "newstatement"), "builtin") : contains(atoms, cur) ? "atom" : "variable"
            }

            function tokenString(quote) {
                return function(stream, state) {
                    for (var next, escaped = !1, end = !1; null != (next = stream.next());) {
                        if (next == quote && !escaped) {
                            end = !0;
                            break
                        }
                        escaped = !escaped && "\\" == next
                    }
                    return (end || !escaped && !multiLineStrings) && (state.tokenize = null), "string"
                }
            }

            function tokenComment(stream, state) {
                for (var ch, maybeEnd = !1; ch = stream.next();) {
                    if ("/" == ch && maybeEnd) {
                        state.tokenize = null;
                        break
                    }
                    maybeEnd = "*" == ch
                }
                return "comment"
            }

            function maybeEOL(stream, state) {
                parserConfig.typeFirstDefinitions && stream.eol() && isTopScope(state.context) && (state.typeAtEndOfLine = typeBefore(stream, state, stream.pos))
            }
            var curPunc, isDefKeyword, indentUnit = config.indentUnit,
                statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,
                dontAlignCalls = parserConfig.dontAlignCalls,
                keywords = parserConfig.keywords || {},
                types = parserConfig.types || {},
                builtin = parserConfig.builtin || {},
                blockKeywords = parserConfig.blockKeywords || {},
                defKeywords = parserConfig.defKeywords || {},
                atoms = parserConfig.atoms || {},
                hooks = parserConfig.hooks || {},
                multiLineStrings = parserConfig.multiLineStrings,
                indentStatements = parserConfig.indentStatements !== !1,
                indentSwitch = parserConfig.indentSwitch !== !1,
                namespaceSeparator = parserConfig.namespaceSeparator,
                isPunctuationChar = parserConfig.isPunctuationChar || /[\[\]{}\(\),;\:\.]/,
                numberStart = parserConfig.numberStart || /[\d\.]/,
                number = parserConfig.number || /^(?:0x[a-f\d]+|0b[01]+|(?:\d+\.?\d*|\.\d+)(?:e[-+]?\d+)?)(u|ll?|l|f)?/i,
                isOperatorChar = parserConfig.isOperatorChar || /[+\-*&%=<>!?|\/]/,
                isIdentifierChar = parserConfig.isIdentifierChar || /[\w\$_\xa1-\uffff]/;
            return {
                startState: function(basecolumn) {
                    return {
                        tokenize: null,
                        context: new Context((basecolumn || 0) - indentUnit, 0, "top", null, (!1)),
                        indented: 0,
                        startOfLine: !0,
                        prevToken: null
                    }
                },
                token: function(stream, state) {
                    var ctx = state.context;
                    if (stream.sol() && (null == ctx.align && (ctx.align = !1), state.indented = stream.indentation(), state.startOfLine = !0), stream.eatSpace()) return maybeEOL(stream, state), null;
                    curPunc = isDefKeyword = null;
                    var style = (state.tokenize || tokenBase)(stream, state);
                    if ("comment" == style || "meta" == style) return style;
                    if (null == ctx.align && (ctx.align = !0), ";" == curPunc || ":" == curPunc || "," == curPunc && stream.match(/^\s*(?:\/\/.*)?$/, !1))
                        for (;
                            "statement" == state.context.type;) popContext(state);
                    else if ("{" == curPunc) pushContext(state, stream.column(), "}");
                    else if ("[" == curPunc) pushContext(state, stream.column(), "]");
                    else if ("(" == curPunc) pushContext(state, stream.column(), ")");
                    else if ("}" == curPunc) {
                        for (;
                            "statement" == ctx.type;) ctx = popContext(state);
                        for ("}" == ctx.type && (ctx = popContext(state));
                            "statement" == ctx.type;) ctx = popContext(state)
                    } else curPunc == ctx.type ? popContext(state) : indentStatements && (("}" == ctx.type || "top" == ctx.type) && ";" != curPunc || "statement" == ctx.type && "newstatement" == curPunc) && pushContext(state, stream.column(), "statement", stream.current());
                    if ("variable" == style && ("def" == state.prevToken || parserConfig.typeFirstDefinitions && typeBefore(stream, state, stream.start) && isTopScope(state.context) && stream.match(/^\s*\(/, !1)) && (style = "def"), hooks.token) {
                        var result = hooks.token(stream, state, style);
                        void 0 !== result && (style = result)
                    }
                    return "def" == style && parserConfig.styleDefs === !1 && (style = "variable"), state.startOfLine = !1, state.prevToken = isDefKeyword ? "def" : style || curPunc, maybeEOL(stream, state), style
                },
                indent: function(state, textAfter) {
                    if (state.tokenize != tokenBase && null != state.tokenize || state.typeAtEndOfLine) return CodeMirror.Pass;
                    var ctx = state.context,
                        firstChar = textAfter && textAfter.charAt(0);
                    if ("statement" == ctx.type && "}" == firstChar && (ctx = ctx.prev), parserConfig.dontIndentStatements)
                        for (;
                            "statement" == ctx.type && parserConfig.dontIndentStatements.test(ctx.info);) ctx = ctx.prev;
                    if (hooks.indent) {
                        var hook = hooks.indent(state, ctx, textAfter);
                        if ("number" == typeof hook) return hook
                    }
                    var closing = firstChar == ctx.type,
                        switchBlock = ctx.prev && "switch" == ctx.prev.info;
                    if (parserConfig.allmanIndentation && /[{(]/.test(firstChar)) {
                        for (;
                            "top" != ctx.type && "}" != ctx.type;) ctx = ctx.prev;
                        return ctx.indented
                    }
                    return "statement" == ctx.type ? ctx.indented + ("{" == firstChar ? 0 : statementIndentUnit) : !ctx.align || dontAlignCalls && ")" == ctx.type ? ")" != ctx.type || closing ? ctx.indented + (closing ? 0 : indentUnit) + (closing || !switchBlock || /^(?:case|default)\b/.test(textAfter) ? 0 : indentUnit) : ctx.indented + statementIndentUnit : ctx.column + (closing ? 0 : 1)
                },
                electricInput: indentSwitch ? /^\s*(?:case .*?:|default:|\{\}?|\})$/ : /^\s*[{}]$/,
                blockCommentStart: "/*",
                blockCommentEnd: "*/",
                blockCommentContinue: " * ",
                lineComment: "//",
                fold: "brace"
            }
        });
        var cKeywords = "auto if break case register continue return default do sizeof static else struct switch extern typedef union for goto while enum const volatile",
            cTypes = "int long char short double float unsigned signed void size_t ptrdiff_t";
        def(["text/x-csrc", "text/x-c", "text/x-chdr"], {
            name: "clike",
            keywords: words(cKeywords),
            types: words(cTypes + " bool _Complex _Bool float_t double_t intptr_t intmax_t int8_t int16_t int32_t int64_t uintptr_t uintmax_t uint8_t uint16_t uint32_t uint64_t"),
            blockKeywords: words("case do else for if switch while struct"),
            defKeywords: words("struct"),
            typeFirstDefinitions: !0,
            atoms: words("NULL true false"),
            hooks: {
                "#": cppHook,
                "*": pointerHook
            },
            modeProps: {
                fold: ["brace", "include"]
            }
        }), def(["text/x-c++src", "text/x-c++hdr"], {
            name: "clike",
            keywords: words(cKeywords + " asm dynamic_cast namespace reinterpret_cast try explicit new static_cast typeid catch operator template typename class friend private this using const_cast inline public throw virtual delete mutable protected alignas alignof constexpr decltype nullptr noexcept thread_local final static_assert override"),
            types: words(cTypes + " bool wchar_t"),
            blockKeywords: words("catch class do else finally for if struct switch try while"),
            defKeywords: words("class namespace struct enum union"),
            typeFirstDefinitions: !0,
            atoms: words("true false NULL"),
            dontIndentStatements: /^template$/,
            isIdentifierChar: /[\w\$_~\xa1-\uffff]/,
            hooks: {
                "#": cppHook,
                "*": pointerHook,
                u: cpp11StringHook,
                U: cpp11StringHook,
                L: cpp11StringHook,
                R: cpp11StringHook,
                0: cpp14Literal,
                1: cpp14Literal,
                2: cpp14Literal,
                3: cpp14Literal,
                4: cpp14Literal,
                5: cpp14Literal,
                6: cpp14Literal,
                7: cpp14Literal,
                8: cpp14Literal,
                9: cpp14Literal,
                token: function(stream, state, style) {
                    if ("variable" == style && "(" == stream.peek() && (";" == state.prevToken || null == state.prevToken || "}" == state.prevToken) && cppLooksLikeConstructor(stream.current())) return "def"
                }
            },
            namespaceSeparator: "::",
            modeProps: {
                fold: ["brace", "include"]
            }
        }), def("text/x-java", {
            name: "clike",
            keywords: words("abstract assert break case catch class const continue default do else enum extends final finally float for goto if implements import instanceof interface native new package private protected public return static strictfp super switch synchronized this throw throws transient try volatile while @interface"),
            types: words("byte short int long float double boolean char void Boolean Byte Character Double Float Integer Long Number Object Short String StringBuffer StringBuilder Void"),
            blockKeywords: words("catch class do else finally for if switch try while"),
            defKeywords: words("class interface enum @interface"),
            typeFirstDefinitions: !0,
            atoms: words("true false null"),
            number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+\.?\d*|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
            hooks: {
                "@": function(stream) {
                    return !stream.match("interface", !1) && (stream.eatWhile(/[\w\$_]/), "meta")
                }
            },
            modeProps: {
                fold: ["brace", "import"]
            }
        }), def("text/x-csharp", {
            name: "clike",
            keywords: words("abstract as async await base break case catch checked class const continue default delegate do else enum event explicit extern finally fixed for foreach goto if implicit in interface internal is lock namespace new operator out override params private protected public readonly ref return sealed sizeof stackalloc static struct switch this throw try typeof unchecked unsafe using virtual void volatile while add alias ascending descending dynamic from get global group into join let orderby partial remove select set value var yield"),
            types: words("Action Boolean Byte Char DateTime DateTimeOffset Decimal Double Func Guid Int16 Int32 Int64 Object SByte Single String Task TimeSpan UInt16 UInt32 UInt64 bool byte char decimal double short int long object sbyte float string ushort uint ulong"),
            blockKeywords: words("catch class do else finally for foreach if struct switch try while"),
            defKeywords: words("class interface namespace struct var"),
            typeFirstDefinitions: !0,
            atoms: words("true false null"),
            hooks: {
                "@": function(stream, state) {
                    return stream.eat('"') ? (state.tokenize = tokenAtString, tokenAtString(stream, state)) : (stream.eatWhile(/[\w\$_]/), "meta")
                }
            }
        }), def("text/x-scala", {
            name: "clike",
            keywords: words("abstract case catch class def do else extends final finally for forSome if implicit import lazy match new null object override package private protected return sealed super this throw trait try type val var while with yield _ assert assume require print println printf readLine readBoolean readByte readShort readChar readInt readLong readFloat readDouble"),
            types: words("AnyVal App Application Array BufferedIterator BigDecimal BigInt Char Console Either Enumeration Equiv Error Exception Fractional Function IndexedSeq Int Integral Iterable Iterator List Map Numeric Nil NotNull Option Ordered Ordering PartialFunction PartialOrdering Product Proxy Range Responder Seq Serializable Set Specializable Stream StringBuilder StringContext Symbol Throwable Traversable TraversableOnce Tuple Unit Vector Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void"),
            multiLineStrings: !0,
            blockKeywords: words("catch class enum do else finally for forSome if match switch try while"),
            defKeywords: words("class enum def object package trait type val var"),
            atoms: words("true false null"),
            indentStatements: !1,
            indentSwitch: !1,
            isOperatorChar: /[+\-*&%=<>!?|\/#:@]/,
            hooks: {
                "@": function(stream) {
                    return stream.eatWhile(/[\w\$_]/), "meta"
                },
                '"': function(stream, state) {
                    return !!stream.match('""') && (state.tokenize = tokenTripleString, state.tokenize(stream, state))
                },
                "'": function(stream) {
                    return stream.eatWhile(/[\w\$_\xa1-\uffff]/), "atom"
                },
                "=": function(stream, state) {
                    var cx = state.context;
                    return !("}" != cx.type || !cx.align || !stream.eat(">")) && (state.context = new Context(cx.indented, cx.column, cx.type, cx.info, null, cx.prev), "operator")
                },
                "/": function(stream, state) {
                    return !!stream.eat("*") && (state.tokenize = tokenNestedComment(1), state.tokenize(stream, state))
                }
            },
            modeProps: {
                closeBrackets: {
                    triples: '"'
                }
            }
        }), def("text/x-kotlin", {
            name: "clike",
            keywords: words("package as typealias class interface this super val operator var fun for is in This throw return annotation break continue object if else while do try when !in !is as? file import where by get set abstract enum open inner override private public internal protected catch finally out final vararg reified dynamic companion constructor init sealed field property receiver param sparam lateinit data inline noinline tailrec external annotation crossinline const operator infix suspend actual expect setparam"),
            types: words("Boolean Byte Character CharSequence Class ClassLoader Cloneable Comparable Compiler Double Exception Float Integer Long Math Number Object Package Pair Process Runtime Runnable SecurityManager Short StackTraceElement StrictMath String StringBuffer System Thread ThreadGroup ThreadLocal Throwable Triple Void Annotation Any BooleanArray ByteArray Char CharArray DeprecationLevel DoubleArray Enum FloatArray Function Int IntArray Lazy LazyThreadSafetyMode LongArray Nothing ShortArray Unit"),
            intendSwitch: !1,
            indentStatements: !1,
            multiLineStrings: !0,
            number: /^(?:0x[a-f\d_]+|0b[01_]+|(?:[\d_]+(\.\d+)?|\.\d+)(?:e[-+]?[\d_]+)?)(u|ll?|l|f)?/i,
            blockKeywords: words("catch class do else finally for if where try while enum"),
            defKeywords: words("class val var object interface fun"),
            atoms: words("true false null this"),
            hooks: {
                "@": function(stream) {
                    return stream.eatWhile(/[\w\$_]/), "meta"
                },
                '"': function(stream, state) {
                    return state.tokenize = tokenKotlinString(stream.match('""')), state.tokenize(stream, state)
                }
            },
            modeProps: {
                closeBrackets: {
                    triples: '"'
                }
            }
        }), def(["x-shader/x-vertex", "x-shader/x-fragment"], {
            name: "clike",
            keywords: words("sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow const attribute uniform varying break continue discard return for while do if else struct in out inout"),
            types: words("float int bool void vec2 vec3 vec4 ivec2 ivec3 ivec4 bvec2 bvec3 bvec4 mat2 mat3 mat4"),
            blockKeywords: words("for while do if else struct"),
            builtin: words("radians degrees sin cos tan asin acos atan pow exp log exp2 sqrt inversesqrt abs sign floor ceil fract mod min max clamp mix step smoothstep length distance dot cross normalize ftransform faceforward reflect refract matrixCompMult lessThan lessThanEqual greaterThan greaterThanEqual equal notEqual any all not texture1D texture1DProj texture1DLod texture1DProjLod texture2D texture2DProj texture2DLod texture2DProjLod texture3D texture3DProj texture3DLod texture3DProjLod textureCube textureCubeLod shadow1D shadow2D shadow1DProj shadow2DProj shadow1DLod shadow2DLod shadow1DProjLod shadow2DProjLod dFdx dFdy fwidth noise1 noise2 noise3 noise4"),
            atoms: words("true false gl_FragColor gl_SecondaryColor gl_Normal gl_Vertex gl_MultiTexCoord0 gl_MultiTexCoord1 gl_MultiTexCoord2 gl_MultiTexCoord3 gl_MultiTexCoord4 gl_MultiTexCoord5 gl_MultiTexCoord6 gl_MultiTexCoord7 gl_FogCoord gl_PointCoord gl_Position gl_PointSize gl_ClipVertex gl_FrontColor gl_BackColor gl_FrontSecondaryColor gl_BackSecondaryColor gl_TexCoord gl_FogFragCoord gl_FragCoord gl_FrontFacing gl_FragData gl_FragDepth gl_ModelViewMatrix gl_ProjectionMatrix gl_ModelViewProjectionMatrix gl_TextureMatrix gl_NormalMatrix gl_ModelViewMatrixInverse gl_ProjectionMatrixInverse gl_ModelViewProjectionMatrixInverse gl_TexureMatrixTranspose gl_ModelViewMatrixInverseTranspose gl_ProjectionMatrixInverseTranspose gl_ModelViewProjectionMatrixInverseTranspose gl_TextureMatrixInverseTranspose gl_NormalScale gl_DepthRange gl_ClipPlane gl_Point gl_FrontMaterial gl_BackMaterial gl_LightSource gl_LightModel gl_FrontLightModelProduct gl_BackLightModelProduct gl_TextureColor gl_EyePlaneS gl_EyePlaneT gl_EyePlaneR gl_EyePlaneQ gl_FogParameters gl_MaxLights gl_MaxClipPlanes gl_MaxTextureUnits gl_MaxTextureCoords gl_MaxVertexAttribs gl_MaxVertexUniformComponents gl_MaxVaryingFloats gl_MaxVertexTextureImageUnits gl_MaxTextureImageUnits gl_MaxFragmentUniformComponents gl_MaxCombineTextureImageUnits gl_MaxDrawBuffers"),
            indentSwitch: !1,
            hooks: {
                "#": cppHook
            },
            modeProps: {
                fold: ["brace", "include"]
            }
        }), def("text/x-nesc", {
            name: "clike",
            keywords: words(cKeywords + "as atomic async call command component components configuration event generic implementation includes interface module new norace nx_struct nx_union post provides signal task uses abstract extends"),
            types: words(cTypes),
            blockKeywords: words("case do else for if switch while struct"),
            atoms: words("null true false"),
            hooks: {
                "#": cppHook
            },
            modeProps: {
                fold: ["brace", "include"]
            }
        }), def("text/x-objectivec", {
            name: "clike",
            keywords: words(cKeywords + "inline restrict _Bool _Complex _Imaginary BOOL Class bycopy byref id IMP in inout nil oneway out Protocol SEL self super atomic nonatomic retain copy readwrite readonly"),
            types: words(cTypes),
            atoms: words("YES NO NULL NILL ON OFF true false"),
            hooks: {
                "@": function(stream) {
                    return stream.eatWhile(/[\w\$]/), "keyword"
                },
                "#": cppHook,
                indent: function(_state, ctx, textAfter) {
                    if ("statement" == ctx.type && /^@\w/.test(textAfter)) return ctx.indented
                }
            },
            modeProps: {
                fold: "brace"
            }
        }), def("text/x-squirrel", {
            name: "clike",
            keywords: words("base break clone continue const default delete enum extends function in class foreach local resume return this throw typeof yield constructor instanceof static"),
            types: words(cTypes),
            blockKeywords: words("case catch class else for foreach if switch try while"),
            defKeywords: words("function local class"),
            typeFirstDefinitions: !0,
            atoms: words("true false null"),
            hooks: {
                "#": cppHook
            },
            modeProps: {
                fold: ["brace", "include"]
            }
        });
        var stringTokenizer = null;
        def("text/x-ceylon", {
            name: "clike",
            keywords: words("abstracts alias assembly assert assign break case catch class continue dynamic else exists extends finally for function given if import in interface is let module new nonempty object of out outer package return satisfies super switch then this throw try value void while"),
            types: function(word) {
                var first = word.charAt(0);
                return first === first.toUpperCase() && first !== first.toLowerCase()
            },
            blockKeywords: words("case catch class dynamic else finally for function if interface module new object switch try while"),
            defKeywords: words("class dynamic function interface module object package value"),
            builtin: words("abstract actual aliased annotation by default deprecated doc final formal late license native optional sealed see serializable shared suppressWarnings tagged throws variable"),
            isPunctuationChar: /[\[\]{}\(\),;\:\.`]/,
            isOperatorChar: /[+\-*&%=<>!?|^~:\/]/,
            numberStart: /[\d#$]/,
            number: /^(?:#[\da-fA-F_]+|\$[01_]+|[\d_]+[kMGTPmunpf]?|[\d_]+\.[\d_]+(?:[eE][-+]?\d+|[kMGTPmunpf]|)|)/i,
            multiLineStrings: !0,
            typeFirstDefinitions: !0,
            atoms: words("true false null larger smaller equal empty finished"),
            indentSwitch: !1,
            styleDefs: !1,
            hooks: {
                "@": function(stream) {
                    return stream.eatWhile(/[\w\$_]/), "meta"
                },
                '"': function(stream, state) {
                    return state.tokenize = tokenCeylonString(stream.match('""') ? "triple" : "single"), state.tokenize(stream, state)
                },
                "`": function(stream, state) {
                    return !(!stringTokenizer || !stream.match("`")) && (state.tokenize = stringTokenizer, stringTokenizer = null, state.tokenize(stream, state))
                },
                "'": function(stream) {
                    return stream.eatWhile(/[\w\$_\xa1-\uffff]/), "atom"
                },
                token: function(_stream, state, style) {
                    if (("variable" == style || "type" == style) && "." == state.prevToken) return "variable-2"
                }
            },
            modeProps: {
                fold: ["brace", "import"],
                closeBrackets: {
                    triples: '"'
                }
            }
        })
    }),
    function(mod) {
        "object" == ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "object" == ("undefined" == typeof module ? "undefined" : _typeof2(module)) ? mod(require("../../lib/codemirror")): "function" == typeof define && define.amd ? define(["../../lib/codemirror"], mod) : mod(CodeMirror)
    }(function(CodeMirror) {
        "use strict";

        function wordSet(words) {
            for (var set = {}, i = 0; i < words.length; i++) set[words[i]] = !0;
            return set
        }

        function tokenBase(stream, state, prev) {
            if (stream.sol() && (state.indented = stream.indentation()), stream.eatSpace()) return null;
            var ch = stream.peek();
            if ("/" == ch) {
                if (stream.match("//")) return stream.skipToEnd(), "comment";
                if (stream.match("/*")) return state.tokenize.push(tokenComment), tokenComment(stream, state)
            }
            if (stream.match(instruction)) return "builtin";
            if (stream.match(attribute)) return "attribute";
            if (stream.match(binary)) return "number";
            if (stream.match(octal)) return "number";
            if (stream.match(hexadecimal)) return "number";
            if (stream.match(decimal)) return "number";
            if (stream.match(property)) return "property";
            if (operators.indexOf(ch) > -1) return stream.next(), "operator";
            if (punc.indexOf(ch) > -1) return stream.next(), stream.match(".."), "punctuation";
            if ('"' == ch || "'" == ch) {
                stream.next();
                var tokenize = tokenString(ch);
                return state.tokenize.push(tokenize), tokenize(stream, state)
            }
            if (stream.match(identifier)) {
                var ident = stream.current();
                return types.hasOwnProperty(ident) ? "variable-2" : atoms.hasOwnProperty(ident) ? "atom" : keywords.hasOwnProperty(ident) ? (definingKeywords.hasOwnProperty(ident) && (state.prev = "define"), "keyword") : "define" == prev ? "def" : "variable"
            }
            return stream.next(), null
        }

        function tokenUntilClosingParen() {
            var depth = 0;
            return function(stream, state, prev) {
                var inner = tokenBase(stream, state, prev);
                if ("punctuation" == inner)
                    if ("(" == stream.current()) ++depth;
                    else if (")" == stream.current()) {
                    if (0 == depth) return stream.backUp(1), state.tokenize.pop(), state.tokenize[state.tokenize.length - 1](stream, state);
                    --depth
                }
                return inner
            }
        }

        function tokenString(quote) {
            return function(stream, state) {
                for (var ch, escaped = !1; ch = stream.next();)
                    if (escaped) {
                        if ("(" == ch) return state.tokenize.push(tokenUntilClosingParen()), "string";
                        escaped = !1
                    } else {
                        if (ch == quote) break;
                        escaped = "\\" == ch
                    } return state.tokenize.pop(), "string"
            }
        }

        function tokenComment(stream, state) {
            for (var ch;;) {
                if (stream.match(/^[^/*]+/, !0), ch = stream.next(), !ch) break;
                "/" === ch && stream.eat("*") ? state.tokenize.push(tokenComment) : "*" === ch && stream.eat("/") && state.tokenize.pop()
            }
            return "comment"
        }

        function Context(prev, align, indented) {
            this.prev = prev, this.align = align, this.indented = indented
        }

        function pushContext(state, stream) {
            var align = stream.match(/^\s*($|\/[\/\*])/, !1) ? null : stream.column() + 1;
            state.context = new Context(state.context, align, state.indented)
        }

        function popContext(state) {
            state.context && (state.indented = state.context.indented, state.context = state.context.prev)
        }
        var keywords = wordSet(["_", "var", "let", "class", "enum", "extension", "import", "protocol", "struct", "func", "typealias", "associatedtype", "open", "public", "internal", "fileprivate", "private", "deinit", "init", "new", "override", "self", "subscript", "super", "convenience", "dynamic", "final", "indirect", "lazy", "required", "static", "unowned", "unowned(safe)", "unowned(unsafe)", "weak", "as", "is", "break", "case", "continue", "default", "else", "fallthrough", "for", "guard", "if", "in", "repeat", "switch", "where", "while", "defer", "return", "inout", "mutating", "nonmutating", "catch", "do", "rethrows", "throw", "throws", "try", "didSet", "get", "set", "willSet", "assignment", "associativity", "infix", "left", "none", "operator", "postfix", "precedence", "precedencegroup", "prefix", "right", "Any", "AnyObject", "Type", "dynamicType", "Self", "Protocol", "__COLUMN__", "__FILE__", "__FUNCTION__", "__LINE__"]),
            definingKeywords = wordSet(["var", "let", "class", "enum", "extension", "import", "protocol", "struct", "func", "typealias", "associatedtype", "for"]),
            atoms = wordSet(["true", "false", "nil", "self", "super", "_"]),
            types = wordSet(["Array", "Bool", "Character", "Dictionary", "Double", "Float", "Int", "Int8", "Int16", "Int32", "Int64", "Never", "Optional", "Set", "String", "UInt8", "UInt16", "UInt32", "UInt64", "Void"]),
            operators = "+-/*%=|&<>~^?!",
            punc = ":;,.(){}[]",
            binary = /^\-?0b[01][01_]*/,
            octal = /^\-?0o[0-7][0-7_]*/,
            hexadecimal = /^\-?0x[\dA-Fa-f][\dA-Fa-f_]*(?:(?:\.[\dA-Fa-f][\dA-Fa-f_]*)?[Pp]\-?\d[\d_]*)?/,
            decimal = /^\-?\d[\d_]*(?:\.\d[\d_]*)?(?:[Ee]\-?\d[\d_]*)?/,
            identifier = /^\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1/,
            property = /^\.(?:\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1)/,
            instruction = /^\#[A-Za-z]+/,
            attribute = /^@(?:\$\d+|(`?)[_A-Za-z][_A-Za-z$0-9]*\1)/;
        CodeMirror.defineMode("swift", function(config) {
            return {
                startState: function() {
                    return {
                        prev: null,
                        context: null,
                        indented: 0,
                        tokenize: []
                    }
                },
                token: function(stream, state) {
                    var prev = state.prev;
                    state.prev = null;
                    var tokenize = state.tokenize[state.tokenize.length - 1] || tokenBase,
                        style = tokenize(stream, state, prev);
                    if (style && "comment" != style ? state.prev || (state.prev = style) : state.prev = prev, "punctuation" == style) {
                        var bracket = /[\(\[\{]|([\]\)\}])/.exec(stream.current());
                        bracket && (bracket[1] ? popContext : pushContext)(state, stream)
                    }
                    return style
                },
                indent: function(state, textAfter) {
                    var cx = state.context;
                    if (!cx) return 0;
                    var closing = /^[\]\}\)]/.test(textAfter);
                    return null != cx.align ? cx.align - (closing ? 1 : 0) : cx.indented + (closing ? 0 : config.indentUnit)
                },
                electricInput: /^\s*[\)\}\]]$/,
                lineComment: "//",
                blockCommentStart: "/*",
                blockCommentEnd: "*/",
                fold: "brace",
                closeBrackets: "()[]{}''\"\"``"
            }
        }), CodeMirror.defineMIME("text/x-swift", "swift")
    }),
    function(mod) {
        "object" == ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "object" == ("undefined" == typeof module ? "undefined" : _typeof2(module)) ? mod(require("../../lib/codemirror")): "function" == typeof define && define.amd ? define(["../../lib/codemirror"], mod) : mod(CodeMirror)
    }(function(CodeMirror) {
        "use strict";
        CodeMirror.defineMode("ruby", function(config) {
            function wordObj(words) {
                for (var o = {}, i = 0, e = words.length; i < e; ++i) o[words[i]] = !0;
                return o
            }

            function chain(newtok, stream, state) {
                return state.tokenize.push(newtok), newtok(stream, state)
            }

            function tokenBase(stream, state) {
                if (stream.sol() && stream.match("=begin") && stream.eol()) return state.tokenize.push(readBlockComment), "comment";
                if (stream.eatSpace()) return null;
                var m, ch = stream.next();
                if ("`" == ch || "'" == ch || '"' == ch) return chain(readQuoted(ch, "string", '"' == ch || "`" == ch), stream, state);
                if ("/" == ch) return regexpAhead(stream) ? chain(readQuoted(ch, "string-2", !0), stream, state) : "operator";
                if ("%" == ch) {
                    var style = "string",
                        embed = !0;
                    stream.eat("s") ? style = "atom" : stream.eat(/[WQ]/) ? style = "string" : stream.eat(/[r]/) ? style = "string-2" : stream.eat(/[wxq]/) && (style = "string", embed = !1);
                    var delim = stream.eat(/[^\w\s=]/);
                    return delim ? (matching.propertyIsEnumerable(delim) && (delim = matching[delim]), chain(readQuoted(delim, style, embed, !0), stream, state)) : "operator"
                }
                if ("#" == ch) return stream.skipToEnd(), "comment";
                if ("<" == ch && (m = stream.match(/^<-?[\`\"\']?([a-zA-Z_?]\w*)[\`\"\']?(?:;|$)/))) return chain(readHereDoc(m[1]), stream, state);
                if ("0" == ch) return stream.eat("x") ? stream.eatWhile(/[\da-fA-F]/) : stream.eat("b") ? stream.eatWhile(/[01]/) : stream.eatWhile(/[0-7]/), "number";
                if (/\d/.test(ch)) return stream.match(/^[\d_]*(?:\.[\d_]+)?(?:[eE][+\-]?[\d_]+)?/), "number";
                if ("?" == ch) {
                    for (; stream.match(/^\\[CM]-/););
                    return stream.eat("\\") ? stream.eatWhile(/\w/) : stream.next(), "string"
                }
                if (":" == ch) return stream.eat("'") ? chain(readQuoted("'", "atom", !1), stream, state) : stream.eat('"') ? chain(readQuoted('"', "atom", !0), stream, state) : stream.eat(/[\<\>]/) ? (stream.eat(/[\<\>]/), "atom") : stream.eat(/[\+\-\*\/\&\|\:\!]/) ? "atom" : stream.eat(/[a-zA-Z$@_\xa1-\uffff]/) ? (stream.eatWhile(/[\w$\xa1-\uffff]/), stream.eat(/[\?\!\=]/), "atom") : "operator";
                if ("@" == ch && stream.match(/^@?[a-zA-Z_\xa1-\uffff]/)) return stream.eat("@"), stream.eatWhile(/[\w\xa1-\uffff]/), "variable-2";
                if ("$" == ch) return stream.eat(/[a-zA-Z_]/) ? stream.eatWhile(/[\w]/) : stream.eat(/\d/) ? stream.eat(/\d/) : stream.next(), "variable-3";
                if (/[a-zA-Z_\xa1-\uffff]/.test(ch)) return stream.eatWhile(/[\w\xa1-\uffff]/), stream.eat(/[\?\!]/), stream.eat(":") ? "atom" : "ident";
                if ("|" != ch || !state.varList && "{" != state.lastTok && "do" != state.lastTok) {
                    if (/[\(\)\[\]{}\\;]/.test(ch)) return curPunc = ch, null;
                    if ("-" == ch && stream.eat(">")) return "arrow";
                    if (/[=+\-\/*:\.^%<>~|]/.test(ch)) {
                        var more = stream.eatWhile(/[=+\-\/*:\.^%<>~|]/);
                        return "." != ch || more || (curPunc = "."), "operator"
                    }
                    return null
                }
                return curPunc = "|", null
            }

            function regexpAhead(stream) {
                for (var next, start = stream.pos, depth = 0, found = !1, escaped = !1; null != (next = stream.next());)
                    if (escaped) escaped = !1;
                    else {
                        if ("[{(".indexOf(next) > -1) depth++;
                        else if ("]})".indexOf(next) > -1) {
                            if (depth--, depth < 0) break
                        } else if ("/" == next && 0 == depth) {
                            found = !0;
                            break
                        }
                        escaped = "\\" == next
                    } return stream.backUp(stream.pos - start), found
            }

            function tokenBaseUntilBrace(depth) {
                return depth || (depth = 1),
                    function(stream, state) {
                        if ("}" == stream.peek()) {
                            if (1 == depth) return state.tokenize.pop(), state.tokenize[state.tokenize.length - 1](stream, state);
                            state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth - 1)
                        } else "{" == stream.peek() && (state.tokenize[state.tokenize.length - 1] = tokenBaseUntilBrace(depth + 1));
                        return tokenBase(stream, state)
                    }
            }

            function tokenBaseOnce() {
                var alreadyCalled = !1;
                return function(stream, state) {
                    return alreadyCalled ? (state.tokenize.pop(), state.tokenize[state.tokenize.length - 1](stream, state)) : (alreadyCalled = !0, tokenBase(stream, state))
                }
            }

            function readQuoted(quote, style, embed, unescaped) {
                return function(stream, state) {
                    var ch, escaped = !1;
                    for ("read-quoted-paused" === state.context.type && (state.context = state.context.prev, stream.eat("}")); null != (ch = stream.next());) {
                        if (ch == quote && (unescaped || !escaped)) {
                            state.tokenize.pop();
                            break
                        }
                        if (embed && "#" == ch && !escaped) {
                            if (stream.eat("{")) {
                                "}" == quote && (state.context = {
                                    prev: state.context,
                                    type: "read-quoted-paused"
                                }), state.tokenize.push(tokenBaseUntilBrace());
                                break
                            }
                            if (/[@\$]/.test(stream.peek())) {
                                state.tokenize.push(tokenBaseOnce());
                                break
                            }
                        }
                        escaped = !escaped && "\\" == ch
                    }
                    return style
                }
            }

            function readHereDoc(phrase) {
                return function(stream, state) {
                    return stream.match(phrase) ? state.tokenize.pop() : stream.skipToEnd(), "string"
                }
            }

            function readBlockComment(stream, state) {
                return stream.sol() && stream.match("=end") && stream.eol() && state.tokenize.pop(), stream.skipToEnd(), "comment"
            }
            var curPunc, keywords = wordObj(["alias", "and", "BEGIN", "begin", "break", "case", "class", "def", "defined?", "do", "else", "elsif", "END", "end", "ensure", "false", "for", "if", "in", "module", "next", "not", "or", "redo", "rescue", "retry", "return", "self", "super", "then", "true", "undef", "unless", "until", "when", "while", "yield", "nil", "raise", "throw", "catch", "fail", "loop", "callcc", "caller", "lambda", "proc", "public", "protected", "private", "require", "load", "require_relative", "extend", "autoload", "__END__", "__FILE__", "__LINE__", "__dir__"]),
                indentWords = wordObj(["def", "class", "case", "for", "while", "until", "module", "then", "catch", "loop", "proc", "begin"]),
                dedentWords = wordObj(["end", "until"]),
                matching = {
                    "[": "]",
                    "{": "}",
                    "(": ")"
                };
            return {
                startState: function() {
                    return {
                        tokenize: [tokenBase],
                        indented: 0,
                        context: {
                            type: "top",
                            indented: -config.indentUnit
                        },
                        continuedLine: !1,
                        lastTok: null,
                        varList: !1
                    }
                },
                token: function(stream, state) {
                    curPunc = null, stream.sol() && (state.indented = stream.indentation());
                    var kwtype, style = state.tokenize[state.tokenize.length - 1](stream, state),
                        thisTok = curPunc;
                    if ("ident" == style) {
                        var word = stream.current();
                        style = "." == state.lastTok ? "property" : keywords.propertyIsEnumerable(stream.current()) ? "keyword" : /^[A-Z]/.test(word) ? "tag" : "def" == state.lastTok || "class" == state.lastTok || state.varList ? "def" : "variable", "keyword" == style && (thisTok = word, indentWords.propertyIsEnumerable(word) ? kwtype = "indent" : dedentWords.propertyIsEnumerable(word) ? kwtype = "dedent" : "if" != word && "unless" != word || stream.column() != stream.indentation() ? "do" == word && state.context.indented < state.indented && (kwtype = "indent") : kwtype = "indent")
                    }
                    return (curPunc || style && "comment" != style) && (state.lastTok = thisTok), "|" == curPunc && (state.varList = !state.varList), "indent" == kwtype || /[\(\[\{]/.test(curPunc) ? state.context = {
                        prev: state.context,
                        type: curPunc || style,
                        indented: state.indented
                    } : ("dedent" == kwtype || /[\)\]\}]/.test(curPunc)) && state.context.prev && (state.context = state.context.prev), stream.eol() && (state.continuedLine = "\\" == curPunc || "operator" == style), style
                },
                indent: function(state, textAfter) {
                    if (state.tokenize[state.tokenize.length - 1] != tokenBase) return 0;
                    var firstChar = textAfter && textAfter.charAt(0),
                        ct = state.context,
                        closing = ct.type == matching[firstChar] || "keyword" == ct.type && /^(?:end|until|else|elsif|when|rescue)\b/.test(textAfter);
                    return ct.indented + (closing ? 0 : config.indentUnit) + (state.continuedLine ? config.indentUnit : 0)
                },
                electricInput: /^\s*(?:end|rescue|elsif|else|\})$/,
                lineComment: "#",
                fold: "indent"
            }
        }), CodeMirror.defineMIME("text/x-ruby", "ruby")
    }),
    function(mod) {
        "object" == ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "object" == ("undefined" == typeof module ? "undefined" : _typeof2(module)) ? mod(require("../../lib/codemirror")): "function" == typeof define && define.amd ? define(["../../lib/codemirror"], mod) : mod(CodeMirror)
    }(function(CodeMirror) {
        "use strict";
        CodeMirror.defineMode("smarty", function(config, parserConf) {
            function cont(style, lastType) {
                return last = lastType, style
            }

            function chain(stream, state, parser) {
                return state.tokenize = parser, parser(stream, state)
            }

            function doesNotCount(stream, pos) {
                return null == pos && (pos = stream.pos), 3 === version && "{" == leftDelimiter && (pos == stream.string.length || /\s/.test(stream.string.charAt(pos)))
            }

            function tokenTop(stream, state) {
                for (var string = stream.string, scan = stream.pos;;) {
                    var nextMatch = string.indexOf(leftDelimiter, scan);
                    if (scan = nextMatch + leftDelimiter.length, nextMatch == -1 || !doesNotCount(stream, nextMatch + leftDelimiter.length)) break
                }
                if (nextMatch == stream.pos) return stream.match(leftDelimiter), stream.eat("*") ? chain(stream, state, tokenBlock("comment", "*" + rightDelimiter)) : (state.depth++, state.tokenize = tokenSmarty, last = "startTag", "tag");
                nextMatch > -1 && (stream.string = string.slice(0, nextMatch));
                var token = baseMode.token(stream, state.base);
                return nextMatch > -1 && (stream.string = string), token
            }

            function tokenSmarty(stream, state) {
                if (stream.match(rightDelimiter, !0)) return 3 === version ? (state.depth--, state.depth <= 0 && (state.tokenize = tokenTop)) : state.tokenize = tokenTop, cont("tag", null);
                if (stream.match(leftDelimiter, !0)) return state.depth++, cont("tag", "startTag");
                var ch = stream.next();
                if ("$" == ch) return stream.eatWhile(regs.validIdentifier), cont("variable-2", "variable");
                if ("|" == ch) return cont("operator", "pipe");
                if ("." == ch) return cont("operator", "property");
                if (regs.stringChar.test(ch)) return state.tokenize = tokenAttribute(ch), cont("string", "string");
                if (regs.operatorChars.test(ch)) return stream.eatWhile(regs.operatorChars), cont("operator", "operator");
                if ("[" == ch || "]" == ch) return cont("bracket", "bracket");
                if ("(" == ch || ")" == ch) return cont("bracket", "operator");
                if (/\d/.test(ch)) return stream.eatWhile(/\d/), cont("number", "number");
                if ("variable" == state.last) {
                    if ("@" == ch) return stream.eatWhile(regs.validIdentifier), cont("property", "property");
                    if ("|" == ch) return stream.eatWhile(regs.validIdentifier), cont("qualifier", "modifier")
                } else {
                    if ("pipe" == state.last) return stream.eatWhile(regs.validIdentifier), cont("qualifier", "modifier");
                    if ("whitespace" == state.last) return stream.eatWhile(regs.validIdentifier), cont("attribute", "modifier")
                }
                if ("property" == state.last) return stream.eatWhile(regs.validIdentifier), cont("property", null);
                if (/\s/.test(ch)) return last = "whitespace", null;
                var str = "";
                "/" != ch && (str += ch);
                for (var c = null; c = stream.eat(regs.validIdentifier);) str += c;
                for (var i = 0, j = keyFunctions.length; i < j; i++)
                    if (keyFunctions[i] == str) return cont("keyword", "keyword");
                return /\s/.test(ch) ? null : cont("tag", "tag")
            }

            function tokenAttribute(quote) {
                return function(stream, state) {
                    for (var prevChar = null, currChar = null; !stream.eol();) {
                        if (currChar = stream.peek(), stream.next() == quote && "\\" !== prevChar) {
                            state.tokenize = tokenSmarty;
                            break
                        }
                        prevChar = currChar
                    }
                    return "string"
                }
            }

            function tokenBlock(style, terminator) {
                return function(stream, state) {
                    for (; !stream.eol();) {
                        if (stream.match(terminator)) {
                            state.tokenize = tokenTop;
                            break
                        }
                        stream.next()
                    }
                    return style
                }
            }
            var last, rightDelimiter = parserConf.rightDelimiter || "}",
                leftDelimiter = parserConf.leftDelimiter || "{",
                version = parserConf.version || 2,
                baseMode = CodeMirror.getMode(config, parserConf.baseMode || "null"),
                keyFunctions = ["debug", "extends", "function", "include", "literal"],
                regs = {
                    operatorChars: /[+\-*&%=<>!?]/,
                    validIdentifier: /[a-zA-Z0-9_]/,
                    stringChar: /['"]/
                };
            return {
                startState: function() {
                    return {
                        base: CodeMirror.startState(baseMode),
                        tokenize: tokenTop,
                        last: null,
                        depth: 0
                    }
                },
                copyState: function(state) {
                    return {
                        base: CodeMirror.copyState(baseMode, state.base),
                        tokenize: state.tokenize,
                        last: state.last,
                        depth: state.depth
                    }
                },
                innerMode: function(state) {
                    if (state.tokenize == tokenTop) return {
                        mode: baseMode,
                        state: state.base
                    }
                },
                token: function(stream, state) {
                    var style = state.tokenize(stream, state);
                    return state.last = last, style
                },
                indent: function(state, text) {
                    return state.tokenize == tokenTop && baseMode.indent ? baseMode.indent(state.base, text) : CodeMirror.Pass
                },
                blockCommentStart: leftDelimiter + "*",
                blockCommentEnd: "*" + rightDelimiter
            }
        }), CodeMirror.defineMIME("text/x-smarty", "smarty")
    }),
    function(mod) {
        "object" == ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "object" == ("undefined" == typeof module ? "undefined" : _typeof2(module)) ? mod(require("../../lib/codemirror"), require("../htmlmixed/htmlmixed"), require("../ruby/ruby")): "function" == typeof define && define.amd ? define(["../../lib/codemirror", "../htmlmixed/htmlmixed", "../ruby/ruby"], mod) : mod(CodeMirror)
    }(function(CodeMirror) {
        "use strict";
        CodeMirror.defineMode("slim", function(config) {
            function backup(pos, tokenize, style) {
                var restore = function(stream, state) {
                    return state.tokenize = tokenize, stream.pos < pos ? (stream.pos = pos, style) : state.tokenize(stream, state)
                };
                return function(stream, state) {
                    return state.tokenize = restore, tokenize(stream, state)
                }
            }

            function maybeBackup(stream, state, pat, offset, style) {
                var cur = stream.current(),
                    idx = cur.search(pat);
                return idx > -1 && (state.tokenize = backup(stream.pos, state.tokenize, style), stream.backUp(cur.length - idx - offset)), style
            }

            function continueLine(state, column) {
                state.stack = {
                    parent: state.stack,
                    style: "continuation",
                    indented: column,
                    tokenize: state.line
                }, state.line = state.tokenize
            }

            function finishContinue(state) {
                state.line == state.tokenize && (state.line = state.stack.tokenize, state.stack = state.stack.parent)
            }

            function lineContinuable(column, tokenize) {
                return function(stream, state) {
                    if (finishContinue(state), stream.match(/^\\$/)) return continueLine(state, column), "lineContinuation";
                    var style = tokenize(stream, state);
                    return stream.eol() && stream.current().match(/(?:^|[^\\])(?:\\\\)*\\$/) && stream.backUp(1), style
                }
            }

            function commaContinuable(column, tokenize) {
                return function(stream, state) {
                    finishContinue(state);
                    var style = tokenize(stream, state);
                    return stream.eol() && stream.current().match(/,$/) && continueLine(state, column), style
                }
            }

            function rubyInQuote(endQuote, tokenize) {
                return function(stream, state) {
                    var ch = stream.peek();
                    return ch == endQuote && 1 == state.rubyState.tokenize.length ? (stream.next(), state.tokenize = tokenize, "closeAttributeTag") : ruby(stream, state)
                }
            }

            function startRubySplat(tokenize) {
                var rubyState, runSplat = function(stream, state) {
                    if (1 == state.rubyState.tokenize.length && !state.rubyState.context.prev) {
                        if (stream.backUp(1), stream.eatSpace()) return state.rubyState = rubyState, state.tokenize = tokenize, tokenize(stream, state);
                        stream.next()
                    }
                    return ruby(stream, state)
                };
                return function(stream, state) {
                    return rubyState = state.rubyState, state.rubyState = CodeMirror.startState(rubyMode), state.tokenize = runSplat, ruby(stream, state)
                }
            }

            function ruby(stream, state) {
                return rubyMode.token(stream, state.rubyState)
            }

            function htmlLine(stream, state) {
                return stream.match(/^\\$/) ? "lineContinuation" : html(stream, state)
            }

            function html(stream, state) {
                return stream.match(/^#\{/) ? (state.tokenize = rubyInQuote("}", state.tokenize), null) : maybeBackup(stream, state, /[^\\]#\{/, 1, htmlMode.token(stream, state.htmlState))
            }

            function startHtmlLine(lastTokenize) {
                return function(stream, state) {
                    var style = htmlLine(stream, state);
                    return stream.eol() && (state.tokenize = lastTokenize), style
                }
            }

            function startHtmlMode(stream, state, offset) {
                return state.stack = {
                    parent: state.stack,
                    style: "html",
                    indented: stream.column() + offset,
                    tokenize: state.line
                }, state.line = state.tokenize = html, null
            }

            function comment(stream, state) {
                return stream.skipToEnd(), state.stack.style
            }

            function commentMode(stream, state) {
                return state.stack = {
                    parent: state.stack,
                    style: "comment",
                    indented: state.indented + 1,
                    tokenize: state.line
                }, state.line = comment, comment(stream, state)
            }

            function attributeWrapper(stream, state) {
                return stream.eat(state.stack.endQuote) ? (state.line = state.stack.line, state.tokenize = state.stack.tokenize, state.stack = state.stack.parent, null) : stream.match(wrappedAttributeNameRegexp) ? (state.tokenize = attributeWrapperAssign, "slimAttribute") : (stream.next(), null)
            }

            function attributeWrapperAssign(stream, state) {
                return stream.match(/^==?/) ? (state.tokenize = attributeWrapperValue, null) : attributeWrapper(stream, state)
            }

            function attributeWrapperValue(stream, state) {
                var ch = stream.peek();
                return '"' == ch || "'" == ch ? (state.tokenize = readQuoted(ch, "string", !0, !1, attributeWrapper), stream.next(), state.tokenize(stream, state)) : "[" == ch ? startRubySplat(attributeWrapper)(stream, state) : stream.match(/^(true|false|nil)\b/) ? (state.tokenize = attributeWrapper, "keyword") : startRubySplat(attributeWrapper)(stream, state)
            }

            function startAttributeWrapperMode(state, endQuote, tokenize) {
                return state.stack = {
                    parent: state.stack,
                    style: "wrapper",
                    indented: state.indented + 1,
                    tokenize: tokenize,
                    line: state.line,
                    endQuote: endQuote
                }, state.line = state.tokenize = attributeWrapper, null
            }

            function sub(stream, state) {
                if (stream.match(/^#\{/)) return state.tokenize = rubyInQuote("}", state.tokenize), null;
                var subStream = new CodeMirror.StringStream(stream.string.slice(state.stack.indented), stream.tabSize);
                subStream.pos = stream.pos - state.stack.indented, subStream.start = stream.start - state.stack.indented, subStream.lastColumnPos = stream.lastColumnPos - state.stack.indented, subStream.lastColumnValue = stream.lastColumnValue - state.stack.indented;
                var style = state.subMode.token(subStream, state.subState);
                return stream.pos = subStream.pos + state.stack.indented, style
            }

            function firstSub(stream, state) {
                return state.stack.indented = stream.column(), state.line = state.tokenize = sub, state.tokenize(stream, state)
            }

            function createMode(mode) {
                var query = embedded[mode],
                    spec = CodeMirror.mimeModes[query];
                if (spec) return CodeMirror.getMode(config, spec);
                var factory = CodeMirror.modes[query];
                return factory ? factory(config, {
                    name: query
                }) : CodeMirror.getMode(config, "null")
            }

            function getMode(mode) {
                return modes.hasOwnProperty(mode) ? modes[mode] : modes[mode] = createMode(mode)
            }

            function startSubMode(mode, state) {
                var subMode = getMode(mode),
                    subState = CodeMirror.startState(subMode);
                return state.subMode = subMode, state.subState = subState, state.stack = {
                    parent: state.stack,
                    style: "sub",
                    indented: state.indented + 1,
                    tokenize: state.line
                }, state.line = state.tokenize = firstSub, "slimSubmode"
            }

            function doctypeLine(stream, _state) {
                return stream.skipToEnd(), "slimDoctype"
            }

            function startLine(stream, state) {
                var ch = stream.peek();
                if ("<" == ch) return (state.tokenize = startHtmlLine(state.tokenize))(stream, state);
                if (stream.match(/^[|']/)) return startHtmlMode(stream, state, 1);
                if (stream.match(/^\/(!|\[\w+])?/)) return commentMode(stream, state);
                if (stream.match(/^(-|==?[<>]?)/)) return state.tokenize = lineContinuable(stream.column(), commaContinuable(stream.column(), ruby)), "slimSwitch";
                if (stream.match(/^doctype\b/)) return state.tokenize = doctypeLine, "keyword";
                var m = stream.match(embeddedRegexp);
                return m ? startSubMode(m[1], state) : slimTag(stream, state)
            }

            function slim(stream, state) {
                return state.startOfLine ? startLine(stream, state) : slimTag(stream, state)
            }

            function slimTag(stream, state) {
                return stream.eat("*") ? (state.tokenize = startRubySplat(slimTagExtras), null) : stream.match(nameRegexp) ? (state.tokenize = slimTagExtras, "slimTag") : slimClass(stream, state)
            }

            function slimTagExtras(stream, state) {
                return stream.match(/^(<>?|><?)/) ? (state.tokenize = slimClass, null) : slimClass(stream, state)
            }

            function slimClass(stream, state) {
                return stream.match(classIdRegexp) ? (state.tokenize = slimClass, "slimId") : stream.match(classNameRegexp) ? (state.tokenize = slimClass, "slimClass") : slimAttribute(stream, state)
            }

            function slimAttribute(stream, state) {
                return stream.match(/^([\[\{\(])/) ? startAttributeWrapperMode(state, closing[RegExp.$1], slimAttribute) : stream.match(attributeNameRegexp) ? (state.tokenize = slimAttributeAssign, "slimAttribute") : "*" == stream.peek() ? (stream.next(), state.tokenize = startRubySplat(slimContent), null) : slimContent(stream, state)
            }

            function slimAttributeAssign(stream, state) {
                return stream.match(/^==?/) ? (state.tokenize = slimAttributeValue, null) : slimAttribute(stream, state)
            }

            function slimAttributeValue(stream, state) {
                var ch = stream.peek();
                return '"' == ch || "'" == ch ? (state.tokenize = readQuoted(ch, "string", !0, !1, slimAttribute), stream.next(), state.tokenize(stream, state)) : "[" == ch ? startRubySplat(slimAttribute)(stream, state) : ":" == ch ? startRubySplat(slimAttributeSymbols)(stream, state) : stream.match(/^(true|false|nil)\b/) ? (state.tokenize = slimAttribute, "keyword") : startRubySplat(slimAttribute)(stream, state)
            }

            function slimAttributeSymbols(stream, state) {
                return stream.backUp(1), stream.match(/^[^\s],(?=:)/) ? (state.tokenize = startRubySplat(slimAttributeSymbols), null) : (stream.next(), slimAttribute(stream, state))
            }

            function readQuoted(quote, style, embed, unescaped, nextTokenize) {
                return function(stream, state) {
                    finishContinue(state);
                    var fresh = 0 == stream.current().length;
                    if (stream.match(/^\\$/, fresh)) return fresh ? (continueLine(state, state.indented), "lineContinuation") : style;
                    if (stream.match(/^#\{/, fresh)) return fresh ? (state.tokenize = rubyInQuote("}", state.tokenize), null) : style;
                    for (var ch, escaped = !1; null != (ch = stream.next());) {
                        if (ch == quote && (unescaped || !escaped)) {
                            state.tokenize = nextTokenize;
                            break
                        }
                        if (embed && "#" == ch && !escaped && stream.eat("{")) {
                            stream.backUp(2);
                            break
                        }
                        escaped = !escaped && "\\" == ch
                    }
                    return stream.eol() && escaped && stream.backUp(1), style
                }
            }

            function slimContent(stream, state) {
                return stream.match(/^==?/) ? (state.tokenize = ruby, "slimSwitch") : stream.match(/^\/$/) ? (state.tokenize = slim, null) : stream.match(/^:/) ? (state.tokenize = slimTag, "slimSwitch") : (startHtmlMode(stream, state, 0), state.tokenize(stream, state))
            }
            var htmlMode = CodeMirror.getMode(config, {
                    name: "htmlmixed"
                }),
                rubyMode = CodeMirror.getMode(config, "ruby"),
                modes = {
                    html: htmlMode,
                    ruby: rubyMode
                },
                embedded = {
                    ruby: "ruby",
                    javascript: "javascript",
                    css: "text/css",
                    sass: "text/x-sass",
                    scss: "text/x-scss",
                    less: "text/x-less",
                    styl: "text/x-styl",
                    coffee: "coffeescript",
                    asciidoc: "text/x-asciidoc",
                    markdown: "text/x-markdown",
                    textile: "text/x-textile",
                    creole: "text/x-creole",
                    wiki: "text/x-wiki",
                    mediawiki: "text/x-mediawiki",
                    rdoc: "text/x-rdoc",
                    builder: "text/x-builder",
                    nokogiri: "text/x-nokogiri",
                    erb: "application/x-erb"
                },
                embeddedRegexp = function(map) {
                    var arr = [];
                    for (var key in map) arr.push(key);
                    return new RegExp("^(" + arr.join("|") + "):")
                }(embedded),
                styleMap = {
                    commentLine: "comment",
                    slimSwitch: "operator special",
                    slimTag: "tag",
                    slimId: "attribute def",
                    slimClass: "attribute qualifier",
                    slimAttribute: "attribute",
                    slimSubmode: "keyword special",
                    closeAttributeTag: null,
                    slimDoctype: null,
                    lineContinuation: null
                },
                closing = {
                    "{": "}",
                    "[": "]",
                    "(": ")"
                },
                nameStartChar = "_a-zA-Z-----------",
                nameChar = nameStartChar + "\\-0-9--",
                nameRegexp = new RegExp("^[:" + nameStartChar + "](?::[" + nameChar + "]|[" + nameChar + "]*)"),
                attributeNameRegexp = new RegExp("^[:" + nameStartChar + "][:\\." + nameChar + "]*(?=\\s*=)"),
                wrappedAttributeNameRegexp = new RegExp("^[:" + nameStartChar + "][:\\." + nameChar + "]*"),
                classNameRegexp = /^\.-?[_a-zA-Z]+[\w\-]*/,
                classIdRegexp = /^#[_a-zA-Z]+[\w\-]*/,
                mode = {
                    startState: function() {
                        var htmlState = CodeMirror.startState(htmlMode),
                            rubyState = CodeMirror.startState(rubyMode);
                        return {
                            htmlState: htmlState,
                            rubyState: rubyState,
                            stack: null,
                            last: null,
                            tokenize: slim,
                            line: slim,
                            indented: 0
                        }
                    },
                    copyState: function(state) {
                        return {
                            htmlState: CodeMirror.copyState(htmlMode, state.htmlState),
                            rubyState: CodeMirror.copyState(rubyMode, state.rubyState),
                            subMode: state.subMode,
                            subState: state.subMode && CodeMirror.copyState(state.subMode, state.subState),
                            stack: state.stack,
                            last: state.last,
                            tokenize: state.tokenize,
                            line: state.line
                        }
                    },
                    token: function(stream, state) {
                        if (stream.sol())
                            for (state.indented = stream.indentation(), state.startOfLine = !0, state.tokenize = state.line; state.stack && state.stack.indented > state.indented && "slimSubmode" != state.last;) state.line = state.tokenize = state.stack.tokenize, state.stack = state.stack.parent, state.subMode = null, state.subState = null;
                        if (stream.eatSpace()) return null;
                        var style = state.tokenize(stream, state);
                        return state.startOfLine = !1, style && (state.last = style), styleMap.hasOwnProperty(style) ? styleMap[style] : style
                    },
                    blankLine: function(state) {
                        if (state.subMode && state.subMode.blankLine) return state.subMode.blankLine(state.subState)
                    },
                    innerMode: function(state) {
                        return state.subMode ? {
                            state: state.subState,
                            mode: state.subMode
                        } : {
                            state: state,
                            mode: mode
                        }
                    }
                };
            return mode
        }, "htmlmixed", "ruby"), CodeMirror.defineMIME("text/x-slim", "slim"), CodeMirror.defineMIME("application/x-slim", "slim")
    }),
    function(mod) {
        "object" == ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "object" == ("undefined" == typeof module ? "undefined" : _typeof2(module)) ? mod(require("../../lib/codemirror"), require("../css/css")): "function" == typeof define && define.amd ? define(["../../lib/codemirror", "../css/css"], mod) : mod(CodeMirror)
    }(function(CodeMirror) {
        "use strict";
        CodeMirror.defineMode("sass", function(config) {
            function tokenRegexp(words) {
                return new RegExp("^" + words.join("|"))
            }

            function isEndLine(stream) {
                return !stream.peek() || stream.match(/\s+$/, !1)
            }

            function urlTokens(stream, state) {
                var ch = stream.peek();
                return ")" === ch ? (stream.next(), state.tokenizer = tokenBase, "operator") : "(" === ch ? (stream.next(), stream.eatSpace(), "operator") : "'" === ch || '"' === ch ? (state.tokenizer = buildStringTokenizer(stream.next()), "string") : (state.tokenizer = buildStringTokenizer(")", !1), "string")
            }

            function comment(indentation, multiLine) {
                return function(stream, state) {
                    return stream.sol() && stream.indentation() <= indentation ? (state.tokenizer = tokenBase, tokenBase(stream, state)) : (multiLine && stream.skipTo("*/") ? (stream.next(), stream.next(), state.tokenizer = tokenBase) : stream.skipToEnd(), "comment")
                }
            }

            function buildStringTokenizer(quote, greedy) {
                function stringTokenizer(stream, state) {
                    var nextChar = stream.next(),
                        peekChar = stream.peek(),
                        previousChar = stream.string.charAt(stream.pos - 2),
                        endingString = "\\" !== nextChar && peekChar === quote || nextChar === quote && "\\" !== previousChar;
                    return endingString ? (nextChar !== quote && greedy && stream.next(), isEndLine(stream) && (state.cursorHalf = 0), state.tokenizer = tokenBase, "string") : "#" === nextChar && "{" === peekChar ? (state.tokenizer = buildInterpolationTokenizer(stringTokenizer), stream.next(), "operator") : "string"
                }
                return null == greedy && (greedy = !0), stringTokenizer
            }

            function buildInterpolationTokenizer(currentTokenizer) {
                return function(stream, state) {
                    return "}" === stream.peek() ? (stream.next(), state.tokenizer = currentTokenizer, "operator") : tokenBase(stream, state)
                }
            }

            function indent(state) {
                if (0 == state.indentCount) {
                    state.indentCount++;
                    var lastScopeOffset = state.scopes[0].offset,
                        currentOffset = lastScopeOffset + config.indentUnit;
                    state.scopes.unshift({
                        offset: currentOffset
                    })
                }
            }

            function dedent(state) {
                1 != state.scopes.length && state.scopes.shift()
            }

            function tokenBase(stream, state) {
                var ch = stream.peek();
                if (stream.match("/*")) return state.tokenizer = comment(stream.indentation(), !0), state.tokenizer(stream, state);
                if (stream.match("//")) return state.tokenizer = comment(stream.indentation(), !1), state.tokenizer(stream, state);
                if (stream.match("#{")) return state.tokenizer = buildInterpolationTokenizer(tokenBase), "operator";
                if ('"' === ch || "'" === ch) return stream.next(), state.tokenizer = buildStringTokenizer(ch), "string";
                if (state.cursorHalf) {
                    if ("#" === ch && (stream.next(), stream.match(/[0-9a-fA-F]{6}|[0-9a-fA-F]{3}/))) return isEndLine(stream) && (state.cursorHalf = 0), "number";
                    if (stream.match(/^-?[0-9\.]+/)) return isEndLine(stream) && (state.cursorHalf = 0), "number";
                    if (stream.match(/^(px|em|in)\b/)) return isEndLine(stream) && (state.cursorHalf = 0), "unit";
                    if (stream.match(keywordsRegexp)) return isEndLine(stream) && (state.cursorHalf = 0), "keyword";
                    if (stream.match(/^url/) && "(" === stream.peek()) return state.tokenizer = urlTokens, isEndLine(stream) && (state.cursorHalf = 0), "atom";
                    if ("$" === ch) return stream.next(), stream.eatWhile(/[\w-]/), isEndLine(stream) && (state.cursorHalf = 0), "variable-2";
                    if ("!" === ch) return stream.next(), state.cursorHalf = 0, stream.match(/^[\w]+/) ? "keyword" : "operator";
                    if (stream.match(opRegexp)) return isEndLine(stream) && (state.cursorHalf = 0), "operator";
                    if (stream.eatWhile(/[\w-]/)) return isEndLine(stream) && (state.cursorHalf = 0), word = stream.current().toLowerCase(), valueKeywords.hasOwnProperty(word) ? "atom" : colorKeywords.hasOwnProperty(word) ? "keyword" : propertyKeywords.hasOwnProperty(word) ? (state.prevProp = stream.current().toLowerCase(), "property") : "tag";
                    if (isEndLine(stream)) return state.cursorHalf = 0, null
                } else {
                    if ("-" === ch && stream.match(/^-\w+-/)) return "meta";
                    if ("." === ch) {
                        if (stream.next(), stream.match(/^[\w-]+/)) return indent(state), "qualifier";
                        if ("#" === stream.peek()) return indent(state), "tag"
                    }
                    if ("#" === ch) {
                        if (stream.next(), stream.match(/^[\w-]+/)) return indent(state), "builtin";
                        if ("#" === stream.peek()) return indent(state), "tag"
                    }
                    if ("$" === ch) return stream.next(), stream.eatWhile(/[\w-]/), "variable-2";
                    if (stream.match(/^-?[0-9\.]+/)) return "number";
                    if (stream.match(/^(px|em|in)\b/)) return "unit";
                    if (stream.match(keywordsRegexp)) return "keyword";
                    if (stream.match(/^url/) && "(" === stream.peek()) return state.tokenizer = urlTokens, "atom";
                    if ("=" === ch && stream.match(/^=[\w-]+/)) return indent(state), "meta";
                    if ("+" === ch && stream.match(/^\+[\w-]+/)) return "variable-3";
                    if ("@" === ch && stream.match(/@extend/) && (stream.match(/\s*[\w]/) || dedent(state)), stream.match(/^@(else if|if|media|else|for|each|while|mixin|function)/)) return indent(state), "def";
                    if ("@" === ch) return stream.next(), stream.eatWhile(/[\w-]/), "def";
                    if (stream.eatWhile(/[\w-]/)) {
                        if (stream.match(/ *: *[\w-\+\$#!\("']/, !1)) {
                            word = stream.current().toLowerCase();
                            var prop = state.prevProp + "-" + word;
                            return propertyKeywords.hasOwnProperty(prop) ? "property" : propertyKeywords.hasOwnProperty(word) ? (state.prevProp = word, "property") : fontProperties.hasOwnProperty(word) ? "property" : "tag"
                        }
                        return stream.match(/ *:/, !1) ? (indent(state), state.cursorHalf = 1, state.prevProp = stream.current().toLowerCase(), "property") : stream.match(/ *,/, !1) ? "tag" : (indent(state), "tag")
                    }
                    if (":" === ch) return stream.match(pseudoElementsRegexp) ? "variable-3" : (stream.next(), state.cursorHalf = 1, "operator")
                }
                return stream.match(opRegexp) ? "operator" : (stream.next(), null)
            }

            function tokenLexer(stream, state) {
                stream.sol() && (state.indentCount = 0);
                var style = state.tokenizer(stream, state),
                    current = stream.current();
                if ("@return" !== current && "}" !== current || dedent(state), null !== style) {
                    for (var startOfToken = stream.pos - current.length, withCurrentIndent = startOfToken + config.indentUnit * state.indentCount, newScopes = [], i = 0; i < state.scopes.length; i++) {
                        var scope = state.scopes[i];
                        scope.offset <= withCurrentIndent && newScopes.push(scope)
                    }
                    state.scopes = newScopes
                }
                return style
            }
            var word, cssMode = CodeMirror.mimeModes["text/css"],
                propertyKeywords = cssMode.propertyKeywords || {},
                colorKeywords = cssMode.colorKeywords || {},
                valueKeywords = cssMode.valueKeywords || {},
                fontProperties = cssMode.fontProperties || {},
                keywords = ["true", "false", "null", "auto"],
                keywordsRegexp = new RegExp("^" + keywords.join("|")),
                operators = ["\\(", "\\)", "=", ">", "<", "==", ">=", "<=", "\\+", "-", "\\!=", "/", "\\*", "%", "and", "or", "not", ";", "\\{", "\\}", ":"],
                opRegexp = tokenRegexp(operators),
                pseudoElementsRegexp = /^::?[a-zA-Z_][\w\-]*/;
            return {
                startState: function() {
                    return {
                        tokenizer: tokenBase,
                        scopes: [{
                            offset: 0,
                            type: "sass"
                        }],
                        indentCount: 0,
                        cursorHalf: 0,
                        definedVars: [],
                        definedMixins: []
                    }
                },
                token: function(stream, state) {
                    var style = tokenLexer(stream, state);
                    return state.lastToken = {
                        style: style,
                        content: stream.current()
                    }, style
                },
                indent: function(state) {
                    return state.scopes[0].offset
                }
            }
        }, "css"), CodeMirror.defineMIME("text/x-sass", "sass")
    }), ! function(e, t) {
        "object" == ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : e.ImageCompressor = t()
    }(this, function() {
        "use strict";

        function A(e) {
            return r.test(e)
        }

        function u(e) {
            var t = new DataView(e),
                r = void 0,
                n = void 0,
                a = void 0,
                i = void 0;
            if (255 === t.getUint8(0) && 216 === t.getUint8(1))
                for (var o = t.byteLength, l = 2; l < o;) {
                    if (255 === t.getUint8(l) && 225 === t.getUint8(l + 1)) {
                        a = l;
                        break
                    }
                    l += 1
                }
            if (a) {
                var u = a + 10;
                if ("Exif" === function(e, t, r) {
                        var n = "",
                            a = void 0;
                        for (r += t, a = t; a < r; a += 1) n += m(e.getUint8(a));
                        return n
                    }(t, a + 4, 4)) {
                    var c = t.getUint16(u);
                    if (((n = 18761 === c) || 19789 === c) && 42 === t.getUint16(u + 2, n)) {
                        var f = t.getUint32(u + 4, n);
                        8 <= f && (i = u + f)
                    }
                }
            }
            if (i) {
                var s = t.getUint16(i, n),
                    h = void 0,
                    d = void 0;
                for (d = 0; d < s; d += 1)
                    if (h = i + 12 * d + 2, 274 === t.getUint16(h, n)) {
                        h += 8, r = t.getUint16(h, n), t.setUint16(h, 1, n);
                        break
                    }
            }
            return r
        }

        function R(e) {
            var t = 1 < arguments.length && void 0 !== arguments[1] ? arguments[1] : 1e11;
            return n.test(e) ? Math.round(e * t) / t : e
        }
        var e, k = (function(e) {
                var t, a, f, s, h, d, i;
                t = window, a = t.HTMLCanvasElement && t.HTMLCanvasElement.prototype, f = t.Blob && function() {
                    try {
                        return Boolean(new Blob)
                    } catch (e) {
                        return !1
                    }
                }(), s = f && t.Uint8Array && function() {
                    try {
                        return 100 === new Blob([new Uint8Array(100)]).size
                    } catch (e) {
                        return !1
                    }
                }(), h = t.BlobBuilder || t.WebKitBlobBuilder || t.MozBlobBuilder || t.MSBlobBuilder, d = /^data:((.*?)(;charset=.*?)?)(;base64)?,/, i = (f || h) && t.atob && t.ArrayBuffer && t.Uint8Array && function(e) {
                    var t, r, n, a, i, o, l, u, c;
                    if (!(t = e.match(d))) throw new Error("invalid data URI");
                    for (r = t[2] ? t[1] : "text/plain" + (t[3] || ";charset=US-ASCII"), n = !!t[4], a = e.slice(t[0].length), i = n ? atob(a) : decodeURIComponent(a), o = new ArrayBuffer(i.length), l = new Uint8Array(o), u = 0; u < i.length; u += 1) l[u] = i.charCodeAt(u);
                    return f ? new Blob([s ? l : o], {
                        type: r
                    }) : ((c = new h).append(o), c.getBlob(r))
                }, t.HTMLCanvasElement && !a.toBlob && (a.mozGetAsFile ? a.toBlob = function(e, t, r) {
                    var n = this;
                    setTimeout(function() {
                        e(r && a.toDataURL && i ? i(n.toDataURL(t, r)) : n.mozGetAsFile("blob", t))
                    })
                } : a.toDataURL && i && (a.toBlob = function(e, t, r) {
                    var n = this;
                    setTimeout(function() {
                        e(i(n.toDataURL(t, r)))
                    })
                })), e.exports ? e.exports = i : t.dataURLtoBlob = i
            }(e = {
                exports: {}
            }, e.exports), e.exports),
            o = Object.prototype.toString,
            t = {
                checkOrientation: !0,
                maxWidth: 1 / 0,
                maxHeight: 1 / 0,
                minWidth: 0,
                minHeight: 0,
                width: void 0,
                height: void 0,
                quality: .8,
                mimeType: "auto",
                convertSize: 5e6,
                beforeDraw: null,
                drew: null,
                success: null,
                error: null
            },
            r = /^image\/.+$/,
            m = String.fromCharCode,
            l = window.btoa,
            n = /\.\d*(?:0|9){12}\d*$/i,
            a = function() {
                function n(e, t) {
                    for (var r = 0; r < t.length; r++) {
                        var n = t[r];
                        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
                    }
                }
                return function(e, t, r) {
                    return t && n(e.prototype, t), r && n(e, r), e
                }
            }(),
            c = Object.assign || function(e) {
                for (var t = 1; t < arguments.length; t++) {
                    var r = arguments[t];
                    for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
                }
                return e
            },
            i = window,
            f = i.ArrayBuffer,
            s = i.FileReader,
            h = window.URL || window.webkitURL,
            d = /\.\w+$/;
        return function() {
            function r(e, t) {
                ! function(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }(this, r), this.result = null, e && this.compress(e, t)
            }
            return a(r, [{
                key: "compress",
                value: function(B, M) {
                    var x = this,
                        T = new Image;
                    return M = c({}, t, M), f || (M.checkOrientation = !1), new Promise(function(r, e) {
                        if ((t = B) instanceof Blob || "[object Blob]" === o.call(t)) {
                            var t, n = B.type;
                            if (A(n))
                                if (h || s) {
                                    if (h && !M.checkOrientation) r({
                                        url: h.createObjectURL(B)
                                    });
                                    else if (s) {
                                        var a = new s,
                                            i = M.checkOrientation && "image/jpeg" === n;
                                        a.onload = function(e) {
                                            var t = e.target.result;
                                            r(i ? c({
                                                url: function(e, t) {
                                                    var r = new Uint8Array(e),
                                                        n = "";
                                                    if ("function" == typeof r.forEach) r.forEach(function(e) {
                                                        n += m(e)
                                                    });
                                                    else
                                                        for (var a = r.length, i = 0; i < a; i += 1) n += m(r[i]);
                                                    return "data:" + t + ";base64," + l(n)
                                                }(t, n)
                                            }, function(e) {
                                                var t = 0,
                                                    r = 1,
                                                    n = 1;
                                                switch (e) {
                                                    case 2:
                                                        r = -1;
                                                        break;
                                                    case 3:
                                                        t = -180;
                                                        break;
                                                    case 4:
                                                        n = -1;
                                                        break;
                                                    case 5:
                                                        t = 90, n = -1;
                                                        break;
                                                    case 6:
                                                        t = 90;
                                                        break;
                                                    case 7:
                                                        t = 90, r = -1;
                                                        break;
                                                    case 8:
                                                        t = -90
                                                }
                                                return {
                                                    rotate: t,
                                                    scaleX: r,
                                                    scaleY: n
                                                }
                                            }(u(t))) : {
                                                url: t
                                            })
                                        }, a.onabort = function() {
                                            e(new Error("Aborted to load the image with FileReader."))
                                        }, a.onerror = function() {
                                            e(new Error("Failed to load the image with FileReader."))
                                        }, i ? a.readAsArrayBuffer(B) : a.readAsDataURL(B)
                                    }
                                } else e(new Error("The current browser does not support image compression."));
                            else e(new Error("The first argument must be an image File or Blob object."))
                        } else e(new Error("The first argument must be a File or Blob object."))
                    }).then(function(r) {
                        return new Promise(function(e, t) {
                            T.onload = function() {
                                return e(c({}, r, {
                                    naturalWidth: T.naturalWidth,
                                    naturalHeight: T.naturalHeight
                                }))
                            }, T.onabort = function() {
                                t(new Error("Aborted to load the image."))
                            }, T.onerror = function() {
                                t(new Error("Failed to load the image."))
                            }, T.alt = B.name, T.src = r.url
                        })
                    }).then(function(e) {
                        var b = e.naturalWidth,
                            w = e.naturalHeight,
                            t = e.rotate,
                            p = void 0 === t ? 0 : t,
                            r = e.scaleX,
                            y = void 0 === r ? 1 : r,
                            n = e.scaleY,
                            U = void 0 === n ? 1 : n;
                        return new Promise(function(t) {
                            var e = document.createElement("canvas"),
                                r = e.getContext("2d"),
                                n = b / w,
                                a = Math.max(M.maxWidth, 0) || 1 / 0,
                                i = Math.max(M.maxHeight, 0) || 1 / 0,
                                o = Math.max(M.minWidth, 0) || 0,
                                l = Math.max(M.minHeight, 0) || 0,
                                u = b,
                                c = w;
                            a < 1 / 0 && i < 1 / 0 ? a < i * n ? i = a / n : a = i * n : a < 1 / 0 ? i = a / n : i < 1 / 0 && (a = i * n), 0 < o && 0 < l ? o < l * n ? l = o / n : o = l * n : 0 < o ? l = o / n : 0 < l && (o = l * n), 0 < M.width ? c = (u = M.width) / n : 0 < M.height && (u = (c = M.height) * n);
                            var f = -(u = Math.min(Math.max(u, o), a)) / 2,
                                s = -(c = Math.min(Math.max(c, l), i)) / 2,
                                h = u,
                                d = c;
                            if (Math.abs(p) % 180 == 90) {
                                var m = {
                                    width: c,
                                    height: u
                                };
                                u = m.width, c = m.height
                            }
                            e.width = R(u), e.height = R(c), A(M.mimeType) || (M.mimeType = B.type);
                            var g = "transparent";
                            B.size > M.convertSize && "image/png" === M.mimeType && (g = "#fff", M.mimeType = "image/jpeg"), r.fillStyle = g, r.fillRect(0, 0, u, c), r.save(), r.translate(u / 2, c / 2), r.rotate(p * Math.PI / 180), r.scale(y, U), M.beforeDraw && M.beforeDraw.call(x, r, e), r.drawImage(T, Math.floor(R(f)), Math.floor(R(s)), Math.floor(R(h)), Math.floor(R(d))),
                                M.drew && M.drew.call(x, r, e), r.restore();
                            var v = function(e) {
                                t({
                                    naturalWidth: b,
                                    naturalHeight: w,
                                    result: e
                                })
                            };
                            e.toBlob ? e.toBlob(v, M.mimeType, M.quality) : v(k(e.toDataURL(M.mimeType, M.quality)))
                        })
                    }).then(function(e) {
                        var t = e.naturalWidth,
                            r = e.naturalHeight,
                            n = e.result;
                        if (h && !M.checkOrientation && h.revokeObjectURL(T.src), n)
                            if (n.size > B.size && M.mimeType === B.type && !(M.width > t || M.height > r || M.minWidth > t || M.minHeight > r)) n = B;
                            else {
                                var a = new Date;
                                n.lastModified = a.getTime(), n.lastModifiedDate = a, n.name = B.name, n.name && n.type !== B.type && (n.name = n.name.replace(d, function(e) {
                                    var t = !(1 < arguments.length && void 0 !== arguments[1]) || arguments[1],
                                        r = A(e) ? e.substr(6) : "";
                                    return "jpeg" === r && (r = "jpg"), r && t && (r = "." + r), r
                                }(n.type)))
                            }
                        else n = B;
                        return x.result = n, M.success && M.success.call(x, n), Promise.resolve(n)
                    }).catch(function(e) {
                        if (!M.error) throw e;
                        M.error.call(x, e)
                    })
                }
            }]), r
        }()
    }),
    function() {
        "use strict";
        var angular, Clipboard, MODULE_NAME = "ngclipboard";
        "object" === ("undefined" == typeof module ? "undefined" : _typeof2(module)) && module.exports ? (angular = require("angular"), Clipboard = require("clipboard"), module.exports = MODULE_NAME) : (angular = window.angular, Clipboard = window.Clipboard), angular.module(MODULE_NAME, []).directive("ngclipboard", function() {
            return {
                restrict: "A",
                scope: {
                    ngclipboardSuccess: "&",
                    ngclipboardError: "&"
                },
                link: function(scope, element) {
                    var clipboard = new Clipboard(element[0]);
                    clipboard.on("success", function(e) {
                        scope.$apply(function() {
                            scope.ngclipboardSuccess({
                                e: e
                            })
                        })
                    }), clipboard.on("error", function(e) {
                        scope.$apply(function() {
                            scope.ngclipboardError({
                                e: e
                            })
                        })
                    })
                }
            }
        })
    }(),
    function(Math) {
        function tinycolor(color, opts) {
            if (color = color ? color : "", opts = opts || {}, color instanceof tinycolor) return color;
            if (!(this instanceof tinycolor)) return new tinycolor(color, opts);
            var rgb = inputToRGB(color);
            this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = mathRound(100 * this._a) / 100, this._format = opts.format || rgb.format, this._gradientType = opts.gradientType, this._r < 1 && (this._r = mathRound(this._r)), this._g < 1 && (this._g = mathRound(this._g)), this._b < 1 && (this._b = mathRound(this._b)), this._ok = rgb.ok, this._tc_id = tinyCounter++
        }

        function inputToRGB(color) {
            var rgb = {
                    r: 0,
                    g: 0,
                    b: 0
                },
                a = 1,
                s = null,
                v = null,
                l = null,
                ok = !1,
                format = !1;
            return "string" == typeof color && (color = stringInputToObject(color)), "object" == _typeof2(color) && (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b) ? (rgb = rgbToRgb(color.r, color.g, color.b), ok = !0, format = "%" === String(color.r).substr(-1) ? "prgb" : "rgb") : isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v) ? (s = convertToPercentage(color.s), v = convertToPercentage(color.v), rgb = hsvToRgb(color.h, s, v), ok = !0, format = "hsv") : isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l) && (s = convertToPercentage(color.s), l = convertToPercentage(color.l), rgb = hslToRgb(color.h, s, l), ok = !0, format = "hsl"), color.hasOwnProperty("a") && (a = color.a)), a = boundAlpha(a), {
                ok: ok,
                format: color.format || format,
                r: mathMin(255, mathMax(rgb.r, 0)),
                g: mathMin(255, mathMax(rgb.g, 0)),
                b: mathMin(255, mathMax(rgb.b, 0)),
                a: a
            }
        }

        function rgbToRgb(r, g, b) {
            return {
                r: 255 * bound01(r, 255),
                g: 255 * bound01(g, 255),
                b: 255 * bound01(b, 255)
            }
        }

        function rgbToHsl(r, g, b) {
            r = bound01(r, 255), g = bound01(g, 255), b = bound01(b, 255);
            var h, s, max = mathMax(r, g, b),
                min = mathMin(r, g, b),
                l = (max + min) / 2;
            if (max == min) h = s = 0;
            else {
                var d = max - min;
                switch (s = l > .5 ? d / (2 - max - min) : d / (max + min), max) {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4
                }
                h /= 6
            }
            return {
                h: h,
                s: s,
                l: l
            }
        }

        function hslToRgb(h, s, l) {
            function hue2rgb(p, q, t) {
                return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? p + 6 * (q - p) * t : t < .5 ? q : t < 2 / 3 ? p + (q - p) * (2 / 3 - t) * 6 : p
            }
            var r, g, b;
            if (h = bound01(h, 360), s = bound01(s, 100), l = bound01(l, 100), 0 === s) r = g = b = l;
            else {
                var q = l < .5 ? l * (1 + s) : l + s - l * s,
                    p = 2 * l - q;
                r = hue2rgb(p, q, h + 1 / 3), g = hue2rgb(p, q, h), b = hue2rgb(p, q, h - 1 / 3)
            }
            return {
                r: 255 * r,
                g: 255 * g,
                b: 255 * b
            }
        }

        function rgbToHsv(r, g, b) {
            r = bound01(r, 255), g = bound01(g, 255), b = bound01(b, 255);
            var h, s, max = mathMax(r, g, b),
                min = mathMin(r, g, b),
                v = max,
                d = max - min;
            if (s = 0 === max ? 0 : d / max, max == min) h = 0;
            else {
                switch (max) {
                    case r:
                        h = (g - b) / d + (g < b ? 6 : 0);
                        break;
                    case g:
                        h = (b - r) / d + 2;
                        break;
                    case b:
                        h = (r - g) / d + 4
                }
                h /= 6
            }
            return {
                h: h,
                s: s,
                v: v
            }
        }

        function hsvToRgb(h, s, v) {
            h = 6 * bound01(h, 360), s = bound01(s, 100), v = bound01(v, 100);
            var i = Math.floor(h),
                f = h - i,
                p = v * (1 - s),
                q = v * (1 - f * s),
                t = v * (1 - (1 - f) * s),
                mod = i % 6,
                r = [v, q, p, p, t, v][mod],
                g = [t, v, v, q, p, p][mod],
                b = [p, p, t, v, v, q][mod];
            return {
                r: 255 * r,
                g: 255 * g,
                b: 255 * b
            }
        }

        function rgbToHex(r, g, b, allow3Char) {
            var hex = [pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16))];
            return allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) ? hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) : hex.join("")
        }

        function rgbaToHex(r, g, b, a, allow4Char) {
            var hex = [pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16)), pad2(convertDecimalToHex(a))];
            return allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1) ? hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0) : hex.join("")
        }

        function rgbaToArgbHex(r, g, b, a) {
            var hex = [pad2(convertDecimalToHex(a)), pad2(mathRound(r).toString(16)), pad2(mathRound(g).toString(16)), pad2(mathRound(b).toString(16))];
            return hex.join("")
        }

        function _desaturate(color, amount) {
            amount = 0 === amount ? 0 : amount || 10;
            var hsl = tinycolor(color).toHsl();
            return hsl.s -= amount / 100, hsl.s = clamp01(hsl.s), tinycolor(hsl)
        }

        function _saturate(color, amount) {
            amount = 0 === amount ? 0 : amount || 10;
            var hsl = tinycolor(color).toHsl();
            return hsl.s += amount / 100, hsl.s = clamp01(hsl.s), tinycolor(hsl)
        }

        function _greyscale(color) {
            return tinycolor(color).desaturate(100)
        }

        function _lighten(color, amount) {
            amount = 0 === amount ? 0 : amount || 10;
            var hsl = tinycolor(color).toHsl();
            return hsl.l += amount / 100, hsl.l = clamp01(hsl.l), tinycolor(hsl)
        }

        function _brighten(color, amount) {
            amount = 0 === amount ? 0 : amount || 10;
            var rgb = tinycolor(color).toRgb();
            return rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * -(amount / 100)))), rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * -(amount / 100)))), rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * -(amount / 100)))), tinycolor(rgb)
        }

        function _darken(color, amount) {
            amount = 0 === amount ? 0 : amount || 10;
            var hsl = tinycolor(color).toHsl();
            return hsl.l -= amount / 100, hsl.l = clamp01(hsl.l), tinycolor(hsl)
        }

        function _spin(color, amount) {
            var hsl = tinycolor(color).toHsl(),
                hue = (hsl.h + amount) % 360;
            return hsl.h = hue < 0 ? 360 + hue : hue, tinycolor(hsl)
        }

        function _complement(color) {
            var hsl = tinycolor(color).toHsl();
            return hsl.h = (hsl.h + 180) % 360, tinycolor(hsl)
        }

        function _triad(color) {
            var hsl = tinycolor(color).toHsl(),
                h = hsl.h;
            return [tinycolor(color), tinycolor({
                h: (h + 120) % 360,
                s: hsl.s,
                l: hsl.l
            }), tinycolor({
                h: (h + 240) % 360,
                s: hsl.s,
                l: hsl.l
            })]
        }

        function _tetrad(color) {
            var hsl = tinycolor(color).toHsl(),
                h = hsl.h;
            return [tinycolor(color), tinycolor({
                h: (h + 90) % 360,
                s: hsl.s,
                l: hsl.l
            }), tinycolor({
                h: (h + 180) % 360,
                s: hsl.s,
                l: hsl.l
            }), tinycolor({
                h: (h + 270) % 360,
                s: hsl.s,
                l: hsl.l
            })]
        }

        function _splitcomplement(color) {
            var hsl = tinycolor(color).toHsl(),
                h = hsl.h;
            return [tinycolor(color), tinycolor({
                h: (h + 72) % 360,
                s: hsl.s,
                l: hsl.l
            }), tinycolor({
                h: (h + 216) % 360,
                s: hsl.s,
                l: hsl.l
            })]
        }

        function _analogous(color, results, slices) {
            results = results || 6, slices = slices || 30;
            var hsl = tinycolor(color).toHsl(),
                part = 360 / slices,
                ret = [tinycolor(color)];
            for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) hsl.h = (hsl.h + part) % 360, ret.push(tinycolor(hsl));
            return ret
        }

        function _monochromatic(color, results) {
            results = results || 6;
            for (var hsv = tinycolor(color).toHsv(), h = hsv.h, s = hsv.s, v = hsv.v, ret = [], modification = 1 / results; results--;) ret.push(tinycolor({
                h: h,
                s: s,
                v: v
            })), v = (v + modification) % 1;
            return ret
        }

        function flip(o) {
            var flipped = {};
            for (var i in o) o.hasOwnProperty(i) && (flipped[o[i]] = i);
            return flipped
        }

        function boundAlpha(a) {
            return a = parseFloat(a), (isNaN(a) || a < 0 || a > 1) && (a = 1), a
        }

        function bound01(n, max) {
            isOnePointZero(n) && (n = "100%");
            var processPercent = isPercentage(n);
            return n = mathMin(max, mathMax(0, parseFloat(n))), processPercent && (n = parseInt(n * max, 10) / 100), Math.abs(n - max) < 1e-6 ? 1 : n % max / parseFloat(max)
        }

        function clamp01(val) {
            return mathMin(1, mathMax(0, val))
        }

        function parseIntFromHex(val) {
            return parseInt(val, 16)
        }

        function isOnePointZero(n) {
            return "string" == typeof n && n.indexOf(".") != -1 && 1 === parseFloat(n)
        }

        function isPercentage(n) {
            return "string" == typeof n && n.indexOf("%") != -1
        }

        function pad2(c) {
            return 1 == c.length ? "0" + c : "" + c
        }

        function convertToPercentage(n) {
            return n <= 1 && (n = 100 * n + "%"), n
        }

        function convertDecimalToHex(d) {
            return Math.round(255 * parseFloat(d)).toString(16)
        }

        function convertHexToDecimal(h) {
            return parseIntFromHex(h) / 255
        }

        function isValidCSSUnit(color) {
            return !!matchers.CSS_UNIT.exec(color)
        }

        function stringInputToObject(color) {
            color = color.replace(trimLeft, "").replace(trimRight, "").toLowerCase();
            var named = !1;
            if (names[color]) color = names[color], named = !0;
            else if ("transparent" == color) return {
                r: 0,
                g: 0,
                b: 0,
                a: 0,
                format: "name"
            };
            var match;
            return (match = matchers.rgb.exec(color)) ? {
                r: match[1],
                g: match[2],
                b: match[3]
            } : (match = matchers.rgba.exec(color)) ? {
                r: match[1],
                g: match[2],
                b: match[3],
                a: match[4]
            } : (match = matchers.hsl.exec(color)) ? {
                h: match[1],
                s: match[2],
                l: match[3]
            } : (match = matchers.hsla.exec(color)) ? {
                h: match[1],
                s: match[2],
                l: match[3],
                a: match[4]
            } : (match = matchers.hsv.exec(color)) ? {
                h: match[1],
                s: match[2],
                v: match[3]
            } : (match = matchers.hsva.exec(color)) ? {
                h: match[1],
                s: match[2],
                v: match[3],
                a: match[4]
            } : (match = matchers.hex8.exec(color)) ? {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                a: convertHexToDecimal(match[4]),
                format: named ? "name" : "hex8"
            } : (match = matchers.hex6.exec(color)) ? {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                format: named ? "name" : "hex"
            } : (match = matchers.hex4.exec(color)) ? {
                r: parseIntFromHex(match[1] + "" + match[1]),
                g: parseIntFromHex(match[2] + "" + match[2]),
                b: parseIntFromHex(match[3] + "" + match[3]),
                a: convertHexToDecimal(match[4] + "" + match[4]),
                format: named ? "name" : "hex8"
            } : !!(match = matchers.hex3.exec(color)) && {
                r: parseIntFromHex(match[1] + "" + match[1]),
                g: parseIntFromHex(match[2] + "" + match[2]),
                b: parseIntFromHex(match[3] + "" + match[3]),
                format: named ? "name" : "hex"
            }
        }

        function validateWCAG2Parms(parms) {
            var level, size;
            return parms = parms || {
                level: "AA",
                size: "small"
            }, level = (parms.level || "AA").toUpperCase(), size = (parms.size || "small").toLowerCase(), "AA" !== level && "AAA" !== level && (level = "AA"), "small" !== size && "large" !== size && (size = "small"), {
                level: level,
                size: size
            }
        }
        var trimLeft = /^\s+/,
            trimRight = /\s+$/,
            tinyCounter = 0,
            mathRound = Math.round,
            mathMin = Math.min,
            mathMax = Math.max,
            mathRandom = Math.random;
        tinycolor.prototype = {
            isDark: function() {
                return this.getBrightness() < 128
            },
            isLight: function() {
                return !this.isDark()
            },
            isValid: function() {
                return this._ok
            },
            getOriginalInput: function() {
                return this._originalInput
            },
            getFormat: function() {
                return this._format
            },
            getAlpha: function() {
                return this._a
            },
            getBrightness: function() {
                var rgb = this.toRgb();
                return (299 * rgb.r + 587 * rgb.g + 114 * rgb.b) / 1e3
            },
            getLuminance: function() {
                var RsRGB, GsRGB, BsRGB, R, G, B, rgb = this.toRgb();
                return RsRGB = rgb.r / 255, GsRGB = rgb.g / 255, BsRGB = rgb.b / 255, R = RsRGB <= .03928 ? RsRGB / 12.92 : Math.pow((RsRGB + .055) / 1.055, 2.4), G = GsRGB <= .03928 ? GsRGB / 12.92 : Math.pow((GsRGB + .055) / 1.055, 2.4), B = BsRGB <= .03928 ? BsRGB / 12.92 : Math.pow((BsRGB + .055) / 1.055, 2.4), .2126 * R + .7152 * G + .0722 * B
            },
            setAlpha: function(value) {
                return this._a = boundAlpha(value), this._roundA = mathRound(100 * this._a) / 100, this
            },
            toHsv: function() {
                var hsv = rgbToHsv(this._r, this._g, this._b);
                return {
                    h: 360 * hsv.h,
                    s: hsv.s,
                    v: hsv.v,
                    a: this._a
                }
            },
            toHsvString: function() {
                var hsv = rgbToHsv(this._r, this._g, this._b),
                    h = mathRound(360 * hsv.h),
                    s = mathRound(100 * hsv.s),
                    v = mathRound(100 * hsv.v);
                return 1 == this._a ? "hsv(" + h + ", " + s + "%, " + v + "%)" : "hsva(" + h + ", " + s + "%, " + v + "%, " + this._roundA + ")"
            },
            toHsl: function() {
                var hsl = rgbToHsl(this._r, this._g, this._b);
                return {
                    h: 360 * hsl.h,
                    s: hsl.s,
                    l: hsl.l,
                    a: this._a
                }
            },
            toHslString: function() {
                var hsl = rgbToHsl(this._r, this._g, this._b),
                    h = mathRound(360 * hsl.h),
                    s = mathRound(100 * hsl.s),
                    l = mathRound(100 * hsl.l);
                return 1 == this._a ? "hsl(" + h + ", " + s + "%, " + l + "%)" : "hsla(" + h + ", " + s + "%, " + l + "%, " + this._roundA + ")"
            },
            toHex: function(allow3Char) {
                return rgbToHex(this._r, this._g, this._b, allow3Char)
            },
            toHexString: function(allow3Char) {
                return "#" + this.toHex(allow3Char)
            },
            toHex8: function(allow4Char) {
                return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char)
            },
            toHex8String: function(allow4Char) {
                return "#" + this.toHex8(allow4Char)
            },
            toRgb: function() {
                return {
                    r: mathRound(this._r),
                    g: mathRound(this._g),
                    b: mathRound(this._b),
                    a: this._a
                }
            },
            toRgbString: function() {
                return 1 == this._a ? "rgb(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" : "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")"
            },
            toPercentageRgb: function() {
                return {
                    r: mathRound(100 * bound01(this._r, 255)) + "%",
                    g: mathRound(100 * bound01(this._g, 255)) + "%",
                    b: mathRound(100 * bound01(this._b, 255)) + "%",
                    a: this._a
                }
            },
            toPercentageRgbString: function() {
                return 1 == this._a ? "rgb(" + mathRound(100 * bound01(this._r, 255)) + "%, " + mathRound(100 * bound01(this._g, 255)) + "%, " + mathRound(100 * bound01(this._b, 255)) + "%)" : "rgba(" + mathRound(100 * bound01(this._r, 255)) + "%, " + mathRound(100 * bound01(this._g, 255)) + "%, " + mathRound(100 * bound01(this._b, 255)) + "%, " + this._roundA + ")"
            },
            toName: function() {
                return 0 === this._a ? "transparent" : !(this._a < 1) && (hexNames[rgbToHex(this._r, this._g, this._b, !0)] || !1)
            },
            toFilter: function(secondColor) {
                var hex8String = "#" + rgbaToArgbHex(this._r, this._g, this._b, this._a),
                    secondHex8String = hex8String,
                    gradientType = this._gradientType ? "GradientType = 1, " : "";
                if (secondColor) {
                    var s = tinycolor(secondColor);
                    secondHex8String = "#" + rgbaToArgbHex(s._r, s._g, s._b, s._a)
                }
                return "progid:DXImageTransform.Microsoft.gradient(" + gradientType + "startColorstr=" + hex8String + ",endColorstr=" + secondHex8String + ")"
            },
            toString: function(format) {
                var formatSet = !!format;
                format = format || this._format;
                var formattedString = !1,
                    hasAlpha = this._a < 1 && this._a >= 0,
                    needsAlphaFormat = !formatSet && hasAlpha && ("hex" === format || "hex6" === format || "hex3" === format || "hex4" === format || "hex8" === format || "name" === format);
                return needsAlphaFormat ? "name" === format && 0 === this._a ? this.toName() : this.toRgbString() : ("rgb" === format && (formattedString = this.toRgbString()), "prgb" === format && (formattedString = this.toPercentageRgbString()), "hex" !== format && "hex6" !== format || (formattedString = this.toHexString()), "hex3" === format && (formattedString = this.toHexString(!0)), "hex4" === format && (formattedString = this.toHex8String(!0)), "hex8" === format && (formattedString = this.toHex8String()), "name" === format && (formattedString = this.toName()), "hsl" === format && (formattedString = this.toHslString()), "hsv" === format && (formattedString = this.toHsvString()), formattedString || this.toHexString())
            },
            clone: function() {
                return tinycolor(this.toString())
            },
            _applyModification: function(fn, args) {
                var color = fn.apply(null, [this].concat([].slice.call(args)));
                return this._r = color._r, this._g = color._g, this._b = color._b, this.setAlpha(color._a), this
            },
            lighten: function() {
                return this._applyModification(_lighten, arguments)
            },
            brighten: function() {
                return this._applyModification(_brighten, arguments)
            },
            darken: function() {
                return this._applyModification(_darken, arguments)
            },
            desaturate: function() {
                return this._applyModification(_desaturate, arguments)
            },
            saturate: function() {
                return this._applyModification(_saturate, arguments)
            },
            greyscale: function() {
                return this._applyModification(_greyscale, arguments)
            },
            spin: function() {
                return this._applyModification(_spin, arguments)
            },
            _applyCombination: function(fn, args) {
                return fn.apply(null, [this].concat([].slice.call(args)))
            },
            analogous: function() {
                return this._applyCombination(_analogous, arguments)
            },
            complement: function() {
                return this._applyCombination(_complement, arguments)
            },
            monochromatic: function() {
                return this._applyCombination(_monochromatic, arguments)
            },
            splitcomplement: function() {
                return this._applyCombination(_splitcomplement, arguments)
            },
            triad: function() {
                return this._applyCombination(_triad, arguments)
            },
            tetrad: function() {
                return this._applyCombination(_tetrad, arguments)
            }
        }, tinycolor.fromRatio = function(color, opts) {
            if ("object" == _typeof2(color)) {
                var newColor = {};
                for (var i in color) color.hasOwnProperty(i) && ("a" === i ? newColor[i] = color[i] : newColor[i] = convertToPercentage(color[i]));
                color = newColor
            }
            return tinycolor(color, opts)
        }, tinycolor.equals = function(color1, color2) {
            return !(!color1 || !color2) && tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString()
        }, tinycolor.random = function() {
            return tinycolor.fromRatio({
                r: mathRandom(),
                g: mathRandom(),
                b: mathRandom()
            })
        }, tinycolor.mix = function(color1, color2, amount) {
            amount = 0 === amount ? 0 : amount || 50;
            var rgb1 = tinycolor(color1).toRgb(),
                rgb2 = tinycolor(color2).toRgb(),
                p = amount / 100,
                rgba = {
                    r: (rgb2.r - rgb1.r) * p + rgb1.r,
                    g: (rgb2.g - rgb1.g) * p + rgb1.g,
                    b: (rgb2.b - rgb1.b) * p + rgb1.b,
                    a: (rgb2.a - rgb1.a) * p + rgb1.a
                };
            return tinycolor(rgba)
        }, tinycolor.readability = function(color1, color2) {
            var c1 = tinycolor(color1),
                c2 = tinycolor(color2);
            return (Math.max(c1.getLuminance(), c2.getLuminance()) + .05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + .05)
        }, tinycolor.isReadable = function(color1, color2, wcag2) {
            var wcag2Parms, out, readability = tinycolor.readability(color1, color2);
            switch (out = !1, wcag2Parms = validateWCAG2Parms(wcag2), wcag2Parms.level + wcag2Parms.size) {
                case "AAsmall":
                case "AAAlarge":
                    out = readability >= 4.5;
                    break;
                case "AAlarge":
                    out = readability >= 3;
                    break;
                case "AAAsmall":
                    out = readability >= 7
            }
            return out
        }, tinycolor.mostReadable = function(baseColor, colorList, args) {
            var readability, includeFallbackColors, level, size, bestColor = null,
                bestScore = 0;
            args = args || {}, includeFallbackColors = args.includeFallbackColors, level = args.level, size = args.size;
            for (var i = 0; i < colorList.length; i++) readability = tinycolor.readability(baseColor, colorList[i]), readability > bestScore && (bestScore = readability, bestColor = tinycolor(colorList[i]));
            return tinycolor.isReadable(baseColor, bestColor, {
                level: level,
                size: size
            }) || !includeFallbackColors ? bestColor : (args.includeFallbackColors = !1, tinycolor.mostReadable(baseColor, ["#fff", "#000"], args))
        };
        var names = tinycolor.names = {
                aliceblue: "f0f8ff",
                antiquewhite: "faebd7",
                aqua: "0ff",
                aquamarine: "7fffd4",
                azure: "f0ffff",
                beige: "f5f5dc",
                bisque: "ffe4c4",
                black: "000",
                blanchedalmond: "ffebcd",
                blue: "00f",
                blueviolet: "8a2be2",
                brown: "a52a2a",
                burlywood: "deb887",
                burntsienna: "ea7e5d",
                cadetblue: "5f9ea0",
                chartreuse: "7fff00",
                chocolate: "d2691e",
                coral: "ff7f50",
                cornflowerblue: "6495ed",
                cornsilk: "fff8dc",
                crimson: "dc143c",
                cyan: "0ff",
                darkblue: "00008b",
                darkcyan: "008b8b",
                darkgoldenrod: "b8860b",
                darkgray: "a9a9a9",
                darkgreen: "006400",
                darkgrey: "a9a9a9",
                darkkhaki: "bdb76b",
                darkmagenta: "8b008b",
                darkolivegreen: "556b2f",
                darkorange: "ff8c00",
                darkorchid: "9932cc",
                darkred: "8b0000",
                darksalmon: "e9967a",
                darkseagreen: "8fbc8f",
                darkslateblue: "483d8b",
                darkslategray: "2f4f4f",
                darkslategrey: "2f4f4f",
                darkturquoise: "00ced1",
                darkviolet: "9400d3",
                deeppink: "ff1493",
                deepskyblue: "00bfff",
                dimgray: "696969",
                dimgrey: "696969",
                dodgerblue: "1e90ff",
                firebrick: "b22222",
                floralwhite: "fffaf0",
                forestgreen: "228b22",
                fuchsia: "f0f",
                gainsboro: "dcdcdc",
                ghostwhite: "f8f8ff",
                gold: "ffd700",
                goldenrod: "daa520",
                gray: "808080",
                green: "008000",
                greenyellow: "adff2f",
                grey: "808080",
                honeydew: "f0fff0",
                hotpink: "ff69b4",
                indianred: "cd5c5c",
                indigo: "4b0082",
                ivory: "fffff0",
                khaki: "f0e68c",
                lavender: "e6e6fa",
                lavenderblush: "fff0f5",
                lawngreen: "7cfc00",
                lemonchiffon: "fffacd",
                lightblue: "add8e6",
                lightcoral: "f08080",
                lightcyan: "e0ffff",
                lightgoldenrodyellow: "fafad2",
                lightgray: "d3d3d3",
                lightgreen: "90ee90",
                lightgrey: "d3d3d3",
                lightpink: "ffb6c1",
                lightsalmon: "ffa07a",
                lightseagreen: "20b2aa",
                lightskyblue: "87cefa",
                lightslategray: "789",
                lightslategrey: "789",
                lightsteelblue: "b0c4de",
                lightyellow: "ffffe0",
                lime: "0f0",
                limegreen: "32cd32",
                linen: "faf0e6",
                magenta: "f0f",
                maroon: "800000",
                mediumaquamarine: "66cdaa",
                mediumblue: "0000cd",
                mediumorchid: "ba55d3",
                mediumpurple: "9370db",
                mediumseagreen: "3cb371",
                mediumslateblue: "7b68ee",
                mediumspringgreen: "00fa9a",
                mediumturquoise: "48d1cc",
                mediumvioletred: "c71585",
                midnightblue: "191970",
                mintcream: "f5fffa",
                mistyrose: "ffe4e1",
                moccasin: "ffe4b5",
                navajowhite: "ffdead",
                navy: "000080",
                oldlace: "fdf5e6",
                olive: "808000",
                olivedrab: "6b8e23",
                orange: "ffa500",
                orangered: "ff4500",
                orchid: "da70d6",
                palegoldenrod: "eee8aa",
                palegreen: "98fb98",
                paleturquoise: "afeeee",
                palevioletred: "db7093",
                papayawhip: "ffefd5",
                peachpuff: "ffdab9",
                peru: "cd853f",
                pink: "ffc0cb",
                plum: "dda0dd",
                powderblue: "b0e0e6",
                purple: "800080",
                rebeccapurple: "663399",
                red: "f00",
                rosybrown: "bc8f8f",
                royalblue: "4169e1",
                saddlebrown: "8b4513",
                salmon: "fa8072",
                sandybrown: "f4a460",
                seagreen: "2e8b57",
                seashell: "fff5ee",
                sienna: "a0522d",
                silver: "c0c0c0",
                skyblue: "87ceeb",
                slateblue: "6a5acd",
                slategray: "708090",
                slategrey: "708090",
                snow: "fffafa",
                springgreen: "00ff7f",
                steelblue: "4682b4",
                tan: "d2b48c",
                teal: "008080",
                thistle: "d8bfd8",
                tomato: "ff6347",
                turquoise: "40e0d0",
                violet: "ee82ee",
                wheat: "f5deb3",
                white: "fff",
                whitesmoke: "f5f5f5",
                yellow: "ff0",
                yellowgreen: "9acd32"
            },
            hexNames = tinycolor.hexNames = flip(names),
            matchers = function() {
                var CSS_INTEGER = "[-\\+]?\\d+%?",
                    CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?",
                    CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")",
                    PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?",
                    PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
                return {
                    CSS_UNIT: new RegExp(CSS_UNIT),
                    rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
                    rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
                    hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
                    hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
                    hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
                    hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
                    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
                    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
                    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
                }
            }();
        "undefined" != typeof module && module.exports ? module.exports = tinycolor : "function" == typeof define && define.amd ? define(function() {
            return tinycolor
        }) : window.tinycolor = tinycolor
    }(Math), angular.module("youtube-embed", ["ng"]).service("youtubeEmbedUtils", ["$window", "$rootScope", function($window, $rootScope) {
        function contains(str, substr) {
            return str.indexOf(substr) > -1
        }

        function applyServiceIsReady() {
            $rootScope.$apply(function() {
                Service.ready = !0
            })
        }
        var Service = {},
            youtubeRegexp = /https?:\/\/(?:[0-9A-Z-]+\.)?(?:youtu\.be\/|youtube(?:-nocookie)?\.com\S*[^\w\s-])([\w-]{11})(?=[^\w-]|$)(?![?=&+%\w.-]*(?:['"][^<>]*>|<\/a>))[?=&+%\w.-]*/gi,
            timeRegexp = /t=(\d+)[ms]?(\d+)?s?/;
        if (Service.getIdFromURL = function(url) {
                var id = url.replace(youtubeRegexp, "$1");
                if (contains(id, ";")) {
                    var pieces = id.split(";");
                    if (contains(pieces[1], "%")) {
                        var uriComponent = decodeURIComponent(id.split(";")[1]);
                        id = ("http://youtube.com" + uriComponent).replace(youtubeRegexp, "$1")
                    } else id = pieces[0]
                } else contains(id, "#") && (id = id.split("#")[0]);
                return id
            }, Service.getTimeFromURL = function(url) {
                url = url || "";
                var times = url.match(timeRegexp);
                if (!times) return 0;
                var full = times[0],
                    minutes = times[1],
                    seconds = times[2];
                return "undefined" != typeof seconds ? (seconds = parseInt(seconds, 10), minutes = parseInt(minutes, 10)) : contains(full, "m") ? (minutes = parseInt(minutes, 10), seconds = 0) : (seconds = parseInt(minutes, 10), minutes = 0), seconds + 60 * minutes
            }, Service.ready = !1, "undefined" == typeof YT) {
            $window.onYouTubeIframeAPIReady = applyServiceIsReady;
            var tag = document.createElement("script");
            tag.src = "https://www.youtube.com/iframe_api";
            var firstScriptTag = document.getElementsByTagName("script")[0];
            firstScriptTag.parentNode.insertBefore(tag, firstScriptTag)
        } else YT.loaded ? Service.ready = !0 : YT.ready(applyServiceIsReady);
        return Service
    }]).directive("youtubeVideo", ["youtubeEmbedUtils", function(youtubeEmbedUtils) {
        var uniqId = 1,
            stateNames = {
                "-1": "unstarted",
                0: "ended",
                1: "playing",
                2: "paused",
                3: "buffering",
                5: "queued"
            },
            eventPrefix = "youtube.player.";
        return {
            restrict: "EA",
            scope: {
                videoId: "=?",
                videoUrl: "=?",
                player: "=?",
                playerVars: "=?",
                playerHeight: "=?",
                playerWidth: "=?"
            },
            link: function(scope, element, attrs) {
                function applyBroadcast() {
                    var args = Array.prototype.slice.call(arguments);
                    scope.$apply(function() {
                        scope.$emit.apply(scope, args)
                    })
                }

                function onPlayerStateChange(event) {
                    var state = stateNames[event.data];
                    "undefined" != typeof state && applyBroadcast(eventPrefix + state, scope.player, event), scope.$apply(function() {
                        scope.player.currentState = state
                    })
                }

                function onPlayerReady(event) {
                    applyBroadcast(eventPrefix + "ready", scope.player, event)
                }

                function onPlayerError(event) {
                    applyBroadcast(eventPrefix + "error", scope.player, event)
                }

                function createPlayer() {
                    var playerVars = angular.copy(scope.playerVars);
                    playerVars.start = playerVars.start || scope.urlStartTime;
                    var player = new YT.Player(playerId, {
                        height: scope.playerHeight,
                        width: scope.playerWidth,
                        videoId: scope.videoId,
                        playerVars: playerVars,
                        events: {
                            onReady: onPlayerReady,
                            onStateChange: onPlayerStateChange,
                            onError: onPlayerError
                        }
                    });
                    return player.id = playerId, player
                }

                function loadPlayer() {
                    (scope.videoId || scope.playerVars.list) && (scope.player && "function" == typeof scope.player.destroy && scope.player.destroy(), scope.player = createPlayer())
                }
                scope.utils = youtubeEmbedUtils;
                var playerId = attrs.playerId || element[0].id || "unique-youtube-embed-id-" + uniqId++;
                element[0].id = playerId, scope.playerHeight = scope.playerHeight || 390, scope.playerWidth = scope.playerWidth || 640, scope.playerVars = scope.playerVars || {};
                var stopWatchingReady = scope.$watch(function() {
                    return scope.utils.ready && ("undefined" != typeof scope.videoUrl || "undefined" != typeof scope.videoId || "undefined" != typeof scope.playerVars.list)
                }, function(ready) {
                    ready && (stopWatchingReady(), "undefined" != typeof scope.videoUrl ? scope.$watch("videoUrl", function(url) {
                        scope.videoId = scope.utils.getIdFromURL(url), scope.urlStartTime = scope.utils.getTimeFromURL(url), loadPlayer()
                    }) : "undefined" != typeof scope.videoId ? scope.$watch("videoId", function() {
                        scope.urlStartTime = null, loadPlayer()
                    }) : scope.$watch("playerVars.list", function() {
                        scope.urlStartTime = null, loadPlayer()
                    }))
                });
                scope.$watchCollection(["playerHeight", "playerWidth"], function() {
                    scope.player && scope.player.setSize(scope.playerWidth, scope.playerHeight)
                }), scope.$on("$destroy", function() {
                    scope.player && scope.player.destroy()
                })
            }
        }
    }]),
    function(angular, analytics) {
        "use strict";
        var angulartics = window.angulartics || (window.angulartics = {});
        angulartics.waitForVendorCount = 0, angulartics.waitForVendorApi = function(objectName, delay, containsField, registerFn, onTimeout) {
            onTimeout || angulartics.waitForVendorCount++, registerFn || (registerFn = containsField, containsField = void 0), !Object.prototype.hasOwnProperty.call(window, objectName) || void 0 !== containsField && void 0 === window[objectName][containsField] ? setTimeout(function() {
                angulartics.waitForVendorApi(objectName, delay, containsField, registerFn, !0)
            }, delay) : (angulartics.waitForVendorCount--, registerFn(window[objectName]))
        }, angular.module("angulartics", []).provider("$analytics", function() {
            var settings = {
                    pageTracking: {
                        autoTrackFirstPage: !0,
                        autoTrackVirtualPages: !0,
                        trackRelativePath: !1,
                        autoBasePath: !1,
                        basePath: ""
                    },
                    eventTracking: {},
                    bufferFlushDelay: 1e3,
                    developerMode: !1
                },
                knownHandlers = ["pageTrack", "eventTrack", "setAlias", "setUsername", "setAlias", "setUserProperties", "setUserPropertiesOnce", "setSuperProperties", "setSuperPropertiesOnce"],
                cache = {},
                handlers = {},
                bufferedHandler = function(handlerName) {
                    return function() {
                        angulartics.waitForVendorCount && (cache[handlerName] || (cache[handlerName] = []), cache[handlerName].push(arguments))
                    }
                },
                updateHandlers = function(handlerName, fn) {
                    return handlers[handlerName] || (handlers[handlerName] = []), handlers[handlerName].push(fn),
                        function() {
                            var handlerArgs = arguments;
                            angular.forEach(handlers[handlerName], function(handler) {
                                handler.apply(this, handlerArgs)
                            }, this)
                        }
                },
                api = {
                    settings: settings
                },
                onTimeout = function(fn, delay) {
                    delay ? setTimeout(fn, delay) : fn()
                },
                provider = {
                    $get: function() {
                        return api
                    },
                    api: api,
                    settings: settings,
                    virtualPageviews: function(value) {
                        this.settings.pageTracking.autoTrackVirtualPages = value
                    },
                    firstPageview: function(value) {
                        this.settings.pageTracking.autoTrackFirstPage = value
                    },
                    withBase: function(value) {
                        this.settings.pageTracking.basePath = value ? angular.element("base").attr("href").slice(0, -1) : ""
                    },
                    withAutoBase: function(value) {
                        this.settings.pageTracking.autoBasePath = value
                    },
                    developerMode: function(value) {
                        this.settings.developerMode = value
                    }
                },
                register = function(handlerName, fn) {
                    api[handlerName] = updateHandlers(handlerName, fn);
                    var handlerSettings = settings[handlerName],
                        handlerDelay = handlerSettings ? handlerSettings.bufferFlushDelay : null,
                        delay = null !== handlerDelay ? handlerDelay : settings.bufferFlushDelay;
                    angular.forEach(cache[handlerName], function(args, index) {
                        onTimeout(function() {
                            fn.apply(this, args)
                        }, index * delay)
                    })
                },
                capitalize = function(input) {
                    return input.replace(/^./, function(match) {
                        return match.toUpperCase()
                    })
                },
                installHandlerRegisterFunction = function(handlerName) {
                    var registerName = "register" + capitalize(handlerName);
                    provider[registerName] = function(fn) {
                        register(handlerName, fn)
                    }, api[handlerName] = updateHandlers(handlerName, bufferedHandler(handlerName))
                };
            return angular.forEach(knownHandlers, installHandlerRegisterFunction), provider
        }).run(["$rootScope", "$window", "$analytics", "$injector", function($rootScope, $window, $analytics, $injector) {
            $analytics.settings.pageTracking.autoTrackFirstPage && $injector.invoke(["$location", function($location) {
                var noRoutesOrStates = !0;
                if ($injector.has("$route")) {
                    var $route = $injector.get("$route");
                    for (var route in $route.routes) {
                        noRoutesOrStates = !1;
                        break
                    }
                } else if ($injector.has("$state")) {
                    var $state = $injector.get("$state");
                    for (var state in $state.get()) {
                        noRoutesOrStates = !1;
                        break
                    }
                }
                if (noRoutesOrStates)
                    if ($analytics.settings.pageTracking.autoBasePath && ($analytics.settings.pageTracking.basePath = $window.location.pathname), $analytics.settings.trackRelativePath) {
                        var url = $analytics.settings.pageTracking.basePath + $location.url();
                        $analytics.pageTrack(url, $location)
                    } else $analytics.pageTrack($location.absUrl(), $location)
            }]), $analytics.settings.pageTracking.autoTrackVirtualPages && $injector.invoke(["$location", function($location) {
                $analytics.settings.pageTracking.autoBasePath && ($analytics.settings.pageTracking.basePath = $window.location.pathname + "#"), $injector.has("$route") && $rootScope.$on("$routeChangeSuccess", function(event, current) {
                    if (!current || !(current.$$route || current).redirectTo) {
                        var url = $analytics.settings.pageTracking.basePath + $location.url();
                        $analytics.pageTrack(url, $location)
                    }
                }), $injector.has("$state") && $rootScope.$on("$stateChangeSuccess", function(event, current) {
                    var url = $analytics.settings.pageTracking.basePath + $location.url();
                    $analytics.pageTrack(url, $location)
                })
            }]), $analytics.settings.developerMode && angular.forEach($analytics, function(attr, name) {
                "function" == typeof attr && ($analytics[name] = function() {})
            })
        }]).directive("analyticsOn", ["$analytics", function($analytics) {
            function isCommand(element) {
                return ["a:", "button:", "button:button", "button:submit", "input:button", "input:submit"].indexOf(element.tagName.toLowerCase() + ":" + (element.type || "")) >= 0
            }

            function inferEventType(element) {
                return isCommand(element), "click"
            }

            function inferEventName(element) {
                return isCommand(element) ? element.innerText || element.value : element.id || element.name || element.tagName
            }

            function isProperty(name) {
                return "analytics" === name.substr(0, 9) && ["On", "Event", "If", "Properties", "EventType"].indexOf(name.substr(9)) === -1
            }

            function propertyName(name) {
                var s = name.slice(9);
                return "undefined" != typeof s && null !== s && s.length > 0 ? s.substring(0, 1).toLowerCase() + s.substring(1) : s
            }
            return {
                restrict: "A",
                link: function($scope, $element, $attrs) {
                    var eventType = $attrs.analyticsOn || inferEventType($element[0]),
                        trackingData = {};
                    angular.forEach($attrs.$attr, function(attr, name) {
                        isProperty(name) && (trackingData[propertyName(name)] = $attrs[name], $attrs.$observe(name, function(value) {
                            trackingData[propertyName(name)] = value
                        }))
                    }), angular.element($element[0]).bind(eventType, function($event) {
                        var eventName = $attrs.analyticsEvent || inferEventName($element[0]);
                        trackingData.eventType = $event.type, $attrs.analyticsIf && !$scope.$eval($attrs.analyticsIf) || ($attrs.analyticsProperties && angular.extend(trackingData, $scope.$eval($attrs.analyticsProperties)), $analytics.eventTrack(eventName, trackingData))
                    })
                }
            }
        }])
    }(angular),
    function(angular) {
        "use strict";
        angular.module("angulartics.google.analytics", ["angulartics"]).config(["$analyticsProvider", function($analyticsProvider) {
            $analyticsProvider.settings.trackRelativePath = !0, $analyticsProvider.settings.ga = {
                additionalAccountNames: void 0
            }, $analyticsProvider.registerPageTrack(function(path) {
                window._gaq && _gaq.push(["_trackPageview", path]), window.ga && (ga("send", "pageview", path),
                    angular.forEach($analyticsProvider.settings.ga.additionalAccountNames, function(accountName) {
                        ga(accountName + ".send", "pageview", path)
                    }))
            }), $analyticsProvider.registerEventTrack(function(action, properties) {
                if (properties && properties.category) {
                    if (properties.value) {
                        var parsed = parseInt(properties.value, 10);
                        properties.value = isNaN(parsed) ? 0 : parsed
                    }
                    if (window.ga) {
                        for (var eventOptions = {
                                eventCategory: properties.category || null,
                                eventAction: action || null,
                                eventLabel: properties.label || null,
                                eventValue: properties.value || null,
                                nonInteraction: properties.noninteraction || null
                            }, idx = 1; idx <= 20; idx++) properties["dimension" + idx.toString()] && (eventOptions["dimension" + idx.toString()] = properties["dimension" + idx.toString()]), properties["metric" + idx.toString()] && (eventOptions["metric" + idx.toString()] = properties["metric" + idx.toString()]);
                        ga("send", "event", eventOptions), angular.forEach($analyticsProvider.settings.ga.additionalAccountNames, function(accountName) {
                            ga(accountName + ".send", "event", eventOptions)
                        })
                    } else window._gaq && _gaq.push(["_trackEvent", properties.category, action, properties.label, properties.value, properties.noninteraction])
                }
            })
        }])
    }(angular),
    function(angular) {
        "use strict";
        angular.module("angulartics.google.tagmanager", ["angulartics"]).config(["$analyticsProvider", function($analyticsProvider) {
            $analyticsProvider.registerPageTrack(function(path) {
                var dataLayer = window.dataLayer = window.dataLayer || [];
                dataLayer.push({
                    event: "content-view",
                    "content-name": path
                })
            }), $analyticsProvider.registerEventTrack(function(action, properties) {
                var dataLayer = window.dataLayer = window.dataLayer || [];
                dataLayer.push({
                    event: "interaction",
                    target: properties.category,
                    action: action,
                    "target-properties": properties.label,
                    value: properties.value,
                    "interaction-type": properties.noninteraction
                })
            })
        }])
    }(angular),
    function(angular) {
        "use strict";
        angular.module("angulartics.kissmetrics", ["angulartics"]).config(["$analyticsProvider", function($analyticsProvider) {
            "undefined" == typeof _kmq ? window._kmq = [] : window._kmq = _kmq, $analyticsProvider.registerPageTrack(function(path) {
                window._kmq.push(["record", "Pageview", {
                    Page: path
                }])
            }), $analyticsProvider.registerEventTrack(function(action, properties) {
                window._kmq.push(["record", action, properties])
            }), $analyticsProvider.registerSetUsername(function(uuid) {
                window._kmq.push(["identify", uuid])
            }), $analyticsProvider.registerSetUserProperties(function(properties) {
                window._kmq.push(["set", properties])
            })
        }])
    }(angular),
    function(window, angular) {
        "use strict";

        function $SanitizeProvider() {
            function stringToMap(str, lowercaseKeys) {
                return arrayToMap(str.split(","), lowercaseKeys)
            }

            function arrayToMap(items, lowercaseKeys) {
                var i, obj = {};
                for (i = 0; i < items.length; i++) obj[lowercaseKeys ? lowercase(items[i]) : items[i]] = !0;
                return obj
            }

            function addElementsTo(elementsMap, newElements) {
                newElements && newElements.length && extend(elementsMap, arrayToMap(newElements))
            }

            function htmlParserImpl(html, handler) {
                null === html || void 0 === html ? html = "" : "string" != typeof html && (html = "" + html);
                var inertBodyElement = getInertBodyElement(html);
                if (!inertBodyElement) return "";
                var mXSSAttempts = 5;
                do {
                    if (0 === mXSSAttempts) throw $sanitizeMinErr("uinput", "Failed to sanitize html because the input is unstable");
                    mXSSAttempts--, html = inertBodyElement.innerHTML, inertBodyElement = getInertBodyElement(html)
                } while (html !== inertBodyElement.innerHTML);
                for (var node = inertBodyElement.firstChild; node;) {
                    switch (node.nodeType) {
                        case 1:
                            handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));
                            break;
                        case 3:
                            handler.chars(node.textContent)
                    }
                    var nextNode;
                    if (!(nextNode = node.firstChild) && (1 === node.nodeType && handler.end(node.nodeName.toLowerCase()), nextNode = getNonDescendant("nextSibling", node), !nextNode))
                        for (; null == nextNode && (node = getNonDescendant("parentNode", node), node !== inertBodyElement);) nextNode = getNonDescendant("nextSibling", node), 1 === node.nodeType && handler.end(node.nodeName.toLowerCase());
                    node = nextNode
                }
                for (; node = inertBodyElement.firstChild;) inertBodyElement.removeChild(node)
            }

            function attrToMap(attrs) {
                for (var map = {}, i = 0, ii = attrs.length; i < ii; i++) {
                    var attr = attrs[i];
                    map[attr.name] = attr.value
                }
                return map
            }

            function encodeEntities(value) {
                return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function(value) {
                    var hi = value.charCodeAt(0),
                        low = value.charCodeAt(1);
                    return "&#" + (1024 * (hi - 55296) + (low - 56320) + 65536) + ";"
                }).replace(NON_ALPHANUMERIC_REGEXP, function(value) {
                    return "&#" + value.charCodeAt(0) + ";"
                }).replace(/</g, "&lt;").replace(/>/g, "&gt;")
            }

            function htmlSanitizeWriterImpl(buf, uriValidator) {
                var ignoreCurrentElement = !1,
                    out = bind(buf, buf.push);
                return {
                    start: function(tag, attrs) {
                        tag = lowercase(tag), !ignoreCurrentElement && blockedElements[tag] && (ignoreCurrentElement = tag), ignoreCurrentElement || validElements[tag] !== !0 || (out("<"), out(tag), forEach(attrs, function(value, key) {
                            var lkey = lowercase(key),
                                isImage = "img" === tag && "src" === lkey || "background" === lkey;
                            validAttrs[lkey] !== !0 || uriAttrs[lkey] === !0 && !uriValidator(value, isImage) || (out(" "), out(key), out('="'), out(encodeEntities(value)), out('"'))
                        }), out(">"))
                    },
                    end: function(tag) {
                        tag = lowercase(tag), ignoreCurrentElement || validElements[tag] !== !0 || voidElements[tag] === !0 || (out("</"), out(tag), out(">")), tag == ignoreCurrentElement && (ignoreCurrentElement = !1)
                    },
                    chars: function(_chars) {
                        ignoreCurrentElement || out(encodeEntities(_chars))
                    }
                }
            }

            function stripCustomNsAttrs(node) {
                for (; node;) {
                    if (node.nodeType === window.Node.ELEMENT_NODE)
                        for (var attrs = node.attributes, i = 0, l = attrs.length; i < l; i++) {
                            var attrNode = attrs[i],
                                attrName = attrNode.name.toLowerCase();
                            "xmlns:ns1" !== attrName && 0 !== attrName.lastIndexOf("ns1:", 0) || (node.removeAttributeNode(attrNode), i--, l--)
                        }
                    var nextNode = node.firstChild;
                    nextNode && stripCustomNsAttrs(nextNode), node = getNonDescendant("nextSibling", node)
                }
            }

            function getNonDescendant(propName, node) {
                var nextNode = node[propName];
                if (nextNode && nodeContains.call(node, nextNode)) throw $sanitizeMinErr("elclob", "Failed to sanitize html because the element is clobbered: {0}", node.outerHTML || node.outerText);
                return nextNode
            }
            var hasBeenInstantiated = !1,
                svgEnabled = !1;
            this.$get = ["$$sanitizeUri", function($$sanitizeUri) {
                return hasBeenInstantiated = !0, svgEnabled && extend(validElements, svgElements),
                    function(html) {
                        var buf = [];
                        return htmlParser(html, htmlSanitizeWriter(buf, function(uri, isImage) {
                            return !/^unsafe:/.test($$sanitizeUri(uri, isImage))
                        })), buf.join("")
                    }
            }], this.enableSvg = function(enableSvg) {
                return isDefined(enableSvg) ? (svgEnabled = enableSvg, this) : svgEnabled
            }, this.addValidElements = function(elements) {
                return hasBeenInstantiated || (isArray(elements) && (elements = {
                    htmlElements: elements
                }), addElementsTo(svgElements, elements.svgElements), addElementsTo(voidElements, elements.htmlVoidElements), addElementsTo(validElements, elements.htmlVoidElements), addElementsTo(validElements, elements.htmlElements)), this
            }, this.addValidAttrs = function(attrs) {
                return hasBeenInstantiated || extend(validAttrs, arrayToMap(attrs, !0)), this
            }, bind = angular.bind, extend = angular.extend, forEach = angular.forEach, isArray = angular.isArray, isDefined = angular.isDefined, lowercase = angular.$$lowercase, noop = angular.noop, htmlParser = htmlParserImpl, htmlSanitizeWriter = htmlSanitizeWriterImpl, nodeContains = window.Node.prototype.contains || function(arg) {
                return !!(16 & this.compareDocumentPosition(arg))
            };
            var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                NON_ALPHANUMERIC_REGEXP = /([^#-~ |!])/g,
                voidElements = stringToMap("area,br,col,hr,img,wbr"),
                optionalEndTagBlockElements = stringToMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
                optionalEndTagInlineElements = stringToMap("rp,rt"),
                optionalEndTagElements = extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements),
                blockElements = extend({}, optionalEndTagBlockElements, stringToMap("address,article,aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul")),
                inlineElements = extend({}, optionalEndTagInlineElements, stringToMap("a,abbr,acronym,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var")),
                svgElements = stringToMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,stop,svg,switch,text,title,tspan"),
                blockedElements = stringToMap("script,style"),
                validElements = extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements),
                uriAttrs = stringToMap("background,cite,href,longdesc,src,xlink:href,xml:base"),
                htmlAttrs = stringToMap("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,valign,value,vspace,width"),
                svgAttrs = stringToMap("accent-height,accumulate,additive,alphabetic,arabic-form,ascent,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan", !0),
                validAttrs = extend({}, uriAttrs, svgAttrs, htmlAttrs),
                getInertBodyElement = function(window, document) {
                    function getInertBodyElement_XHR(html) {
                        html = "<remove></remove>" + html;
                        try {
                            html = encodeURI(html)
                        } catch (e) {
                            return
                        }
                        var xhr = new window.XMLHttpRequest;
                        xhr.responseType = "document", xhr.open("GET", "data:text/html;charset=utf-8," + html, !1), xhr.send(null);
                        var body = xhr.response.body;
                        return body.firstChild.remove(), body
                    }

                    function getInertBodyElement_DOMParser(html) {
                        html = "<remove></remove>" + html;
                        try {
                            var body = (new window.DOMParser).parseFromString(html, "text/html").body;
                            return body.firstChild.remove(), body
                        } catch (e) {
                            return
                        }
                    }

                    function getInertBodyElement_InertDocument(html) {
                        return inertBodyElement.innerHTML = html, document.documentMode && stripCustomNsAttrs(inertBodyElement), inertBodyElement
                    }
                    var inertDocument;
                    if (!document || !document.implementation) throw $sanitizeMinErr("noinert", "Can't create an inert html document");
                    inertDocument = document.implementation.createHTMLDocument("inert");
                    var inertBodyElement = (inertDocument.documentElement || inertDocument.getDocumentElement()).querySelector("body");
                    return inertBodyElement.innerHTML = '<svg><g onload="this.parentNode.remove()"></g></svg>', inertBodyElement.querySelector("svg") ? (inertBodyElement.innerHTML = '<svg><p><style><img src="</style><img src=x onerror=alert(1)//">', inertBodyElement.querySelector("svg img") ? getInertBodyElement_DOMParser : getInertBodyElement_InertDocument) : getInertBodyElement_XHR
                }(window, window.document)
        }

        function sanitizeText(chars) {
            var buf = [],
                writer = htmlSanitizeWriter(buf, noop);
            return writer.chars(chars), buf.join("")
        }
        var bind, extend, forEach, isArray, isDefined, lowercase, noop, nodeContains, htmlParser, htmlSanitizeWriter, $sanitizeMinErr = angular.$$minErr("$sanitize");
        angular.module("ngSanitize", []).provider("$sanitize", $SanitizeProvider).info({
            angularVersion: "1.7.6"
        }), angular.module("ngSanitize").filter("linky", ["$sanitize", function($sanitize) {
            var LINKY_URL_REGEXP = /((s?ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
                MAILTO_REGEXP = /^mailto:/i,
                linkyMinErr = angular.$$minErr("linky"),
                isDefined = angular.isDefined,
                isFunction = angular.isFunction,
                isObject = angular.isObject,
                isString = angular.isString;
            return function(text, target, attributes) {
                function addText(text) {
                    text && html.push(sanitizeText(text))
                }

                function addLink(url, text) {
                    var key, linkAttributes = attributesFn(url);
                    html.push("<a ");
                    for (key in linkAttributes) html.push(key + '="' + linkAttributes[key] + '" ');
                    !isDefined(target) || "target" in linkAttributes || html.push('target="', target, '" '), html.push('href="', url.replace(/"/g, "&quot;"), '">'), addText(text), html.push("</a>")
                }
                if (null == text || "" === text) return text;
                if (!isString(text)) throw linkyMinErr("notstring", "Expected string but received: {0}", text);
                for (var match, url, i, attributesFn = isFunction(attributes) ? attributes : isObject(attributes) ? function() {
                        return attributes
                    } : function() {
                        return {}
                    }, raw = text, html = []; match = raw.match(LINKY_URL_REGEXP);) url = match[0], match[2] || match[4] || (url = (match[3] ? "http://" : "mailto:") + url), i = match.index, addText(raw.substr(0, i)), addLink(url, match[0].replace(MAILTO_REGEXP, "")), raw = raw.substring(i + match[0].length);
                return addText(raw), $sanitize(html.join(""))
            }
        }])
    }(window, window.angular);
var duScrollDefaultEasing = function(x) {
        "use strict";
        return x < .5 ? Math.pow(2 * x, 2) / 2 : 1 - Math.pow(2 * (1 - x), 2) / 2
    },
    duScroll = angular.module("duScroll", ["duScroll.scrollspy", "duScroll.smoothScroll", "duScroll.scrollContainer", "duScroll.spyContext", "duScroll.scrollHelpers"]).value("duScrollDuration", 350).value("duScrollSpyWait", 100).value("duScrollSpyRefreshInterval", 0).value("duScrollGreedy", !1).value("duScrollOffset", 0).value("duScrollEasing", duScrollDefaultEasing).value("duScrollCancelOnEvents", "scroll mousedown mousewheel touchmove keydown").value("duScrollBottomSpy", !1).value("duScrollActiveClass", "active");
"undefined" != typeof module && module && module.exports && (module.exports = duScroll), angular.module("duScroll.scrollHelpers", ["duScroll.requestAnimation"]).run(["$window", "$q", "cancelAnimation", "requestAnimation", "duScrollEasing", "duScrollDuration", "duScrollOffset", "duScrollCancelOnEvents", function($window, $q, cancelAnimation, requestAnimation, duScrollEasing, duScrollDuration, duScrollOffset, duScrollCancelOnEvents) {
        "use strict";
        var proto = {},
            isDocument = function(el) {
                return "undefined" != typeof HTMLDocument && el instanceof HTMLDocument || el.nodeType && el.nodeType === el.DOCUMENT_NODE
            },
            isElement = function(el) {
                return "undefined" != typeof HTMLElement && el instanceof HTMLElement || el.nodeType && el.nodeType === el.ELEMENT_NODE
            },
            unwrap = function(el) {
                return isElement(el) || isDocument(el) ? el : el[0]
            };
        proto.duScrollTo = function(left, top, duration, easing) {
            var aliasFn;
            if (angular.isElement(left) ? aliasFn = this.duScrollToElement : angular.isDefined(duration) && (aliasFn = this.duScrollToAnimated), aliasFn) return aliasFn.apply(this, arguments);
            var el = unwrap(this);
            return isDocument(el) ? $window.scrollTo(left, top) : (el.scrollLeft = left, void(el.scrollTop = top))
        };
        var scrollAnimation, deferred;
        proto.duScrollToAnimated = function(left, top, duration, easing) {
            duration && !easing && (easing = duScrollEasing);
            var startLeft = this.duScrollLeft(),
                startTop = this.duScrollTop(),
                deltaLeft = Math.round(left - startLeft),
                deltaTop = Math.round(top - startTop),
                startTime = null,
                progress = 0,
                el = this,
                cancelScrollAnimation = function cancelScrollAnimation($event) {
                    (!$event || progress && $event.which > 0) && (duScrollCancelOnEvents && el.unbind(duScrollCancelOnEvents, cancelScrollAnimation), cancelAnimation(scrollAnimation), deferred.reject(), scrollAnimation = null)
                };
            if (scrollAnimation && cancelScrollAnimation(), deferred = $q.defer(), 0 === duration || !deltaLeft && !deltaTop) return 0 === duration && el.duScrollTo(left, top), deferred.resolve(), deferred.promise;
            var animationStep = function animationStep(timestamp) {
                null === startTime && (startTime = timestamp), progress = timestamp - startTime;
                var percent = progress >= duration ? 1 : easing(progress / duration);
                el.scrollTo(startLeft + Math.ceil(deltaLeft * percent), startTop + Math.ceil(deltaTop * percent)), percent < 1 ? scrollAnimation = requestAnimation(animationStep) : (duScrollCancelOnEvents && el.unbind(duScrollCancelOnEvents, cancelScrollAnimation), scrollAnimation = null, deferred.resolve())
            };
            return el.duScrollTo(startLeft, startTop), duScrollCancelOnEvents && el.bind(duScrollCancelOnEvents, cancelScrollAnimation), scrollAnimation = requestAnimation(animationStep), deferred.promise
        }, proto.duScrollToElement = function(target, offset, duration, easing) {
            var el = unwrap(this);
            angular.isNumber(offset) && !isNaN(offset) || (offset = duScrollOffset);
            var top = this.duScrollTop() + unwrap(target).getBoundingClientRect().top - offset;
            return isElement(el) && (top -= el.getBoundingClientRect().top), this.duScrollTo(0, top, duration, easing)
        }, proto.duScrollLeft = function(value, duration, easing) {
            if (angular.isNumber(value)) return this.duScrollTo(value, this.duScrollTop(), duration, easing);
            var el = unwrap(this);
            return isDocument(el) ? $window.scrollX || document.documentElement.scrollLeft || document.body.scrollLeft : el.scrollLeft
        }, proto.duScrollTop = function(value, duration, easing) {
            if (angular.isNumber(value)) return this.duScrollTo(this.duScrollLeft(), value, duration, easing);
            var el = unwrap(this);
            return isDocument(el) ? $window.scrollY || document.documentElement.scrollTop || document.body.scrollTop : el.scrollTop
        }, proto.duScrollToElementAnimated = function(target, offset, duration, easing) {
            return this.duScrollToElement(target, offset, duration || duScrollDuration, easing)
        }, proto.duScrollTopAnimated = function(top, duration, easing) {
            return this.duScrollTop(top, duration || duScrollDuration, easing)
        }, proto.duScrollLeftAnimated = function(left, duration, easing) {
            return this.duScrollLeft(left, duration || duScrollDuration, easing)
        }, angular.forEach(proto, function(fn, key) {
            angular.element.prototype[key] = fn;
            var unprefixed = key.replace(/^duScroll/, "scroll");
            angular.isUndefined(angular.element.prototype[unprefixed]) && (angular.element.prototype[unprefixed] = fn)
        })
    }]), angular.module("duScroll.polyfill", []).factory("polyfill", ["$window", function($window) {
        "use strict";
        var vendors = ["webkit", "moz", "o", "ms"];
        return function(fnName, fallback) {
            if ($window[fnName]) return $window[fnName];
            for (var key, suffix = fnName.substr(0, 1).toUpperCase() + fnName.substr(1), i = 0; i < vendors.length; i++)
                if (key = vendors[i] + suffix, $window[key]) return $window[key];
            return fallback
        }
    }]), angular.module("duScroll.requestAnimation", ["duScroll.polyfill"]).factory("requestAnimation", ["polyfill", "$timeout", function(polyfill, $timeout) {
        "use strict";
        var lastTime = 0,
            fallback = function(callback, element) {
                var currTime = (new Date).getTime(),
                    timeToCall = Math.max(0, 16 - (currTime - lastTime)),
                    id = $timeout(function() {
                        callback(currTime + timeToCall)
                    }, timeToCall);
                return lastTime = currTime + timeToCall, id
            };
        return polyfill("requestAnimationFrame", fallback)
    }]).factory("cancelAnimation", ["polyfill", "$timeout", function(polyfill, $timeout) {
        "use strict";
        var fallback = function(promise) {
            $timeout.cancel(promise)
        };
        return polyfill("cancelAnimationFrame", fallback)
    }]), angular.module("duScroll.spyAPI", ["duScroll.scrollContainerAPI"]).factory("spyAPI", ["$rootScope", "$timeout", "$interval", "$window", "$document", "scrollContainerAPI", "duScrollGreedy", "duScrollSpyWait", "duScrollSpyRefreshInterval", "duScrollBottomSpy", "duScrollActiveClass", function($rootScope, $timeout, $interval, $window, $document, scrollContainerAPI, duScrollGreedy, duScrollSpyWait, duScrollSpyRefreshInterval, duScrollBottomSpy, duScrollActiveClass) {
        "use strict";
        var createScrollHandler = function(context) {
                var timer = !1,
                    queued = !1,
                    handler = function() {
                        queued = !1;
                        var bottomReached, container = context.container,
                            containerEl = container[0],
                            containerOffset = 0;
                        if ("undefined" != typeof HTMLElement && containerEl instanceof HTMLElement || containerEl.nodeType && containerEl.nodeType === containerEl.ELEMENT_NODE) containerOffset = containerEl.getBoundingClientRect().top, bottomReached = Math.round(containerEl.scrollTop + containerEl.clientHeight) >= containerEl.scrollHeight;
                        else {
                            var documentScrollHeight = $document[0].body.scrollHeight || $document[0].documentElement.scrollHeight;
                            bottomReached = Math.round($window.pageYOffset + $window.innerHeight) >= documentScrollHeight
                        }
                        var i, currentlyActive, toBeActive, spies, spy, pos, compareProperty = duScrollBottomSpy && bottomReached ? "bottom" : "top";
                        for (spies = context.spies, currentlyActive = context.currentlyActive, toBeActive = void 0, i = 0; i < spies.length; i++) spy = spies[i], pos = spy.getTargetPosition(), pos && spy.$element && (duScrollBottomSpy && bottomReached || pos.top + spy.offset - containerOffset < 20 && (duScrollGreedy || pos.top * -1 + containerOffset) < pos.height) && (!toBeActive || toBeActive[compareProperty] < pos[compareProperty]) && (toBeActive = {
                            spy: spy
                        }, toBeActive[compareProperty] = pos[compareProperty]);
                        toBeActive && (toBeActive = toBeActive.spy), currentlyActive === toBeActive || duScrollGreedy && !toBeActive || (currentlyActive && currentlyActive.$element && (currentlyActive.$element.removeClass(duScrollActiveClass), $rootScope.$broadcast("duScrollspy:becameInactive", currentlyActive.$element, angular.element(currentlyActive.getTargetElement()))), toBeActive && (toBeActive.$element.addClass(duScrollActiveClass), $rootScope.$broadcast("duScrollspy:becameActive", toBeActive.$element, angular.element(toBeActive.getTargetElement()))), context.currentlyActive = toBeActive)
                    };
                return duScrollSpyWait ? function() {
                    timer ? queued = !0 : (handler(), timer = $timeout(function() {
                        timer = !1, queued && handler()
                    }, duScrollSpyWait, !1))
                } : handler
            },
            contexts = {},
            createContext = function($scope) {
                var id = $scope.$id,
                    context = {
                        spies: []
                    };
                return context.handler = createScrollHandler(context), contexts[id] = context, $scope.$on("$destroy", function() {
                    destroyContext($scope)
                }), id
            },
            destroyContext = function($scope) {
                var id = $scope.$id,
                    context = contexts[id],
                    container = context.container;
                context.intervalPromise && $interval.cancel(context.intervalPromise), container && container.off("scroll", context.handler), delete contexts[id]
            },
            defaultContextId = createContext($rootScope),
            getContextForScope = function getContextForScope(scope) {
                return contexts[scope.$id] ? contexts[scope.$id] : scope.$parent ? getContextForScope(scope.$parent) : contexts[defaultContextId]
            },
            getContextForSpy = function(spy) {
                var context, contextId, scope = spy.$scope;
                if (scope) return getContextForScope(scope);
                for (contextId in contexts)
                    if (context = contexts[contextId], context.spies.indexOf(spy) !== -1) return context
            },
            isElementInDocument = function(element) {
                for (; element.parentNode;)
                    if (element = element.parentNode, element === document) return !0;
                return !1
            },
            addSpy = function(spy) {
                var context = getContextForSpy(spy);
                context && (context.spies.push(spy), context.container && isElementInDocument(context.container) || (context.container && context.container.off("scroll", context.handler), context.container = scrollContainerAPI.getContainer(spy.$scope), duScrollSpyRefreshInterval && !context.intervalPromise && (context.intervalPromise = $interval(context.handler, duScrollSpyRefreshInterval, 0, !1)), context.container.on("scroll", context.handler).triggerHandler("scroll")))
            },
            removeSpy = function(spy) {
                var context = getContextForSpy(spy);
                spy === context.currentlyActive && ($rootScope.$broadcast("duScrollspy:becameInactive", context.currentlyActive.$element), context.currentlyActive = null);
                var i = context.spies.indexOf(spy);
                i !== -1 && context.spies.splice(i, 1), spy.$element = null
            };
        return {
            addSpy: addSpy,
            removeSpy: removeSpy,
            createContext: createContext,
            destroyContext: destroyContext,
            getContextForScope: getContextForScope
        }
    }]), angular.module("duScroll.scrollContainerAPI", []).factory("scrollContainerAPI", ["$document", function($document) {
        "use strict";
        var containers = {},
            setContainer = function(scope, element) {
                var id = scope.$id;
                return containers[id] = element, id
            },
            getContainerId = function getContainerId(scope) {
                return containers[scope.$id] ? scope.$id : scope.$parent ? getContainerId(scope.$parent) : void 0
            },
            getContainer = function(scope) {
                var id = getContainerId(scope);
                return id ? containers[id] : $document
            },
            removeContainer = function(scope) {
                var id = getContainerId(scope);
                id && delete containers[id]
            };
        return {
            getContainerId: getContainerId,
            getContainer: getContainer,
            setContainer: setContainer,
            removeContainer: removeContainer
        }
    }]), angular.module("duScroll.smoothScroll", ["duScroll.scrollHelpers", "duScroll.scrollContainerAPI"]).directive("duSmoothScroll", ["duScrollDuration", "duScrollOffset", "scrollContainerAPI", function(duScrollDuration, duScrollOffset, scrollContainerAPI) {
        "use strict";
        return {
            link: function($scope, $element, $attr) {
                $element.on("click", function(e) {
                    if ($attr.href && $attr.href.indexOf("#") !== -1 || "" !== $attr.duSmoothScroll) {
                        var id = $attr.href ? $attr.href.replace(/.*(?=#[^\s]+$)/, "").substring(1) : $attr.duSmoothScroll,
                            target = document.getElementById(id) || document.getElementsByName(id)[0];
                        if (target && target.getBoundingClientRect) {
                            e.stopPropagation && e.stopPropagation(), e.preventDefault && e.preventDefault();
                            var offset = $attr.offset ? parseInt($attr.offset, 10) : duScrollOffset,
                                duration = $attr.duration ? parseInt($attr.duration, 10) : duScrollDuration,
                                container = scrollContainerAPI.getContainer($scope);
                            container.duScrollToElement(angular.element(target), isNaN(offset) ? 0 : offset, isNaN(duration) ? 0 : duration)
                        }
                    }
                })
            }
        }
    }]), angular.module("duScroll.spyContext", ["duScroll.spyAPI"]).directive("duSpyContext", ["spyAPI", function(spyAPI) {
        "use strict";
        return {
            restrict: "A",
            scope: !0,
            compile: function(tElement, tAttrs, transclude) {
                return {
                    pre: function($scope, iElement, iAttrs, controller) {
                        spyAPI.createContext($scope)
                    }
                }
            }
        }
    }]), angular.module("duScroll.scrollContainer", ["duScroll.scrollContainerAPI"]).directive("duScrollContainer", ["scrollContainerAPI", function(scrollContainerAPI) {
        "use strict";
        return {
            restrict: "A",
            scope: !0,
            compile: function(tElement, tAttrs, transclude) {
                return {
                    pre: function($scope, iElement, iAttrs, controller) {
                        iAttrs.$observe("duScrollContainer", function(element) {
                            angular.isString(element) && (element = document.getElementById(element)), element = angular.isElement(element) ? angular.element(element) : iElement, scrollContainerAPI.setContainer($scope, element), $scope.$on("$destroy", function() {
                                scrollContainerAPI.removeContainer($scope)
                            })
                        })
                    }
                }
            }
        }
    }]), angular.module("duScroll.scrollspy", ["duScroll.spyAPI"]).directive("duScrollspy", ["spyAPI", "duScrollOffset", "$timeout", "$rootScope", function(spyAPI, duScrollOffset, $timeout, $rootScope) {
        "use strict";
        var Spy = function(targetElementOrId, $scope, $element, offset) {
            angular.isElement(targetElementOrId) ? this.target = targetElementOrId : angular.isString(targetElementOrId) && (this.targetId = targetElementOrId), this.$scope = $scope, this.$element = $element, this.offset = offset
        };
        return Spy.prototype.getTargetElement = function() {
            return !this.target && this.targetId && (this.target = document.getElementById(this.targetId) || document.getElementsByName(this.targetId)[0]), this.target
        }, Spy.prototype.getTargetPosition = function() {
            var target = this.getTargetElement();
            if (target) return target.getBoundingClientRect()
        }, Spy.prototype.flushTargetCache = function() {
            this.targetId && (this.target = void 0)
        }, {
            link: function($scope, $element, $attr) {
                var targetId, href = $attr.ngHref || $attr.href;
                if (href && href.indexOf("#") !== -1 ? targetId = href.replace(/.*(?=#[^\s]+$)/, "").substring(1) : $attr.duScrollspy ? targetId = $attr.duScrollspy : $attr.duSmoothScroll && (targetId = $attr.duSmoothScroll), targetId) {
                    var timeoutPromise = $timeout(function() {
                        var spy = new Spy(targetId, $scope, $element, (-($attr.offset ? parseInt($attr.offset, 10) : duScrollOffset)));
                        spyAPI.addSpy(spy), $scope.$on("$locationChangeSuccess", spy.flushTargetCache.bind(spy));
                        var deregisterOnStateChange = $rootScope.$on("$stateChangeSuccess", spy.flushTargetCache.bind(spy));
                        $scope.$on("$destroy", function() {
                            spyAPI.removeSpy(spy), deregisterOnStateChange()
                        })
                    }, 0, !1);
                    $scope.$on("$destroy", function() {
                        $timeout.cancel(timeoutPromise)
                    })
                }
            }
        }
    }]),
    function(window, document, exportName, undefined) {
        "use strict";

        function setTimeoutContext(fn, timeout, context) {
            return setTimeout(bindFn(fn, context), timeout)
        }

        function invokeArrayArg(arg, fn, context) {
            return !!Array.isArray(arg) && (each(arg, context[fn], context), !0)
        }

        function each(obj, iterator, context) {
            var i;
            if (obj)
                if (obj.forEach) obj.forEach(iterator, context);
                else if (obj.length !== undefined)
                for (i = 0; i < obj.length;) iterator.call(context, obj[i], i, obj), i++;
            else
                for (i in obj) obj.hasOwnProperty(i) && iterator.call(context, obj[i], i, obj)
        }

        function deprecate(method, name, message) {
            var deprecationMessage = "DEPRECATED METHOD: " + name + "\n" + message + " AT \n";
            return function() {
                var e = new Error("get-stack-trace"),
                    stack = e && e.stack ? e.stack.replace(/^[^\(]+?[\n$]/gm, "").replace(/^\s+at\s+/gm, "").replace(/^Object.<anonymous>\s*\(/gm, "{anonymous}()@") : "Unknown Stack Trace",
                    log = window.console && (window.console.warn || window.console.log);
                return log && log.call(window.console, deprecationMessage, stack), method.apply(this, arguments)
            }
        }

        function inherit(child, base, properties) {
            var childP, baseP = base.prototype;
            childP = child.prototype = Object.create(baseP), childP.constructor = child, childP._super = baseP, properties && assign(childP, properties)
        }

        function bindFn(fn, context) {
            return function() {
                return fn.apply(context, arguments)
            }
        }

        function boolOrFn(val, args) {
            return _typeof2(val) == TYPE_FUNCTION ? val.apply(args ? args[0] || undefined : undefined, args) : val
        }

        function ifUndefined(val1, val2) {
            return val1 === undefined ? val2 : val1
        }

        function addEventListeners(target, types, handler) {
            each(splitStr(types), function(type) {
                target.addEventListener(type, handler, !1)
            })
        }

        function removeEventListeners(target, types, handler) {
            each(splitStr(types), function(type) {
                target.removeEventListener(type, handler, !1)
            })
        }

        function hasParent(node, parent) {
            for (; node;) {
                if (node == parent) return !0;
                node = node.parentNode
            }
            return !1
        }

        function inStr(str, find) {
            return str.indexOf(find) > -1
        }

        function splitStr(str) {
            return str.trim().split(/\s+/g)
        }

        function inArray(src, find, findByKey) {
            if (src.indexOf && !findByKey) return src.indexOf(find);
            for (var i = 0; i < src.length;) {
                if (findByKey && src[i][findByKey] == find || !findByKey && src[i] === find) return i;
                i++
            }
            return -1
        }

        function toArray(obj) {
            return Array.prototype.slice.call(obj, 0)
        }

        function uniqueArray(src, key, sort) {
            for (var results = [], values = [], i = 0; i < src.length;) {
                var val = key ? src[i][key] : src[i];
                inArray(values, val) < 0 && results.push(src[i]), values[i] = val, i++
            }
            return sort && (results = key ? results.sort(function(a, b) {
                return a[key] > b[key]
            }) : results.sort()), results
        }

        function prefixed(obj, property) {
            for (var prefix, prop, camelProp = property[0].toUpperCase() + property.slice(1), i = 0; i < VENDOR_PREFIXES.length;) {
                if (prefix = VENDOR_PREFIXES[i], prop = prefix ? prefix + camelProp : property, prop in obj) return prop;
                i++
            }
            return undefined
        }

        function uniqueId() {
            return _uniqueId++
        }

        function getWindowForElement(element) {
            var doc = element.ownerDocument || element;
            return doc.defaultView || doc.parentWindow || window
        }

        function Input(manager, callback) {
            var self = this;
            this.manager = manager, this.callback = callback, this.element = manager.element, this.target = manager.options.inputTarget, this.domHandler = function(ev) {
                boolOrFn(manager.options.enable, [manager]) && self.handler(ev)
            }, this.init()
        }

        function createInputInstance(manager) {
            var Type, inputClass = manager.options.inputClass;
            return new(Type = inputClass ? inputClass : SUPPORT_POINTER_EVENTS ? PointerEventInput : SUPPORT_ONLY_TOUCH ? TouchInput : SUPPORT_TOUCH ? TouchMouseInput : MouseInput)(manager, inputHandler)
        }

        function inputHandler(manager, eventType, input) {
            var pointersLen = input.pointers.length,
                changedPointersLen = input.changedPointers.length,
                isFirst = eventType & INPUT_START && pointersLen - changedPointersLen === 0,
                isFinal = eventType & (INPUT_END | INPUT_CANCEL) && pointersLen - changedPointersLen === 0;
            input.isFirst = !!isFirst, input.isFinal = !!isFinal, isFirst && (manager.session = {}), input.eventType = eventType, computeInputData(manager, input), manager.emit("hammer.input", input), manager.recognize(input), manager.session.prevInput = input
        }

        function computeInputData(manager, input) {
            var session = manager.session,
                pointers = input.pointers,
                pointersLength = pointers.length;
            session.firstInput || (session.firstInput = simpleCloneInputData(input)), pointersLength > 1 && !session.firstMultiple ? session.firstMultiple = simpleCloneInputData(input) : 1 === pointersLength && (session.firstMultiple = !1);
            var firstInput = session.firstInput,
                firstMultiple = session.firstMultiple,
                offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center,
                center = input.center = getCenter(pointers);
            input.timeStamp = now(), input.deltaTime = input.timeStamp - firstInput.timeStamp, input.angle = getAngle(offsetCenter, center), input.distance = getDistance(offsetCenter, center), computeDeltaXY(session, input), input.offsetDirection = getDirection(input.deltaX, input.deltaY);
            var overallVelocity = getVelocity(input.deltaTime, input.deltaX, input.deltaY);
            input.overallVelocityX = overallVelocity.x, input.overallVelocityY = overallVelocity.y, input.overallVelocity = abs(overallVelocity.x) > abs(overallVelocity.y) ? overallVelocity.x : overallVelocity.y, input.scale = firstMultiple ? getScale(firstMultiple.pointers, pointers) : 1, input.rotation = firstMultiple ? getRotation(firstMultiple.pointers, pointers) : 0, input.maxPointers = session.prevInput ? input.pointers.length > session.prevInput.maxPointers ? input.pointers.length : session.prevInput.maxPointers : input.pointers.length, computeIntervalInputData(session, input);
            var target = manager.element;
            hasParent(input.srcEvent.target, target) && (target = input.srcEvent.target), input.target = target
        }

        function computeDeltaXY(session, input) {
            var center = input.center,
                offset = session.offsetDelta || {},
                prevDelta = session.prevDelta || {},
                prevInput = session.prevInput || {};
            input.eventType !== INPUT_START && prevInput.eventType !== INPUT_END || (prevDelta = session.prevDelta = {
                x: prevInput.deltaX || 0,
                y: prevInput.deltaY || 0
            }, offset = session.offsetDelta = {
                x: center.x,
                y: center.y
            }), input.deltaX = prevDelta.x + (center.x - offset.x), input.deltaY = prevDelta.y + (center.y - offset.y)
        }

        function computeIntervalInputData(session, input) {
            var velocity, velocityX, velocityY, direction, last = session.lastInterval || input,
                deltaTime = input.timeStamp - last.timeStamp;
            if (input.eventType != INPUT_CANCEL && (deltaTime > COMPUTE_INTERVAL || last.velocity === undefined)) {
                var deltaX = input.deltaX - last.deltaX,
                    deltaY = input.deltaY - last.deltaY,
                    v = getVelocity(deltaTime, deltaX, deltaY);
                velocityX = v.x, velocityY = v.y, velocity = abs(v.x) > abs(v.y) ? v.x : v.y, direction = getDirection(deltaX, deltaY), session.lastInterval = input
            } else velocity = last.velocity, velocityX = last.velocityX, velocityY = last.velocityY, direction = last.direction;
            input.velocity = velocity, input.velocityX = velocityX, input.velocityY = velocityY, input.direction = direction
        }

        function simpleCloneInputData(input) {
            for (var pointers = [], i = 0; i < input.pointers.length;) pointers[i] = {
                clientX: round(input.pointers[i].clientX),
                clientY: round(input.pointers[i].clientY)
            }, i++;
            return {
                timeStamp: now(),
                pointers: pointers,
                center: getCenter(pointers),
                deltaX: input.deltaX,
                deltaY: input.deltaY
            }
        }

        function getCenter(pointers) {
            var pointersLength = pointers.length;
            if (1 === pointersLength) return {
                x: round(pointers[0].clientX),
                y: round(pointers[0].clientY)
            };
            for (var x = 0, y = 0, i = 0; i < pointersLength;) x += pointers[i].clientX, y += pointers[i].clientY, i++;
            return {
                x: round(x / pointersLength),
                y: round(y / pointersLength)
            }
        }

        function getVelocity(deltaTime, x, y) {
            return {
                x: x / deltaTime || 0,
                y: y / deltaTime || 0
            }
        }

        function getDirection(x, y) {
            return x === y ? DIRECTION_NONE : abs(x) >= abs(y) ? x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT : y < 0 ? DIRECTION_UP : DIRECTION_DOWN
        }

        function getDistance(p1, p2, props) {
            props || (props = PROPS_XY);
            var x = p2[props[0]] - p1[props[0]],
                y = p2[props[1]] - p1[props[1]];
            return Math.sqrt(x * x + y * y)
        }

        function getAngle(p1, p2, props) {
            props || (props = PROPS_XY);
            var x = p2[props[0]] - p1[props[0]],
                y = p2[props[1]] - p1[props[1]];
            return 180 * Math.atan2(y, x) / Math.PI
        }

        function getRotation(start, end) {
            return getAngle(end[1], end[0], PROPS_CLIENT_XY) + getAngle(start[1], start[0], PROPS_CLIENT_XY)
        }

        function getScale(start, end) {
            return getDistance(end[0], end[1], PROPS_CLIENT_XY) / getDistance(start[0], start[1], PROPS_CLIENT_XY)
        }

        function MouseInput() {
            this.evEl = MOUSE_ELEMENT_EVENTS, this.evWin = MOUSE_WINDOW_EVENTS, this.pressed = !1, Input.apply(this, arguments)
        }

        function PointerEventInput() {
            this.evEl = POINTER_ELEMENT_EVENTS, this.evWin = POINTER_WINDOW_EVENTS, Input.apply(this, arguments), this.store = this.manager.session.pointerEvents = []
        }

        function SingleTouchInput() {
            this.evTarget = SINGLE_TOUCH_TARGET_EVENTS, this.evWin = SINGLE_TOUCH_WINDOW_EVENTS, this.started = !1, Input.apply(this, arguments)
        }

        function normalizeSingleTouches(ev, type) {
            var all = toArray(ev.touches),
                changed = toArray(ev.changedTouches);
            return type & (INPUT_END | INPUT_CANCEL) && (all = uniqueArray(all.concat(changed), "identifier", !0)), [all, changed]
        }

        function TouchInput() {
            this.evTarget = TOUCH_TARGET_EVENTS, this.targetIds = {}, Input.apply(this, arguments)
        }

        function getTouches(ev, type) {
            var allTouches = toArray(ev.touches),
                targetIds = this.targetIds;
            if (type & (INPUT_START | INPUT_MOVE) && 1 === allTouches.length) return targetIds[allTouches[0].identifier] = !0, [allTouches, allTouches];
            var i, targetTouches, changedTouches = toArray(ev.changedTouches),
                changedTargetTouches = [],
                target = this.target;
            if (targetTouches = allTouches.filter(function(touch) {
                    return hasParent(touch.target, target)
                }), type === INPUT_START)
                for (i = 0; i < targetTouches.length;) targetIds[targetTouches[i].identifier] = !0, i++;
            for (i = 0; i < changedTouches.length;) targetIds[changedTouches[i].identifier] && changedTargetTouches.push(changedTouches[i]), type & (INPUT_END | INPUT_CANCEL) && delete targetIds[changedTouches[i].identifier], i++;
            return changedTargetTouches.length ? [uniqueArray(targetTouches.concat(changedTargetTouches), "identifier", !0), changedTargetTouches] : void 0
        }

        function TouchMouseInput() {
            Input.apply(this, arguments);
            var handler = bindFn(this.handler, this);
            this.touch = new TouchInput(this.manager, handler), this.mouse = new MouseInput(this.manager, handler), this.primaryTouch = null, this.lastTouches = []
        }

        function recordTouches(eventType, eventData) {
            eventType & INPUT_START ? (this.primaryTouch = eventData.changedPointers[0].identifier, setLastTouch.call(this, eventData)) : eventType & (INPUT_END | INPUT_CANCEL) && setLastTouch.call(this, eventData)
        }

        function setLastTouch(eventData) {
            var touch = eventData.changedPointers[0];
            if (touch.identifier === this.primaryTouch) {
                var lastTouch = {
                    x: touch.clientX,
                    y: touch.clientY
                };
                this.lastTouches.push(lastTouch);
                var lts = this.lastTouches,
                    removeLastTouch = function() {
                        var i = lts.indexOf(lastTouch);
                        i > -1 && lts.splice(i, 1)
                    };
                setTimeout(removeLastTouch, DEDUP_TIMEOUT)
            }
        }

        function isSyntheticEvent(eventData) {
            for (var x = eventData.srcEvent.clientX, y = eventData.srcEvent.clientY, i = 0; i < this.lastTouches.length; i++) {
                var t = this.lastTouches[i],
                    dx = Math.abs(x - t.x),
                    dy = Math.abs(y - t.y);
                if (dx <= DEDUP_DISTANCE && dy <= DEDUP_DISTANCE) return !0
            }
            return !1
        }

        function TouchAction(manager, value) {
            this.manager = manager, this.set(value)
        }

        function cleanTouchActions(actions) {
            if (inStr(actions, TOUCH_ACTION_NONE)) return TOUCH_ACTION_NONE;
            var hasPanX = inStr(actions, TOUCH_ACTION_PAN_X),
                hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y);
            return hasPanX && hasPanY ? TOUCH_ACTION_NONE : hasPanX || hasPanY ? hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y : inStr(actions, TOUCH_ACTION_MANIPULATION) ? TOUCH_ACTION_MANIPULATION : TOUCH_ACTION_AUTO
        }

        function getTouchActionProps() {
            if (!NATIVE_TOUCH_ACTION) return !1;
            var touchMap = {},
                cssSupports = window.CSS && window.CSS.supports;
            return ["auto", "manipulation", "pan-y", "pan-x", "pan-x pan-y", "none"].forEach(function(val) {
                touchMap[val] = !cssSupports || window.CSS.supports("touch-action", val)
            }), touchMap
        }

        function Recognizer(options) {
            this.options = assign({}, this.defaults, options || {}), this.id = uniqueId(), this.manager = null, this.options.enable = ifUndefined(this.options.enable, !0), this.state = STATE_POSSIBLE, this.simultaneous = {}, this.requireFail = []
        }

        function stateStr(state) {
            return state & STATE_CANCELLED ? "cancel" : state & STATE_ENDED ? "end" : state & STATE_CHANGED ? "move" : state & STATE_BEGAN ? "start" : ""
        }

        function directionStr(direction) {
            return direction == DIRECTION_DOWN ? "down" : direction == DIRECTION_UP ? "up" : direction == DIRECTION_LEFT ? "left" : direction == DIRECTION_RIGHT ? "right" : ""
        }

        function getRecognizerByNameIfManager(otherRecognizer, recognizer) {
            var manager = recognizer.manager;
            return manager ? manager.get(otherRecognizer) : otherRecognizer
        }

        function AttrRecognizer() {
            Recognizer.apply(this, arguments)
        }

        function PanRecognizer() {
            AttrRecognizer.apply(this, arguments), this.pX = null, this.pY = null
        }

        function PinchRecognizer() {
            AttrRecognizer.apply(this, arguments)
        }

        function PressRecognizer() {
            Recognizer.apply(this, arguments), this._timer = null, this._input = null
        }

        function RotateRecognizer() {
            AttrRecognizer.apply(this, arguments)
        }

        function SwipeRecognizer() {
            AttrRecognizer.apply(this, arguments)
        }

        function TapRecognizer() {
            Recognizer.apply(this, arguments), this.pTime = !1, this.pCenter = !1, this._timer = null, this._input = null, this.count = 0
        }

        function Hammer(element, options) {
            return options = options || {}, options.recognizers = ifUndefined(options.recognizers, Hammer.defaults.preset), new Manager(element, options)
        }

        function Manager(element, options) {
            this.options = assign({}, Hammer.defaults, options || {}), this.options.inputTarget = this.options.inputTarget || element, this.handlers = {}, this.session = {}, this.recognizers = [], this.oldCssProps = {}, this.element = element, this.input = createInputInstance(this), this.touchAction = new TouchAction(this, this.options.touchAction), toggleCssProps(this, !0), each(this.options.recognizers, function(item) {
                var recognizer = this.add(new item[0](item[1]));
                item[2] && recognizer.recognizeWith(item[2]), item[3] && recognizer.requireFailure(item[3])
            }, this)
        }

        function toggleCssProps(manager, add) {
            var element = manager.element;
            if (element.style) {
                var prop;
                each(manager.options.cssProps, function(value, name) {
                    prop = prefixed(element.style, name), add ? (manager.oldCssProps[prop] = element.style[prop], element.style[prop] = value) : element.style[prop] = manager.oldCssProps[prop] || ""
                }), add || (manager.oldCssProps = {})
            }
        }

        function triggerDomEvent(event, data) {
            var gestureEvent = document.createEvent("Event");
            gestureEvent.initEvent(event, !0, !0), gestureEvent.gesture = data, data.target.dispatchEvent(gestureEvent)
        }
        var assign, VENDOR_PREFIXES = ["", "webkit", "Moz", "MS", "ms", "o"],
            TEST_ELEMENT = document.createElement("div"),
            TYPE_FUNCTION = "function",
            round = Math.round,
            abs = Math.abs,
            now = Date.now;
        assign = "function" != typeof Object.assign ? function(target) {
            if (target === undefined || null === target) throw new TypeError("Cannot convert undefined or null to object");
            for (var output = Object(target), index = 1; index < arguments.length; index++) {
                var source = arguments[index];
                if (source !== undefined && null !== source)
                    for (var nextKey in source) source.hasOwnProperty(nextKey) && (output[nextKey] = source[nextKey])
            }
            return output
        } : Object.assign;
        var extend = deprecate(function(dest, src, merge) {
                for (var keys = Object.keys(src), i = 0; i < keys.length;)(!merge || merge && dest[keys[i]] === undefined) && (dest[keys[i]] = src[keys[i]]), i++;
                return dest
            }, "extend", "Use `assign`."),
            merge = deprecate(function(dest, src) {
                return extend(dest, src, !0)
            }, "merge", "Use `assign`."),
            _uniqueId = 1,
            MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i,
            SUPPORT_TOUCH = "ontouchstart" in window,
            SUPPORT_POINTER_EVENTS = prefixed(window, "PointerEvent") !== undefined,
            SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test(navigator.userAgent),
            INPUT_TYPE_TOUCH = "touch",
            INPUT_TYPE_PEN = "pen",
            INPUT_TYPE_MOUSE = "mouse",
            INPUT_TYPE_KINECT = "kinect",
            COMPUTE_INTERVAL = 25,
            INPUT_START = 1,
            INPUT_MOVE = 2,
            INPUT_END = 4,
            INPUT_CANCEL = 8,
            DIRECTION_NONE = 1,
            DIRECTION_LEFT = 2,
            DIRECTION_RIGHT = 4,
            DIRECTION_UP = 8,
            DIRECTION_DOWN = 16,
            DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT,
            DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN,
            DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            PROPS_XY = ["x", "y"],
            PROPS_CLIENT_XY = ["clientX", "clientY"];
        Input.prototype = {
            handler: function() {},
            init: function() {
                this.evEl && addEventListeners(this.element, this.evEl, this.domHandler), this.evTarget && addEventListeners(this.target, this.evTarget, this.domHandler), this.evWin && addEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler)
            },
            destroy: function() {
                this.evEl && removeEventListeners(this.element, this.evEl, this.domHandler), this.evTarget && removeEventListeners(this.target, this.evTarget, this.domHandler), this.evWin && removeEventListeners(getWindowForElement(this.element), this.evWin, this.domHandler)
            }
        };
        var MOUSE_INPUT_MAP = {
                mousedown: INPUT_START,
                mousemove: INPUT_MOVE,
                mouseup: INPUT_END
            },
            MOUSE_ELEMENT_EVENTS = "mousedown",
            MOUSE_WINDOW_EVENTS = "mousemove mouseup";
        inherit(MouseInput, Input, {
            handler: function(ev) {
                var eventType = MOUSE_INPUT_MAP[ev.type];
                eventType & INPUT_START && 0 === ev.button && (this.pressed = !0), eventType & INPUT_MOVE && 1 !== ev.which && (eventType = INPUT_END), this.pressed && (eventType & INPUT_END && (this.pressed = !1), this.callback(this.manager, eventType, {
                    pointers: [ev],
                    changedPointers: [ev],
                    pointerType: INPUT_TYPE_MOUSE,
                    srcEvent: ev
                }))
            }
        });
        var POINTER_INPUT_MAP = {
                pointerdown: INPUT_START,
                pointermove: INPUT_MOVE,
                pointerup: INPUT_END,
                pointercancel: INPUT_CANCEL,
                pointerout: INPUT_CANCEL
            },
            IE10_POINTER_TYPE_ENUM = {
                2: INPUT_TYPE_TOUCH,
                3: INPUT_TYPE_PEN,
                4: INPUT_TYPE_MOUSE,
                5: INPUT_TYPE_KINECT
            },
            POINTER_ELEMENT_EVENTS = "pointerdown",
            POINTER_WINDOW_EVENTS = "pointermove pointerup pointercancel";
        window.MSPointerEvent && !window.PointerEvent && (POINTER_ELEMENT_EVENTS = "MSPointerDown", POINTER_WINDOW_EVENTS = "MSPointerMove MSPointerUp MSPointerCancel"), inherit(PointerEventInput, Input, {
            handler: function(ev) {
                var store = this.store,
                    removePointer = !1,
                    eventTypeNormalized = ev.type.toLowerCase().replace("ms", ""),
                    eventType = POINTER_INPUT_MAP[eventTypeNormalized],
                    pointerType = IE10_POINTER_TYPE_ENUM[ev.pointerType] || ev.pointerType,
                    isTouch = pointerType == INPUT_TYPE_TOUCH,
                    storeIndex = inArray(store, ev.pointerId, "pointerId");
                eventType & INPUT_START && (0 === ev.button || isTouch) ? storeIndex < 0 && (store.push(ev), storeIndex = store.length - 1) : eventType & (INPUT_END | INPUT_CANCEL) && (removePointer = !0), storeIndex < 0 || (store[storeIndex] = ev, this.callback(this.manager, eventType, {
                    pointers: store,
                    changedPointers: [ev],
                    pointerType: pointerType,
                    srcEvent: ev
                }), removePointer && store.splice(storeIndex, 1))
            }
        });
        var SINGLE_TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
            },
            SINGLE_TOUCH_TARGET_EVENTS = "touchstart",
            SINGLE_TOUCH_WINDOW_EVENTS = "touchstart touchmove touchend touchcancel";
        inherit(SingleTouchInput, Input, {
            handler: function(ev) {
                var type = SINGLE_TOUCH_INPUT_MAP[ev.type];
                if (type === INPUT_START && (this.started = !0), this.started) {
                    var touches = normalizeSingleTouches.call(this, ev, type);
                    type & (INPUT_END | INPUT_CANCEL) && touches[0].length - touches[1].length === 0 && (this.started = !1), this.callback(this.manager, type, {
                        pointers: touches[0],
                        changedPointers: touches[1],
                        pointerType: INPUT_TYPE_TOUCH,
                        srcEvent: ev
                    })
                }
            }
        });
        var TOUCH_INPUT_MAP = {
                touchstart: INPUT_START,
                touchmove: INPUT_MOVE,
                touchend: INPUT_END,
                touchcancel: INPUT_CANCEL
            },
            TOUCH_TARGET_EVENTS = "touchstart touchmove touchend touchcancel";
        inherit(TouchInput, Input, {
            handler: function(ev) {
                var type = TOUCH_INPUT_MAP[ev.type],
                    touches = getTouches.call(this, ev, type);
                touches && this.callback(this.manager, type, {
                    pointers: touches[0],
                    changedPointers: touches[1],
                    pointerType: INPUT_TYPE_TOUCH,
                    srcEvent: ev
                })
            }
        });
        var DEDUP_TIMEOUT = 2500,
            DEDUP_DISTANCE = 25;
        inherit(TouchMouseInput, Input, {
            handler: function(manager, inputEvent, inputData) {
                var isTouch = inputData.pointerType == INPUT_TYPE_TOUCH,
                    isMouse = inputData.pointerType == INPUT_TYPE_MOUSE;
                if (!(isMouse && inputData.sourceCapabilities && inputData.sourceCapabilities.firesTouchEvents)) {
                    if (isTouch) recordTouches.call(this, inputEvent, inputData);
                    else if (isMouse && isSyntheticEvent.call(this, inputData)) return;
                    this.callback(manager, inputEvent, inputData)
                }
            },
            destroy: function() {
                this.touch.destroy(), this.mouse.destroy()
            }
        });
        var PREFIXED_TOUCH_ACTION = prefixed(TEST_ELEMENT.style, "touchAction"),
            NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined,
            TOUCH_ACTION_COMPUTE = "compute",
            TOUCH_ACTION_AUTO = "auto",
            TOUCH_ACTION_MANIPULATION = "manipulation",
            TOUCH_ACTION_NONE = "none",
            TOUCH_ACTION_PAN_X = "pan-x",
            TOUCH_ACTION_PAN_Y = "pan-y",
            TOUCH_ACTION_MAP = getTouchActionProps();
        TouchAction.prototype = {
            set: function(value) {
                value == TOUCH_ACTION_COMPUTE && (value = this.compute()), NATIVE_TOUCH_ACTION && this.manager.element.style && TOUCH_ACTION_MAP[value] && (this.manager.element.style[PREFIXED_TOUCH_ACTION] = value), this.actions = value.toLowerCase().trim()
            },
            update: function() {
                this.set(this.manager.options.touchAction)
            },
            compute: function() {
                var actions = [];
                return each(this.manager.recognizers, function(recognizer) {
                    boolOrFn(recognizer.options.enable, [recognizer]) && (actions = actions.concat(recognizer.getTouchAction()))
                }), cleanTouchActions(actions.join(" "))
            },
            preventDefaults: function(input) {
                var srcEvent = input.srcEvent,
                    direction = input.offsetDirection;
                if (this.manager.session.prevented) return void srcEvent.preventDefault();
                var actions = this.actions,
                    hasNone = inStr(actions, TOUCH_ACTION_NONE) && !TOUCH_ACTION_MAP[TOUCH_ACTION_NONE],
                    hasPanY = inStr(actions, TOUCH_ACTION_PAN_Y) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_Y],
                    hasPanX = inStr(actions, TOUCH_ACTION_PAN_X) && !TOUCH_ACTION_MAP[TOUCH_ACTION_PAN_X];
                if (hasNone) {
                    var isTapPointer = 1 === input.pointers.length,
                        isTapMovement = input.distance < 2,
                        isTapTouchTime = input.deltaTime < 250;
                    if (isTapPointer && isTapMovement && isTapTouchTime) return
                }
                return hasPanX && hasPanY ? void 0 : hasNone || hasPanY && direction & DIRECTION_HORIZONTAL || hasPanX && direction & DIRECTION_VERTICAL ? this.preventSrc(srcEvent) : void 0
            },
            preventSrc: function(srcEvent) {
                this.manager.session.prevented = !0, srcEvent.preventDefault()
            }
        };
        var STATE_POSSIBLE = 1,
            STATE_BEGAN = 2,
            STATE_CHANGED = 4,
            STATE_ENDED = 8,
            STATE_RECOGNIZED = STATE_ENDED,
            STATE_CANCELLED = 16,
            STATE_FAILED = 32;
        Recognizer.prototype = {
            defaults: {},
            set: function(options) {
                return assign(this.options, options), this.manager && this.manager.touchAction.update(), this
            },
            recognizeWith: function(otherRecognizer) {
                if (invokeArrayArg(otherRecognizer, "recognizeWith", this)) return this;
                var simultaneous = this.simultaneous;
                return otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this), simultaneous[otherRecognizer.id] || (simultaneous[otherRecognizer.id] = otherRecognizer, otherRecognizer.recognizeWith(this)), this
            },
            dropRecognizeWith: function(otherRecognizer) {
                return invokeArrayArg(otherRecognizer, "dropRecognizeWith", this) ? this : (otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this), delete this.simultaneous[otherRecognizer.id], this)
            },
            requireFailure: function(otherRecognizer) {
                if (invokeArrayArg(otherRecognizer, "requireFailure", this)) return this;
                var requireFail = this.requireFail;
                return otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this), inArray(requireFail, otherRecognizer) === -1 && (requireFail.push(otherRecognizer), otherRecognizer.requireFailure(this)), this
            },
            dropRequireFailure: function(otherRecognizer) {
                if (invokeArrayArg(otherRecognizer, "dropRequireFailure", this)) return this;
                otherRecognizer = getRecognizerByNameIfManager(otherRecognizer, this);
                var index = inArray(this.requireFail, otherRecognizer);
                return index > -1 && this.requireFail.splice(index, 1), this
            },
            hasRequireFailures: function() {
                return this.requireFail.length > 0
            },
            canRecognizeWith: function(otherRecognizer) {
                return !!this.simultaneous[otherRecognizer.id]
            },
            emit: function emit(input) {
                function emit(event) {
                    self.manager.emit(event, input)
                }
                var self = this,
                    state = this.state;
                state < STATE_ENDED && emit(self.options.event + stateStr(state)), emit(self.options.event), input.additionalEvent && emit(input.additionalEvent), state >= STATE_ENDED && emit(self.options.event + stateStr(state))
            },
            tryEmit: function(input) {
                return this.canEmit() ? this.emit(input) : void(this.state = STATE_FAILED)
            },
            canEmit: function() {
                for (var i = 0; i < this.requireFail.length;) {
                    if (!(this.requireFail[i].state & (STATE_FAILED | STATE_POSSIBLE))) return !1;
                    i++
                }
                return !0
            },
            recognize: function(inputData) {
                var inputDataClone = assign({}, inputData);
                return boolOrFn(this.options.enable, [this, inputDataClone]) ? (this.state & (STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED) && (this.state = STATE_POSSIBLE), this.state = this.process(inputDataClone), void(this.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED) && this.tryEmit(inputDataClone))) : (this.reset(), void(this.state = STATE_FAILED))
            },
            process: function(inputData) {},
            getTouchAction: function() {},
            reset: function() {}
        }, inherit(AttrRecognizer, Recognizer, {
            defaults: {
                pointers: 1
            },
            attrTest: function(input) {
                var optionPointers = this.options.pointers;
                return 0 === optionPointers || input.pointers.length === optionPointers
            },
            process: function(input) {
                var state = this.state,
                    eventType = input.eventType,
                    isRecognized = state & (STATE_BEGAN | STATE_CHANGED),
                    isValid = this.attrTest(input);
                return isRecognized && (eventType & INPUT_CANCEL || !isValid) ? state | STATE_CANCELLED : isRecognized || isValid ? eventType & INPUT_END ? state | STATE_ENDED : state & STATE_BEGAN ? state | STATE_CHANGED : STATE_BEGAN : STATE_FAILED
            }
        }), inherit(PanRecognizer, AttrRecognizer, {
            defaults: {
                event: "pan",
                threshold: 10,
                pointers: 1,
                direction: DIRECTION_ALL
            },
            getTouchAction: function() {
                var direction = this.options.direction,
                    actions = [];
                return direction & DIRECTION_HORIZONTAL && actions.push(TOUCH_ACTION_PAN_Y), direction & DIRECTION_VERTICAL && actions.push(TOUCH_ACTION_PAN_X), actions
            },
            directionTest: function(input) {
                var options = this.options,
                    hasMoved = !0,
                    distance = input.distance,
                    direction = input.direction,
                    x = input.deltaX,
                    y = input.deltaY;
                return direction & options.direction || (options.direction & DIRECTION_HORIZONTAL ? (direction = 0 === x ? DIRECTION_NONE : x < 0 ? DIRECTION_LEFT : DIRECTION_RIGHT, hasMoved = x != this.pX, distance = Math.abs(input.deltaX)) : (direction = 0 === y ? DIRECTION_NONE : y < 0 ? DIRECTION_UP : DIRECTION_DOWN, hasMoved = y != this.pY, distance = Math.abs(input.deltaY))), input.direction = direction, hasMoved && distance > options.threshold && direction & options.direction
            },
            attrTest: function(input) {
                return AttrRecognizer.prototype.attrTest.call(this, input) && (this.state & STATE_BEGAN || !(this.state & STATE_BEGAN) && this.directionTest(input))
            },
            emit: function(input) {
                this.pX = input.deltaX, this.pY = input.deltaY;
                var direction = directionStr(input.direction);
                direction && (input.additionalEvent = this.options.event + direction), this._super.emit.call(this, input)
            }
        }), inherit(PinchRecognizer, AttrRecognizer, {
            defaults: {
                event: "pinch",
                threshold: 0,
                pointers: 2
            },
            getTouchAction: function() {
                return [TOUCH_ACTION_NONE]
            },
            attrTest: function(input) {
                return this._super.attrTest.call(this, input) && (Math.abs(input.scale - 1) > this.options.threshold || this.state & STATE_BEGAN)
            },
            emit: function(input) {
                if (1 !== input.scale) {
                    var inOut = input.scale < 1 ? "in" : "out";
                    input.additionalEvent = this.options.event + inOut
                }
                this._super.emit.call(this, input)
            }
        }), inherit(PressRecognizer, Recognizer, {
            defaults: {
                event: "press",
                pointers: 1,
                time: 251,
                threshold: 9
            },
            getTouchAction: function() {
                return [TOUCH_ACTION_AUTO]
            },
            process: function(input) {
                var options = this.options,
                    validPointers = input.pointers.length === options.pointers,
                    validMovement = input.distance < options.threshold,
                    validTime = input.deltaTime > options.time;
                if (this._input = input, !validMovement || !validPointers || input.eventType & (INPUT_END | INPUT_CANCEL) && !validTime) this.reset();
                else if (input.eventType & INPUT_START) this.reset(), this._timer = setTimeoutContext(function() {
                    this.state = STATE_RECOGNIZED, this.tryEmit()
                }, options.time, this);
                else if (input.eventType & INPUT_END) return STATE_RECOGNIZED;
                return STATE_FAILED
            },
            reset: function() {
                clearTimeout(this._timer)
            },
            emit: function(input) {
                this.state === STATE_RECOGNIZED && (input && input.eventType & INPUT_END ? this.manager.emit(this.options.event + "up", input) : (this._input.timeStamp = now(), this.manager.emit(this.options.event, this._input)))
            }
        }), inherit(RotateRecognizer, AttrRecognizer, {
            defaults: {
                event: "rotate",
                threshold: 0,
                pointers: 2
            },
            getTouchAction: function() {
                return [TOUCH_ACTION_NONE]
            },
            attrTest: function(input) {
                return this._super.attrTest.call(this, input) && (Math.abs(input.rotation) > this.options.threshold || this.state & STATE_BEGAN)
            }
        }), inherit(SwipeRecognizer, AttrRecognizer, {
            defaults: {
                event: "swipe",
                threshold: 10,
                velocity: .3,
                direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
                pointers: 1
            },
            getTouchAction: function() {
                return PanRecognizer.prototype.getTouchAction.call(this)
            },
            attrTest: function(input) {
                var velocity, direction = this.options.direction;
                return direction & (DIRECTION_HORIZONTAL | DIRECTION_VERTICAL) ? velocity = input.overallVelocity : direction & DIRECTION_HORIZONTAL ? velocity = input.overallVelocityX : direction & DIRECTION_VERTICAL && (velocity = input.overallVelocityY), this._super.attrTest.call(this, input) && direction & input.offsetDirection && input.distance > this.options.threshold && input.maxPointers == this.options.pointers && abs(velocity) > this.options.velocity && input.eventType & INPUT_END
            },
            emit: function(input) {
                var direction = directionStr(input.offsetDirection);
                direction && this.manager.emit(this.options.event + direction, input), this.manager.emit(this.options.event, input)
            }
        }), inherit(TapRecognizer, Recognizer, {
            defaults: {
                event: "tap",
                pointers: 1,
                taps: 1,
                interval: 300,
                time: 250,
                threshold: 9,
                posThreshold: 10
            },
            getTouchAction: function() {
                return [TOUCH_ACTION_MANIPULATION]
            },
            process: function(input) {
                var options = this.options,
                    validPointers = input.pointers.length === options.pointers,
                    validMovement = input.distance < options.threshold,
                    validTouchTime = input.deltaTime < options.time;
                if (this.reset(), input.eventType & INPUT_START && 0 === this.count) return this.failTimeout();
                if (validMovement && validTouchTime && validPointers) {
                    if (input.eventType != INPUT_END) return this.failTimeout();
                    var validInterval = !this.pTime || input.timeStamp - this.pTime < options.interval,
                        validMultiTap = !this.pCenter || getDistance(this.pCenter, input.center) < options.posThreshold;
                    this.pTime = input.timeStamp, this.pCenter = input.center, validMultiTap && validInterval ? this.count += 1 : this.count = 1, this._input = input;
                    var tapCount = this.count % options.taps;
                    if (0 === tapCount) return this.hasRequireFailures() ? (this._timer = setTimeoutContext(function() {
                        this.state = STATE_RECOGNIZED, this.tryEmit()
                    }, options.interval, this), STATE_BEGAN) : STATE_RECOGNIZED
                }
                return STATE_FAILED
            },
            failTimeout: function() {
                return this._timer = setTimeoutContext(function() {
                    this.state = STATE_FAILED
                }, this.options.interval, this), STATE_FAILED
            },
            reset: function() {
                clearTimeout(this._timer)
            },
            emit: function() {
                this.state == STATE_RECOGNIZED && (this._input.tapCount = this.count, this.manager.emit(this.options.event, this._input))
            }
        }), Hammer.VERSION = "2.0.7", Hammer.defaults = {
            domEvents: !1,
            touchAction: TOUCH_ACTION_COMPUTE,
            enable: !0,
            inputTarget: null,
            inputClass: null,
            preset: [
                [RotateRecognizer, {
                    enable: !1
                }],
                [PinchRecognizer, {
                        enable: !1
                    },
                    ["rotate"]
                ],
                [SwipeRecognizer, {
                    direction: DIRECTION_HORIZONTAL
                }],
                [PanRecognizer, {
                        direction: DIRECTION_HORIZONTAL
                    },
                    ["swipe"]
                ],
                [TapRecognizer],
                [TapRecognizer, {
                        event: "doubletap",
                        taps: 2
                    },
                    ["tap"]
                ],
                [PressRecognizer]
            ],
            cssProps: {
                userSelect: "none",
                touchSelect: "none",
                touchCallout: "none",
                contentZooming: "none",
                userDrag: "none",
                tapHighlightColor: "rgba(0,0,0,0)"
            }
        };
        var STOP = 1,
            FORCED_STOP = 2;
        Manager.prototype = {
            set: function(options) {
                return assign(this.options, options), options.touchAction && this.touchAction.update(), options.inputTarget && (this.input.destroy(), this.input.target = options.inputTarget, this.input.init()), this
            },
            stop: function(force) {
                this.session.stopped = force ? FORCED_STOP : STOP
            },
            recognize: function(inputData) {
                var session = this.session;
                if (!session.stopped) {
                    this.touchAction.preventDefaults(inputData);
                    var recognizer, recognizers = this.recognizers,
                        curRecognizer = session.curRecognizer;
                    (!curRecognizer || curRecognizer && curRecognizer.state & STATE_RECOGNIZED) && (curRecognizer = session.curRecognizer = null);
                    for (var i = 0; i < recognizers.length;) recognizer = recognizers[i], session.stopped === FORCED_STOP || curRecognizer && recognizer != curRecognizer && !recognizer.canRecognizeWith(curRecognizer) ? recognizer.reset() : recognizer.recognize(inputData), !curRecognizer && recognizer.state & (STATE_BEGAN | STATE_CHANGED | STATE_ENDED) && (curRecognizer = session.curRecognizer = recognizer), i++
                }
            },
            get: function(recognizer) {
                if (recognizer instanceof Recognizer) return recognizer;
                for (var recognizers = this.recognizers, i = 0; i < recognizers.length; i++)
                    if (recognizers[i].options.event == recognizer) return recognizers[i];
                return null
            },
            add: function(recognizer) {
                if (invokeArrayArg(recognizer, "add", this)) return this;
                var existing = this.get(recognizer.options.event);
                return existing && this.remove(existing), this.recognizers.push(recognizer), recognizer.manager = this, this.touchAction.update(), recognizer
            },
            remove: function(recognizer) {
                if (invokeArrayArg(recognizer, "remove", this)) return this;
                if (recognizer = this.get(recognizer)) {
                    var recognizers = this.recognizers,
                        index = inArray(recognizers, recognizer);
                    index !== -1 && (recognizers.splice(index, 1), this.touchAction.update())
                }
                return this
            },
            on: function(events, handler) {
                if (events !== undefined && handler !== undefined) {
                    var handlers = this.handlers;
                    return each(splitStr(events), function(event) {
                        handlers[event] = handlers[event] || [], handlers[event].push(handler)
                    }), this
                }
            },
            off: function(events, handler) {
                if (events !== undefined) {
                    var handlers = this.handlers;
                    return each(splitStr(events), function(event) {
                        handler ? handlers[event] && handlers[event].splice(inArray(handlers[event], handler), 1) : delete handlers[event]
                    }), this
                }
            },
            emit: function(event, data) {
                this.options.domEvents && triggerDomEvent(event, data);
                var handlers = this.handlers[event] && this.handlers[event].slice();
                if (handlers && handlers.length) {
                    data.type = event, data.preventDefault = function() {
                        data.srcEvent.preventDefault()
                    };
                    for (var i = 0; i < handlers.length;) handlers[i](data), i++
                }
            },
            destroy: function() {
                this.element && toggleCssProps(this, !1), this.handlers = {}, this.session = {}, this.input.destroy(), this.element = null
            }
        }, assign(Hammer, {
            INPUT_START: INPUT_START,
            INPUT_MOVE: INPUT_MOVE,
            INPUT_END: INPUT_END,
            INPUT_CANCEL: INPUT_CANCEL,
            STATE_POSSIBLE: STATE_POSSIBLE,
            STATE_BEGAN: STATE_BEGAN,
            STATE_CHANGED: STATE_CHANGED,
            STATE_ENDED: STATE_ENDED,
            STATE_RECOGNIZED: STATE_RECOGNIZED,
            STATE_CANCELLED: STATE_CANCELLED,
            STATE_FAILED: STATE_FAILED,
            DIRECTION_NONE: DIRECTION_NONE,
            DIRECTION_LEFT: DIRECTION_LEFT,
            DIRECTION_RIGHT: DIRECTION_RIGHT,
            DIRECTION_UP: DIRECTION_UP,
            DIRECTION_DOWN: DIRECTION_DOWN,
            DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
            DIRECTION_VERTICAL: DIRECTION_VERTICAL,
            DIRECTION_ALL: DIRECTION_ALL,
            Manager: Manager,
            Input: Input,
            TouchAction: TouchAction,
            TouchInput: TouchInput,
            MouseInput: MouseInput,
            PointerEventInput: PointerEventInput,
            TouchMouseInput: TouchMouseInput,
            SingleTouchInput: SingleTouchInput,
            Recognizer: Recognizer,
            AttrRecognizer: AttrRecognizer,
            Tap: TapRecognizer,
            Pan: PanRecognizer,
            Swipe: SwipeRecognizer,
            Pinch: PinchRecognizer,
            Rotate: RotateRecognizer,
            Press: PressRecognizer,
            on: addEventListeners,
            off: removeEventListeners,
            each: each,
            merge: merge,
            extend: extend,
            assign: assign,
            inherit: inherit,
            bindFn: bindFn,
            prefixed: prefixed
        });
        var freeGlobal = "undefined" != typeof window ? window : "undefined" != typeof self ? self : {};
        freeGlobal.Hammer = Hammer, "function" == typeof define && define.amd ? define(function() {
            return Hammer
        }) : "undefined" != typeof module && module.exports ? module.exports = Hammer : window[exportName] = Hammer
    }(window, document, "Hammer"),
    function(window, undefined) {
        "use strict";
        var LIBVERSION = "0.7.18",
            EMPTY = "",
            UNKNOWN = "?",
            FUNC_TYPE = "function",
            UNDEF_TYPE = "undefined",
            OBJ_TYPE = "object",
            STR_TYPE = "string",
            MAJOR = "major",
            MODEL = "model",
            NAME = "name",
            TYPE = "type",
            VENDOR = "vendor",
            VERSION = "version",
            ARCHITECTURE = "architecture",
            CONSOLE = "console",
            MOBILE = "mobile",
            TABLET = "tablet",
            SMARTTV = "smarttv",
            WEARABLE = "wearable",
            EMBEDDED = "embedded",
            util = {
                extend: function(regexes, extensions) {
                    var margedRegexes = {};
                    for (var i in regexes) extensions[i] && extensions[i].length % 2 === 0 ? margedRegexes[i] = extensions[i].concat(regexes[i]) : margedRegexes[i] = regexes[i];
                    return margedRegexes
                },
                has: function(str1, str2) {
                    return "string" == typeof str1 && str2.toLowerCase().indexOf(str1.toLowerCase()) !== -1
                },
                lowerize: function(str) {
                    return str.toLowerCase()
                },
                major: function(version) {
                    return _typeof2(version) === STR_TYPE ? version.replace(/[^\d\.]/g, "").split(".")[0] : undefined
                },
                trim: function(str) {
                    return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
                }
            },
            mapper = {
                rgx: function(ua, arrays) {
                    for (var j, k, p, q, matches, match, i = 0; i < arrays.length && !matches;) {
                        var regex = arrays[i],
                            props = arrays[i + 1];
                        for (j = k = 0; j < regex.length && !matches;)
                            if (matches = regex[j++].exec(ua))
                                for (p = 0; p < props.length; p++) match = matches[++k], q = props[p], _typeof2(q) === OBJ_TYPE && q.length > 0 ? 2 == q.length ? _typeof2(q[1]) == FUNC_TYPE ? this[q[0]] = q[1].call(this, match) : this[q[0]] = q[1] : 3 == q.length ? _typeof2(q[1]) !== FUNC_TYPE || q[1].exec && q[1].test ? this[q[0]] = match ? match.replace(q[1], q[2]) : undefined : this[q[0]] = match ? q[1].call(this, match, q[2]) : undefined : 4 == q.length && (this[q[0]] = match ? q[3].call(this, match.replace(q[1], q[2])) : undefined) : this[q] = match ? match : undefined;
                        i += 2
                    }
                },
                str: function(_str, map) {
                    for (var i in map)
                        if (_typeof2(map[i]) === OBJ_TYPE && map[i].length > 0) {
                            for (var j = 0; j < map[i].length; j++)
                                if (util.has(map[i][j], _str)) return i === UNKNOWN ? undefined : i
                        } else if (util.has(map[i], _str)) return i === UNKNOWN ? undefined : i;
                    return _str
                }
            },
            maps = {
                browser: {
                    oldsafari: {
                        version: {
                            "1.0": "/8",
                            1.2: "/1",
                            1.3: "/3",
                            "2.0": "/412",
                            "2.0.2": "/416",
                            "2.0.3": "/417",
                            "2.0.4": "/419",
                            "?": "/"
                        }
                    }
                },
                device: {
                    amazon: {
                        model: {
                            "Fire Phone": ["SD", "KF"]
                        }
                    },
                    sprint: {
                        model: {
                            "Evo Shift 4G": "7373KT"
                        },
                        vendor: {
                            HTC: "APA",
                            Sprint: "Sprint"
                        }
                    }
                },
                os: {
                    windows: {
                        version: {
                            ME: "4.90",
                            "NT 3.11": "NT3.51",
                            "NT 4.0": "NT4.0",
                            2000: "NT 5.0",
                            XP: ["NT 5.1", "NT 5.2"],
                            Vista: "NT 6.0",
                            7: "NT 6.1",
                            8: "NT 6.2",
                            8.1: "NT 6.3",
                            10: ["NT 6.4", "NT 10.0"],
                            RT: "ARM"
                        }
                    }
                }
            },
            regexes = {
                browser: [
                    [/(opera\smini)\/([\w\.-]+)/i, /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i, /(opera).+version\/([\w\.]+)/i, /(opera)[\/\s]+([\w\.]+)/i],
                    [NAME, VERSION],
                    [/(opios)[\/\s]+([\w\.]+)/i],
                    [
                        [NAME, "Opera Mini"], VERSION
                    ],
                    [/\s(opr)\/([\w\.]+)/i],
                    [
                        [NAME, "Opera"], VERSION
                    ],
                    [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]*)/i, /(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i, /(?:ms|\()(ie)\s([\w\.]+)/i, /(rekonq)\/([\w\.]*)/i, /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark)\/([\w\.-]+)/i],
                    [NAME, VERSION],
                    [/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i],
                    [
                        [NAME, "IE"], VERSION
                    ],
                    [/(edge|edgios|edgea)\/((\d+)?[\w\.]+)/i],
                    [
                        [NAME, "Edge"], VERSION
                    ],
                    [/(yabrowser)\/([\w\.]+)/i],
                    [
                        [NAME, "Yandex"], VERSION
                    ],
                    [/(puffin)\/([\w\.]+)/i],
                    [
                        [NAME, "Puffin"], VERSION
                    ],
                    [/((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i],
                    [
                        [NAME, "UCBrowser"], VERSION
                    ],
                    [/(comodo_dragon)\/([\w\.]+)/i],
                    [
                        [NAME, /_/g, " "], VERSION
                    ],
                    [/(micromessenger)\/([\w\.]+)/i],
                    [
                        [NAME, "WeChat"], VERSION
                    ],
                    [/(qqbrowserlite)\/([\w\.]+)/i],
                    [NAME, VERSION],
                    [/(QQ)\/([\d\.]+)/i],
                    [NAME, VERSION],
                    [/m?(qqbrowser)[\/\s]?([\w\.]+)/i],
                    [NAME, VERSION],
                    [/(BIDUBrowser)[\/\s]?([\w\.]+)/i],
                    [NAME, VERSION],
                    [/(2345Explorer)[\/\s]?([\w\.]+)/i],
                    [NAME, VERSION],
                    [/(MetaSr)[\/\s]?([\w\.]+)/i],
                    [NAME],
                    [/(LBBROWSER)/i],
                    [NAME],
                    [/xiaomi\/miuibrowser\/([\w\.]+)/i],
                    [VERSION, [NAME, "MIUI Browser"]],
                    [/;fbav\/([\w\.]+);/i],
                    [VERSION, [NAME, "Facebook"]],
                    [/headlesschrome(?:\/([\w\.]+)|\s)/i],
                    [VERSION, [NAME, "Chrome Headless"]],
                    [/\swv\).+(chrome)\/([\w\.]+)/i],
                    [
                        [NAME, /(.+)/, "$1 WebView"], VERSION
                    ],
                    [/((?:oculus|samsung)browser)\/([\w\.]+)/i],
                    [
                        [NAME, /(.+(?:g|us))(.+)/, "$1 $2"], VERSION
                    ],
                    [/android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i],
                    [VERSION, [NAME, "Android Browser"]],
                    [/(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i],
                    [NAME, VERSION],
                    [/(dolfin)\/([\w\.]+)/i],
                    [
                        [NAME, "Dolphin"], VERSION
                    ],
                    [/((?:android.+)crmo|crios)\/([\w\.]+)/i],
                    [
                        [NAME, "Chrome"], VERSION
                    ],
                    [/(coast)\/([\w\.]+)/i],
                    [
                        [NAME, "Opera Coast"], VERSION
                    ],
                    [/fxios\/([\w\.-]+)/i],
                    [VERSION, [NAME, "Firefox"]],
                    [/version\/([\w\.]+).+?mobile\/\w+\s(safari)/i],
                    [VERSION, [NAME, "Mobile Safari"]],
                    [/version\/([\w\.]+).+?(mobile\s?safari|safari)/i],
                    [VERSION, NAME],
                    [/webkit.+?(gsa)\/([\w\.]+).+?(mobile\s?safari|safari)(\/[\w\.]+)/i],
                    [
                        [NAME, "GSA"], VERSION
                    ],
                    [/webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i],
                    [NAME, [VERSION, mapper.str, maps.browser.oldsafari.version]],
                    [/(konqueror)\/([\w\.]+)/i, /(webkit|khtml)\/([\w\.]+)/i],
                    [NAME, VERSION],
                    [/(navigator|netscape)\/([\w\.-]+)/i],
                    [
                        [NAME, "Netscape"], VERSION
                    ],
                    [/(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i, /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([\w\.-]+)$/i, /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i, /(links)\s\(([\w\.]+)/i, /(gobrowser)\/?([\w\.]*)/i, /(ice\s?browser)\/v?([\w\._]+)/i, /(mosaic)[\/\s]([\w\.]+)/i],
                    [NAME, VERSION]
                ],
                cpu: [
                    [/(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i],
                    [
                        [ARCHITECTURE, "amd64"]
                    ],
                    [/(ia32(?=;))/i],
                    [
                        [ARCHITECTURE, util.lowerize]
                    ],
                    [/((?:i[346]|x)86)[;\)]/i],
                    [
                        [ARCHITECTURE, "ia32"]
                    ],
                    [/windows\s(ce|mobile);\sppc;/i],
                    [
                        [ARCHITECTURE, "arm"]
                    ],
                    [/((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i],
                    [
                        [ARCHITECTURE, /ower/, "", util.lowerize]
                    ],
                    [/(sun4\w)[;\)]/i],
                    [
                        [ARCHITECTURE, "sparc"]
                    ],
                    [/((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+;))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i],
                    [
                        [ARCHITECTURE, util.lowerize]
                    ]
                ],
                device: [
                    [/\((ipad|playbook);[\w\s\);-]+(rim|apple)/i],
                    [MODEL, VENDOR, [TYPE, TABLET]],
                    [/applecoremedia\/[\w\.]+ \((ipad)/],
                    [MODEL, [VENDOR, "Apple"],
                        [TYPE, TABLET]
                    ],
                    [/(apple\s{0,1}tv)/i],
                    [
                        [MODEL, "Apple TV"],
                        [VENDOR, "Apple"]
                    ],
                    [/(archos)\s(gamepad2?)/i, /(hp).+(touchpad)/i, /(hp).+(tablet)/i, /(kindle)\/([\w\.]+)/i, /\s(nook)[\w\s]+build\/(\w+)/i, /(dell)\s(strea[kpr\s\d]*[\dko])/i],
                    [VENDOR, MODEL, [TYPE, TABLET]],
                    [/(kf[A-z]+)\sbuild\/.+silk\//i],
                    [MODEL, [VENDOR, "Amazon"],
                        [TYPE, TABLET]
                    ],
                    [/(sd|kf)[0349hijorstuw]+\sbuild\/.+silk\//i],
                    [
                        [MODEL, mapper.str, maps.device.amazon.model],
                        [VENDOR, "Amazon"],
                        [TYPE, MOBILE]
                    ],
                    [/\((ip[honed|\s\w*]+);.+(apple)/i],
                    [MODEL, VENDOR, [TYPE, MOBILE]],
                    [/\((ip[honed|\s\w*]+);/i],
                    [MODEL, [VENDOR, "Apple"],
                        [TYPE, MOBILE]
                    ],
                    [/(blackberry)[\s-]?(\w+)/i, /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]*)/i, /(hp)\s([\w\s]+\w)/i, /(asus)-?(\w+)/i],
                    [VENDOR, MODEL, [TYPE, MOBILE]],
                    [/\(bb10;\s(\w+)/i],
                    [MODEL, [VENDOR, "BlackBerry"],
                        [TYPE, MOBILE]
                    ],
                    [/android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone)/i],
                    [MODEL, [VENDOR, "Asus"],
                        [TYPE, TABLET]
                    ],
                    [/(sony)\s(tablet\s[ps])\sbuild\//i, /(sony)?(?:sgp.+)\sbuild\//i],
                    [
                        [VENDOR, "Sony"],
                        [MODEL, "Xperia Tablet"],
                        [TYPE, TABLET]
                    ],
                    [/android.+\s([c-g]\d{4}|so[-l]\w+)\sbuild\//i],
                    [MODEL, [VENDOR, "Sony"],
                        [TYPE, MOBILE]
                    ],
                    [/\s(ouya)\s/i, /(nintendo)\s([wids3u]+)/i],
                    [VENDOR, MODEL, [TYPE, CONSOLE]],
                    [/android.+;\s(shield)\sbuild/i],
                    [MODEL, [VENDOR, "Nvidia"],
                        [TYPE, CONSOLE]
                    ],
                    [/(playstation\s[34portablevi]+)/i],
                    [MODEL, [VENDOR, "Sony"],
                        [TYPE, CONSOLE]
                    ],
                    [/(sprint\s(\w+))/i],
                    [
                        [VENDOR, mapper.str, maps.device.sprint.vendor],
                        [MODEL, mapper.str, maps.device.sprint.model],
                        [TYPE, MOBILE]
                    ],
                    [/(lenovo)\s?(S(?:5000|6000)+(?:[-][\w+]))/i],
                    [VENDOR, MODEL, [TYPE, TABLET]],
                    [/(htc)[;_\s-]+([\w\s]+(?=\))|\w+)*/i, /(zte)-(\w*)/i, /(alcatel|geeksphone|lenovo|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]*)/i],
                    [VENDOR, [MODEL, /_/g, " "],
                        [TYPE, MOBILE]
                    ],
                    [/(nexus\s9)/i],
                    [MODEL, [VENDOR, "HTC"],
                        [TYPE, TABLET]
                    ],
                    [/d\/huawei([\w\s-]+)[;\)]/i, /(nexus\s6p)/i],
                    [MODEL, [VENDOR, "Huawei"],
                        [TYPE, MOBILE]
                    ],
                    [/(microsoft);\s(lumia[\s\w]+)/i],
                    [VENDOR, MODEL, [TYPE, MOBILE]],
                    [/[\s\(;](xbox(?:\sone)?)[\s\);]/i],
                    [MODEL, [VENDOR, "Microsoft"],
                        [TYPE, CONSOLE]
                    ],
                    [/(kin\.[onetw]{3})/i],
                    [
                        [MODEL, /\./g, " "],
                        [VENDOR, "Microsoft"],
                        [TYPE, MOBILE]
                    ],
                    [/\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?:?(\s4g)?)[\w\s]+build\//i, /mot[\s-]?(\w*)/i, /(XT\d{3,4}) build\//i, /(nexus\s6)/i],
                    [MODEL, [VENDOR, "Motorola"],
                        [TYPE, MOBILE]
                    ],
                    [/android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i],
                    [MODEL, [VENDOR, "Motorola"],
                        [TYPE, TABLET]
                    ],
                    [/hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i],
                    [
                        [VENDOR, util.trim],
                        [MODEL, util.trim],
                        [TYPE, SMARTTV]
                    ],
                    [/hbbtv.+maple;(\d+)/i],
                    [
                        [MODEL, /^/, "SmartTV"],
                        [VENDOR, "Samsung"],
                        [TYPE, SMARTTV]
                    ],
                    [/\(dtv[\);].+(aquos)/i],
                    [MODEL, [VENDOR, "Sharp"],
                        [TYPE, SMARTTV]
                    ],
                    [/android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i, /((SM-T\w+))/i],
                    [
                        [VENDOR, "Samsung"], MODEL, [TYPE, TABLET]
                    ],
                    [/smart-tv.+(samsung)/i],
                    [VENDOR, [TYPE, SMARTTV], MODEL],
                    [/((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i, /(sam[sung]*)[\s-]*(\w+-?[\w-]*)/i, /sec-((sgh\w+))/i],
                    [
                        [VENDOR, "Samsung"], MODEL, [TYPE, MOBILE]
                    ],
                    [/sie-(\w*)/i],
                    [MODEL, [VENDOR, "Siemens"],
                        [TYPE, MOBILE]
                    ],
                    [/(maemo|nokia).*(n900|lumia\s\d+)/i, /(nokia)[\s_-]?([\w-]*)/i],
                    [
                        [VENDOR, "Nokia"], MODEL, [TYPE, MOBILE]
                    ],
                    [/android\s3\.[\s\w;-]{10}(a\d{3})/i],
                    [MODEL, [VENDOR, "Acer"],
                        [TYPE, TABLET]
                    ],
                    [/android.+([vl]k\-?\d{3})\s+build/i],
                    [MODEL, [VENDOR, "LG"],
                        [TYPE, TABLET]
                    ],
                    [/android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i],
                    [
                        [VENDOR, "LG"], MODEL, [TYPE, TABLET]
                    ],
                    [/(lg) netcast\.tv/i],
                    [VENDOR, MODEL, [TYPE, SMARTTV]],
                    [/(nexus\s[45])/i, /lg[e;\s\/-]+(\w*)/i, /android.+lg(\-?[\d\w]+)\s+build/i],
                    [MODEL, [VENDOR, "LG"],
                        [TYPE, MOBILE]
                    ],
                    [/android.+(ideatab[a-z0-9\-\s]+)/i],
                    [MODEL, [VENDOR, "Lenovo"],
                        [TYPE, TABLET]
                    ],
                    [/linux;.+((jolla));/i],
                    [VENDOR, MODEL, [TYPE, MOBILE]],
                    [/((pebble))app\/[\d\.]+\s/i],
                    [VENDOR, MODEL, [TYPE, WEARABLE]],
                    [/android.+;\s(oppo)\s?([\w\s]+)\sbuild/i],
                    [VENDOR, MODEL, [TYPE, MOBILE]],
                    [/crkey/i],
                    [
                        [MODEL, "Chromecast"],
                        [VENDOR, "Google"]
                    ],
                    [/android.+;\s(glass)\s\d/i],
                    [MODEL, [VENDOR, "Google"],
                        [TYPE, WEARABLE]
                    ],
                    [/android.+;\s(pixel c)\s/i],
                    [MODEL, [VENDOR, "Google"],
                        [TYPE, TABLET]
                    ],
                    [/android.+;\s(pixel xl|pixel)\s/i],
                    [MODEL, [VENDOR, "Google"],
                        [TYPE, MOBILE]
                    ],
                    [/android.+;\s(\w+)\s+build\/hm\1/i, /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i, /android.+(mi[\s\-_]*(?:one|one[\s_]plus|note lte)?[\s_]*(?:\d?\w?)[\s_]*(?:plus)?)\s+build/i, /android.+(redmi[\s\-_]*(?:note)?(?:[\s_]*[\w\s]+))\s+build/i],
                    [
                        [MODEL, /_/g, " "],
                        [VENDOR, "Xiaomi"],
                        [TYPE, MOBILE]
                    ],
                    [/android.+(mi[\s\-_]*(?:pad)(?:[\s_]*[\w\s]+))\s+build/i],
                    [
                        [MODEL, /_/g, " "],
                        [VENDOR, "Xiaomi"],
                        [TYPE, TABLET]
                    ],
                    [/android.+;\s(m[1-5]\snote)\sbuild/i],
                    [MODEL, [VENDOR, "Meizu"],
                        [TYPE, TABLET]
                    ],
                    [/android.+a000(1)\s+build/i, /android.+oneplus\s(a\d{4})\s+build/i],
                    [MODEL, [VENDOR, "OnePlus"],
                        [TYPE, MOBILE]
                    ],
                    [/android.+[;\/]\s*(RCT[\d\w]+)\s+build/i],
                    [MODEL, [VENDOR, "RCA"],
                        [TYPE, TABLET]
                    ],
                    [/android.+[;\/\s]+(Venue[\d\s]{2,7})\s+build/i],
                    [MODEL, [VENDOR, "Dell"],
                        [TYPE, TABLET]
                    ],
                    [/android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i],
                    [MODEL, [VENDOR, "Verizon"],
                        [TYPE, TABLET]
                    ],
                    [/android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(V?.*)\s+build/i],
                    [
                        [VENDOR, "Barnes & Noble"], MODEL, [TYPE, TABLET]
                    ],
                    [/android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i],
                    [MODEL, [VENDOR, "NuVision"],
                        [TYPE, TABLET]
                    ],
                    [/android.+;\s(k88)\sbuild/i],
                    [MODEL, [VENDOR, "ZTE"],
                        [TYPE, TABLET]
                    ],
                    [/android.+[;\/]\s*(gen\d{3})\s+build.*49h/i],
                    [MODEL, [VENDOR, "Swiss"],
                        [TYPE, MOBILE]
                    ],
                    [/android.+[;\/]\s*(zur\d{3})\s+build/i],
                    [MODEL, [VENDOR, "Swiss"],
                        [TYPE, TABLET]
                    ],
                    [/android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i],
                    [MODEL, [VENDOR, "Zeki"],
                        [TYPE, TABLET]
                    ],
                    [/(android).+[;\/]\s+([YR]\d{2})\s+build/i, /android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(\w{5})\sbuild/i],
                    [
                        [VENDOR, "Dragon Touch"], MODEL, [TYPE, TABLET]
                    ],
                    [/android.+[;\/]\s*(NS-?\w{0,9})\sbuild/i],
                    [MODEL, [VENDOR, "Insignia"],
                        [TYPE, TABLET]
                    ],
                    [/android.+[;\/]\s*((NX|Next)-?\w{0,9})\s+build/i],
                    [MODEL, [VENDOR, "NextBook"],
                        [TYPE, TABLET]
                    ],
                    [/android.+[;\/]\s*(Xtreme\_)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i],
                    [
                        [VENDOR, "Voice"], MODEL, [TYPE, MOBILE]
                    ],
                    [/android.+[;\/]\s*(LVTEL\-)?(V1[12])\s+build/i],
                    [
                        [VENDOR, "LvTel"], MODEL, [TYPE, MOBILE]
                    ],
                    [/android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i],
                    [MODEL, [VENDOR, "Envizen"],
                        [TYPE, TABLET]
                    ],
                    [/android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(\w{1,9})\s+build/i],
                    [VENDOR, MODEL, [TYPE, TABLET]],
                    [/android.+[;\/]\s*(Trio[\s\-]*.*)\s+build/i],
                    [MODEL, [VENDOR, "MachSpeed"],
                        [TYPE, TABLET]
                    ],
                    [/android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i],
                    [VENDOR, MODEL, [TYPE, TABLET]],
                    [/android.+[;\/]\s*TU_(1491)\s+build/i],
                    [MODEL, [VENDOR, "Rotor"],
                        [TYPE, TABLET]
                    ],
                    [/android.+(KS(.+))\s+build/i],
                    [MODEL, [VENDOR, "Amazon"],
                        [TYPE, TABLET]
                    ],
                    [/android.+(Gigaset)[\s\-]+(Q\w{1,9})\s+build/i],
                    [VENDOR, MODEL, [TYPE, TABLET]],
                    [/\s(tablet|tab)[;\/]/i, /\s(mobile)(?:[;\/]|\ssafari)/i],
                    [
                        [TYPE, util.lowerize], VENDOR, MODEL
                    ],
                    [/(android[\w\.\s\-]{0,9});.+build/i],
                    [MODEL, [VENDOR, "Generic"]]
                ],
                engine: [
                    [/windows.+\sedge\/([\w\.]+)/i],
                    [VERSION, [NAME, "EdgeHTML"]],
                    [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i, /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i, /(icab)[\/\s]([23]\.[\d\.]+)/i],
                    [NAME, VERSION],
                    [/rv\:([\w\.]{1,9}).+(gecko)/i],
                    [VERSION, NAME]
                ],
                os: [
                    [/microsoft\s(windows)\s(vista|xp)/i],
                    [NAME, VERSION],
                    [/(windows)\snt\s6\.2;\s(arm)/i, /(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s\w]*)/i, /(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i],
                    [NAME, [VERSION, mapper.str, maps.os.windows.version]],
                    [/(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i],
                    [
                        [NAME, "Windows"],
                        [VERSION, mapper.str, maps.os.windows.version]
                    ],
                    [/\((bb)(10);/i],
                    [
                        [NAME, "BlackBerry"], VERSION
                    ],
                    [/(blackberry)\w*\/?([\w\.]*)/i, /(tizen)[\/\s]([\w\.]+)/i, /(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|contiki)[\/\s-]?([\w\.]*)/i, /linux;.+(sailfish);/i],
                    [NAME, VERSION],
                    [/(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]*)/i],
                    [
                        [NAME, "Symbian"], VERSION
                    ],
                    [/\((series40);/i],
                    [NAME],
                    [/mozilla.+\(mobile;.+gecko.+firefox/i],
                    [
                        [NAME, "Firefox OS"], VERSION
                    ],
                    [/(nintendo|playstation)\s([wids34portablevu]+)/i, /(mint)[\/\s\(]?(\w*)/i, /(mageia|vectorlinux)[;\s]/i, /(joli|[kxln]?ubuntu|debian|suse|opensuse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]*)/i, /(hurd|linux)\s?([\w\.]*)/i, /(gnu)\s?([\w\.]*)/i],
                    [NAME, VERSION],
                    [/(cros)\s[\w]+\s([\w\.]+\w)/i],
                    [
                        [NAME, "Chromium OS"], VERSION
                    ],
                    [/(sunos)\s?([\w\.\d]*)/i],
                    [
                        [NAME, "Solaris"], VERSION
                    ],
                    [/\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]*)/i],
                    [NAME, VERSION],
                    [/(haiku)\s(\w+)/i],
                    [NAME, VERSION],
                    [/cfnetwork\/.+darwin/i, /ip[honead]{2,4}(?:.*os\s([\w]+)\slike\smac|;\sopera)/i],
                    [
                        [VERSION, /_/g, "."],
                        [NAME, "iOS"]
                    ],
                    [/(mac\sos\sx)\s?([\w\s\.]*)/i, /(macintosh|mac(?=_powerpc)\s)/i],
                    [
                        [NAME, "Mac OS"],
                        [VERSION, /_/g, "."]
                    ],
                    [/((?:open)?solaris)[\/\s-]?([\w\.]*)/i, /(aix)\s((\d)(?=\.|\)|\s)[\w\.])*/i, /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms)/i, /(unix)\s?([\w\.]*)/i],
                    [NAME, VERSION]
                ]
            },
            UAParser = function UAParser(uastring, extensions) {
                if ("object" === _typeof2(uastring) && (extensions = uastring, uastring = undefined), !(this instanceof UAParser)) return new UAParser(uastring, extensions).getResult();
                var ua = uastring || (window && window.navigator && window.navigator.userAgent ? window.navigator.userAgent : EMPTY),
                    rgxmap = extensions ? util.extend(regexes, extensions) : regexes;
                return this.getBrowser = function() {
                    var browser = {
                        name: undefined,
                        version: undefined
                    };
                    return mapper.rgx.call(browser, ua, rgxmap.browser), browser.major = util.major(browser.version), browser
                }, this.getCPU = function() {
                    var cpu = {
                        architecture: undefined
                    };
                    return mapper.rgx.call(cpu, ua, rgxmap.cpu), cpu
                }, this.getDevice = function() {
                    var device = {
                        vendor: undefined,
                        model: undefined,
                        type: undefined
                    };
                    return mapper.rgx.call(device, ua, rgxmap.device), device
                }, this.getEngine = function() {
                    var engine = {
                        name: undefined,
                        version: undefined
                    };
                    return mapper.rgx.call(engine, ua, rgxmap.engine), engine
                }, this.getOS = function() {
                    var os = {
                        name: undefined,
                        version: undefined
                    };
                    return mapper.rgx.call(os, ua, rgxmap.os), os
                }, this.getResult = function() {
                    return {
                        ua: this.getUA(),
                        browser: this.getBrowser(),
                        engine: this.getEngine(),
                        os: this.getOS(),
                        device: this.getDevice(),
                        cpu: this.getCPU()
                    }
                }, this.getUA = function() {
                    return ua
                }, this.setUA = function(uastring) {
                    return ua = uastring, this
                }, this
            };
        UAParser.VERSION = LIBVERSION, UAParser.BROWSER = {
            NAME: NAME,
            MAJOR: MAJOR,
            VERSION: VERSION
        }, UAParser.CPU = {
            ARCHITECTURE: ARCHITECTURE
        }, UAParser.DEVICE = {
            MODEL: MODEL,
            VENDOR: VENDOR,
            TYPE: TYPE,
            CONSOLE: CONSOLE,
            MOBILE: MOBILE,
            SMARTTV: SMARTTV,
            TABLET: TABLET,
            WEARABLE: WEARABLE,
            EMBEDDED: EMBEDDED
        }, UAParser.ENGINE = {
            NAME: NAME,
            VERSION: VERSION
        }, UAParser.OS = {
            NAME: NAME,
            VERSION: VERSION
        }, ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) !== UNDEF_TYPE ? (("undefined" == typeof module ? "undefined" : _typeof2(module)) !== UNDEF_TYPE && module.exports && (exports = module.exports = UAParser), exports.UAParser = UAParser) : ("undefined" == typeof define ? "undefined" : _typeof2(define)) === FUNC_TYPE && define.amd ? define(function() {
            return UAParser
        }) : window && (window.UAParser = UAParser);
        var $ = window && (window.jQuery || window.Zepto);
        if (_typeof2($) !== UNDEF_TYPE) {
            var parser = new UAParser;
            $.ua = parser.getResult(), $.ua.get = function() {
                return parser.getUA()
            }, $.ua.set = function(uastring) {
                parser.setUA(uastring);
                var result = parser.getResult();
                for (var prop in result) $.ua[prop] = result[prop]
            }
        }
    }("object" === ("undefined" == typeof window ? "undefined" : _typeof2(window)) ? window : this),
    function() {
        "use strict";
        angular.module("cfp.hotkeys", []).provider("hotkeys", ["$injector", function($injector) {
            this.includeCheatSheet = !0, this.useNgRoute = $injector.has("ngViewDirective"), this.templateTitle = "Keyboard Shortcuts:", this.templateHeader = null, this.templateFooter = null, this.template = '<div class="cfp-hotkeys-container fade" ng-class="{in: helpVisible}" style="display: none;"><div class="cfp-hotkeys"><h4 class="cfp-hotkeys-title" ng-if="!header">{{ title }}</h4><div ng-bind-html="header" ng-if="header"></div><table><tbody><tr ng-repeat="hotkey in hotkeys | filter:{ description: \'!$$undefined$$\' }"><td class="cfp-hotkeys-keys"><span ng-repeat="key in hotkey.format() track by $index" class="cfp-hotkeys-key">{{ key }}</span></td><td class="cfp-hotkeys-text">{{ hotkey.description }}</td></tr></tbody></table><div ng-bind-html="footer" ng-if="footer"></div><div class="cfp-hotkeys-close" ng-click="toggleCheatSheet()">&#215;</div></div></div>', this.cheatSheetHotkey = "?", this.cheatSheetDescription = "Show / hide this help menu", this.$get = ["$rootElement", "$rootScope", "$compile", "$window", "$document", function($rootElement, $rootScope, $compile, $window, $document) {
                function pause() {
                    mouseTrapEnabled = !1
                }

                function unpause() {
                    mouseTrapEnabled = !0
                }

                function symbolize(combo) {
                    var map = {
                        command: "",
                        shift: "",
                        left: "",
                        right: "",
                        up: "",
                        down: "",
                        return: "",
                        backspace: ""
                    };
                    combo = combo.split("+");
                    for (var i = 0; i < combo.length; i++) "mod" === combo[i] && ($window.navigator && $window.navigator.platform.indexOf("Mac") >= 0 ? combo[i] = "command" : combo[i] = "ctrl"), combo[i] = map[combo[i]] || combo[i];
                    return combo.join(" + ")
                }

                function Hotkey(combo, description, callback, action, allowIn, persistent) {
                    this.combo = combo instanceof Array ? combo : [combo], this.description = description, this.callback = callback, this.action = action, this.allowIn = allowIn, this.persistent = persistent, this._formated = null
                }

                function purgeHotkeys() {
                    for (var i = scope.hotkeys.length; i--;) {
                        var hotkey = scope.hotkeys[i];
                        hotkey && !hotkey.persistent && _del(hotkey)
                    }
                }

                function toggleCheatSheet() {
                    scope.helpVisible = !scope.helpVisible, scope.helpVisible ? (previousEsc = _get("esc"), _del("esc"), _add("esc", previousEsc.description, toggleCheatSheet, null, ["INPUT", "SELECT", "TEXTAREA"])) : (_del("esc"), previousEsc !== !1 && _add(previousEsc))
                }

                function _add(combo, description, callback, action, allowIn, persistent) {
                    var _callback, preventIn = ["INPUT", "SELECT", "TEXTAREA"],
                        objType = Object.prototype.toString.call(combo);
                    if ("[object Object]" === objType && (description = combo.description, callback = combo.callback, action = combo.action, persistent = combo.persistent, allowIn = combo.allowIn, combo = combo.combo), _del(combo), description instanceof Function ? (action = callback, callback = description, description = "$$undefined$$") : angular.isUndefined(description) && (description = "$$undefined$$"), void 0 === persistent && (persistent = !0), "function" == typeof callback) {
                        _callback = callback, allowIn instanceof Array || (allowIn = []);
                        for (var index, i = 0; i < allowIn.length; i++) allowIn[i] = allowIn[i].toUpperCase(), index = preventIn.indexOf(allowIn[i]), index !== -1 && preventIn.splice(index, 1);
                        callback = function(event) {
                            var shouldExecute = !0;
                            if (event) {
                                var target = event.target || event.srcElement,
                                    nodeName = target.nodeName.toUpperCase();
                                if ((" " + target.className + " ").indexOf(" mousetrap ") > -1) shouldExecute = !0;
                                else
                                    for (var i = 0; i < preventIn.length; i++)
                                        if (preventIn[i] === nodeName) {
                                            shouldExecute = !1;
                                            break
                                        }
                            }
                            shouldExecute && wrapApply(_callback.apply(this, arguments))
                        }
                    }
                    "string" == typeof action ? Mousetrap.bind(combo, wrapApply(callback), action) : Mousetrap.bind(combo, wrapApply(callback));
                    var hotkey = new Hotkey(combo, description, callback, action, allowIn, persistent);
                    return scope.hotkeys.push(hotkey), hotkey
                }

                function _del(hotkey) {
                    var combo = hotkey instanceof Hotkey ? hotkey.combo : hotkey;
                    if (Mousetrap.unbind(combo), angular.isArray(combo)) {
                        for (var retStatus = !0, i = combo.length; i--;) retStatus = _del(combo[i]) && retStatus;
                        return retStatus
                    }
                    var index = scope.hotkeys.indexOf(_get(combo));
                    return index > -1 && (scope.hotkeys[index].combo.length > 1 ? scope.hotkeys[index].combo.splice(scope.hotkeys[index].combo.indexOf(combo), 1) : (angular.forEach(boundScopes, function(boundScope) {
                        var scopeIndex = boundScope.indexOf(scope.hotkeys[index]);
                        scopeIndex !== -1 && boundScope.splice(scopeIndex, 1)
                    }), scope.hotkeys.splice(index, 1)), !0)
                }

                function _get(combo) {
                    if (!combo) return scope.hotkeys;
                    for (var hotkey, i = 0; i < scope.hotkeys.length; i++)
                        if (hotkey = scope.hotkeys[i], hotkey.combo.indexOf(combo) > -1) return hotkey;
                    return !1
                }

                function bindTo(scope) {
                    return scope.$id in boundScopes || (boundScopes[scope.$id] = [], scope.$on("$destroy", function() {
                        for (var i = boundScopes[scope.$id].length; i--;) _del(boundScopes[scope.$id].pop())
                    })), {
                        add: function(args) {
                            var hotkey;
                            return hotkey = arguments.length > 1 ? _add.apply(this, arguments) : _add(args), boundScopes[scope.$id].push(hotkey), this
                        }
                    }
                }

                function wrapApply(callback) {
                    return function(event, combo) {
                        if (callback instanceof Array) {
                            var funcString = callback[0],
                                route = callback[1];
                            callback = function(event) {
                                route.scope.$eval(funcString)
                            }
                        }
                        $rootScope.$apply(function() {
                            callback(event, _get(combo))
                        })
                    }
                }
                var mouseTrapEnabled = !0;
                Mousetrap.prototype.stopCallback = function(event, element) {
                    return !mouseTrapEnabled || !((" " + element.className + " ").indexOf(" mousetrap ") > -1) && (element.contentEditable && "true" == element.contentEditable)
                }, Hotkey.prototype.format = function() {
                    if (null === this._formated) {
                        for (var combo = this.combo[0], sequence = combo.split(/[\s]/), i = 0; i < sequence.length; i++) sequence[i] = symbolize(sequence[i]);
                        this._formated = sequence
                    }
                    return this._formated
                };
                var scope = $rootScope.$new();
                scope.hotkeys = [], scope.helpVisible = !1, scope.title = this.templateTitle, scope.header = this.templateHeader, scope.footer = this.templateFooter, scope.toggleCheatSheet = toggleCheatSheet;
                var boundScopes = {};
                if (this.useNgRoute && $rootScope.$on("$routeChangeSuccess", function(event, route) {
                        purgeHotkeys(), route && route.hotkeys && angular.forEach(route.hotkeys, function(hotkey) {
                            var callback = hotkey[2];
                            ("string" == typeof callback || callback instanceof String) && (hotkey[2] = [callback, route]), hotkey[5] = !1, _add.apply(this, hotkey)
                        })
                    }), this.includeCheatSheet) {
                    var document = $document[0],
                        element = $rootElement[0],
                        helpMenu = angular.element(this.template);
                    _add(this.cheatSheetHotkey, this.cheatSheetDescription, toggleCheatSheet), element !== document && element !== document.documentElement || (element = document.body), angular.element(element).append($compile(helpMenu)(scope))
                }
                var previousEsc = !1,
                    publicApi = {
                        add: _add,
                        del: _del,
                        get: _get,
                        bindTo: bindTo,
                        template: this.template,
                        toggleCheatSheet: toggleCheatSheet,
                        includeCheatSheet: this.includeCheatSheet,
                        cheatSheetHotkey: this.cheatSheetHotkey,
                        cheatSheetDescription: this.cheatSheetDescription,
                        useNgRoute: this.useNgRoute,
                        purgeHotkeys: purgeHotkeys,
                        templateTitle: this.templateTitle,
                        pause: pause,
                        unpause: unpause
                    };
                return publicApi
            }]
        }]).directive("hotkey", ["hotkeys", function(hotkeys) {
            return {
                restrict: "A",
                link: function(scope, el, attrs) {
                    var allowIn, keys = [];
                    angular.forEach(scope.$eval(attrs.hotkey), function(func, hotkey) {
                        allowIn = "string" == typeof attrs.hotkeyAllowIn ? attrs.hotkeyAllowIn.split(/[\s,]+/) : [], keys.push(hotkey), hotkeys.add({
                            combo: hotkey,
                            description: attrs.hotkeyDescription,
                            callback: func,
                            action: attrs.hotkeyAction,
                            allowIn: allowIn
                        })
                    }), el.bind("$destroy", function() {
                        angular.forEach(keys, hotkeys.del)
                    })
                }
            }
        }]).run(["hotkeys", function(hotkeys) {}])
    }(),
    function(window, document, undefined) {
        function _addEvent(object, type, callback) {
            return object.addEventListener ? void object.addEventListener(type, callback, !1) : void object.attachEvent("on" + type, callback)
        }

        function _characterFromEvent(e) {
            if ("keypress" == e.type) {
                var character = String.fromCharCode(e.which);
                return e.shiftKey || (character = character.toLowerCase()), character
            }
            return _MAP[e.which] ? _MAP[e.which] : _KEYCODE_MAP[e.which] ? _KEYCODE_MAP[e.which] : String.fromCharCode(e.which).toLowerCase()
        }

        function _modifiersMatch(modifiers1, modifiers2) {
            return modifiers1.sort().join(",") === modifiers2.sort().join(",")
        }

        function _eventModifiers(e) {
            var modifiers = [];
            return e.shiftKey && modifiers.push("shift"), e.altKey && modifiers.push("alt"), e.ctrlKey && modifiers.push("ctrl"), e.metaKey && modifiers.push("meta"), modifiers
        }

        function _preventDefault(e) {
            return e.preventDefault ? void e.preventDefault() : void(e.returnValue = !1)
        }

        function _stopPropagation(e) {
            return e.stopPropagation ? void e.stopPropagation() : void(e.cancelBubble = !0)
        }

        function _isModifier(key) {
            return "shift" == key || "ctrl" == key || "alt" == key || "meta" == key
        }

        function _getReverseMap() {
            if (!_REVERSE_MAP) {
                _REVERSE_MAP = {};
                for (var key in _MAP) key > 95 && key < 112 || _MAP.hasOwnProperty(key) && (_REVERSE_MAP[_MAP[key]] = key)
            }
            return _REVERSE_MAP
        }

        function _pickBestAction(key, modifiers, action) {
            return action || (action = _getReverseMap()[key] ? "keydown" : "keypress"), "keypress" == action && modifiers.length && (action = "keydown"), action
        }

        function _keysFromString(combination) {
            return "+" === combination ? ["+"] : (combination = combination.replace(/\+{2}/g, "+plus"), combination.split("+"))
        }

        function _getKeyInfo(combination, action) {
            var keys, key, i, modifiers = [];
            for (keys = _keysFromString(combination), i = 0; i < keys.length; ++i) key = keys[i], _SPECIAL_ALIASES[key] && (key = _SPECIAL_ALIASES[key]), action && "keypress" != action && _SHIFT_MAP[key] && (key = _SHIFT_MAP[key], modifiers.push("shift")), _isModifier(key) && modifiers.push(key);
            return action = _pickBestAction(key, modifiers, action), {
                key: key,
                modifiers: modifiers,
                action: action
            }
        }

        function _belongsTo(element, ancestor) {
            return element !== document && (element === ancestor || _belongsTo(element.parentNode, ancestor))
        }

        function Mousetrap(targetElement) {
            function _resetSequences(doNotReset) {
                doNotReset = doNotReset || {};
                var key, activeSequences = !1;
                for (key in _sequenceLevels) doNotReset[key] ? activeSequences = !0 : _sequenceLevels[key] = 0;
                activeSequences || (_nextExpectedAction = !1)
            }

            function _getMatches(character, modifiers, e, sequenceName, combination, level) {
                var i, callback, matches = [],
                    action = e.type;
                if (!self._callbacks[character]) return [];
                for ("keyup" == action && _isModifier(character) && (modifiers = [character]), i = 0; i < self._callbacks[character].length; ++i)
                    if (callback = self._callbacks[character][i], (sequenceName || !callback.seq || _sequenceLevels[callback.seq] == callback.level) && action == callback.action && ("keypress" == action && !e.metaKey && !e.ctrlKey || _modifiersMatch(modifiers, callback.modifiers))) {
                        var deleteCombo = !sequenceName && callback.combo == combination,
                            deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
                        (deleteCombo || deleteSequence) && self._callbacks[character].splice(i, 1), matches.push(callback)
                    } return matches
            }

            function _fireCallback(callback, e, combo, sequence) {
                self.stopCallback(e, e.target || e.srcElement, combo, sequence) || callback(e, combo) === !1 && (_preventDefault(e), _stopPropagation(e))
            }

            function _handleKeyEvent(e) {
                "number" != typeof e.which && (e.which = e.keyCode);
                var character = _characterFromEvent(e);
                if (character) return "keyup" == e.type && _ignoreNextKeyup === character ? void(_ignoreNextKeyup = !1) : void self.handleKey(character, _eventModifiers(e), e)
            }

            function _resetSequenceTimer() {
                clearTimeout(_resetTimer), _resetTimer = setTimeout(_resetSequences, 1e3)
            }

            function _bindSequence(combo, keys, callback, action) {
                function _increaseSequence(nextAction) {
                    return function() {
                        _nextExpectedAction = nextAction, ++_sequenceLevels[combo], _resetSequenceTimer()
                    }
                }

                function _callbackAndReset(e) {
                    _fireCallback(callback, e, combo), "keyup" !== action && (_ignoreNextKeyup = _characterFromEvent(e)), setTimeout(_resetSequences, 10)
                }
                _sequenceLevels[combo] = 0;
                for (var i = 0; i < keys.length; ++i) {
                    var isFinal = i + 1 === keys.length,
                        wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);
                    _bindSingle(keys[i], wrappedCallback, action, combo, i)
                }
            }

            function _bindSingle(combination, callback, action, sequenceName, level) {
                self._directMap[combination + ":" + action] = callback, combination = combination.replace(/\s+/g, " ");
                var info, sequence = combination.split(" ");
                return sequence.length > 1 ? void _bindSequence(combination, sequence, callback, action) : (info = _getKeyInfo(combination, action), self._callbacks[info.key] = self._callbacks[info.key] || [], _getMatches(info.key, info.modifiers, {
                    type: info.action
                }, sequenceName, combination, level), void self._callbacks[info.key][sequenceName ? "unshift" : "push"]({
                    callback: callback,
                    modifiers: info.modifiers,
                    action: info.action,
                    seq: sequenceName,
                    level: level,
                    combo: combination
                }))
            }
            var self = this;
            if (targetElement = targetElement || document, !(self instanceof Mousetrap)) return new Mousetrap(targetElement);
            self.target = targetElement, self._callbacks = {}, self._directMap = {};
            var _resetTimer, _sequenceLevels = {},
                _ignoreNextKeyup = !1,
                _ignoreNextKeypress = !1,
                _nextExpectedAction = !1;
            self._handleKey = function(character, modifiers, e) {
                var i, callbacks = _getMatches(character, modifiers, e),
                    doNotReset = {},
                    maxLevel = 0,
                    processedSequenceCallback = !1;
                for (i = 0; i < callbacks.length; ++i) callbacks[i].seq && (maxLevel = Math.max(maxLevel, callbacks[i].level));
                for (i = 0; i < callbacks.length; ++i)
                    if (callbacks[i].seq) {
                        if (callbacks[i].level != maxLevel) continue;
                        processedSequenceCallback = !0, doNotReset[callbacks[i].seq] = 1, _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq)
                    } else processedSequenceCallback || _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
                var ignoreThisKeypress = "keypress" == e.type && _ignoreNextKeypress;
                e.type != _nextExpectedAction || _isModifier(character) || ignoreThisKeypress || _resetSequences(doNotReset), _ignoreNextKeypress = processedSequenceCallback && "keydown" == e.type
            }, self._bindMultiple = function(combinations, callback, action) {
                for (var i = 0; i < combinations.length; ++i) _bindSingle(combinations[i], callback, action)
            }, _addEvent(targetElement, "keypress", _handleKeyEvent), _addEvent(targetElement, "keydown", _handleKeyEvent), _addEvent(targetElement, "keyup", _handleKeyEvent)
        }
        for (var _REVERSE_MAP, _MAP = {
                8: "backspace",
                9: "tab",
                13: "enter",
                16: "shift",
                17: "ctrl",
                18: "alt",
                20: "capslock",
                27: "esc",
                32: "space",
                33: "pageup",
                34: "pagedown",
                35: "end",
                36: "home",
                37: "left",
                38: "up",
                39: "right",
                40: "down",
                45: "ins",
                46: "del",
                91: "meta",
                93: "meta",
                224: "meta"
            }, _KEYCODE_MAP = {
                106: "*",
                107: "+",
                109: "-",
                110: ".",
                111: "/",
                186: ";",
                187: "=",
                188: ",",
                189: "-",
                190: ".",
                191: "/",
                192: "`",
                219: "[",
                220: "\\",
                221: "]",
                222: "'"
            }, _SHIFT_MAP = {
                "~": "`",
                "!": "1",
                "@": "2",
                "#": "3",
                $: "4",
                "%": "5",
                "^": "6",
                "&": "7",
                "*": "8",
                "(": "9",
                ")": "0",
                _: "-",
                "+": "=",
                ":": ";",
                '"': "'",
                "<": ",",
                ">": ".",
                "?": "/",
                "|": "\\"
            }, _SPECIAL_ALIASES = {
                option: "alt",
                command: "meta",
                return: "enter",
                escape: "esc",
                plus: "+",
                mod: /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? "meta" : "ctrl"
            }, i = 1; i < 20; ++i) _MAP[111 + i] = "f" + i;
        for (i = 0; i <= 9; ++i) _MAP[i + 96] = i;
        Mousetrap.prototype.bind = function(keys, callback, action) {
            var self = this;
            return keys = keys instanceof Array ? keys : [keys], self._bindMultiple.call(self, keys, callback, action), self
        }, Mousetrap.prototype.unbind = function(keys, action) {
            var self = this;
            return self.bind.call(self, keys, function() {}, action)
        }, Mousetrap.prototype.trigger = function(keys, action) {
            var self = this;
            return self._directMap[keys + ":" + action] && self._directMap[keys + ":" + action]({}, keys), self
        }, Mousetrap.prototype.reset = function() {
            var self = this;
            return self._callbacks = {}, self._directMap = {}, self
        }, Mousetrap.prototype.stopCallback = function(e, element) {
            var self = this;
            return !((" " + element.className + " ").indexOf(" mousetrap ") > -1) && (!_belongsTo(element, self.target) && ("INPUT" == element.tagName || "SELECT" == element.tagName || "TEXTAREA" == element.tagName || element.isContentEditable))
        }, Mousetrap.prototype.handleKey = function() {
            var self = this;
            return self._handleKey.apply(self, arguments)
        }, Mousetrap.init = function() {
            var documentMousetrap = Mousetrap(document);
            for (var method in documentMousetrap) "_" !== method.charAt(0) && (Mousetrap[method] = function(method) {
                return function() {
                    return documentMousetrap[method].apply(documentMousetrap, arguments)
                }
            }(method))
        }, Mousetrap.init(), window.Mousetrap = Mousetrap, "undefined" != typeof module && module.exports && (module.exports = Mousetrap), "function" == typeof define && define.amd && define(function() {
            return Mousetrap
        })
    }(window, document),
    function(window, document, undefined) {
        function _addEvent(object, type, callback) {
            return object.addEventListener ? void object.addEventListener(type, callback, !1) : void object.attachEvent("on" + type, callback)
        }

        function _characterFromEvent(e) {
            if ("keypress" == e.type) {
                var character = String.fromCharCode(e.which);
                return e.shiftKey || (character = character.toLowerCase()), character
            }
            return _MAP[e.which] ? _MAP[e.which] : _KEYCODE_MAP[e.which] ? _KEYCODE_MAP[e.which] : String.fromCharCode(e.which).toLowerCase()
        }

        function _modifiersMatch(modifiers1, modifiers2) {
            return modifiers1.sort().join(",") === modifiers2.sort().join(",")
        }

        function _eventModifiers(e) {
            var modifiers = [];
            return e.shiftKey && modifiers.push("shift"), e.altKey && modifiers.push("alt"), e.ctrlKey && modifiers.push("ctrl"), e.metaKey && modifiers.push("meta"), modifiers
        }

        function _preventDefault(e) {
            return e.preventDefault ? void e.preventDefault() : void(e.returnValue = !1)
        }

        function _stopPropagation(e) {
            return e.stopPropagation ? void e.stopPropagation() : void(e.cancelBubble = !0)
        }

        function _isModifier(key) {
            return "shift" == key || "ctrl" == key || "alt" == key || "meta" == key
        }

        function _getReverseMap() {
            if (!_REVERSE_MAP) {
                _REVERSE_MAP = {};
                for (var key in _MAP) key > 95 && key < 112 || _MAP.hasOwnProperty(key) && (_REVERSE_MAP[_MAP[key]] = key)
            }
            return _REVERSE_MAP
        }

        function _pickBestAction(key, modifiers, action) {
            return action || (action = _getReverseMap()[key] ? "keydown" : "keypress"), "keypress" == action && modifiers.length && (action = "keydown"), action
        }

        function _keysFromString(combination) {
            return "+" === combination ? ["+"] : (combination = combination.replace(/\+{2}/g, "+plus"), combination.split("+"))
        }

        function _getKeyInfo(combination, action) {
            var keys, key, i, modifiers = [];
            for (keys = _keysFromString(combination), i = 0; i < keys.length; ++i) key = keys[i], _SPECIAL_ALIASES[key] && (key = _SPECIAL_ALIASES[key]), action && "keypress" != action && _SHIFT_MAP[key] && (key = _SHIFT_MAP[key], modifiers.push("shift")), _isModifier(key) && modifiers.push(key);
            return action = _pickBestAction(key, modifiers, action), {
                key: key,
                modifiers: modifiers,
                action: action
            }
        }

        function _belongsTo(element, ancestor) {
            return null !== element && element !== document && (element === ancestor || _belongsTo(element.parentNode, ancestor))
        }

        function Mousetrap(targetElement) {
            function _resetSequences(doNotReset) {
                doNotReset = doNotReset || {};
                var key, activeSequences = !1;
                for (key in _sequenceLevels) doNotReset[key] ? activeSequences = !0 : _sequenceLevels[key] = 0;
                activeSequences || (_nextExpectedAction = !1)
            }

            function _getMatches(character, modifiers, e, sequenceName, combination, level) {
                var i, callback, matches = [],
                    action = e.type;
                if (!self._callbacks[character]) return [];
                for ("keyup" == action && _isModifier(character) && (modifiers = [character]), i = 0; i < self._callbacks[character].length; ++i)
                    if (callback = self._callbacks[character][i], (sequenceName || !callback.seq || _sequenceLevels[callback.seq] == callback.level) && action == callback.action && ("keypress" == action && !e.metaKey && !e.ctrlKey || _modifiersMatch(modifiers, callback.modifiers))) {
                        var deleteCombo = !sequenceName && callback.combo == combination,
                            deleteSequence = sequenceName && callback.seq == sequenceName && callback.level == level;
                        (deleteCombo || deleteSequence) && self._callbacks[character].splice(i, 1), matches.push(callback)
                    } return matches
            }

            function _fireCallback(callback, e, combo, sequence) {
                self.stopCallback(e, e.target || e.srcElement, combo, sequence) || callback(e, combo) === !1 && (_preventDefault(e), _stopPropagation(e))
            }

            function _handleKeyEvent(e) {
                "number" != typeof e.which && (e.which = e.keyCode);
                var character = _characterFromEvent(e);
                if (character) return "keyup" == e.type && _ignoreNextKeyup === character ? void(_ignoreNextKeyup = !1) : void self.handleKey(character, _eventModifiers(e), e)
            }

            function _resetSequenceTimer() {
                clearTimeout(_resetTimer), _resetTimer = setTimeout(_resetSequences, 1e3)
            }

            function _bindSequence(combo, keys, callback, action) {
                function _increaseSequence(nextAction) {
                    return function() {
                        _nextExpectedAction = nextAction, ++_sequenceLevels[combo], _resetSequenceTimer()
                    }
                }

                function _callbackAndReset(e) {
                    _fireCallback(callback, e, combo), "keyup" !== action && (_ignoreNextKeyup = _characterFromEvent(e)), setTimeout(_resetSequences, 10)
                }
                _sequenceLevels[combo] = 0;
                for (var i = 0; i < keys.length; ++i) {
                    var isFinal = i + 1 === keys.length,
                        wrappedCallback = isFinal ? _callbackAndReset : _increaseSequence(action || _getKeyInfo(keys[i + 1]).action);
                    _bindSingle(keys[i], wrappedCallback, action, combo, i)
                }
            }

            function _bindSingle(combination, callback, action, sequenceName, level) {
                self._directMap[combination + ":" + action] = callback, combination = combination.replace(/\s+/g, " ");
                var info, sequence = combination.split(" ");
                return sequence.length > 1 ? void _bindSequence(combination, sequence, callback, action) : (info = _getKeyInfo(combination, action), self._callbacks[info.key] = self._callbacks[info.key] || [],
                    _getMatches(info.key, info.modifiers, {
                        type: info.action
                    }, sequenceName, combination, level), void self._callbacks[info.key][sequenceName ? "unshift" : "push"]({
                        callback: callback,
                        modifiers: info.modifiers,
                        action: info.action,
                        seq: sequenceName,
                        level: level,
                        combo: combination
                    }))
            }
            var self = this;
            if (targetElement = targetElement || document, !(self instanceof Mousetrap)) return new Mousetrap(targetElement);
            self.target = targetElement, self._callbacks = {}, self._directMap = {};
            var _resetTimer, _sequenceLevels = {},
                _ignoreNextKeyup = !1,
                _ignoreNextKeypress = !1,
                _nextExpectedAction = !1;
            self._handleKey = function(character, modifiers, e) {
                var i, callbacks = _getMatches(character, modifiers, e),
                    doNotReset = {},
                    maxLevel = 0,
                    processedSequenceCallback = !1;
                for (i = 0; i < callbacks.length; ++i) callbacks[i].seq && (maxLevel = Math.max(maxLevel, callbacks[i].level));
                for (i = 0; i < callbacks.length; ++i)
                    if (callbacks[i].seq) {
                        if (callbacks[i].level != maxLevel) continue;
                        processedSequenceCallback = !0, doNotReset[callbacks[i].seq] = 1, _fireCallback(callbacks[i].callback, e, callbacks[i].combo, callbacks[i].seq)
                    } else processedSequenceCallback || _fireCallback(callbacks[i].callback, e, callbacks[i].combo);
                var ignoreThisKeypress = "keypress" == e.type && _ignoreNextKeypress;
                e.type != _nextExpectedAction || _isModifier(character) || ignoreThisKeypress || _resetSequences(doNotReset), _ignoreNextKeypress = processedSequenceCallback && "keydown" == e.type
            }, self._bindMultiple = function(combinations, callback, action) {
                for (var i = 0; i < combinations.length; ++i) _bindSingle(combinations[i], callback, action)
            }, _addEvent(targetElement, "keypress", _handleKeyEvent), _addEvent(targetElement, "keydown", _handleKeyEvent), _addEvent(targetElement, "keyup", _handleKeyEvent)
        }
        if (window) {
            for (var _REVERSE_MAP, _MAP = {
                    8: "backspace",
                    9: "tab",
                    13: "enter",
                    16: "shift",
                    17: "ctrl",
                    18: "alt",
                    20: "capslock",
                    27: "esc",
                    32: "space",
                    33: "pageup",
                    34: "pagedown",
                    35: "end",
                    36: "home",
                    37: "left",
                    38: "up",
                    39: "right",
                    40: "down",
                    45: "ins",
                    46: "del",
                    91: "meta",
                    93: "meta",
                    224: "meta"
                }, _KEYCODE_MAP = {
                    106: "*",
                    107: "+",
                    109: "-",
                    110: ".",
                    111: "/",
                    186: ";",
                    187: "=",
                    188: ",",
                    189: "-",
                    190: ".",
                    191: "/",
                    192: "`",
                    219: "[",
                    220: "\\",
                    221: "]",
                    222: "'"
                }, _SHIFT_MAP = {
                    "~": "`",
                    "!": "1",
                    "@": "2",
                    "#": "3",
                    $: "4",
                    "%": "5",
                    "^": "6",
                    "&": "7",
                    "*": "8",
                    "(": "9",
                    ")": "0",
                    _: "-",
                    "+": "=",
                    ":": ";",
                    '"': "'",
                    "<": ",",
                    ">": ".",
                    "?": "/",
                    "|": "\\"
                }, _SPECIAL_ALIASES = {
                    option: "alt",
                    command: "meta",
                    return: "enter",
                    escape: "esc",
                    plus: "+",
                    mod: /Mac|iPod|iPhone|iPad/.test(navigator.platform) ? "meta" : "ctrl"
                }, i = 1; i < 20; ++i) _MAP[111 + i] = "f" + i;
            for (i = 0; i <= 9; ++i) _MAP[i + 96] = i.toString();
            Mousetrap.prototype.bind = function(keys, callback, action) {
                var self = this;
                return keys = keys instanceof Array ? keys : [keys], self._bindMultiple.call(self, keys, callback, action), self
            }, Mousetrap.prototype.unbind = function(keys, action) {
                var self = this;
                return self.bind.call(self, keys, function() {}, action)
            }, Mousetrap.prototype.trigger = function(keys, action) {
                var self = this;
                return self._directMap[keys + ":" + action] && self._directMap[keys + ":" + action]({}, keys), self
            }, Mousetrap.prototype.reset = function() {
                var self = this;
                return self._callbacks = {}, self._directMap = {}, self
            }, Mousetrap.prototype.stopCallback = function(e, element) {
                var self = this;
                return !((" " + element.className + " ").indexOf(" mousetrap ") > -1) && (!_belongsTo(element, self.target) && ("INPUT" == element.tagName || "SELECT" == element.tagName || "TEXTAREA" == element.tagName || element.isContentEditable))
            }, Mousetrap.prototype.handleKey = function() {
                var self = this;
                return self._handleKey.apply(self, arguments)
            }, Mousetrap.addKeycodes = function(object) {
                for (var key in object) object.hasOwnProperty(key) && (_MAP[key] = object[key]);
                _REVERSE_MAP = null
            }, Mousetrap.init = function() {
                var documentMousetrap = Mousetrap(document);
                for (var method in documentMousetrap) "_" !== method.charAt(0) && (Mousetrap[method] = function(method) {
                    return function() {
                        return documentMousetrap[method].apply(documentMousetrap, arguments)
                    }
                }(method))
            }, Mousetrap.init(), window.Mousetrap = Mousetrap, "undefined" != typeof module && module.exports && (module.exports = Mousetrap), "function" == typeof define && define.amd && define(function() {
                return Mousetrap
            })
        }
    }("undefined" != typeof window ? window : null, "undefined" != typeof window ? document : null),
    function(root, factory) {
        "object" === ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "object" === ("undefined" == typeof module ? "undefined" : _typeof2(module)) ? module.exports = factory(): "function" == typeof define && define.amd ? define([], factory) : "object" === ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) ? exports.CssKeyframesAnimation = factory() : root.CssKeyframesAnimation = factory()
    }(this, function() {
        return function(modules) {
            function __webpack_require__(moduleId) {
                if (installedModules[moduleId]) return installedModules[moduleId].exports;
                var module = installedModules[moduleId] = {
                    exports: {},
                    id: moduleId,
                    loaded: !1
                };
                return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.loaded = !0, module.exports
            }
            var installedModules = {};
            return __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.p = "", __webpack_require__(0)
        }([function(module, exports, __webpack_require__) {
            "use strict";

            function _interopRequireDefault(obj) {
                return obj && obj.__esModule ? obj : {
                    default: obj
                }
            }

            function _classCallCheck(instance, Constructor) {
                if (!(instance instanceof Constructor)) throw new TypeError("Cannot call a class as a function")
            }
            Object.defineProperty(exports, "__esModule", {
                value: !0
            });
            var _createClass = function() {
                    function defineProperties(target, props) {
                        for (var i = 0; i < props.length; i++) {
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || !1, descriptor.configurable = !0, "value" in descriptor && (descriptor.writable = !0), Object.defineProperty(target, descriptor.key, descriptor)
                        }
                    }
                    return function(Constructor, protoProps, staticProps) {
                        return protoProps && defineProperties(Constructor.prototype, protoProps), staticProps && defineProperties(Constructor, staticProps), Constructor
                    }
                }(),
                _cuid = __webpack_require__(1),
                _cuid2 = _interopRequireDefault(_cuid),
                _blueimpMd = __webpack_require__(2),
                _blueimpMd2 = _interopRequireDefault(_blueimpMd),
                CssKeyframesAnimation = function() {
                    function CssKeyframesAnimation() {
                        var keyframes = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
                            animationName = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
                        _classCallCheck(this, CssKeyframesAnimation), this.name = animationName, this.keyframes = keyframes || {}, this.prefixes = ["-webkit-", "-moz-", "-o-", "-ms-"], this.cachedCss = null, this.checksum = null
                    }
                    return _createClass(CssKeyframesAnimation, [{
                        key: "insertKeyFrame",
                        value: function(keyFrameSelector, css) {
                            this.keyframes[keyFrameSelector] = css, this.cachedCss = null, this.checksum = null
                        }
                    }, {
                        key: "removeKeyFrame",
                        value: function(keyFrameSelector) {
                            delete this.keyframes[keyFrameSelector], this.cachedCss = null, this.checksum = null
                        }
                    }, {
                        key: "decamelizeCssProperty",
                        value: function() {
                            var property = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                                decamelizedProperty = property.replace(/([a-z])([A-Z])/g, "$1-$2"),
                                regex = new RegExp("(" + this.prefixes.map(function(prefix) {
                                    return prefix.substring(1)
                                }).join("|") + ")", "i");
                            return decamelizedProperty.replace(regex, "-$1").toLowerCase()
                        }
                    }, {
                        key: "generateCss",
                        value: function(css) {
                            var _this = this;
                            return Object.keys(css).map(function(property) {
                                return _this.decamelizeCssProperty(property) + ": " + css[property] + ";"
                            }).join(" ").trim()
                        }
                    }, {
                        key: "parseKeyFrameSelector",
                        value: function(keySelector) {
                            var percent = parseInt(keySelector);
                            return isNaN(percent) ? keySelector : percent + "%"
                        }
                    }, {
                        key: "generateKeyFrame",
                        value: function(keySelector) {
                            return this.parseKeyFrameSelector(keySelector) + " { " + this.generateCss(this.keyframes[keySelector]) + " }"
                        }
                    }, {
                        key: "generateKeyFrames",
                        value: function() {
                            var prefix = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
                            return "@" + prefix + "keyframes " + this.name + " { " + Object.keys(this.keyframes).map(this.generateKeyFrame.bind(this)).join(" ") + " }"
                        }
                    }, {
                        key: "generateKeyframesAnimation",
                        value: function(prefix) {
                            return this.cachedCss = this.cachedCss || this.generateKeyFrames() + " " + (prefix ? this.generateKeyFrames(prefix) : ""), this.cachedCss
                        }
                    }, {
                        key: "name",
                        set: function(name) {
                            this._name = name
                        },
                        get: function() {
                            return this._name || (this._name = (0, _cuid2.default)()), this._name
                        }
                    }, {
                        key: "checksum",
                        set: function(checkSum) {
                            this._checksum = checkSum
                        },
                        get: function() {
                            return this._checksum || (this.checksum = (0, _blueimpMd2.default)(JSON.stringify(this.keyframes))), this._checksum
                        }
                    }]), CssKeyframesAnimation
                }();
            exports.default = CssKeyframesAnimation
        }, function(module, exports, __webpack_require__) {
            ! function(app) {
                "use strict";
                var namespace = "cuid",
                    c = 0,
                    blockSize = 4,
                    base = 36,
                    discreteValues = Math.pow(base, blockSize),
                    pad = function(num, size) {
                        var s = "000000000" + num;
                        return s.substr(s.length - size)
                    },
                    randomBlock = function() {
                        return pad((Math.random() * discreteValues << 0).toString(base), blockSize)
                    },
                    safeCounter = function() {
                        return c = c < discreteValues ? c : 0, c++, c - 1
                    },
                    api = function() {
                        var counter, letter = "c",
                            timestamp = (new Date).getTime().toString(base),
                            fingerprint = api.fingerprint(),
                            random = randomBlock() + randomBlock();
                        return counter = pad(safeCounter().toString(base), blockSize), letter + timestamp + counter + fingerprint + random
                    };
                api.slug = function() {
                    var counter, date = (new Date).getTime().toString(36),
                        print = api.fingerprint().slice(0, 1) + api.fingerprint().slice(-1),
                        random = randomBlock().slice(-2);
                    return counter = safeCounter().toString(36).slice(-4), date.slice(-2) + counter + print + random
                }, api.globalCount = function() {
                    var cache = function() {
                        var i, count = 0;
                        for (i in window) count++;
                        return count
                    }();
                    return api.globalCount = function() {
                        return cache
                    }, cache
                }, api.fingerprint = function() {
                    return pad((navigator.mimeTypes.length + navigator.userAgent.length).toString(36) + api.globalCount().toString(36), 4)
                }, app.register ? app.register(namespace, api) : module.exports = api
            }(this.applitude || this)
        }, function(module, exports, __webpack_require__) {
            var __WEBPACK_AMD_DEFINE_RESULT__;
            ! function($) {
                "use strict";

                function safeAdd(x, y) {
                    var lsw = (65535 & x) + (65535 & y),
                        msw = (x >> 16) + (y >> 16) + (lsw >> 16);
                    return msw << 16 | 65535 & lsw
                }

                function bitRotateLeft(num, cnt) {
                    return num << cnt | num >>> 32 - cnt
                }

                function md5cmn(q, a, b, x, s, t) {
                    return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b)
                }

                function md5ff(a, b, c, d, x, s, t) {
                    return md5cmn(b & c | ~b & d, a, b, x, s, t)
                }

                function md5gg(a, b, c, d, x, s, t) {
                    return md5cmn(b & d | c & ~d, a, b, x, s, t)
                }

                function md5hh(a, b, c, d, x, s, t) {
                    return md5cmn(b ^ c ^ d, a, b, x, s, t)
                }

                function md5ii(a, b, c, d, x, s, t) {
                    return md5cmn(c ^ (b | ~d), a, b, x, s, t)
                }

                function binlMD5(x, len) {
                    x[len >> 5] |= 128 << len % 32, x[(len + 64 >>> 9 << 4) + 14] = len;
                    var i, olda, oldb, oldc, oldd, a = 1732584193,
                        b = -271733879,
                        c = -1732584194,
                        d = 271733878;
                    for (i = 0; i < x.length; i += 16) olda = a, oldb = b, oldc = c, oldd = d, a = md5ff(a, b, c, d, x[i], 7, -680876936), d = md5ff(d, a, b, c, x[i + 1], 12, -389564586), c = md5ff(c, d, a, b, x[i + 2], 17, 606105819), b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330), a = md5ff(a, b, c, d, x[i + 4], 7, -176418897), d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426), c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341), b = md5ff(b, c, d, a, x[i + 7], 22, -45705983), a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416), d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417), c = md5ff(c, d, a, b, x[i + 10], 17, -42063), b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162), a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682), d = md5ff(d, a, b, c, x[i + 13], 12, -40341101), c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290), b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329), a = md5gg(a, b, c, d, x[i + 1], 5, -165796510), d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632), c = md5gg(c, d, a, b, x[i + 11], 14, 643717713), b = md5gg(b, c, d, a, x[i], 20, -373897302), a = md5gg(a, b, c, d, x[i + 5], 5, -701558691), d = md5gg(d, a, b, c, x[i + 10], 9, 38016083), c = md5gg(c, d, a, b, x[i + 15], 14, -660478335), b = md5gg(b, c, d, a, x[i + 4], 20, -405537848), a = md5gg(a, b, c, d, x[i + 9], 5, 568446438), d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690), c = md5gg(c, d, a, b, x[i + 3], 14, -187363961), b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501), a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467), d = md5gg(d, a, b, c, x[i + 2], 9, -51403784), c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473), b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734), a = md5hh(a, b, c, d, x[i + 5], 4, -378558), d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463), c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562), b = md5hh(b, c, d, a, x[i + 14], 23, -35309556), a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060), d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353), c = md5hh(c, d, a, b, x[i + 7], 16, -155497632), b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640), a = md5hh(a, b, c, d, x[i + 13], 4, 681279174), d = md5hh(d, a, b, c, x[i], 11, -358537222), c = md5hh(c, d, a, b, x[i + 3], 16, -722521979), b = md5hh(b, c, d, a, x[i + 6], 23, 76029189), a = md5hh(a, b, c, d, x[i + 9], 4, -640364487), d = md5hh(d, a, b, c, x[i + 12], 11, -421815835), c = md5hh(c, d, a, b, x[i + 15], 16, 530742520), b = md5hh(b, c, d, a, x[i + 2], 23, -995338651), a = md5ii(a, b, c, d, x[i], 6, -198630844), d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415), c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905), b = md5ii(b, c, d, a, x[i + 5], 21, -57434055), a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571), d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606), c = md5ii(c, d, a, b, x[i + 10], 15, -1051523), b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799), a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359), d = md5ii(d, a, b, c, x[i + 15], 10, -30611744), c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380), b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649), a = md5ii(a, b, c, d, x[i + 4], 6, -145523070), d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379), c = md5ii(c, d, a, b, x[i + 2], 15, 718787259), b = md5ii(b, c, d, a, x[i + 9], 21, -343485551), a = safeAdd(a, olda), b = safeAdd(b, oldb), c = safeAdd(c, oldc), d = safeAdd(d, oldd);
                    return [a, b, c, d]
                }

                function binl2rstr(input) {
                    var i, output = "",
                        length32 = 32 * input.length;
                    for (i = 0; i < length32; i += 8) output += String.fromCharCode(input[i >> 5] >>> i % 32 & 255);
                    return output
                }

                function rstr2binl(input) {
                    var i, output = [];
                    for (output[(input.length >> 2) - 1] = void 0, i = 0; i < output.length; i += 1) output[i] = 0;
                    var length8 = 8 * input.length;
                    for (i = 0; i < length8; i += 8) output[i >> 5] |= (255 & input.charCodeAt(i / 8)) << i % 32;
                    return output
                }

                function rstrMD5(s) {
                    return binl2rstr(binlMD5(rstr2binl(s), 8 * s.length))
                }

                function rstrHMACMD5(key, data) {
                    var i, hash, bkey = rstr2binl(key),
                        ipad = [],
                        opad = [];
                    for (ipad[15] = opad[15] = void 0, bkey.length > 16 && (bkey = binlMD5(bkey, 8 * key.length)), i = 0; i < 16; i += 1) ipad[i] = 909522486 ^ bkey[i], opad[i] = 1549556828 ^ bkey[i];
                    return hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + 8 * data.length), binl2rstr(binlMD5(opad.concat(hash), 640))
                }

                function rstr2hex(input) {
                    var x, i, hexTab = "0123456789abcdef",
                        output = "";
                    for (i = 0; i < input.length; i += 1) x = input.charCodeAt(i), output += hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(15 & x);
                    return output
                }

                function str2rstrUTF8(input) {
                    return unescape(encodeURIComponent(input))
                }

                function rawMD5(s) {
                    return rstrMD5(str2rstrUTF8(s))
                }

                function hexMD5(s) {
                    return rstr2hex(rawMD5(s))
                }

                function rawHMACMD5(k, d) {
                    return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d))
                }

                function hexHMACMD5(k, d) {
                    return rstr2hex(rawHMACMD5(k, d))
                }

                function md5(string, key, raw) {
                    return key ? raw ? rawHMACMD5(key, string) : hexHMACMD5(key, string) : raw ? rawMD5(string) : hexMD5(string)
                }
                __WEBPACK_AMD_DEFINE_RESULT__ = function() {
                    return md5
                }.call(exports, __webpack_require__, exports, module), !(void 0 !== __WEBPACK_AMD_DEFINE_RESULT__ && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
            }(this)
        }])
    }),
    function(f) {
        if ("object" === ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "undefined" != typeof module) module.exports = f();
        else if ("function" == typeof define && define.amd) define([], f);
        else {
            var g;
            g = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, g.uxpinSharedComponents = f()
        }
    }(function() {
        var define;
        return function e(t, n, r) {
            function s(o, u) {
                if (!n[o]) {
                    if (!t[o]) {
                        var a = "function" == typeof require && require;
                        if (!u && a) return a(o, !0);
                        if (i) return i(o, !0);
                        var f = new Error("Cannot find module '" + o + "'");
                        throw f.code = "MODULE_NOT_FOUND", f
                    }
                    var l = n[o] = {
                        exports: {}
                    };
                    t[o][0].call(l.exports, function(e) {
                        var n = t[o][1][e];
                        return s(n ? n : e)
                    }, l, l.exports, e, t, n, r)
                }
                return n[o].exports
            }
            for (var i = "function" == typeof require && require, o = 0; o < r.length; o++) s(r[o]);
            return s
        }({
            1: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function _asyncToGenerator(e) {
                    return function() {
                        var t = e.apply(this, arguments);
                        return new Promise(function(e, n) {
                            return function r(i, a) {
                                try {
                                    var o = t[i](a),
                                        s = o.value
                                } catch (e) {
                                    return void n(e)
                                }
                                return o.done ? void e(s) : Promise.resolve(s).then(function(e) {
                                    r("next", e)
                                }, function(e) {
                                    r("throw", e)
                                })
                            }("next")
                        })
                    }
                }

                function _defineProperty(e, t, n) {
                    return t in e ? Object.defineProperty(e, t, {
                        value: n,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : e[t] = n, e
                }

                function _toConsumableArray(e) {
                    if (Array.isArray(e)) {
                        for (var t = 0, n = Array(e.length); t < e.length; t++) n[t] = e[t];
                        return n
                    }
                    return Array.from(e)
                }

                function _classCallCheck(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _regenerator = require("babel-runtime/regenerator"),
                    _regenerator2 = _interopRequireDefault(_regenerator),
                    _reduce3 = require("lodash/reduce"),
                    _reduce4 = _interopRequireDefault(_reduce3),
                    _isUndefined2 = require("lodash/isUndefined"),
                    _isUndefined3 = _interopRequireDefault(_isUndefined2),
                    _forEach2 = require("lodash/forEach"),
                    _forEach3 = _interopRequireDefault(_forEach2),
                    _filter2 = require("lodash/filter"),
                    _filter3 = _interopRequireDefault(_filter2),
                    _createClass = function() {
                        function e(e, t) {
                            for (var n = 0; n < t.length; n++) {
                                var r = t[n];
                                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                            }
                        }
                        return function(t, n, r) {
                            return n && e(t.prototype, n), r && e(t, r), t
                        }
                    }(),
                    _genericFonts = require("../constants/genericFonts.constants"),
                    localFontAvailabilityCache = {},
                    localFontWidthCache = {},
                    shouldCheckLocalFonts = !1,
                    fontContainer = document.createElement("span");
                fontContainer.innerHTML = "1234567890qwertyuiopasdfghjklzxcvbnm-+=;:|<>", fontContainer.style.cssText = ["position:absolute", "width:auto", "font-size:128px", "left:-99999px"].join(" !important;");
                var getWidth = function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        if (!(0, _isUndefined3.default)(localFontWidthCache[e]) && !t) return localFontWidthCache[e];
                        fontContainer.style.fontFamily = e, document.body.appendChild(fontContainer);
                        var n = fontContainer.clientWidth;
                        return document.body.removeChild(fontContainer), localFontWidthCache[e] = n, localFontWidthCache[e]
                    },
                    LocalFontHandler = function() {
                        function e(t) {
                            var n = t.getAllElementLocalFonts;
                            _classCallCheck(this, e), this.getAllElementLocalFonts = n, this.shouldCheckLocalFonts = !1, this.listeners = []
                        }
                        return _createClass(e, null, [{
                            key: "isLocalFontAvailable",
                            value: function(e) {
                                var t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                                if (!(0, _isUndefined3.default)(localFontAvailabilityCache[e]) && !t) return localFontAvailabilityCache[e];
                                var n = getWidth(_genericFonts.genericFonts.MONOSPACE),
                                    r = getWidth(_genericFonts.genericFonts.SERIF),
                                    i = getWidth(_genericFonts.genericFonts.SANS_SERIF),
                                    a = n !== getWidth(e + "," + _genericFonts.genericFonts.MONOSPACE, t) || i !== getWidth(e + "," + _genericFonts.genericFonts.SANS_SERIF, t) || r !== getWidth(e + "," + _genericFonts.genericFonts.SERIF, t);
                                return t || (localFontAvailabilityCache[e] = a), a
                            }
                        }]), _createClass(e, [{
                            key: "initialize",
                            value: function() {
                                var e = this;
                                window.addEventListener("blur", function() {
                                    return e.onWindowBlur()
                                }), window.addEventListener("focus", function() {
                                    return e.onWindowFocus()
                                })
                            }
                        }, {
                            key: "onWindowBlur",
                            value: function() {
                                shouldCheckLocalFonts = !0
                            }
                        }, {
                            key: "addListener",
                            value: function(e) {
                                this.listeners.push(e)
                            }
                        }, {
                            key: "removeListener",
                            value: function(e) {
                                this.listeners = (0, _filter3.default)(this.listeners, function(t) {
                                    return t !== e
                                })
                            }
                        }, {
                            key: "extractMissingFont",
                            value: function(t, n) {
                                var r = n.postscriptName,
                                    i = n.variant,
                                    a = t,
                                    o = e.isLocalFontAvailable(r, !0);
                                return !o && localFontAvailabilityCache[r] && (a = {
                                    postscriptNames: [].concat(_toConsumableArray(t.postscriptNames), [{
                                        postscriptName: r,
                                        variant: i
                                    }]),
                                    variants: Object.assign({}, t.variants, _defineProperty({}, i, !0))
                                }), localFontAvailabilityCache[r] = o, a
                            }
                        }, {
                            key: "onWindowFocus",
                            value: function() {
                                var e = _asyncToGenerator(_regenerator2.default.mark(function e() {
                                    var t;
                                    return _regenerator2.default.wrap(function(e) {
                                        for (;;) switch (e.prev = e.next) {
                                            case 0:
                                                if (shouldCheckLocalFonts) {
                                                    e.next = 2;
                                                    break
                                                }
                                                return e.abrupt("return");
                                            case 2:
                                                return e.next = 4, this.getMissingFonts();
                                            case 4:
                                                (t = e.sent) && t.length && (0, _forEach3.default)(this.listeners, function(e) {
                                                    e(t)
                                                });
                                            case 6:
                                            case "end":
                                                return e.stop()
                                        }
                                    }, e, this)
                                }));
                                return function() {
                                    return e.apply(this, arguments)
                                }
                            }()
                        }, {
                            key: "getMissingFonts",
                            value: function() {
                                var e = _asyncToGenerator(_regenerator2.default.mark(function e() {
                                    var t, n, r = this;
                                    return _regenerator2.default.wrap(function(e) {
                                        for (;;) switch (e.prev = e.next) {
                                            case 0:
                                                return e.next = 2, this.getAllElementLocalFonts();
                                            case 2:
                                                return t = e.sent, n = [], (0, _forEach3.default)(t, function(e) {
                                                    var t = (0, _reduce4.default)(e.postscriptNames, r.extractMissingFont, {
                                                            postscriptNames: [],
                                                            variants: {}
                                                        }),
                                                        i = t.postscriptNames,
                                                        a = t.variants;
                                                    i.length && n.push(Object.assign({}, e, {
                                                        variants: a
                                                    }, {
                                                        postscriptNames: i
                                                    }))
                                                }), e.abrupt("return", n);
                                            case 6:
                                            case "end":
                                                return e.stop()
                                        }
                                    }, e, this)
                                }));
                                return function() {
                                    return e.apply(this, arguments)
                                }
                            }()
                        }]), e
                    }();
                exports.default = LocalFontHandler
            }, {
                "../constants/genericFonts.constants": 34,
                "babel-runtime/regenerator": 46,
                "lodash/filter": 369,
                "lodash/forEach": 373,
                "lodash/isUndefined": 395,
                "lodash/reduce": 407
            }],
            2: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function _defineProperty(e, t, r) {
                    return t in e ? Object.defineProperty(e, t, {
                        value: r,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : e[t] = r, e
                }

                function _classCallCheck(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }

                function _possibleConstructorReturn(e, t) {
                    if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != _typeof2(t) && "function" != typeof t ? e : t
                }

                function _inherits(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(t));
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }

                function _applyDecoratedDescriptor(e, t, r, n, s) {
                    var i = {};
                    return Object.keys(n).forEach(function(e) {
                        i[e] = n[e]
                    }), i.enumerable = !!i.enumerable, i.configurable = !!i.configurable, ("value" in i || i.initializer) && (i.writable = !0), i = r.slice().reverse().reduce(function(r, n) {
                        return n(e, t, r) || r
                    }, i), s && void 0 !== i.initializer && (i.value = i.initializer ? i.initializer.call(s) : void 0, i.initializer = void 0), void 0 === i.initializer && (Object.defineProperty(e, t, i), i = null), i
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _class, _PropTypes$shape, _noop2 = require("lodash/noop"),
                    _noop3 = _interopRequireDefault(_noop2),
                    _createClass = function() {
                        function e(e, t) {
                            for (var r = 0; r < t.length; r++) {
                                var n = t[r];
                                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
                            }
                        }
                        return function(t, r, n) {
                            return r && e(t.prototype, r), n && e(t, n), t
                        }
                    }(),
                    _react = require("react"),
                    _react2 = _interopRequireDefault(_react),
                    _propTypes = require("prop-types"),
                    _propTypes2 = _interopRequireDefault(_propTypes),
                    _classnames = require("classnames"),
                    _classnames2 = _interopRequireDefault(_classnames),
                    _autobindDecorator = require("autobind-decorator"),
                    _autobindDecorator2 = _interopRequireDefault(_autobindDecorator),
                    SECTIONS = {
                        HEADER: "header",
                        CONTENT: "content"
                    },
                    OnboardingWidget = (_applyDecoratedDescriptor((_class = function(e) {
                        function t(e) {
                            _classCallCheck(this, t);
                            var r = _possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e)),
                                n = e.currentSlide,
                                s = r.getSlidesCount();
                            return r.state = {
                                currentSlide: n,
                                isFirstSlide: 0 === n,
                                isLastSlide: n >= s - 1,
                                isNavigationActive: !0
                            }, r.buttons = {
                                next: null,
                                prev: null
                            }, r
                        }
                        return _inherits(t, _react2.default.Component), _createClass(t, [{
                            key: "componentDidMount",
                            value: function() {
                                this.props.showSlideEvent(this.state.currentSlide)
                            }
                        }, {
                            key: "componentDidUpdate",
                            value: function(e, t) {
                                var r = this.state.currentSlide;
                                r !== t.currentSlide && this.props.showSlideEvent(r)
                            }
                        }, {
                            key: "getCurrentSlideContent",
                            value: function() {
                                return this.props.content[this.state.currentSlide]
                            }
                        }, {
                            key: "getSlidesCount",
                            value: function() {
                                return this.props.content.length
                            }
                        }, {
                            key: "getCurrentSlideSection",
                            value: function(e) {
                                return this.getCurrentSlideContent()[e]
                            }
                        }, {
                            key: "getDisplayedCurrentSlideNumber",
                            value: function() {
                                return this.state.currentSlide + 1 + this.props.slidesOffset
                            }
                        }, {
                            key: "getDisplayedSlidesCount",
                            value: function() {
                                var e = this.props,
                                    t = e.slidesOffset;
                                return e.customSlidesCount || this.getSlidesCount() + t
                            }
                        }, {
                            key: "setNextSlide",
                            value: function() {
                                var e = this.state,
                                    t = e.currentSlide,
                                    r = (e.isFirstSlide, e.isLastSlide),
                                    n = (e.isNavigationActive, this.getSlidesCount());
                                return r ? t : (r = (t += 1) >= n - 1, this.setState({
                                    currentSlide: t,
                                    isFirstSlide: !1,
                                    isLastSlide: r,
                                    isNavigationActive: !0
                                }), t)
                            }
                        }, {
                            key: "setPreviousSlide",
                            value: function() {
                                var e = this.state,
                                    t = e.currentSlide,
                                    r = e.isFirstSlide;
                                return e.isLastSlide, e.isNavigationActive, r ? t : (r = (t -= 1) < 1, this.setState({
                                    currentSlide: t,
                                    isFirstSlide: r,
                                    isLastSlide: !1,
                                    isNavigationActive: !0
                                }), t)
                            }
                        }, {
                            key: "actionCallback",
                            value: function() {
                                var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                                return this.setState({
                                    isNavigationActive: !0
                                }), e ? this.setNextSlide() : this.setPreviousSlide()
                            }
                        }, {
                            key: "renderHeader",
                            value: function() {
                                var e = this.getCurrentSlideSection(SECTIONS.HEADER),
                                    t = this.getDisplayedCurrentSlideNumber() + " of " + this.getDisplayedSlidesCount();
                                return _react2.default.createElement("header", {
                                    className: "header"
                                }, _react2.default.createElement("h4", {
                                    className: "title"
                                }, e), _react2.default.createElement("span", {
                                    className: "page-count"
                                }, t))
                            }
                        }, {
                            key: "renderContent",
                            value: function() {
                                var e = this.getCurrentSlideSection(SECTIONS.CONTENT);
                                return _react2.default.createElement("section", {
                                    className: "content"
                                }, e)
                            }
                        }, {
                            key: "renderPrevButton",
                            value: function() {
                                var e = this,
                                    t = this.props,
                                    r = t.customPrevActions,
                                    n = t.defaultActions,
                                    s = t.customPrevLabels,
                                    i = t.defaultLabels,
                                    o = t.hideButtons,
                                    a = this.state,
                                    l = a.currentSlide,
                                    u = a.isFirstSlide,
                                    c = a.isNavigationActive;
                                if (u && o.first) return null;
                                var p = r[l],
                                    d = (0, _classnames2.default)("ds-btn", "ds-btn--style-chameleon", "ds-btn--weight-light", "nav-btn", {
                                        "ds-btn--is-disabled": u && !p
                                    }),
                                    f = s[l] || i.prev,
                                    _ = p || n.prev,
                                    v = function() {
                                        return e.actionCallback()
                                    };
                                return _react2.default.createElement("button", {
                                    ref: function(t) {
                                        e.buttons.prev = t
                                    },
                                    type: "button",
                                    className: d,
                                    onClick: function(t) {
                                        t.preventDefault(), e.buttons.prev.blur(), c && (e.setState({
                                            isNavigationActive: !1
                                        }), _(v))
                                    }
                                }, f)
                            }
                        }, {
                            key: "renderNextButton",
                            value: function() {
                                var e = this,
                                    t = this.props,
                                    r = t.customNextActions,
                                    n = t.defaultActions,
                                    s = t.customNextLabels,
                                    i = t.defaultLabels,
                                    o = t.hideButtons,
                                    a = this.state,
                                    l = a.currentSlide,
                                    u = a.isLastSlide,
                                    c = a.isNavigationActive;
                                if (u && o.last) return null;
                                var p = r[l],
                                    d = (0, _classnames2.default)("ds-btn", "ds-btn--style-default", "nav-btn", {
                                        "ds-btn--is-disabled": u && !p
                                    }),
                                    f = s[l] || i.next,
                                    _ = p || n.next,
                                    v = function() {
                                        return e.actionCallback(!0)
                                    };
                                return _react2.default.createElement("button", {
                                    ref: function(t) {
                                        e.buttons.next = t
                                    },
                                    type: "button",
                                    className: d,
                                    onClick: function(t) {
                                        t.preventDefault(), e.buttons.next.blur(), c && (e.setState({
                                            isNavigationActive: !1
                                        }), _(v))
                                    }
                                }, f)
                            }
                        }, {
                            key: "renderFooter",
                            value: function() {
                                var e = this.props.hideButtons,
                                    t = this.state.isFirstSlide,
                                    r = (0, _classnames2.default)("footer", {
                                        "only-next": t && e.first
                                    });
                                return _react2.default.createElement("footer", {
                                    className: r
                                }, this.renderPrevButton(), this.renderNextButton())
                            }
                        }, {
                            key: "render",
                            value: function() {
                                var e = (0, _classnames2.default)("onboarding-path-widget", this.props.additionalClasses);
                                return _react2.default.createElement("aside", {
                                    className: e
                                }, this.renderHeader(), this.renderContent(), this.renderFooter())
                            }
                        }]), t
                    }()).prototype, "actionCallback", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "actionCallback"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "renderPrevButton", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "renderPrevButton"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "renderNextButton", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "renderNextButton"), _class.prototype), _class);
                exports.default = OnboardingWidget, OnboardingWidget.propTypes = {
                    additionalClasses: _propTypes2.default.string,
                    defaultActions: _propTypes2.default.shape({
                        next: _propTypes2.default.func,
                        prev: _propTypes2.default.func
                    }),
                    defaultLabels: _propTypes2.default.shape({
                        next: _propTypes2.default.string,
                        prev: _propTypes2.default.string
                    }),
                    hideButtons: _propTypes2.default.shape({
                        first: _propTypes2.default.bool,
                        last: _propTypes2.default.bool
                    }),
                    customNextActions: _propTypes2.default.object,
                    customPrevActions: _propTypes2.default.object,
                    customNextLabels: _propTypes2.default.object,
                    customPrevLabels: _propTypes2.default.object,
                    content: _propTypes2.default.arrayOf(_propTypes2.default.shape((_PropTypes$shape = {}, _defineProperty(_PropTypes$shape, SECTIONS.HEADER, _propTypes2.default.string.isRequired), _defineProperty(_PropTypes$shape, SECTIONS.CONTENT, _propTypes2.default.element.isRequired), _PropTypes$shape))).isRequired,
                    slidesOffset: _propTypes2.default.number,
                    customSlidesCount: _propTypes2.default.number,
                    currentSlide: _propTypes2.default.number,
                    showSlideEvent: _propTypes2.default.func
                }, OnboardingWidget.defaultProps = {
                    additionalClasses: "",
                    defaultActions: {
                        next: _noop3.default,
                        prev: _noop3.default
                    },
                    defaultLabels: {
                        next: "Next",
                        prev: "Previous"
                    },
                    hideButtons: {
                        first: !1,
                        last: !1
                    },
                    customNextActions: {},
                    customPrevActions: {},
                    customNextLabels: {},
                    customPrevLabels: {},
                    slidesOffset: 0,
                    customSlidesCount: 0,
                    currentSlide: 0,
                    showSlideEvent: _noop3.default
                }
            }, {
                "autobind-decorator": 43,
                classnames: 47,
                "lodash/noop": 402,
                "prop-types": 435,
                react: 455
            }],
            3: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function _classCallCheck(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }

                function _possibleConstructorReturn(e, t) {
                    if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != _typeof2(t) && "function" != typeof t ? e : t
                }

                function _inherits(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(t));
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }

                function _applyDecoratedDescriptor(e, t, o, i, r) {
                    var n = {};
                    return Object.keys(i).forEach(function(e) {
                        n[e] = i[e]
                    }), n.enumerable = !!n.enumerable, n.configurable = !!n.configurable, ("value" in n || n.initializer) && (n.writable = !0), n = o.slice().reverse().reduce(function(o, i) {
                        return i(e, t, o) || o
                    }, n), r && void 0 !== n.initializer && (n.value = n.initializer ? n.initializer.call(r) : void 0, n.initializer = void 0), void 0 === n.initializer && (Object.defineProperty(e, t, n), n = null), n
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _class, _noop2 = require("lodash/noop"),
                    _noop3 = _interopRequireDefault(_noop2),
                    _isUndefined2 = require("lodash/isUndefined"),
                    _isUndefined3 = _interopRequireDefault(_isUndefined2),
                    _createClass = function() {
                        function e(e, t) {
                            for (var o = 0; o < t.length; o++) {
                                var i = t[o];
                                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                            }
                        }
                        return function(t, o, i) {
                            return o && e(t.prototype, o), i && e(t, i), t
                        }
                    }(),
                    _autobindDecorator = require("autobind-decorator"),
                    _autobindDecorator2 = _interopRequireDefault(_autobindDecorator),
                    _classnames = require("classnames"),
                    _classnames2 = _interopRequireDefault(_classnames),
                    _draftJs = require("draft-js"),
                    _propTypes = require("prop-types"),
                    _propTypes2 = _interopRequireDefault(_propTypes),
                    _react = require("react"),
                    _react2 = _interopRequireDefault(_react),
                    _draftUtils = require("../utils/draftUtils"),
                    _RichEditorStylesCloud = require("./components/RichEditorStylesCloud"),
                    _RichEditorStylesCloud2 = _interopRequireDefault(_RichEditorStylesCloud),
                    _CodeEditorPlugin = require("./plugins/CodeEditor/CodeEditorPlugin"),
                    _CodeEditorPlugin2 = _interopRequireDefault(_CodeEditorPlugin),
                    _EditorWithPlugins = require("./plugins/EditorWithPlugins"),
                    _EditorWithPlugins2 = _interopRequireDefault(_EditorWithPlugins),
                    _LinkifyPlugin = require("./plugins/Linkify/LinkifyPlugin"),
                    _LinkifyPlugin2 = _interopRequireDefault(_LinkifyPlugin),
                    _RichEditorPlugin = require("./plugins/RichEditor/RichEditorPlugin"),
                    _RichEditorPlugin2 = _interopRequireDefault(_RichEditorPlugin),
                    _ImagePlugin = require("./plugins/Image/ImagePlugin"),
                    _ImagePlugin2 = _interopRequireDefault(_ImagePlugin),
                    _TablePlugin = require("./plugins/Table/TablePlugin"),
                    _TablePlugin2 = _interopRequireDefault(_TablePlugin),
                    _SelectionPopup = require("./SelectionPopup"),
                    _SelectionPopup2 = _interopRequireDefault(_SelectionPopup),
                    PADDING_LEFT = 60,
                    AREA_OFFSET_LEFT = 260,
                    RichTextEditor = (_applyDecoratedDescriptor((_class = function(e) {
                        function t(e, o) {
                            _classCallCheck(this, t);
                            var i = _possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, o));
                            return i.state = {
                                editorState: (0, _draftUtils.createEditorStateFromValue)(i.props.value),
                                isFocus: !1,
                                isEditorLocked: !1
                            }, i.codeEditorPlugin = new _CodeEditorPlugin2.default, i.richEditorPlugin = new _RichEditorPlugin2.default, i.linkifyPlugin = new _LinkifyPlugin2.default, i.tablePlugin = new _TablePlugin2.default({
                                getMainEditor: function() {
                                    return i
                                },
                                onChange: i.props.onChange,
                                isReadOnly: function() {
                                    return i.props.readOnly
                                }
                            }), i.imagePlugin = new _ImagePlugin2.default({
                                getMainEditor: function() {
                                    return i
                                },
                                getEditorState: function() {
                                    return i.state.editorState
                                },
                                isEditorFocused: i.isEditorFocused,
                                isEditorLocked: function() {
                                    return i.isLocked()
                                },
                                isReadOnly: function() {
                                    return i.props.readOnly
                                },
                                onChange: i.onChange,
                                onUpload: e.onUploadImage
                            }), i.plugins = [i.codeEditorPlugin, i.richEditorPlugin, i.linkifyPlugin, i.imagePlugin, i.tablePlugin], i.editorWrapper = {
                                getEditorRef: function() {
                                    return i.editor && i.editor.refs && i.editor.refs.editorContainer
                                }
                            }, i
                        }
                        return _inherits(t, _react.Component), _createClass(t, [{
                            key: "componentWillReceiveProps",
                            value: function(e) {
                                this.props.readOnly !== e.readOnly && this.setState({
                                    editorState: (0, _draftUtils.createEditorStateFromValue)(e.value)
                                }), this.props.onUploadImage !== e.onUploadImage && (this.imagePlugin.onUpload = e.onUploadImage), this.props.value === e.value || this.isEditorFocused() || this.isLocked() || this.setState({
                                    editorState: (0, _draftUtils.createEditorStateFromValue)(e.value)
                                })
                            }
                        }, {
                            key: "focus",
                            value: function() {
                                this.isLocked() || this.state.isFocus || this.editor.focus()
                            }
                        }, {
                            key: "isLocked",
                            value: function() {
                                return this.state.isEditorLocked
                            }
                        }, {
                            key: "lockEditor",
                            value: function() {
                                this.isLocked() || (this.state.isFocus && this.editor.blur(), this.setState({
                                    isEditorLocked: !0
                                }))
                            }
                        }, {
                            key: "unlockEditor",
                            value: function(e) {
                                this.isLocked() && (window.getSelection().removeAllRanges(), this.editor.focus(), this.setState({
                                    editorState: e || (0, _draftUtils.createEditorStateFromValue)(this.props.value),
                                    isEditorLocked: !1
                                }))
                            }
                        }, {
                            key: "onChange",
                            value: function(e) {
                                var t = this,
                                    o = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                                    i = this.state.editorState.getCurrentContent();
                                this.setState({
                                    editorState: e
                                }, function() {
                                    var r = e.getCurrentContent();
                                    if (i !== r || o) {
                                        var n = r.hasText() ? (0, _draftJs.convertToRaw)(r) : "";
                                        t.props.onChange(n)
                                    }
                                })
                            }
                        }, {
                            key: "onFocus",
                            value: function() {
                                this.setState({
                                    isFocus: !0
                                })
                            }
                        }, {
                            key: "onBlur",
                            value: function() {
                                this.setState({
                                    isFocus: !1
                                })
                            }
                        }, {
                            key: "onMouseDown",
                            value: function(e) {
                                this.props.readOnly || this.plugins.filter(function(e) {
                                    return !(0, _isUndefined3.default)(e.onMouseDown)
                                }).forEach(function(t) {
                                    t.onMouseDown(e)
                                })
                            }
                        }, {
                            key: "setEditorRef",
                            value: function(e) {
                                e && (this.editor = e.getEditorRef())
                            }
                        }, {
                            key: "getSelectedBlock",
                            value: function(e) {
                                if (!e) return null;
                                var t = e.getCurrentContent(),
                                    o = e.getSelection().getStartKey();
                                return t.getBlockForKey(o)
                            }
                        }, {
                            key: "isSelectedBlockEmpty",
                            value: function() {
                                var e = this.getSelectedBlock(this.state.editorState);
                                return !e || !e.getLength()
                            }
                        }, {
                            key: "isEditorFocused",
                            value: function() {
                                var e = window.getSelection().anchorNode,
                                    t = this.editorWrapper.getEditorRef();
                                return this.state.isFocus || t && t.contains(e)
                            }
                        }, {
                            key: "shouldShowSelectionPopup",
                            value: function() {
                                return this.isEditorFocused() && this.isSelectedBlockEmpty()
                            }
                        }, {
                            key: "renderSelectionPopup",
                            value: function() {
                                var e = this.props,
                                    t = e.readOnly,
                                    o = e.uploadImage,
                                    i = this.state.editorState;
                                return t || this.isLocked() ? null : _react2.default.createElement(_SelectionPopup2.default, {
                                    editor: this.editorWrapper,
                                    isEditorFocused: this.state.isFocus,
                                    editorState: i,
                                    fitLeft: this.shouldShowSelectionPopup(),
                                    wrapInsideLeft: !0,
                                    paddingLeft: PADDING_LEFT,
                                    forceVisibility: this.shouldShowSelectionPopup(),
                                    offsetLeft: AREA_OFFSET_LEFT,
                                    shouldIgnoreSelection: (0, _draftUtils.isAtomicBlockSelected)(this.state.editorState)
                                }, _react2.default.createElement(_RichEditorStylesCloud2.default, {
                                    codeEditorPlugin: this.codeEditorPlugin,
                                    currentBlock: this.getSelectedBlock(i),
                                    editorState: i,
                                    onChange: this.onChange,
                                    uploadImage: o,
                                    richEditorPlugin: this.richEditorPlugin,
                                    imagePlugin: this.imagePlugin,
                                    tablePlugin: this.tablePlugin
                                }))
                            }
                        }, {
                            key: "render",
                            value: function() {
                                var e = this.props,
                                    t = e.placeholder,
                                    o = e.readOnly,
                                    i = e.value,
                                    r = this.state.editorState,
                                    n = r.getCurrentContent(),
                                    a = (0, _classnames2.default)("custom-text-field", {
                                        empty: (0, _draftUtils.shouldHidePlaceholder)(n),
                                        active: r.getSelection().hasFocus
                                    });
                                return _react2.default.createElement("div", {
                                    className: "text-editor-wrapper",
                                    onMouseDown: this.onMouseDown
                                }, _react2.default.createElement("div", {
                                    className: a,
                                    onClick: this.focus
                                }, _react2.default.createElement(_EditorWithPlugins2.default, {
                                    editorState: r,
                                    onChange: this.onChange,
                                    onFocus: this.onFocus,
                                    onBlur: this.onBlur,
                                    placeholder: t,
                                    plugins: this.plugins,
                                    readOnly: o || this.isLocked(),
                                    ref: this.setEditorRef,
                                    spellCheck: !0,
                                    value: i
                                }), this.renderSelectionPopup()))
                            }
                        }]), t
                    }()).prototype, "focus", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "focus"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onChange", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "onChange"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onFocus", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "onFocus"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onBlur", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "onBlur"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onMouseDown", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "onMouseDown"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "setEditorRef", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "setEditorRef"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "isEditorFocused", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "isEditorFocused"), _class.prototype), _class);
                exports.default = RichTextEditor, RichTextEditor.propTypes = {
                    onChange: _propTypes2.default.func,
                    placeholder: _propTypes2.default.string,
                    readOnly: _propTypes2.default.bool,
                    value: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),
                    uploadImage: _propTypes2.default.func,
                    onUploadImage: _propTypes2.default.func
                }, RichTextEditor.defaultProps = {
                    onChange: _noop3.default,
                    onUploadImage: _noop3.default,
                    uploadImage: _noop3.default,
                    placeholder: "",
                    readOnly: !1,
                    value: ""
                }
            }, {
                "../utils/draftUtils": 38,
                "./SelectionPopup": 4,
                "./components/RichEditorStylesCloud": 5,
                "./plugins/CodeEditor/CodeEditorPlugin": 10,
                "./plugins/EditorWithPlugins": 17,
                "./plugins/Image/ImagePlugin": 18,
                "./plugins/Linkify/LinkifyPlugin": 21,
                "./plugins/RichEditor/RichEditorPlugin": 24,
                "./plugins/Table/TablePlugin": 26,
                "autobind-decorator": 43,
                classnames: 47,
                "draft-js": 61,
                "lodash/isUndefined": 395,
                "lodash/noop": 402,
                "prop-types": 435,
                react: 455
            }],
            4: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function _classCallCheck(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }

                function _possibleConstructorReturn(e, t) {
                    if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != _typeof2(t) && "function" != typeof t ? e : t
                }

                function _inherits(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(t));
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }

                function _applyDecoratedDescriptor(e, t, o, i, n) {
                    var r = {};
                    return Object.keys(i).forEach(function(e) {
                        r[e] = i[e]
                    }), r.enumerable = !!r.enumerable, r.configurable = !!r.configurable, ("value" in r || r.initializer) && (r.writable = !0), r = o.slice().reverse().reduce(function(o, i) {
                        return i(e, t, o) || o
                    }, r), n && void 0 !== r.initializer && (r.value = r.initializer ? r.initializer.call(n) : void 0, r.initializer = void 0), void 0 === r.initializer && (Object.defineProperty(e, t, r), r = null), r
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _class, _noop2 = require("lodash/noop"),
                    _noop3 = _interopRequireDefault(_noop2),
                    _isFunction2 = require("lodash/isFunction"),
                    _isFunction3 = _interopRequireDefault(_isFunction2),
                    _createClass = function() {
                        function e(e, t) {
                            for (var o = 0; o < t.length; o++) {
                                var i = t[o];
                                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                            }
                        }
                        return function(t, o, i) {
                            return o && e(t.prototype, o), i && e(t, i), t
                        }
                    }(),
                    _autobindDecorator = require("autobind-decorator"),
                    _autobindDecorator2 = _interopRequireDefault(_autobindDecorator),
                    _classnames = require("classnames"),
                    _classnames2 = _interopRequireDefault(_classnames),
                    _propTypes = require("prop-types"),
                    _propTypes2 = _interopRequireDefault(_propTypes),
                    _react = require("react"),
                    _react2 = _interopRequireDefault(_react),
                    MARGIN = 30,
                    SAFETY_OFFSET = 15,
                    WRAPPED_LEFT_POS = -10,
                    ACTION_TYPES = {
                        MOUSE: "mouse",
                        KEY: "key"
                    },
                    SelectionPopup = (_applyDecoratedDescriptor((_class = function(e) {
                        function t(e, o) {
                            _classCallCheck(this, t);
                            var i = _possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, o));
                            return i.popup = null, i.state = {
                                selection: null,
                                showPopup: !1,
                                actionType: null,
                                position: {
                                    top: 0,
                                    left: 0
                                },
                                shouldWrapLeft: !1,
                                shouldWrapRight: !1
                            }, i.checkSelectionMouse = i.checkSelection.bind(i, ACTION_TYPES.MOUSE), i.checkSelectionKey = i.checkSelection.bind(i, ACTION_TYPES.KEY), i
                        }
                        return _inherits(t, _react.Component), _createClass(t, [{
                            key: "componentWillReceiveProps",
                            value: function(e) {
                                var t = this;
                                e.forceVisibility && this.props.editorState !== e.editorState && (this.positionAnimationFrame = window.requestAnimationFrame(function() {
                                    var e = window.getSelection().anchorNode;
                                    e || t.isSelection() ? t.calculatePosition(e) : t.setState({
                                        position: null
                                    })
                                }))
                            }
                        }, {
                            key: "componentDidMount",
                            value: function() {
                                document.addEventListener("mouseup", this.checkSelectionMouse), document.addEventListener("keyup", this.checkSelectionKey), document.addEventListener("mousedown", this.handleMouseDown), this.calculatePosition(this.getArea())
                            }
                        }, {
                            key: "componentWillUnmount",
                            value: function() {
                                document.removeEventListener("mouseup", this.checkSelectionMouse), document.removeEventListener("keyup", this.checkSelectionKey), document.removeEventListener("mousedown", this.handleMouseDown), window.cancelAnimationFrame(this.positionAnimationFrame)
                            }
                        }, {
                            key: "componentWillUpdate",
                            value: function(e, t) {
                                this.state.showPopup && !t.showPopup && t.actionType !== ACTION_TYPES.KEY && this.clearSelection()
                            }
                        }, {
                            key: "getArea",
                            value: function() {
                                return this.props.editor.getEditorRef()
                            }
                        }, {
                            key: "isSelection",
                            value: function() {
                                var e = window.getSelection(),
                                    t = this.getArea();
                                if (!e || !e.rangeCount || !e.anchorNode || t && !t.contains(e.anchorNode)) return !1;
                                var o = e.getRangeAt(0),
                                    i = o.getBoundingClientRect();
                                return !o.collapsed && i.width > 0 && i.height > 0
                            }
                        }, {
                            key: "isChildComponent",
                            value: function() {
                                return !(!this.popup || !this.popup.children)
                            }
                        }, {
                            key: "checkSelection",
                            value: function(e) {
                                var t = this.getArea(),
                                    o = this.props.shouldIgnoreSelection;
                                if (t && !o) return this.isSelection() ? (this.onSelect(), void this.calculatePosition()) : void this.onDeselect(e)
                            }
                        }, {
                            key: "handleMouseDown",
                            value: function(e) {
                                var t = e.target;
                                this.state.showPopup && !this.popup.contains(t) && this.onDeselect(ACTION_TYPES.MOUSE)
                            }
                        }, {
                            key: "onSelect",
                            value: function() {
                                var e = this,
                                    t = this.props.onSelect;
                                this.setState({
                                    showPopup: !0
                                }, function() {
                                    (0, _isFunction3.default)(t) && t(), e.isSelection() ? e.calculatePosition() : e.onDeselect()
                                })
                            }
                        }, {
                            key: "onDeselect",
                            value: function(e) {
                                var t = this.props.onDeselect;
                                (this.state.showPopup || this.state.actionType !== e) && this.setState({
                                    showPopup: !1,
                                    actionType: e
                                }, function() {
                                    t()
                                })
                            }
                        }, {
                            key: "clearSelection",
                            value: function() {
                                window.getSelection().removeAllRanges(), this.setState({
                                    selection: null
                                })
                            }
                        }, {
                            key: "getBoundingRects",
                            value: function() {
                                var e = this.getArea();
                                return {
                                    popupChildBox: this.popup.children[0].getBoundingClientRect(),
                                    selectableAreaBox: e.getBoundingClientRect(),
                                    selectableAreaOffsetLeft: e.offsetLeft,
                                    selectableAreaOffsetTop: e.offsetTop
                                }
                            }
                        }, {
                            key: "calculatePosition",
                            value: function(e) {
                                var t = this;
                                window.requestAnimationFrame(function() {
                                    if (t.isChildComponent())
                                        if (t.isSelection()) {
                                            var o = window.getSelection(),
                                                i = o.getRangeAt(0).getBoundingClientRect(),
                                                n = t.getBoundingRects(),
                                                r = n.popupChildBox,
                                                s = n.selectableAreaBox,
                                                l = n.selectableAreaOffsetLeft,
                                                a = n.selectableAreaOffsetTop,
                                                p = i.top - s.top - t.props.offsetTop - a,
                                                u = i.left - s.left + (i.width / 2 - r.width / 2) + l;
                                            u = t.fitTooltip(u, i), t.setState({
                                                selection: o,
                                                position: {
                                                    top: p,
                                                    left: u
                                                }
                                            })
                                        } else if (e && e.nodeType === Node.ELEMENT_NODE) {
                                        var c = e.getBoundingClientRect(),
                                            f = t.getBoundingRects(),
                                            d = f.popupChildBox,
                                            h = f.selectableAreaBox,
                                            _ = f.selectableAreaOffsetLeft,
                                            y = f.selectableAreaOffsetTop,
                                            v = c.top - h.top - t.props.offsetTop - y,
                                            g = c.left - h.left + _;
                                        h.left + d.width > window.innerWidth ? t.setState({
                                            shouldWrapLeft: !1,
                                            shouldWrapRight: !0,
                                            position: {
                                                top: v,
                                                left: g - d.width + MARGIN
                                            }
                                        }) : t.setState({
                                            shouldWrapLeft: !0,
                                            shouldWrapRight: !1,
                                            position: {
                                                top: v,
                                                left: g
                                            }
                                        })
                                    }
                                })
                            }
                        }, {
                            key: "fitTooltip",
                            value: function(e, t) {
                                var o = this.props,
                                    i = o.fitLeft,
                                    n = o.fitRight,
                                    r = o.paddingLeft,
                                    s = o.wrapInsideLeft,
                                    l = o.canWrapInsideRight;
                                if (!i && !n && !s) return e;
                                var a = this.popup.children[0].getBoundingClientRect();
                                if (i && e < a.width / 2) return a.width / 2 + SAFETY_OFFSET;
                                var p = this.props.offsetLeft,
                                    u = window.innerWidth,
                                    c = this.getArea().getBoundingClientRect(),
                                    f = this.getArea().offsetLeft,
                                    d = s && e < -a.width / 2 + 2 * r && t.left + a.width < window.innerWidth,
                                    h = l && t.left - a.width < u && p < t.left - a.width;
                                return n && e > c.width - a.width / 2 - f ? c.width - a.width / 2 - f - SAFETY_OFFSET : d ? (this.setState({
                                    shouldWrapLeft: !0,
                                    shouldWrapRight: !1
                                }), WRAPPED_LEFT_POS + (t.left - c.left)) : h ? (this.setState({
                                    shouldWrapLeft: !1,
                                    shouldWrapRight: !0
                                }), -a.width + MARGIN + (t.left - c.left)) : (this.setState({
                                    shouldWrapLeft: !1,
                                    shouldWrapRight: !1
                                }), e)
                            }
                        }, {
                            key: "renderChildrenWithProps",
                            value: function() {
                                var e = this.props,
                                    t = e.children,
                                    o = e.forceVisibility,
                                    i = this.state,
                                    n = i.selection,
                                    r = i.showPopup,
                                    s = i.shouldWrapLeft,
                                    l = i.shouldWrapRight;
                                return _react2.default.Children.map(t, function(e) {
                                    return _react2.default.cloneElement(e, {
                                        isVisible: r || o,
                                        shouldWrapLeft: s,
                                        shouldWrapRight: l,
                                        selection: n
                                    })
                                })
                            }
                        }, {
                            key: "render",
                            value: function() {
                                var e = this,
                                    t = this.props,
                                    o = t.forceVisibility,
                                    i = t.skipAutoDisplay,
                                    n = this.state,
                                    r = n.showPopup,
                                    s = n.position;
                                if (!s) return null;
                                var l = s.top,
                                    a = s.left,
                                    p = (0, _classnames2.default)("text-styles-cloud-wrapper", {
                                        visible: r || i || o
                                    });
                                return _react2.default.createElement("div", {
                                    className: p,
                                    ref: function(t) {
                                        e.popup = t
                                    },
                                    style: {
                                        position: "absolute",
                                        top: l,
                                        left: a
                                    }
                                }, this.renderChildrenWithProps())
                            }
                        }]), t
                    }()).prototype, "handleMouseDown", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "handleMouseDown"), _class.prototype), _class);
                exports.default = SelectionPopup, SelectionPopup.propTypes = {
                    canWrapInsideRight: _propTypes2.default.bool,
                    children: _propTypes2.default.node.isRequired,
                    editor: _propTypes2.default.object.isRequired,
                    offsetTop: _propTypes2.default.number,
                    offsetLeft: _propTypes2.default.number,
                    onDeselect: _propTypes2.default.func,
                    onSelect: _propTypes2.default.func,
                    skipAutoDisplay: _propTypes2.default.bool,
                    fitRight: _propTypes2.default.bool,
                    fitLeft: _propTypes2.default.bool,
                    paddingLeft: _propTypes2.default.number,
                    wrapInsideLeft: _propTypes2.default.bool,
                    shouldIgnoreSelection: _propTypes2.default.bool
                }, SelectionPopup.defaultProps = {
                    canWrapInsideRight: !0,
                    fitRight: !0,
                    fitLeft: !0,
                    wrapInsideLeft: !1,
                    offsetTop: 40,
                    offsetLeft: 0,
                    onDeselect: _noop3.default,
                    onSelect: _noop3.default,
                    paddingLeft: 10,
                    skipAutoDisplay: !1,
                    shouldIgnoreSelection: !1
                }
            }, {
                "autobind-decorator": 43,
                classnames: 47,
                "lodash/isFunction": 385,
                "lodash/noop": 402,
                "prop-types": 435,
                react: 455
            }],
            5: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function _toConsumableArray(e) {
                    if (Array.isArray(e)) {
                        for (var t = 0, r = Array(e.length); t < e.length; t++) r[t] = e[t];
                        return r
                    }
                    return Array.from(e)
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
                var _uniqueId2 = require("lodash/uniqueId"),
                    _uniqueId3 = _interopRequireDefault(_uniqueId2),
                    _pick2 = require("lodash/pick"),
                    _pick3 = _interopRequireDefault(_pick2),
                    _propTypes = require("prop-types"),
                    _propTypes2 = _interopRequireDefault(_propTypes),
                    _react = require("react"),
                    _react2 = _interopRequireDefault(_react),
                    _draft = require("../enums/draft"),
                    _icons = require("../enums/icons"),
                    _TextStylesCloud = require("./TextStylesCloud"),
                    _TextStylesCloud2 = _interopRequireDefault(_TextStylesCloud),
                    TEXT_STYLE_OPTION_PROPS = ["active", "className", "iconSet", "parentClassName", "isVisible", "onClick", "type"],
                    RichEditorStylesCloud = function(e) {
                        var t = e.availableActionTypes,
                            r = e.codeEditorPlugin,
                            a = e.currentBlock,
                            i = e.editorState,
                            l = e.imagePlugin,
                            o = e.isVisible,
                            s = e.onChange,
                            n = e.richEditorPlugin,
                            u = e.shouldWrapLeft,
                            d = e.shouldWrapRight,
                            p = e.tablePlugin,
                            _ = e.uploadImage,
                            c = n.isActiveMap(i, [_draft.BLOCKQUOTE, _draft.BOLD, _draft.HEADER, _draft.HEADER_THREE, _draft.HEADER_TWO, _draft.ITALIC, _draft.ORDERED_LIST, _draft.STRIKETHROUGH, _draft.UNDERLINE, _draft.UNORDERED_LIST]),
                            f = function() {
                                return a && !a.getLength() && -1 === [_draft.BLOCKQUOTE, _draft.CODE_BLOCK, _draft.ORDERED_LIST, _draft.UNORDERED_LIST].indexOf(a.getType())
                            },
                            y = function(e) {
                                return function() {
                                    return s(n.toggle(i, e))
                                }
                            },
                            T = function(e) {
                                var t, r = (0, _pick3.default)(Object.assign({
                                    active: (t = e.type, c[t]),
                                    onClick: y(e.type),
                                    isVisible: function() {
                                        return !0
                                    }
                                }, e), TEXT_STYLE_OPTION_PROPS);
                                return _react2.default.createElement(_TextStylesCloud.TextStyleOption, Object.assign({
                                    key: e.type
                                }, r), e.text)
                            },
                            E = [{
                                className: "header",
                                type: _draft.HEADER,
                                text: "Header"
                            }, {
                                className: "header-2",
                                type: _draft.HEADER_TWO,
                                text: "Header two"
                            }, {
                                className: "header-3",
                                type: _draft.HEADER_THREE,
                                text: "Header three"
                            }, {
                                className: "unordered-list",
                                type: _draft.UNORDERED_LIST,
                                text: "Unordered list"
                            }, {
                                className: "ordered-list",
                                type: _draft.ORDERED_LIST,
                                text: "Ordered list"
                            }, {
                                className: "blockquote",
                                type: _draft.BLOCKQUOTE,
                                text: "Blockquote"
                            }, {
                                className: "code",
                                type: _draft.CODE_BLOCK,
                                text: "Code",
                                onClick: function() {
                                    return s(r.toggle(i))
                                },
                                active: r.isActive(i)
                            }, {
                                className: "elements-table",
                                iconSet: _icons.DS_ICON_TYPES.DS_FONT,
                                type: _draft.TABLE,
                                text: "Table",
                                onClick: function() {
                                    return s(p.insert(i))
                                },
                                isVisible: f
                            }, {
                                className: "elements-image",
                                iconSet: _icons.DS_ICON_TYPES.DS_FONT,
                                parentClassName: "item-separator left",
                                type: _draft.IMAGE,
                                text: "Image",
                                onClick: function() {
                                    var e = void 0,
                                        t = (0, _uniqueId3.default)("entity-" + Date.now()),
                                        r = _(function(r) {
                                            r && l.onUploadImage(t, e, r)
                                        }),
                                        a = r.promise,
                                        o = r.cancel;
                                    a.then(function(r) {
                                        var a = r.preview,
                                            n = r.width,
                                            u = r.height;
                                        if (a) {
                                            var d = l.insert(i, {
                                                id: t,
                                                src: a,
                                                width: n,
                                                height: u,
                                                isLoading: !0,
                                                cancelUpload: o
                                            });
                                            e = d.entityKey, s(d.editorState)
                                        }
                                    })
                                },
                                isVisible: f
                            }, {
                                className: "element-hr",
                                iconSet: _icons.DS_ICON_TYPES.DS_CUSTOM,
                                parentClassName: "item-separator right",
                                type: _draft.HORIZONTAL_RULE,
                                text: "Horizontal rule",
                                isVisible: f
                            }, {
                                className: "bold",
                                iconSet: "general",
                                type: _draft.BOLD,
                                text: "Bold"
                            }, {
                                className: "italic",
                                iconSet: "general",
                                type: _draft.ITALIC,
                                text: "Italic"
                            }, {
                                className: "underline",
                                iconSet: "general",
                                type: _draft.UNDERLINE,
                                text: "Underline"
                            }, {
                                className: "strike",
                                iconSet: "general",
                                type: _draft.STRIKETHROUGH,
                                text: "Strikethrough"
                            }];
                        return _react2.default.createElement(_TextStylesCloud2.default, {
                            isVisible: o,
                            shouldWrapLeft: u,
                            shouldWrapRight: d
                        }, E.reduce(function(e, r) {
                            return t && -1 === t.indexOf(r.type) ? e : [].concat(_toConsumableArray(e), [T(r)])
                        }, []))
                    };
                RichEditorStylesCloud.propTypes = {
                    availableActionTypes: _propTypes2.default.array,
                    codeEditorPlugin: _propTypes2.default.object,
                    currentBlock: _propTypes2.default.shape({
                        getLength: _propTypes2.default.func,
                        getType: _propTypes2.default.func
                    }).isRequired,
                    editorState: _propTypes2.default.shape().isRequired,
                    imagePlugin: _propTypes2.default.object.isRequired,
                    isVisible: _propTypes2.default.bool,
                    onChange: _propTypes2.default.func.isRequired,
                    richEditorPlugin: _propTypes2.default.object.isRequired,
                    shouldWrapLeft: _propTypes2.default.bool,
                    shouldWrapRight: _propTypes2.default.bool,
                    tablePlugin: _propTypes2.default.object.isRequired
                }, RichEditorStylesCloud.defaultProps = {
                    availableActionTypes: null,
                    isVisible: !1,
                    shouldWrapLeft: !1,
                    shouldWrapRight: !1
                }, exports.default = RichEditorStylesCloud
            }, {
                "../enums/draft": 7,
                "../enums/icons": 8,
                "./TextStylesCloud": 6,
                "lodash/pick": 405,
                "lodash/uniqueId": 417,
                "prop-types": 435,
                react: 455
            }],
            6: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function _classCallCheck(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }

                function _possibleConstructorReturn(e, t) {
                    if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != _typeof2(t) && "function" != typeof t ? e : t
                }

                function _inherits(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(t));
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = exports.TextStyleOption = void 0;
                var _createClass = function() {
                        function e(e, t) {
                            for (var o = 0; o < t.length; o++) {
                                var r = t[o];
                                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                            }
                        }
                        return function(t, o, r) {
                            return o && e(t.prototype, o), r && e(t, r), t
                        }
                    }(),
                    _classnames = require("classnames"),
                    _classnames2 = _interopRequireDefault(_classnames),
                    _propTypes = require("prop-types"),
                    _propTypes2 = _interopRequireDefault(_propTypes),
                    _react = require("react"),
                    _react2 = _interopRequireDefault(_react),
                    _icons = require("../enums/icons"),
                    TextStyleOption = exports.TextStyleOption = function(e) {
                        var t = e.active,
                            o = e.children,
                            r = e.iconSet,
                            n = e.parentClassName,
                            s = e.isVisible,
                            l = e.className,
                            a = e.onClick,
                            i = r,
                            u = _icons.DS_ICON_VARIANTS.indexOf(r) > -1 ? _icons.DS_ICON_MAP[r] + "__" + l : "icon-" + i + "-style-" + l,
                            c = (0, _classnames2.default)(u + " only-icon-font", {
                                active: t
                            });
                        return s() ? _react2.default.createElement("li", {
                            className: n
                        }, _react2.default.createElement("a", {
                            href: "#" + l,
                            className: c,
                            onMouseDown: function(e) {
                                e.preventDefault(), e.stopPropagation()
                            },
                            onClick: function(e) {
                                e.preventDefault(), e.stopPropagation(), a()
                            },
                            title: o
                        }, o)) : null
                    };
                TextStyleOption.propTypes = {
                    isVisible: _propTypes2.default.func
                }, TextStyleOption.defaultProps = {
                    iconSet: "font",
                    isVisible: function() {
                        return !0
                    }
                };
                var TextStylesCloud = function(e) {
                    function t() {
                        return _classCallCheck(this, t), _possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments))
                    }
                    return _inherits(t, _react.Component), _createClass(t, [{
                        key: "getCloudClassName",
                        value: function() {
                            var e = this.props,
                                t = e.isVisible,
                                o = e.shouldWrapLeft,
                                r = e.shouldWrapRight;
                            return (0, _classnames2.default)("text-styles-cloud cloud options-cloud", {
                                "arrow-bottom": !o && !r,
                                "arrow-bottom-left": o,
                                "arrow-bottom-right": r,
                                visible: t
                            })
                        }
                    }, {
                        key: "render",
                        value: function() {
                            var e = this.props.children;
                            return _react2.default.createElement("div", {
                                className: this.getCloudClassName(),
                                style: {
                                    zIndex: 20
                                }
                            }, _react2.default.createElement("ul", {
                                className: "options-list"
                            }, e))
                        }
                    }]), t
                }();
                exports.default = TextStylesCloud, TextStylesCloud.propTypes = {
                    isVisible: _propTypes2.default.bool,
                    shouldWrapLeft: _propTypes2.default.bool
                }, TextStylesCloud.defaultProps = {
                    isVisible: !1,
                    shouldWrapLeft: !1
                }
            }, {
                "../enums/icons": 8,
                classnames: 47,
                "prop-types": 435,
                react: 455
            }],
            7: [function(require, module, exports) {
                "use strict";
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
                var CODE_BLOCK = (exports.HANDLED = "handled", exports.NOT_HANDLED = "not-handled", exports.NEW_LINE = "\n", exports.LIST_MAX_DEPTH = 4, exports.ATOMIC = "atomic", exports.CODE_BLOCK = "code-block"),
                    HEADER = exports.HEADER = "header-three",
                    HEADER_TWO = exports.HEADER_TWO = "header-four",
                    HEADER_THREE = exports.HEADER_THREE = "header-five",
                    ORDERED_LIST = exports.ORDERED_LIST = "ordered-list-item",
                    UNORDERED_LIST = exports.UNORDERED_LIST = "unordered-list-item",
                    UNSTYLED = exports.UNSTYLED = "unstyled",
                    BLOCKQUOTE = exports.BLOCKQUOTE = "blockquote";
                exports.HORIZONTAL_RULE = "horizontal-rule", exports.IMAGE = "image", exports.TABLE = "table", exports.DRAFT_ENTITY_MUTABILITY = {
                    IMMUTABLE: "IMMUTABLE"
                }, exports.BLOCK_TYPES = [BLOCKQUOTE, CODE_BLOCK, HEADER, HEADER_TWO, HEADER_THREE, ORDERED_LIST, UNORDERED_LIST, UNSTYLED], exports.HEADER_TYPES = [HEADER, HEADER_TWO, HEADER_THREE], exports.BOLD = "BOLD", exports.CODE = "CODE", exports.ITALIC = "ITALIC", exports.UNDERLINE = "UNDERLINE", exports.STRIKETHROUGH = "STRIKETHROUGH", exports.COMMAND_BACKSPACE = "backspace", exports.COMMAND_SELECT_ALL = "select-all"
            }, {}],
            8: [function(require, module, exports) {
                "use strict";
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
                var DS_ICON_TYPES = exports.DS_ICON_TYPES = {
                    DS_CUSTOM: "DS_CUSTOM",
                    DS_FONT: "DS_FONT"
                };
                exports.DS_ICON_VARIANTS = [DS_ICON_TYPES.DS_CUSTOM, DS_ICON_TYPES.DS_FONT], exports.DS_ICON_MAP = {
                    DS_CUSTOM: "ds-icon--custom",
                    DS_FONT: "ds-icon--font"
                }
            }, {}],
            9: [function(require, module, exports) {
                "use strict";
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
                exports.DEFAULT_SYNTAX = "javascript", exports.LANGUAGES = [{
                    value: "css",
                    text: "CSS"
                }, {
                    value: "handlebars",
                    text: "Handlebars"
                }, {
                    value: "html",
                    text: "HTML"
                }, {
                    value: "jade",
                    text: "Jade"
                }, {
                    value: "java",
                    text: "Java"
                }, {
                    value: "javascript",
                    text: "JavaScript"
                }, {
                    value: "jsx",
                    text: "JSX"
                }, {
                    value: "php",
                    text: "PHP"
                }, {
                    value: "ruby",
                    text: "Ruby"
                }, {
                    value: "smarty",
                    text: "Smarty"
                }, {
                    value: "yaml",
                    text: "YAML"
                }, {
                    value: "",
                    text: "Other"
                }]
            }, {}],
            10: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function _defineProperty(e, t, r) {
                    return t in e ? Object.defineProperty(e, t, {
                        value: r,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : e[t] = r, e
                }

                function _classCallCheck(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }

                function _applyDecoratedDescriptor(e, t, r, o, i) {
                    var a = {};
                    return Object.keys(o).forEach(function(e) {
                        a[e] = o[e]
                    }), a.enumerable = !!a.enumerable, a.configurable = !!a.configurable, ("value" in a || a.initializer) && (a.writable = !0), a = r.slice().reverse().reduce(function(r, o) {
                        return o(e, t, r) || r
                    }, a), i && void 0 !== a.initializer && (a.value = a.initializer ? a.initializer.call(i) : void 0, a.initializer = void 0), void 0 === a.initializer && (Object.defineProperty(e, t, a), a = null), a
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _class, _without2 = require("lodash/without"),
                    _without3 = _interopRequireDefault(_without2),
                    _createClass = function() {
                        function e(e, t) {
                            for (var r = 0; r < t.length; r++) {
                                var o = t[r];
                                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
                            }
                        }
                        return function(t, r, o) {
                            return r && e(t.prototype, r), o && e(t, o), t
                        }
                    }(),
                    _autobindDecorator = require("autobind-decorator"),
                    _autobindDecorator2 = _interopRequireDefault(_autobindDecorator),
                    _draftJs = require("draft-js"),
                    _immutable = require("immutable"),
                    _draftUtils = require("../../../utils/draftUtils"),
                    _draft = require("../../enums/draft"),
                    _behaviors = require("./behaviors"),
                    _prismDecorator = require("./prismDecorator"),
                    _prismDecorator2 = _interopRequireDefault(_prismDecorator),
                    _CodeEditorBlock = require("./components/CodeEditorBlock"),
                    _CodeEditorBlock2 = _interopRequireDefault(_CodeEditorBlock),
                    DEFAULT_OPTIONS = {
                        indent: "  "
                    },
                    toggleBlockCode = function(e) {
                        var t = e.getSelection();
                        return t.isCollapsed() || (0, _draftUtils.isAllBlockSelected)(e) && (0, _draftUtils.hasSelectionInBlock)(e, _draft.CODE_BLOCK) ? _draftJs.RichUtils.toggleBlockType(e, _draft.CODE_BLOCK) : (0, _draftUtils.hasSelectionInBlock)(e, _draft.CODE_BLOCK) || t.isCollapsed() ? (0, _draftUtils.createBlockElementAndExtractFromSelection)(e, _draft.UNSTYLED) : (0, _behaviors.createCodeBlock)(e)
                    },
                    toggleInlineCode = function(e) {
                        return _draftJs.RichUtils.toggleInlineStyle(e, _draft.CODE)
                    },
                    CodeEditor = (_applyDecoratedDescriptor((_class = function() {
                        function e() {
                            var t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : DEFAULT_OPTIONS;
                            _classCallCheck(this, e), this.options = Object.assign({}, DEFAULT_OPTIONS, t), this.decorator = (0, _prismDecorator2.default)(), this.blockRenderMap = (0, _immutable.Map)(_defineProperty({}, _draft.CODE_BLOCK, {
                                element: "pre",
                                wrapper: null
                            })), this.listeners = [], this.customStyleMap = _defineProperty({}, _draft.CODE, {
                                backgroundColor: "#f6f6f6",
                                borderRadius: 2,
                                color: "#5d5d5d",
                                fontSize: 14,
                                padding: "4px 7px"
                            })
                        }
                        return _createClass(e, [{
                            key: "componentWillReceiveProps",
                            value: function(e) {
                                this.listeners.forEach(function(t) {
                                    return t(e)
                                })
                            }
                        }, {
                            key: "blockRendererFn",
                            value: function(e, t) {
                                var r = t.getEditorState,
                                    o = t.getProps,
                                    i = t.setEditorState;
                                if (e.getType() === _draft.CODE_BLOCK) return {
                                    component: _CodeEditorBlock2.default,
                                    props: {
                                        addEditorPropsChangedListener: this.addEditorPropsChangedListener,
                                        getEditorState: r,
                                        onChange: i,
                                        removeEditorPropsChangedListener: this.removeEditorPropsChangedListener,
                                        readOnly: o().readOnly
                                    }
                                }
                            }
                        }, {
                            key: "keyBindingFn",
                            value: function(e, t) {
                                var r = t.getEditorState;
                                if ((0, _draftUtils.hasSelectionInBlock)(r(), _draft.CODE_BLOCK)) return _draftJs.KeyBindingUtil.hasCommandModifier(e) && 65 === e.keyCode ? _draft.COMMAND_SELECT_ALL : void 0
                            }
                        }, {
                            key: "addEditorPropsChangedListener",
                            value: function(e) {
                                this.listeners.push(e)
                            }
                        }, {
                            key: "removeEditorPropsChangedListener",
                            value: function(e) {
                                this.listeners = (0, _without3.default)(this.listeners, e)
                            }
                        }, {
                            key: "handleKeyCommand",
                            value: function(e, t, r) {
                                var o = r.setEditorState;
                                if ((0, _draftUtils.hasSelectionInBlock)(t, _draft.CODE_BLOCK)) {
                                    var i = (0, _behaviors.handleKeyCommand)(e, t, this.options);
                                    if (i) return o(i), _draft.HANDLED
                                }
                            }
                        }, {
                            key: "handleReturn",
                            value: function(e, t, r) {
                                var o = r.setEditorState;
                                if ((0, _draftUtils.hasSelectionInBlock)(t, _draft.CODE_BLOCK)) return o((0, _behaviors.handleReturn)(e, t)), _draft.HANDLED
                            }
                        }, {
                            key: "onTab",
                            value: function(e, t) {
                                var r = t.getEditorState,
                                    o = t.setEditorState,
                                    i = r();
                                if ((0, _draftUtils.hasSelectionInBlock)(i, _draft.CODE_BLOCK)) {
                                    var a = (0, _behaviors.onTab)(e, i, this.options);
                                    if (a) return o(a), !0
                                }
                            }
                        }, {
                            key: "isActive",
                            value: function(e) {
                                var t = (0, _draftUtils.getSelectedBlockType)(e),
                                    r = e.getCurrentInlineStyle();
                                return t === _draft.CODE_BLOCK || r.has(_draft.CODE)
                            }
                        }, {
                            key: "toggle",
                            value: function(e) {
                                var t = e.getCurrentInlineStyle(),
                                    r = (0, _draftUtils.getSelectedBlockType)(e);
                                return t.has(_draft.CODE) ? toggleInlineCode(e) : this.options.forceInline || !(0, _draftUtils.isNewLineInSelection)(e) && !(0, _draftUtils.isAllBlockSelected)(e) && _draft.CODE_BLOCK !== r ? toggleInlineCode(e) : toggleBlockCode(e)
                            }
                        }]), e
                    }()).prototype, "blockRendererFn", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "blockRendererFn"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "addEditorPropsChangedListener", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "addEditorPropsChangedListener"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "removeEditorPropsChangedListener", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "removeEditorPropsChangedListener"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleKeyCommand", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "handleKeyCommand"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onTab", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "onTab"), _class.prototype), _class);
                exports.default = CodeEditor
            }, {
                "../../../utils/draftUtils": 38,
                "../../enums/draft": 7,
                "./behaviors": 11,
                "./components/CodeEditorBlock": 12,
                "./prismDecorator": 16,
                "autobind-decorator": 43,
                "draft-js": 61,
                immutable: 193,
                "lodash/without": 419
            }],
            11: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.createCodeBlock = exports.handleReturn = exports.handleKeyCommand = exports.onTab = void 0;
                var _endsWith2 = require("lodash/endsWith"),
                    _endsWith3 = _interopRequireDefault(_endsWith2),
                    _draftJs = require("draft-js"),
                    _draftUtils = require("../../../utils/draftUtils"),
                    _draft = require("../../enums/draft"),
                    removeIndent = function(e, t) {
                        var r = e.getCurrentContent(),
                            n = e.getSelection();
                        if (n.isCollapsed()) {
                            var o = n.getStartKey(),
                                a = n.getStartOffset(),
                                i = r.getBlockForKey(o).getText();
                            if ("" === i) {
                                var d = _draftJs.Modifier.setBlockType(r, n, _draft.UNSTYLED);
                                return _draftJs.EditorState.push(e, d, "change-block-type")
                            }
                            var s = (0, _draftUtils.detectNewLineSeparator)(i),
                                f = (0, _draftUtils.getLines)(i, s),
                                l = (0, _draftUtils.getLineAnchorForOffset)(i, a, s),
                                c = f.get(l.line).slice(0, l.offset);
                            if ((0, _endsWith3.default)(c, t)) {
                                var u = a - t.length,
                                    _ = n.merge({
                                        focusKey: o,
                                        focusOffset: u,
                                        anchorKey: o,
                                        anchorOffset: a,
                                        isBackward: !0
                                    }),
                                    g = _draftJs.Modifier.removeRange(r, _, "backward"),
                                    C = _draftJs.EditorState.push(e, g, "remove-range");
                                return _draftJs.EditorState.forceSelection(C, g.getSelectionAfter())
                            }
                        }
                    },
                    selectCurrentBlock = function(e) {
                        var t = e.getCurrentContent(),
                            r = e.getSelection(),
                            n = (0, _draftUtils.extendSelectionToWholeBlock)(r, t);
                        return _draftJs.EditorState.forceSelection(e, n)
                    },
                    getContentStateForIndent = function(e, t, r) {
                        return t.isCollapsed() ? _draftJs.Modifier.insertText(e, t, r) : _draftJs.Modifier.replaceText(e, t, r)
                    };
                exports.onTab = function(e, t, r) {
                    var n = t.getCurrentContent(),
                        o = t.getSelection(),
                        a = o.getStartKey(),
                        i = n.getBlockForKey(a),
                        d = (0, _draftUtils.getIndentation)(i.getText(), r.indent),
                        s = getContentStateForIndent(n, o, d, e.shiftKey);
                    return e.preventDefault(), e.shiftKey ? removeIndent(t, d) : _draftJs.EditorState.push(t, s, "insert-characters")
                }, exports.handleKeyCommand = function(e, t, r) {
                    switch (e) {
                        case _draft.COMMAND_BACKSPACE:
                            return removeIndent(t, r.indent);
                        case _draft.COMMAND_SELECT_ALL:
                            return selectCurrentBlock(t)
                    }
                }, exports.handleReturn = function(e, t) {
                    var r = t.getCurrentContent(),
                        n = t.getSelection();
                    if (n.isCollapsed() && _draftJs.KeyBindingUtil.hasCommandModifier(e)) {
                        var o = _draftJs.Modifier.splitBlock(r, n);
                        return _draftJs.EditorState.push(t, o, "split-block")
                    }
                    return (0, _draftUtils.insertNewLine)(t)
                }, exports.createCodeBlock = function(e) {
                    var t = (0, _draftUtils.getSelectedBlocks)(e).reduce(function(e, t) {
                            return t.getType() !== _draft.ATOMIC && e.push(t.getText()), e
                        }, []).join(_draft.NEW_LINE).trim(),
                        r = e.getSelection(),
                        n = e.getCurrentContent(),
                        o = (0, _draftUtils.extendSelectionToWholeBlock)(r, n),
                        a = _draftJs.Modifier.removeRange(e.getCurrentContent(), o, o.isBackward ? "backward" : "forward");
                    return o = a.getSelectionAfter(), a = _draftJs.Modifier.insertText(a, o, t), a = _draftJs.Modifier.setBlockType(a, o, _draft.CODE_BLOCK), _draftJs.EditorState.push(e, a, "insert-fragment")
                }
            }, {
                "../../../utils/draftUtils": 38,
                "../../enums/draft": 7,
                "draft-js": 61,
                "lodash/endsWith": 366
            }],
            12: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function _classCallCheck(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }

                function _possibleConstructorReturn(e, t) {
                    if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != _typeof2(t) && "function" != typeof t ? e : t
                }

                function _inherits(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(t));
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }

                function _applyDecoratedDescriptor(e, t, r, o, a) {
                    var n = {};
                    return Object.keys(o).forEach(function(e) {
                        n[e] = o[e]
                    }), n.enumerable = !!n.enumerable, n.configurable = !!n.configurable, ("value" in n || n.initializer) && (n.writable = !0), n = r.slice().reverse().reduce(function(r, o) {
                        return o(e, t, r) || r
                    }, n), a && void 0 !== n.initializer && (n.value = n.initializer ? n.initializer.call(a) : void 0, n.initializer = void 0), void 0 === n.initializer && (Object.defineProperty(e, t, n), n = null), n
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _class, _createClass = function() {
                        function e(e, t) {
                            for (var r = 0; r < t.length; r++) {
                                var o = t[r];
                                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
                            }
                        }
                        return function(t, r, o) {
                            return r && e(t.prototype, r), o && e(t, o), t
                        }
                    }(),
                    _autobindDecorator = require("autobind-decorator"),
                    _autobindDecorator2 = _interopRequireDefault(_autobindDecorator),
                    _draftJs = require("draft-js"),
                    _propTypes = require("prop-types"),
                    _propTypes2 = _interopRequireDefault(_propTypes),
                    _react = require("react"),
                    _react2 = _interopRequireDefault(_react),
                    _draftUtils = require("../../../../utils/draftUtils"),
                    _languages = require("../../../enums/languages"),
                    _draft = require("../../../enums/draft"),
                    _LineNumbers = require("./LineNumbers"),
                    _LineNumbers2 = _interopRequireDefault(_LineNumbers),
                    _SyntaxSelectCloud = require("./SyntaxSelectCloud"),
                    _SyntaxSelectCloud2 = _interopRequireDefault(_SyntaxSelectCloud),
                    CodeEditorBlock = (_applyDecoratedDescriptor((_class = function(e) {
                        function t(e, r) {
                            _classCallCheck(this, t);
                            var o = _possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, r));
                            return o.syntax = o.getSelectedSyntax(), o.state = {
                                readOnly: o.props.blockProps.readOnly
                            }, o
                        }
                        return _inherits(t, _react.Component), _createClass(t, [{
                            key: "componentDidMount",
                            value: function() {
                                (0, this.props.blockProps.addEditorPropsChangedListener)(this.handleEditorPropsChange)
                            }
                        }, {
                            key: "componentWillUnmount",
                            value: function() {
                                (0, this.props.blockProps.removeEditorPropsChangedListener)(this.handleEditorPropsChange)
                            }
                        }, {
                            key: "componentWillReceiveProps",
                            value: function(e) {
                                var t = e.block,
                                    r = e.blockProps,
                                    o = t.getData().get("syntax"),
                                    a = r.onChange,
                                    n = r.getEditorState;
                                o && o === this.syntax || a((0, _draftUtils.updateBlockDataSyntax)(n(), t, this.syntax))
                            }
                        }, {
                            key: "handleEditorPropsChange",
                            value: function(e) {
                                var t = e.readOnly;
                                t !== this.state.readOnly && this.setState({
                                    readOnly: t
                                })
                            }
                        }, {
                            key: "handleChange",
                            value: function(e) {
                                var t = this.props,
                                    r = t.block,
                                    o = t.blockProps,
                                    a = o.onChange,
                                    n = o.getEditorState;
                                this.syntax = e, a((0, _draftUtils.updateBlockDataSyntax)(n(), r, e))
                            }
                        }, {
                            key: "getSelectedSyntax",
                            value: function() {
                                return this.props.block.getData().get("syntax") || _languages.DEFAULT_SYNTAX
                            }
                        }, {
                            key: "render",
                            value: function() {
                                var e = this.props.block,
                                    t = this.state.readOnly;
                                return _react2.default.createElement("section", {
                                    className: "public-DraftStyleDefault-pre"
                                }, _react2.default.createElement(_LineNumbers2.default, {
                                    lineNumbers: e.getText().split(_draft.NEW_LINE).length
                                }), _react2.default.createElement(_SyntaxSelectCloud2.default, {
                                    onChange: this.handleChange,
                                    value: this.getSelectedSyntax(),
                                    readOnly: t
                                }), _react2.default.createElement(_draftJs.EditorBlock, this.props))
                            }
                        }]), t
                    }()).prototype, "handleEditorPropsChange", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "handleEditorPropsChange"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleChange", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "handleChange"), _class.prototype), _class);
                exports.default = CodeEditorBlock, CodeEditorBlock.propTypes = {
                    block: _propTypes2.default.shape({
                        getText: _propTypes2.default.func
                    }),
                    blockProps: _propTypes2.default.shape({
                        addEditorPropsChangedListener: _propTypes2.default.func.isRequired,
                        getEditorState: _propTypes2.default.func.isRequired,
                        onChange: _propTypes2.default.func.isRequired,
                        removeEditorPropsChangedListener: _propTypes2.default.func.isRequired,
                        readOnly: _propTypes2.default.bool.isRequired
                    }).isRequired
                }
            }, {
                "../../../../utils/draftUtils": 38,
                "../../../enums/draft": 7,
                "../../../enums/languages": 9,
                "./LineNumbers": 13,
                "./SyntaxSelectCloud": 15,
                "autobind-decorator": 43,
                "draft-js": 61,
                "prop-types": 435,
                react: 455
            }],
            13: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
                var _map2 = require("lodash/map"),
                    _map3 = _interopRequireDefault(_map2),
                    _propTypes = require("prop-types"),
                    _propTypes2 = _interopRequireDefault(_propTypes),
                    _react = require("react"),
                    _react2 = _interopRequireDefault(_react),
                    LineNumbers = function(e) {
                        var r = e.lineNumbers;
                        return _react2.default.createElement("section", {
                            className: "line-numbers",
                            contentEditable: !1
                        }, (0, _map3.default)(Array(r), function(e, r) {
                            return _react2.default.createElement("div", {
                                key: r
                            }, r + 1)
                        }))
                    };
                LineNumbers.propTypes = {
                    lineNumbers: _propTypes2.default.number.isRequired
                }, exports.default = LineNumbers
            }, {
                "lodash/map": 399,
                "prop-types": 435,
                react: 455
            }],
            14: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
                var _propTypes = require("prop-types"),
                    _propTypes2 = _interopRequireDefault(_propTypes),
                    _react = require("react"),
                    _react2 = _interopRequireDefault(_react),
                    PrismToken = function(e) {
                        var r = e.alias,
                            p = e.type,
                            t = e.children,
                            a = "prism-" + p,
                            s = r ? "prism-" + r : "";
                        return _react2.default.createElement("span", {
                            className: "prism-token token " + a + " " + s
                        }, t)
                    };
                PrismToken.propTypes = {
                    alias: _propTypes2.default.string,
                    type: _propTypes2.default.string,
                    children: _propTypes2.default.any
                }, PrismToken.defaultProps = {
                    alias: "",
                    type: "",
                    children: null
                }, exports.default = PrismToken
            }, {
                "prop-types": 435,
                react: 455
            }],
            15: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function _classCallCheck(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }

                function _possibleConstructorReturn(e, t) {
                    if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != _typeof2(t) && "function" != typeof t ? e : t
                }

                function _inherits(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(t));
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }

                function _applyDecoratedDescriptor(e, t, r, o, n) {
                    var a = {};
                    return Object.keys(o).forEach(function(e) {
                        a[e] = o[e]
                    }), a.enumerable = !!a.enumerable, a.configurable = !!a.configurable, ("value" in a || a.initializer) && (a.writable = !0), a = r.slice().reverse().reduce(function(r, o) {
                        return o(e, t, r) || r
                    }, a), n && void 0 !== a.initializer && (a.value = a.initializer ? a.initializer.call(n) : void 0, a.initializer = void 0), void 0 === a.initializer && (Object.defineProperty(e, t, a), a = null), a
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _class, _find2 = require("lodash/find"),
                    _find3 = _interopRequireDefault(_find2),
                    _createClass = function() {
                        function e(e, t) {
                            for (var r = 0; r < t.length; r++) {
                                var o = t[r];
                                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
                            }
                        }
                        return function(t, r, o) {
                            return r && e(t.prototype, r), o && e(t, o), t
                        }
                    }(),
                    _autobindDecorator = require("autobind-decorator"),
                    _autobindDecorator2 = _interopRequireDefault(_autobindDecorator),
                    _classnames = require("classnames"),
                    _classnames2 = _interopRequireDefault(_classnames),
                    _propTypes = require("prop-types"),
                    _propTypes2 = _interopRequireDefault(_propTypes),
                    _react = require("react"),
                    _react2 = _interopRequireDefault(_react),
                    _languages = require("../../../enums/languages"),
                    SyntaxSelectCloud = (_applyDecoratedDescriptor((_class = function(e) {
                        function t(e, r) {
                            _classCallCheck(this, t);
                            var o = _possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, r));
                            return o.state = {
                                syntax: o.props.value,
                                visible: !1
                            }, o
                        }
                        return _inherits(t, _react.Component), _createClass(t, [{
                            key: "componentWillReceiveProps",
                            value: function(e) {
                                e.value !== this.props.value && this.setState({
                                    syntax: e.value
                                }), e.readOnly && this.props.readOnly !== e.readOnly && this.hideCloud()
                            }
                        }, {
                            key: "componentWillUnmount",
                            value: function() {
                                this.removeDocumentListener()
                            }
                        }, {
                            key: "addDocumentListener",
                            value: function() {
                                document.addEventListener("click", this.handleCloudOutsideClick, !0), document.addEventListener("keydown", this.hideCloud, !0)
                            }
                        }, {
                            key: "removeDocumentListener",
                            value: function() {
                                document.removeEventListener("click", this.handleCloudOutsideClick, !0), document.removeEventListener("keydown", this.hideCloud, !0)
                            }
                        }, {
                            key: "handleItemClick",
                            value: function(e, t) {
                                var r = this;
                                e.preventDefault();
                                var o = this.props.onChange;
                                this.setState({
                                    syntax: t,
                                    visible: !1
                                }, function() {
                                    r.removeDocumentListener(), o(t)
                                })
                            }
                        }, {
                            key: "handleMouseDown",
                            value: function(e) {
                                var t = this;
                                return e.preventDefault(), this.props.readOnly ? this.hideCloud() : this.setState(function(e) {
                                    return {
                                        visible: !e.visible
                                    }
                                }, function() {
                                    t.state.visible ? t.addDocumentListener() : t.removeDocumentListener()
                                })
                            }
                        }, {
                            key: "handleCloudOutsideClick",
                            value: function(e) {
                                this.root.contains(e.target) || this.hideCloud()
                            }
                        }, {
                            key: "setRootRef",
                            value: function(e) {
                                this.root = e
                            }
                        }, {
                            key: "hideCloud",
                            value: function() {
                                var e = this;
                                this.setState({
                                    visible: !1
                                }, function() {
                                    return e.removeDocumentListener()
                                })
                            }
                        }, {
                            key: "renderOption",
                            value: function(e) {
                                var t = this,
                                    r = e.value,
                                    o = e.text,
                                    n = this.state.syntax;
                                return _react2.default.createElement("li", {
                                    key: r,
                                    className: (0, _classnames2.default)({
                                        active: r === n
                                    })
                                }, _react2.default.createElement("span", {
                                    onClick: function(e) {
                                        return t.handleItemClick(e, r)
                                    }
                                }, o))
                            }
                        }, {
                            key: "renderButton",
                            value: function() {
                                var e = this.state.syntax,
                                    t = (0, _find3.default)(_languages.LANGUAGES, {
                                        value: e
                                    });
                                return _react2.default.createElement("span", {
                                    onMouseDown: this.handleMouseDown,
                                    className: "icon-general-chevron"
                                }, t.text)
                            }
                        }, {
                            key: "renderCloud",
                            value: function() {
                                var e = this.props.readOnly,
                                    t = this.state.visible;
                                return e ? null : _react2.default.createElement("ul", {
                                    className: (0, _classnames2.default)("cloud no-info with-scroll options-cloud auto-width global-no-user-select", {
                                        visible: t
                                    })
                                }, _languages.LANGUAGES.map(this.renderOption))
                            }
                        }, {
                            key: "render",
                            value: function() {
                                var e = this.props.readOnly,
                                    t = this.state.visible,
                                    r = (0, _classnames2.default)("syntax-select", {
                                        active: !e,
                                        opened: t
                                    });
                                return _react2.default.createElement("div", {
                                    className: r,
                                    ref: this.setRootRef,
                                    contentEditable: !1
                                }, this.renderButton(), this.renderCloud())
                            }
                        }]), t
                    }()).prototype, "handleItemClick", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "handleItemClick"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleMouseDown", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "handleMouseDown"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleCloudOutsideClick", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "handleCloudOutsideClick"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "setRootRef", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "setRootRef"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "hideCloud", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "hideCloud"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "renderOption", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "renderOption"), _class.prototype), _class);
                exports.default = SyntaxSelectCloud, SyntaxSelectCloud.propTypes = {
                    onChange: _propTypes2.default.func.isRequired,
                    value: _propTypes2.default.string.isRequired,
                    readOnly: _propTypes2.default.bool.isRequired
                }
            }, {
                "../../../enums/languages": 9,
                "autobind-decorator": 43,
                classnames: 47,
                "lodash/find": 370,
                "prop-types": 435,
                react: 455
            }],
            16: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function createDecorator() {
                    return new _draftJsSimpledecorator2.default(strategy, _PrismToken2.default)
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
                var _isUndefined2 = require("lodash/isUndefined"),
                    _isUndefined3 = _interopRequireDefault(_isUndefined2),
                    _isString2 = require("lodash/isString"),
                    _isString3 = _interopRequireDefault(_isString2),
                    _isEmpty2 = require("lodash/isEmpty"),
                    _isEmpty3 = _interopRequireDefault(_isEmpty2),
                    _forEach2 = require("lodash/forEach"),
                    _forEach3 = _interopRequireDefault(_forEach2);
                exports.default = createDecorator;
                var _draftJsSimpledecorator = require("draft-js-simpledecorator"),
                    _draftJsSimpledecorator2 = _interopRequireDefault(_draftJsSimpledecorator),
                    _prismjs = require("prismjs"),
                    _prismjs2 = _interopRequireDefault(_prismjs);
                require("prismjs/components/prism-css"), require("prismjs/components/prism-handlebars"), require("prismjs/components/prism-jade"), require("prismjs/components/prism-java"), require("prismjs/components/prism-javascript"), require("prismjs/components/prism-jsx"), require("prismjs/components/prism-php"), require("prismjs/components/prism-ruby"), require("prismjs/components/prism-smarty"), require("prismjs/components/prism-yaml");
                var _PrismToken = require("./components/PrismToken"),
                    _PrismToken2 = _interopRequireDefault(_PrismToken),
                    _draft = require("../../enums/draft"),
                    _languages = require("../../enums/languages"),
                    isCodeBlock = function(e) {
                        return e.getType() === _draft.CODE_BLOCK
                    },
                    getSyntax = function(e) {
                        var r = e.getData().get("syntax");
                        return (0, _isUndefined3.default)(r) ? _languages.DEFAULT_SYNTAX : r
                    },
                    processStringToken = function(e, r, i, t) {
                        (0, _isEmpty3.default)(t) || i(r, r + e.length, t)
                    },
                    processToken = function e(r, i, t, s) {
                        if ((0, _isString3.default)(r)) return processStringToken(r, i, t, s);
                        var n = {
                            alias: r.alias,
                            type: r.type
                        };
                        return (0, _isString3.default)(r.content) ? processStringToken(r.content, i, t, n) : void(0, _forEach3.default)(r.content, function(r) {
                            e(r, i, t, n), i += r.length
                        })
                    },
                    strategy = function(e, r) {
                        if (isCodeBlock(e)) {
                            var i = 0,
                                t = _prismjs2.default.languages[getSyntax(e)];
                            t && (0, _forEach3.default)(_prismjs2.default.tokenize(e.getText(), t), function(e) {
                                processToken(e, i, r), i += e.length
                            })
                        }
                    }
            }, {
                "../../enums/draft": 7,
                "../../enums/languages": 9,
                "./components/PrismToken": 14,
                "draft-js-simpledecorator": 50,
                "lodash/forEach": 373,
                "lodash/isEmpty": 383,
                "lodash/isString": 392,
                "lodash/isUndefined": 395,
                prismjs: 432,
                "prismjs/components/prism-css": 422,
                "prismjs/components/prism-handlebars": 423,
                "prismjs/components/prism-jade": 424,
                "prismjs/components/prism-java": 425,
                "prismjs/components/prism-javascript": 426,
                "prismjs/components/prism-jsx": 427,
                "prismjs/components/prism-php": 428,
                "prismjs/components/prism-ruby": 429,
                "prismjs/components/prism-smarty": 430,
                "prismjs/components/prism-yaml": 431
            }],
            17: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function _toConsumableArray(e) {
                    if (Array.isArray(e)) {
                        for (var t = 0, r = Array(e.length); t < e.length; t++) r[t] = e[t];
                        return r
                    }
                    return Array.from(e)
                }

                function _classCallCheck(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }

                function _possibleConstructorReturn(e, t) {
                    if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != _typeof2(t) && "function" != typeof t ? e : t
                }

                function _inherits(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(t));
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }

                function _applyDecoratedDescriptor(e, t, r, o, n) {
                    var i = {};
                    return Object.keys(o).forEach(function(e) {
                        i[e] = o[e]
                    }), i.enumerable = !!i.enumerable, i.configurable = !!i.configurable, ("value" in i || i.initializer) && (i.writable = !0), i = r.slice().reverse().reduce(function(r, o) {
                        return o(e, t, r) || r
                    }, i), n && void 0 !== i.initializer && (i.value = i.initializer ? i.initializer.call(n) : void 0, i.initializer = void 0), void 0 === i.initializer && (Object.defineProperty(e, t, i), i = null), i
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _class, _startsWith2 = require("lodash/startsWith"),
                    _startsWith3 = _interopRequireDefault(_startsWith2),
                    _some2 = require("lodash/some"),
                    _some3 = _interopRequireDefault(_some2),
                    _omit2 = require("lodash/omit"),
                    _omit3 = _interopRequireDefault(_omit2),
                    _mapValues2 = require("lodash/mapValues"),
                    _mapValues3 = _interopRequireDefault(_mapValues2),
                    _isUndefined2 = require("lodash/isUndefined"),
                    _isUndefined3 = _interopRequireDefault(_isUndefined2),
                    _isFunction2 = require("lodash/isFunction"),
                    _isFunction3 = _interopRequireDefault(_isFunction2),
                    _createClass = function() {
                        function e(e, t) {
                            for (var r = 0; r < t.length; r++) {
                                var o = t[r];
                                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
                            }
                        }
                        return function(t, r, o) {
                            return r && e(t.prototype, r), o && e(t, o), t
                        }
                    }(),
                    _autobindDecorator = require("autobind-decorator"),
                    _autobindDecorator2 = _interopRequireDefault(_autobindDecorator),
                    _draftJs = require("draft-js"),
                    _immutable = require("immutable"),
                    _propTypes = require("prop-types"),
                    _propTypes2 = _interopRequireDefault(_propTypes),
                    _react = require("react"),
                    _react2 = _interopRequireDefault(_react),
                    _MultiDecorator = require("./core/MultiDecorator"),
                    _MultiDecorator2 = _interopRequireDefault(_MultiDecorator),
                    _draft = require("../enums/draft"),
                    PLUGIN_METHODS = ["blockRendererFn", "blockStyleFn", "handleReturn", "handleKeyCommand", "handleBeforeInput", "handlePastedText", "handlePastedFiles", "handleDroppedFiles", "handleDrop", "onEscape", "onTab", "onUpArrow", "onDownArrow"],
                    isEventHook = function(e) {
                        return (0, _startsWith3.default)(e, "on")
                    },
                    isHandleHook = function(e) {
                        return (0, _startsWith3.default)(e, "handle")
                    },
                    EditorWithPlugins = (_applyDecoratedDescriptor((_class = function(e) {
                        function t() {
                            return _classCallCheck(this, t), _possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments))
                        }
                        return _inherits(t, _react.Component), _createClass(t, [{
                            key: "componentWillMount",
                            value: function() {
                                this.appendDecorator(this.props)
                            }
                        }, {
                            key: "componentDidMount",
                            value: function() {
                                this.props.plugins.filter(function(e) {
                                    return !(0, _isUndefined3.default)(e.componentDidMount)
                                }).forEach(function(e) {
                                    return e.componentDidMount()
                                })
                            }
                        }, {
                            key: "componentWillUnmount",
                            value: function() {
                                this.props.plugins.filter(function(e) {
                                    return !(0, _isUndefined3.default)(e.componentWillUnmount)
                                }).forEach(function(e) {
                                    return e.componentWillUnmount()
                                })
                            }
                        }, {
                            key: "componentWillReceiveProps",
                            value: function(e) {
                                var t = this;
                                e.plugins.filter(function(e) {
                                    return !(0, _isUndefined3.default)(e.componentWillReceiveProps)
                                }).forEach(function(r) {
                                    (0, _isUndefined3.default)(r.props) || (r.props = t.props), r.componentWillReceiveProps(e)
                                }), e.editorState.getDecorator() || this.appendDecorator(e)
                            }
                        }, {
                            key: "appendDecorator",
                            value: function(e) {
                                var t = e.editorState,
                                    r = e.plugins;
                                (0, e.onChange)(_draftJs.EditorState.set(t, {
                                    decorator: _MultiDecorator2.default.fromPlugins(r, this.getPluginsProps())
                                }))
                            }
                        }, {
                            key: "getEditorRef",
                            value: function() {
                                return this.editor
                            }
                        }, {
                            key: "setEditorRef",
                            value: function(e) {
                                this.editor = e
                            }
                        }, {
                            key: "getEditorState",
                            value: function() {
                                return this.props.editorState
                            }
                        }, {
                            key: "getProps",
                            value: function() {
                                return this.props
                            }
                        }, {
                            key: "getPluginsProps",
                            value: function() {
                                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
                                return [].concat(_toConsumableArray(e), [{
                                    setEditorState: this.props.onChange,
                                    getEditorState: this.getEditorState,
                                    getProps: this.getProps
                                }])
                            }
                        }, {
                            key: "createEventHook",
                            value: function(e) {
                                var t = this;
                                return function() {
                                    for (var r = arguments.length, o = Array(r), n = 0; n < r; n++) o[n] = arguments[n];
                                    var i = t.getPluginsProps(o);
                                    return (0, _some3.default)(e, function(e) {
                                        return e.apply(void 0, _toConsumableArray(i))
                                    })
                                }
                            }
                        }, {
                            key: "createHandleHook",
                            value: function(e) {
                                var t = this;
                                return function() {
                                    for (var r = arguments.length, o = Array(r), n = 0; n < r; n++) o[n] = arguments[n];
                                    var i = t.getPluginsProps(o);
                                    return (0, _some3.default)(e, function(e) {
                                        return e.apply(void 0, _toConsumableArray(i)) === _draft.HANDLED
                                    }) ? _draft.HANDLED : _draft.NOT_HANDLED
                                }
                            }
                        }, {
                            key: "createFnHook",
                            value: function(e, t) {
                                var r = this;
                                return function() {
                                    for (var o = arguments.length, n = Array(o), i = 0; i < o; i++) n[i] = arguments[i];
                                    var a = r.getPluginsProps(n);
                                    if ("blockRendererFn" === t) {
                                        var u = {
                                            props: {}
                                        };
                                        return e.forEach(function(e) {
                                            var t = e.apply(void 0, _toConsumableArray(a));
                                            if (t) {
                                                var r = t.props,
                                                    o = (0, _omit3.default)(t, "props"),
                                                    n = u.props,
                                                    i = (0, _omit3.default)(u, "props");
                                                u = Object.assign({}, i, o, {
                                                    props: Object.assign({}, n, r)
                                                })
                                            }
                                        }), !!u.component && u
                                    }
                                    if ("blockStyleFn" === t) {
                                        var s = void 0;
                                        return e.forEach(function(e) {
                                            var t = e.apply(void 0, _toConsumableArray(a));
                                            t && (s = (s ? s + " " : "") + t)
                                        }), s || !1
                                    }
                                    var l = !1;
                                    return e.some(function(e) {
                                        return void 0 !== (l = e.apply(void 0, _toConsumableArray(a)))
                                    }), l || !1
                                }
                            }
                        }, {
                            key: "createEditorHooks",
                            value: function(e) {
                                var t = this;
                                return (0, _mapValues3.default)(e, function(e, r) {
                                    return isEventHook(r) ? t.createEventHook(e) : isHandleHook(r) ? t.createHandleHook(e) : t.createFnHook(e, r)
                                })
                            }
                        }, {
                            key: "keyBindingFn",
                            value: function(e) {
                                var t = this,
                                    r = this.props.plugins,
                                    o = !1;
                                return r.filter(function(e) {
                                    return !(0, _isUndefined3.default)(e.keyBindingFn)
                                }).some(function(r) {
                                    return o = r.keyBindingFn.apply(r, _toConsumableArray(t.getPluginsProps([e])))
                                }), o || (0, _draftJs.getDefaultKeyBinding)(e)
                            }
                        }, {
                            key: "getPluginsHooks",
                            value: function() {
                                var e = this.props.plugins,
                                    t = {};
                                return e.forEach(function(e) {
                                    PLUGIN_METHODS.forEach(function(r) {
                                        (0, _isFunction3.default)(e[r]) && (t[r] || (t[r] = []), t[r].push(e[r]))
                                    })
                                }), this.createEditorHooks(t)
                            }
                        }, {
                            key: "resolveCustomStyleMap",
                            value: function() {
                                var e = this.props,
                                    t = e.customStyleMap;
                                return e.plugins.filter(function(e) {
                                    return !(0, _isUndefined3.default)(e.customStyleMap)
                                }).map(function(e) {
                                    return e.customStyleMap
                                }).concat([t]).reduce(function(e, t) {
                                    return Object.assign({}, e, t)
                                })
                            }
                        }, {
                            key: "resolveBlockRenderMap",
                            value: function() {
                                var e = this.props,
                                    t = e.blockRenderMap,
                                    r = e.defaultBlockRenderMap,
                                    o = e.plugins.filter(function(e) {
                                        return !(0, _isUndefined3.default)(e.blockRenderMap)
                                    }).concat([t]).reduce(function(e, t) {
                                        return e.merge(t.blockRenderMap)
                                    }, (0, _immutable.Map)({}));
                                return r ? _draftJs.DefaultDraftBlockRenderMap.merge(o) : o
                            }
                        }, {
                            key: "render",
                            value: function() {
                                return _react2.default.createElement(_draftJs.Editor, Object.assign({}, this.props, this.getPluginsHooks(), {
                                    keyBindingFn: this.keyBindingFn,
                                    blockRenderMap: this.resolveBlockRenderMap(),
                                    customStyleMap: this.resolveCustomStyleMap(),
                                    editorState: this.props.editorState,
                                    ref: this.setEditorRef
                                }))
                            }
                        }]), t
                    }()).prototype, "setEditorRef", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "setEditorRef"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "getEditorState", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "getEditorState"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "getProps", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "getProps"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "keyBindingFn", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "keyBindingFn"), _class.prototype), _class);
                exports.default = EditorWithPlugins, EditorWithPlugins.propTypes = {
                    blockRenderMap: _propTypes2.default.object,
                    customStyleMap: _propTypes2.default.object,
                    defaultBlockRenderMap: _propTypes2.default.bool,
                    editorState: _propTypes2.default.object.isRequired,
                    onChange: _propTypes2.default.func.isRequired,
                    plugins: _propTypes2.default.array
                }, EditorWithPlugins.defaultProps = {
                    blockRenderMap: {},
                    customStyleMap: {},
                    defaultBlockRenderMap: !0,
                    plugins: []
                }
            }, {
                "../enums/draft": 7,
                "./core/MultiDecorator": 32,
                "autobind-decorator": 43,
                "draft-js": 61,
                immutable: 193,
                "lodash/isFunction": 385,
                "lodash/isUndefined": 395,
                "lodash/mapValues": 400,
                "lodash/omit": 404,
                "lodash/some": 409,
                "lodash/startsWith": 410,
                "prop-types": 435,
                react: 455
            }],
            18: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function _classCallCheck(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }

                function _applyDecoratedDescriptor(e, t, a, r, o) {
                    var i = {};
                    return Object.keys(r).forEach(function(e) {
                        i[e] = r[e]
                    }), i.enumerable = !!i.enumerable, i.configurable = !!i.configurable, ("value" in i || i.initializer) && (i.writable = !0), i = a.slice().reverse().reduce(function(a, r) {
                        return r(e, t, a) || a
                    }, i), o && void 0 !== i.initializer && (i.value = i.initializer ? i.initializer.call(o) : void 0, i.initializer = void 0), void 0 === i.initializer && (Object.defineProperty(e, t, i), i = null), i
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _class, _reduce2 = require("lodash/reduce"),
                    _reduce3 = _interopRequireDefault(_reduce2),
                    _forEach2 = require("lodash/forEach"),
                    _forEach3 = _interopRequireDefault(_forEach2),
                    _createClass = function() {
                        function e(e, t) {
                            for (var a = 0; a < t.length; a++) {
                                var r = t[a];
                                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                            }
                        }
                        return function(t, a, r) {
                            return a && e(t.prototype, a), r && e(t, r), t
                        }
                    }(),
                    _autobindDecorator = require("autobind-decorator"),
                    _autobindDecorator2 = _interopRequireDefault(_autobindDecorator),
                    _draftJs = require("draft-js"),
                    _draft = require("../../enums/draft"),
                    _draftUtils = require("../../../utils/draftUtils"),
                    _behaviors = require("./behaviors"),
                    _Image = require("./components/Image"),
                    _Image2 = _interopRequireDefault(_Image),
                    ImagePlugin = (_applyDecoratedDescriptor((_class = function() {
                            function e(t) {
                                _classCallCheck(this, e), this.props = {}, this.getEditorState = t.getEditorState, this.isReadOnly = t.isReadOnly, this.isEditorFocused = t.isEditorFocused, this.isEditorLocked = t.isEditorLocked, this.getMainEditor = t.getMainEditor, this.onChange = t.onChange, this.onUpload = t.onUpload, this.selectedImageKey = null
                            }
                            return _createClass(e, [{
                                key: "componentWillReceiveProps",
                                value: function(e) {
                                    var t = this;
                                    if (!e.readOnly && this.props.value && e.value && this.props.value !== e.value) {
                                        var a = this.getChangedImageEntitiesData(this.props.value, e.value);
                                        (0, _forEach3.default)(a, function(e) {
                                            var a = (0, _draftUtils.findImageEntityById)(t.getEditorState(), e.id),
                                                r = a.entity,
                                                o = a.entityKey;
                                            if (r) {
                                                var i = r.getData().src;
                                                e.src !== i && t.replaceEntityData(o, e)
                                            }
                                        })
                                    }
                                }
                            }, {
                                key: "removeImage",
                                value: function() {
                                    this.onChange((0, _behaviors.removeImage)(this.getEditorState(), this.imageSelection)), this.selectedImageKey = null, this.imageSelection = null
                                }
                            }, {
                                key: "handleImageClick",
                                value: function(e) {
                                    !this.selectedImageKey || e.target.className.contains("editor-image") || e.target.className.contains("editor-image-wrapper") || this.unselectImage()
                                }
                            }, {
                                key: "handleKeyDown",
                                value: function(e) {
                                    (!e.metaKey && !e.ctrlKey || "c" !== e.key && "x" !== e.key) && this.selectedImageKey && (e.keyCode >= 48 && e.keyCode <= 57 || e.keyCode >= 65 && e.keyCode <= 90 || e.keyCode >= 96 && e.keyCode <= 105 || e.keyCode >= 186 && e.keyCode <= 222) && (e.stopImmediatePropagation(), this.removeImage())
                                }
                            }, {
                                key: "keyBindingFn",
                                value: function(e) {
                                    if (this.selectedImageKey && ("Backspace" === e.key || "Delete" === e.key || "Enter" === e.key)) return this.removeImage(), "abort"
                                }
                            }, {
                                key: "componentDidMount",
                                value: function() {
                                    this.isComponentMounted = !0, document.addEventListener("mousedown", this.handleImageClick), window.addEventListener("keydown", this.handleKeyDown, !0)
                                }
                            }, {
                                key: "componentWillUnmount",
                                value: function() {
                                    this.isComponentMounted = !1;
                                    var e = (0, _draftUtils.findNotLoadedImageEntities)(this.getEditorState());
                                    (0, _forEach3.default)(e, function(e) {
                                        var t = e.entity,
                                            a = e.entityKey;
                                        _draftJs.Entity.replaceData(a, Object.assign({}, t.getData(), {
                                            shouldPreventCancel: !0
                                        }))
                                    }), document.removeEventListener("mousedown", this.handleImageClick), window.removeEventListener("keydown", this.handleKeyDown, !0)
                                }
                            }, {
                                key: "getChangedImageEntitiesData",
                                value: function(e, t) {
                                    return e.entityMap && t.entityMap ? (0, _reduce3.default)(t.entityMap, function(t, a, r) {
                                        var o = e.entityMap[r];
                                        return o && a && o.data.isLoading && !a.data.isLoading && a.type === _draft.IMAGE && t.push(a.data), t
                                    }, []) : []
                                }
                            }, {
                                key: "replaceEntityData",
                                value: function(e, t) {
                                    if (this.isEditorLocked()) _draftJs.Entity.replaceData(e, t);
                                    else if (this.isEditorFocused()) _draftJs.Entity.replaceData(e, t), this.onChange(_draftJs.EditorState.forceSelection(this.getEditorState(), this.getEditorState().getSelection()), !0);
                                    else {
                                        var a = this.getEditorState().getCurrentContent();
                                        this.onChange(_draftJs.EditorState.createWithContent(a.replaceEntityData(e, t)), !0)
                                    }
                                }
                            }, {
                                key: "onUploadImage",
                                value: function(e, t, a) {
                                    var r = {
                                        id: e,
                                        src: a.url,
                                        isLoading: !1,
                                        width: a.width,
                                        height: a.height
                                    };
                                    return this.isComponentMounted ? this.replaceEntityData(t, r) : this.onUpload(e, r)
                                }
                            }, {
                                key: "selectImage",
                                value: function(e) {
                                    var t = e.getKey(),
                                        a = _draftJs.SelectionState.createEmpty(t);
                                    this.imageSelection = a.merge({
                                        anchorKey: t,
                                        anchorOffset: 0,
                                        focusKey: t,
                                        focusOffset: e.getLength(),
                                        isBackward: !1,
                                        hasFocus: !1
                                    });
                                    var r = _draftJs.EditorState.forceSelection(this.getEditorState(), this.imageSelection);
                                    this.selectedImageKey = t, this.onChange(r), window.getSelection().removeAllRanges()
                                }
                            }, {
                                key: "unselectImage",
                                value: function() {
                                    if (this.selectedImageKey) return this.selectedImageKey = null, this.onChange(_draftJs.EditorState.forceSelection(this.getEditorState(), this.getEditorState().getSelection()))
                                }
                            }, {
                                key: "blockRendererFn",
                                value: function(e, t) {
                                    var a = t.getEditorState;
                                    if (e.getType() === _draft.ATOMIC) {
                                        var r = a().getCurrentContent(),
                                            o = e.getEntityAt(0);
                                        if (!o) return null;
                                        if (r.getEntity(o).getType() === _draft.IMAGE) return {
                                            component: _Image2.default,
                                            editable: !1,
                                            props: {
                                                block: e,
                                                editorState: a(),
                                                readOnly: this.isReadOnly(),
                                                selectedImageKey: this.selectedImageKey,
                                                selectImage: this.selectImage
                                            }
                                        }
                                    }
                                }
                            }, {
                                key: "insert",
                                value: function(e) {
                                    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                                    return (0, _behaviors.insertImage)(e, t)
                                }
                            }]), e
                        }()).prototype, "handleImageClick", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "handleImageClick"), _class.prototype),
                        _applyDecoratedDescriptor(_class.prototype, "handleKeyDown", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "handleKeyDown"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "keyBindingFn", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "keyBindingFn"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onUploadImage", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "onUploadImage"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "selectImage", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "selectImage"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "unselectImage", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "unselectImage"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "blockRendererFn", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "blockRendererFn"), _class.prototype), _class);
                exports.default = ImagePlugin
            }, {
                "../../../utils/draftUtils": 38,
                "../../enums/draft": 7,
                "./behaviors": 19,
                "./components/Image": 20,
                "autobind-decorator": 43,
                "draft-js": 61,
                "lodash/forEach": 373,
                "lodash/reduce": 407
            }],
            19: [function(require, module, exports) {
                "use strict";
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.removeImage = exports.insertImage = void 0;
                var _draftJs = require("draft-js"),
                    _immutable = require("immutable"),
                    _draft = require("../../enums/draft");
                exports.insertImage = function(e, t) {
                    var r = e.getCurrentContent(),
                        a = r.createEntity(_draft.IMAGE, _draft.DRAFT_ENTITY_MUTABILITY.IMMUTABLE, t).getLastCreatedEntityKey(),
                        i = _draftJs.CharacterMetadata.create({
                            entity: a
                        }),
                        n = [new _draftJs.ContentBlock({
                            key: (0, _draftJs.genKey)(),
                            type: _draft.ATOMIC,
                            text: " ",
                            characterList: (0, _immutable.List)((0, _immutable.Repeat)(i, 1))
                        }), new _draftJs.ContentBlock({
                            key: (0, _draftJs.genKey)(),
                            type: _draft.UNSTYLED,
                            text: "",
                            characterList: (0, _immutable.List)()
                        })],
                        o = (0, _immutable.OrderedMap)(n.map(function(e) {
                            return [e.getKey(), e]
                        })),
                        d = _draftJs.Modifier.replaceWithFragment(r, e.getSelection(), o);
                    return {
                        editorState: _draftJs.EditorState.push(e, d, "insert-fragment"),
                        entityKey: a
                    }
                }, exports.removeImage = function(e, t) {
                    var r = _draftJs.Modifier.removeRange(e.getCurrentContent(), t, "forward"),
                        a = _draftJs.Modifier.setBlockType(r, r.getSelectionAfter(), "unstyled"),
                        i = _draftJs.EditorState.push(e, a, "remove-range");
                    return _draftJs.EditorState.forceSelection(i, i.getSelection())
                }
            }, {
                "../../enums/draft": 7,
                "draft-js": 61,
                immutable: 193
            }],
            20: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function _classCallCheck(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }

                function _possibleConstructorReturn(e, t) {
                    if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != _typeof2(t) && "function" != typeof t ? e : t
                }

                function _inherits(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(t));
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }

                function _applyDecoratedDescriptor(e, t, r, a, o) {
                    var i = {};
                    return Object.keys(a).forEach(function(e) {
                        i[e] = a[e]
                    }), i.enumerable = !!i.enumerable, i.configurable = !!i.configurable, ("value" in i || i.initializer) && (i.writable = !0), i = r.slice().reverse().reduce(function(r, a) {
                        return a(e, t, r) || r
                    }, i), o && void 0 !== i.initializer && (i.value = i.initializer ? i.initializer.call(o) : void 0, i.initializer = void 0), void 0 === i.initializer && (Object.defineProperty(e, t, i), i = null), i
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _class, _isFunction2 = require("lodash/isFunction"),
                    _isFunction3 = _interopRequireDefault(_isFunction2),
                    _createClass = function() {
                        function e(e, t) {
                            for (var r = 0; r < t.length; r++) {
                                var a = t[r];
                                a.enumerable = a.enumerable || !1, a.configurable = !0, "value" in a && (a.writable = !0), Object.defineProperty(e, a.key, a)
                            }
                        }
                        return function(t, r, a) {
                            return r && e(t.prototype, r), a && e(t, a), t
                        }
                    }(),
                    _autobindDecorator = require("autobind-decorator"),
                    _autobindDecorator2 = _interopRequireDefault(_autobindDecorator),
                    _classnames = require("classnames"),
                    _classnames2 = _interopRequireDefault(_classnames),
                    _propTypes = require("prop-types"),
                    _propTypes2 = _interopRequireDefault(_propTypes),
                    _react = require("react"),
                    _react2 = _interopRequireDefault(_react),
                    Image = (_applyDecoratedDescriptor((_class = function(e) {
                        function t() {
                            return _classCallCheck(this, t), _possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments))
                        }
                        return _inherits(t, _react.Component), _createClass(t, [{
                            key: "componentWillUnmount",
                            value: function() {
                                var e = this.getEntityData(),
                                    t = e.cancelUpload,
                                    r = e.shouldPreventCancel;
                                (0, _isFunction3.default)(t) && !r && t()
                            }
                        }, {
                            key: "getEntityData",
                            value: function() {
                                var e = this.props,
                                    t = e.block;
                                return e.contentState.getEntity(t.getEntityAt(0)).getData()
                            }
                        }, {
                            key: "selectImage",
                            value: function(e) {
                                e.preventDefault();
                                var t = this.props.block,
                                    r = this.props.blockProps,
                                    a = r.readOnly,
                                    o = r.selectImage;
                                a || o(t)
                            }
                        }, {
                            key: "render",
                            value: function() {
                                var e = this.getEntityData(),
                                    t = e.isLoading,
                                    r = e.src,
                                    a = e.width,
                                    o = e.height,
                                    i = this.props.blockProps,
                                    n = i.readOnly,
                                    s = i.selectedImageKey,
                                    l = this.props.block,
                                    c = (0, _classnames2.default)("editor-image-wrapper", {
                                        loading: t
                                    }, {
                                        selected: !n && s === l.getKey()
                                    });
                                return _react2.default.createElement("div", {
                                    className: c
                                }, _react2.default.createElement("img", {
                                    onClick: this.selectImage,
                                    className: "editor-image",
                                    src: r,
                                    width: a,
                                    height: o,
                                    alt: ""
                                }))
                            }
                        }]), t
                    }()).prototype, "selectImage", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "selectImage"), _class.prototype), _class);
                exports.default = Image, Image.propTypes = {
                    block: _propTypes2.default.shape({
                        getEntityAt: _propTypes2.default.func
                    }).isRequired,
                    blockProps: _propTypes2.default.shape({
                        readOnly: _propTypes2.default.bool,
                        selectImage: _propTypes2.default.func,
                        selectedImageKey: _propTypes2.default.string
                    }).isRequired,
                    contentState: _propTypes2.default.shape({
                        getEntity: _propTypes2.default.func.isRequired
                    }).isRequired
                }
            }, {
                "autobind-decorator": 43,
                classnames: 47,
                "lodash/isFunction": 385,
                "prop-types": 435,
                react: 455
            }],
            21: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function _classCallCheck(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _react = require("react"),
                    _Link = (_interopRequireDefault(_react), require("./components/Link")),
                    _Link2 = _interopRequireDefault(_Link),
                    _strategy = require("./strategy"),
                    _strategy2 = _interopRequireDefault(_strategy),
                    LinkifyPlugin = function e() {
                        _classCallCheck(this, e), this.decorator = {
                            strategy: _strategy2.default,
                            component: _Link2.default
                        }
                    };
                exports.default = LinkifyPlugin
            }, {
                "./components/Link": 22,
                "./strategy": 23,
                react: 455
            }],
            22: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
                var _linkifyIt = require("linkify-it"),
                    _linkifyIt2 = _interopRequireDefault(_linkifyIt),
                    _propTypes = require("prop-types"),
                    _propTypes2 = _interopRequireDefault(_propTypes),
                    _react = require("react"),
                    _react2 = _interopRequireDefault(_react),
                    linkify = (0, _linkifyIt2.default)(),
                    Link = function(e) {
                        var r = e.children,
                            t = e.decoratedText,
                            i = linkify.match(t),
                            n = i && i[0] ? i[0].url : "";
                        return _react2.default.createElement("a", {
                            href: n,
                            target: "_blank"
                        }, r)
                    };
                Link.propTypes = {
                    decoratedText: _propTypes2.default.string,
                    children: _propTypes2.default.node
                }, Link.defaultProps = {
                    decoratedText: "",
                    children: null
                }, exports.default = Link
            }, {
                "linkify-it": 195,
                "prop-types": 435,
                react: 455
            }],
            23: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
                var _forEach2 = require("lodash/forEach"),
                    _forEach3 = _interopRequireDefault(_forEach2),
                    _linkifyIt = require("linkify-it"),
                    _linkifyIt2 = _interopRequireDefault(_linkifyIt),
                    _draft = require("../../enums/draft"),
                    linkify = (0, _linkifyIt2.default)(),
                    strategy = function(e, t) {
                        if (e.getType() !== _draft.CODE_BLOCK) {
                            var r = linkify.match(e.get("text"));
                            (0, _forEach3.default)(r, function(e) {
                                t(e.index, e.lastIndex)
                            })
                        }
                    };
                exports.default = strategy
            }, {
                "../../enums/draft": 7,
                "linkify-it": 195,
                "lodash/forEach": 373
            }],
            24: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function _defineProperty(e, t, r) {
                    return t in e ? Object.defineProperty(e, t, {
                        value: r,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : e[t] = r, e
                }

                function _classCallCheck(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _reduce2 = require("lodash/reduce"),
                    _reduce3 = _interopRequireDefault(_reduce2),
                    _includes2 = require("lodash/includes"),
                    _includes3 = _interopRequireDefault(_includes2),
                    _createClass = function() {
                        function e(e, t) {
                            for (var r = 0; r < t.length; r++) {
                                var n = t[r];
                                n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(e, n.key, n)
                            }
                        }
                        return function(t, r, n) {
                            return r && e(t.prototype, r), n && e(t, n), t
                        }
                    }(),
                    _draftJs = require("draft-js"),
                    _immutable = require("immutable"),
                    _react = require("react"),
                    _react2 = _interopRequireDefault(_react),
                    _draftUtils = require("../../../utils/draftUtils"),
                    _draft = require("../../enums/draft"),
                    _behaviors = require("./behaviors"),
                    isBlockType = function(e) {
                        return (0, _includes3.default)(_draft.BLOCK_TYPES, e)
                    },
                    isHeaderType = function(e) {
                        return (0, _includes3.default)(_draft.HEADER_TYPES, e)
                    },
                    HorizontalRule = function() {
                        return _react2.default.createElement("hr", null)
                    },
                    RichEditorPlugin = function() {
                        function e() {
                            _classCallCheck(this, e), this.blockRenderMap = (0, _immutable.Map)(_defineProperty({}, _draft.BLOCKQUOTE, {
                                element: "blockquote",
                                wrapper: _react2.default.createElement("div", {
                                    className: "blockquote-wrapper"
                                })
                            })), this.customStyleMap = _defineProperty({}, _draft.STRIKETHROUGH, {
                                textDecoration: "line-through"
                            })
                        }
                        return _createClass(e, [{
                            key: "blockRendererFn",
                            value: function(e, t) {
                                var r = t.getEditorState;
                                if (e.getType() === _draft.ATOMIC) {
                                    var n = r().getCurrentContent(),
                                        a = e.getEntityAt(0);
                                    if (!a) return null;
                                    if (n.getEntity(a).getType() === _draft.HORIZONTAL_RULE) return {
                                        component: HorizontalRule,
                                        editable: !1
                                    }
                                }
                            }
                        }, {
                            key: "handleKeyCommand",
                            value: function(e, t, r) {
                                var n = r.setEditorState,
                                    a = _draftJs.RichUtils.handleKeyCommand(t, e);
                                if (a) return n(a), _draft.HANDLED
                            }
                        }, {
                            key: "onTab",
                            value: function(e, t) {
                                var r = t.getEditorState;
                                return (0, t.setEditorState)(_draftJs.RichUtils.onTab(e, r(), _draft.LIST_MAX_DEPTH)), _draft.HANDLED
                            }
                        }, {
                            key: "isActiveMap",
                            value: function(e, t) {
                                var r = (0, _draftUtils.getSelectedBlockType)(e),
                                    n = e.getCurrentInlineStyle();
                                return (0, _reduce3.default)(t, function(e, t) {
                                    return Object.assign({}, e, _defineProperty({}, t, isBlockType(t) ? function(e) {
                                        return r === e
                                    }(t) : (a = t, n.has(a))));
                                    var a
                                }, {})
                            }
                        }, {
                            key: "toggle",
                            value: function(e, t) {
                                return t === _draft.HORIZONTAL_RULE ? (0, _behaviors.insertHorizontalRule)(e) : isHeaderType(t) ? (0, _behaviors.toggleHeader)(e, t) : isBlockType(t) ? _draftJs.RichUtils.toggleBlockType(e, t) : _draftJs.RichUtils.toggleInlineStyle(e, t)
                            }
                        }, {
                            key: "handlePastedText",
                            value: function(e, t, r, n) {
                                var a = (0, n.getProps)().onChange,
                                    i = _draftJs.ContentState.createFromText(e, null).blockMap,
                                    u = _draftJs.Modifier.replaceWithFragment(r.getCurrentContent(), r.getSelection(), i);
                                return a(_draftJs.EditorState.push(r, u, "insert-fragment")), _draft.HANDLED
                            }
                        }]), e
                    }();
                exports.default = RichEditorPlugin
            }, {
                "../../../utils/draftUtils": 38,
                "../../enums/draft": 7,
                "./behaviors": 25,
                "draft-js": 61,
                immutable: 193,
                "lodash/includes": 377,
                "lodash/reduce": 407,
                react: 455
            }],
            25: [function(require, module, exports) {
                "use strict";
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.insertHorizontalRule = exports.toggleHeader = void 0;
                var _draftJs = require("draft-js"),
                    _immutable = require("immutable"),
                    _draftUtils = require("../../../utils/draftUtils"),
                    _draft = require("../../enums/draft");
                exports.toggleHeader = function(t, e) {
                    if ((0, _draftUtils.isAllBlockSelected)(t)) {
                        var r = t.getSelection();
                        return r.isCollapsed() ? _draftJs.RichUtils.toggleBlockType(t, e) : (0, _draftUtils.selectBlock)(_draftJs.RichUtils.toggleBlockType(t, e), r.getStartKey())
                    }
                    return (0, _draftUtils.getSelectedBlockType)(t) === _draft.HEADER ? (0, _draftUtils.createBlockElementAndExtractFromSelection)(t, _draft.UNSTYLED) : (0, _draftUtils.createBlockElementAndExtractFromSelection)(t, e)
                }, exports.insertHorizontalRule = function(t) {
                    var e = t.getCurrentContent(),
                        r = e.createEntity(_draft.HORIZONTAL_RULE, "IMMUTABLE").getLastCreatedEntityKey(),
                        a = _draftJs.CharacterMetadata.create({
                            entity: r
                        }),
                        i = [new _draftJs.ContentBlock({
                            key: (0, _draftJs.genKey)(),
                            type: _draft.ATOMIC,
                            text: " ",
                            characterList: (0, _immutable.List)((0, _immutable.Repeat)(a, 1))
                        }), new _draftJs.ContentBlock({
                            key: (0, _draftJs.genKey)(),
                            type: _draft.UNSTYLED,
                            text: "",
                            characterList: (0, _immutable.List)()
                        })],
                        l = (0, _immutable.OrderedMap)(i.map(function(t) {
                            return [t.getKey(), t]
                        })),
                        s = _draftJs.Modifier.replaceWithFragment(e, t.getSelection(), l);
                    return _draftJs.EditorState.push(t, s, "insert-fragment")
                }
            }, {
                "../../../utils/draftUtils": 38,
                "../../enums/draft": 7,
                "draft-js": 61,
                immutable: 193
            }],
            26: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function _classCallCheck(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }

                function _applyDecoratedDescriptor(e, t, r, i, n) {
                    var o = {};
                    return Object.keys(i).forEach(function(e) {
                        o[e] = i[e]
                    }), o.enumerable = !!o.enumerable, o.configurable = !!o.configurable, ("value" in o || o.initializer) && (o.writable = !0), o = r.slice().reverse().reduce(function(r, i) {
                        return i(e, t, r) || r
                    }, o), n && void 0 !== o.initializer && (o.value = o.initializer ? o.initializer.call(n) : void 0, o.initializer = void 0), void 0 === o.initializer && (Object.defineProperty(e, t, o), o = null), o
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _class, _createClass = function() {
                        function e(e, t) {
                            for (var r = 0; r < t.length; r++) {
                                var i = t[r];
                                i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(e, i.key, i)
                            }
                        }
                        return function(t, r, i) {
                            return r && e(t.prototype, r), i && e(t, i), t
                        }
                    }(),
                    _autobindDecorator = require("autobind-decorator"),
                    _autobindDecorator2 = _interopRequireDefault(_autobindDecorator),
                    _react = require("react"),
                    _react2 = _interopRequireDefault(_react),
                    _draft = require("../../enums/draft"),
                    _behaviors = require("./behaviors"),
                    _Table = require("./components/Table"),
                    _Table2 = _interopRequireDefault(_Table),
                    _NestedEditor = require("./components/NestedEditor"),
                    _NestedEditor2 = _interopRequireDefault(_NestedEditor),
                    TablePlugin = (_applyDecoratedDescriptor((_class = function() {
                        function e(t) {
                            _classCallCheck(this, e), this.getMainEditor = t.getMainEditor, this.isReadOnly = t.isReadOnly, this.onChange = t.onChange
                        }
                        return _createClass(e, [{
                            key: "onMouseDown",
                            value: function() {
                                this.getMainEditor().unlockEditor()
                            }
                        }, {
                            key: "blockRendererFn",
                            value: function(e, t) {
                                var r = this,
                                    i = t.getEditorState;
                                if (e.getType() === _draft.ATOMIC) {
                                    var n = i().getCurrentContent(),
                                        o = e.getEntityAt(0);
                                    if (!o) return null;
                                    if (n.getEntity(o).getType() === _draft.TABLE) return {
                                        component: _Table2.default,
                                        editable: !1,
                                        props: {
                                            getMainEditor: this.getMainEditor,
                                            getEditorState: i,
                                            onChange: this.onChange,
                                            readOnly: this.isReadOnly(),
                                            renderNestedEditor: function() {
                                                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                                                return _react2.default.createElement(_NestedEditor2.default, Object.assign({}, e, {
                                                    getMainEditor: r.getMainEditor,
                                                    readOnly: r.isReadOnly()
                                                }))
                                            }
                                        }
                                    }
                                }
                            }
                        }, {
                            key: "insert",
                            value: function(e) {
                                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
                                return this.getMainEditor().lockEditor(), (0, _behaviors.insertTable)(e, t)
                            }
                        }]), e
                    }()).prototype, "onMouseDown", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "onMouseDown"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "blockRendererFn", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "blockRendererFn"), _class.prototype), _class);
                exports.default = TablePlugin
            }, {
                "../../enums/draft": 7,
                "./behaviors": 27,
                "./components/NestedEditor": 29,
                "./components/Table": 31,
                "autobind-decorator": 43,
                react: 455
            }],
            27: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.insertTable = exports.removeTable = void 0;
                var _uniqueId2 = require("lodash/uniqueId"),
                    _uniqueId3 = _interopRequireDefault(_uniqueId2),
                    _draftJs = require("draft-js"),
                    _immutable = require("immutable"),
                    _draft = require("../../enums/draft");
                exports.removeTable = function(e, t) {
                    var r = _draftJs.SelectionState.createEmpty(t.getKey()).merge({
                            anchorKey: t.getKey(),
                            anchorOffset: 0,
                            focusKey: t.getKey(),
                            focusOffset: t.getLength(),
                            isBackward: !1
                        }),
                        a = _draftJs.Modifier.removeRange(e.getCurrentContent(), r, "forward"),
                        n = _draftJs.Modifier.setBlockType(a, a.getSelectionAfter(), "unstyled");
                    return _draftJs.EditorState.push(e, n, "remove-range")
                }, exports.insertTable = function(e, t) {
                    var r = e.getCurrentContent(),
                        a = r.createEntity(_draft.TABLE, _draft.DRAFT_ENTITY_MUTABILITY.IMMUTABLE, t).getLastCreatedEntityKey(),
                        n = _draftJs.CharacterMetadata.create({
                            entity: a
                        }),
                        u = [new _draftJs.ContentBlock({
                            key: (0, _draftJs.genKey)(),
                            type: _draft.ATOMIC,
                            data: (0, _immutable.Map)({
                                rows: [{
                                    id: (0, _uniqueId3.default)(Date.now()),
                                    cells: [{
                                        id: (0, _uniqueId3.default)(Date.now())
                                    }, {
                                        id: (0, _uniqueId3.default)(Date.now())
                                    }]
                                }],
                                columnsCount: 2,
                                shouldFocus: !0
                            }),
                            text: " ",
                            characterList: (0, _immutable.List)((0, _immutable.Repeat)(n, 1))
                        }), new _draftJs.ContentBlock({
                            key: (0, _draftJs.genKey)(),
                            type: _draft.UNSTYLED,
                            text: "",
                            characterList: (0, _immutable.List)()
                        })],
                        i = (0, _immutable.OrderedMap)(u.map(function(e) {
                            return [e.getKey(), e]
                        })),
                        d = _draftJs.Modifier.replaceWithFragment(r, e.getSelection(), i);
                    return _draftJs.EditorState.push(e, d, "insert-fragment")
                }
            }, {
                "../../enums/draft": 7,
                "draft-js": 61,
                immutable: 193,
                "lodash/uniqueId": 417
            }],
            28: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
                var _propTypes = require("prop-types"),
                    _propTypes2 = _interopRequireDefault(_propTypes),
                    _react = require("react"),
                    _react2 = _interopRequireDefault(_react),
                    Cell = function(e) {
                        var r = e.changeFocus,
                            o = e.cellIndex,
                            u = e.columnsCount,
                            p = e.isTableLocked,
                            t = e.value,
                            n = e.onCellChange,
                            s = e.onCellEditorBackspace,
                            l = e.registerEditor,
                            d = e.removeColumn,
                            i = e.removeRow,
                            a = e.renderNestedEditor,
                            c = e.rowIndex,
                            f = e.unregisterEditor;
                        return _react2.default.createElement("td", {
                            onMouseDown: function() {
                                r(o + c * u)
                            }
                        }, a({
                            changeFocus: r,
                            cellIndex: o,
                            columnsCount: u,
                            isTableLocked: p,
                            onBackspace: s,
                            onChange: n,
                            registerEditor: l,
                            removeColumn: d,
                            removeRow: i,
                            rowIndex: c,
                            unregisterEditor: f,
                            value: t
                        }))
                    };
                Cell.propTypes = {
                    cellIndex: _propTypes2.default.number.isRequired,
                    changeFocus: _propTypes2.default.func.isRequired,
                    columnsCount: _propTypes2.default.number.isRequired,
                    isTableLocked: _propTypes2.default.bool.isRequired,
                    onCellChange: _propTypes2.default.func.isRequired,
                    onCellEditorBackspace: _propTypes2.default.func.isRequired,
                    registerEditor: _propTypes2.default.func.isRequired,
                    removeColumn: _propTypes2.default.func.isRequired,
                    removeRow: _propTypes2.default.func.isRequired,
                    renderNestedEditor: _propTypes2.default.func.isRequired,
                    rowIndex: _propTypes2.default.number.isRequired,
                    unregisterEditor: _propTypes2.default.func.isRequired,
                    value: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object])
                }, exports.default = Cell
            }, {
                "prop-types": 435,
                react: 455
            }],
            29: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function _classCallCheck(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }

                function _possibleConstructorReturn(e, t) {
                    if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != _typeof2(t) && "function" != typeof t ? e : t
                }

                function _inherits(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(t));
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }

                function _applyDecoratedDescriptor(e, t, o, r, i) {
                    var n = {};
                    return Object.keys(r).forEach(function(e) {
                        n[e] = r[e]
                    }), n.enumerable = !!n.enumerable, n.configurable = !!n.configurable, ("value" in n || n.initializer) && (n.writable = !0), n = o.slice().reverse().reduce(function(o, r) {
                        return r(e, t, o) || o
                    }, n), i && void 0 !== n.initializer && (n.value = n.initializer ? n.initializer.call(i) : void 0, n.initializer = void 0), void 0 === n.initializer && (Object.defineProperty(e, t, n), n = null), n
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _class, _noop2 = require("lodash/noop"),
                    _noop3 = _interopRequireDefault(_noop2),
                    _createClass = function() {
                        function e(e, t) {
                            for (var o = 0; o < t.length; o++) {
                                var r = t[o];
                                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                            }
                        }
                        return function(t, o, r) {
                            return o && e(t.prototype, o), r && e(t, r), t
                        }
                    }(),
                    _autobindDecorator = require("autobind-decorator"),
                    _autobindDecorator2 = _interopRequireDefault(_autobindDecorator),
                    _classnames = require("classnames"),
                    _classnames2 = _interopRequireDefault(_classnames),
                    _draftJs = require("draft-js"),
                    _propTypes = require("prop-types"),
                    _propTypes2 = _interopRequireDefault(_propTypes),
                    _react = require("react"),
                    _react2 = _interopRequireDefault(_react),
                    _reactDom = require("react-dom"),
                    _draftUtils = require("../../../../utils/draftUtils"),
                    _RichEditorStylesCloud = require("../../../components/RichEditorStylesCloud"),
                    _RichEditorStylesCloud2 = _interopRequireDefault(_RichEditorStylesCloud),
                    _CodeEditorPlugin = require("../../CodeEditor/CodeEditorPlugin"),
                    _CodeEditorPlugin2 = _interopRequireDefault(_CodeEditorPlugin),
                    _EditorWithPlugins = require("../../EditorWithPlugins"),
                    _EditorWithPlugins2 = _interopRequireDefault(_EditorWithPlugins),
                    _LinkifyPlugin = require("../../Linkify/LinkifyPlugin"),
                    _LinkifyPlugin2 = _interopRequireDefault(_LinkifyPlugin),
                    _RichEditorPlugin = require("../../RichEditor/RichEditorPlugin"),
                    _RichEditorPlugin2 = _interopRequireDefault(_RichEditorPlugin),
                    _draft = require("../../../enums/draft"),
                    _SelectionPopup = require("../../../SelectionPopup"),
                    _SelectionPopup2 = _interopRequireDefault(_SelectionPopup),
                    PADDING_LEFT = 60,
                    BACKSPACE = 8,
                    LEFT_ARROW = 37,
                    RIGHT_ARROW = 39,
                    AREA_OFFSET_LEFT = 260,
                    stopPropagation = function(e) {
                        e.stopPropagation()
                    },
                    NestedEditor = (_applyDecoratedDescriptor((_class = function(e) {
                        function t(e, o) {
                            _classCallCheck(this, t);
                            var r = _possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, o));
                            return r.state = {
                                editorState: (0, _draftUtils.createEditorStateFromValue)(r.props.value),
                                isFocus: !1
                            }, r.codeEditorPlugin = new _CodeEditorPlugin2.default({
                                forceInline: !0
                            }), r.richEditorPlugin = new _RichEditorPlugin2.default, r.linkifyPlugin = new _LinkifyPlugin2.default, r.plugins = [r.codeEditorPlugin, r.richEditorPlugin, r.linkifyPlugin], r.editorWrapper = {
                                getEditorRef: function() {
                                    return r.editor && r.editor.refs && r.editor.refs.editorContainer
                                }
                            }, r.availableActionTypes = [_draft.BOLD, _draft.CODE_BLOCK, _draft.ITALIC, _draft.ORDERED_LIST, _draft.STRIKETHROUGH, _draft.UNDERLINE, _draft.UNORDERED_LIST], r
                        }
                        return _inherits(t, _react.Component), _createClass(t, [{
                            key: "componentWillReceiveProps",
                            value: function(e) {
                                !this.props.readOnly && e.readOnly && this.blur(), this.props.readOnly !== e.readOnly && this.setState({
                                    editorState: (0, _draftUtils.createEditorStateFromValue)(e.value)
                                }), this.props.value === e.value || this.isEditorFocused() || this.setState({
                                    editorState: (0, _draftUtils.createEditorStateFromValue)(e.value)
                                })
                            }
                        }, {
                            key: "componentDidMount",
                            value: function() {
                                this.props.registerEditor(this), this.domEl = (0, _reactDom.findDOMNode)(this.editor), this.domEl.addEventListener("keydown", this.onKeyDown)
                            }
                        }, {
                            key: "componentWillUnmount",
                            value: function() {
                                this.props.unregisterEditor(this), this.domEl.removeEventListener("keydown", this.onKeyDown), window.cancelAnimationFrame(this.focusAnimationFrame)
                            }
                        }, {
                            key: "getEditorIndex",
                            value: function() {
                                var e = this.props;
                                return e.cellIndex + e.rowIndex * e.columnsCount
                            }
                        }, {
                            key: "focus",
                            value: function(e) {
                                var t = this;
                                this.props.getMainEditor().lockEditor(), this.focusAnimationFrame = window.requestAnimationFrame(function() {
                                    e ? (t.onChange(_draftJs.EditorState.moveFocusToEnd(t.state.editorState)), t.setState({
                                        isFocus: !0
                                    })) : t.editor.focus()
                                })
                            }
                        }, {
                            key: "blur",
                            value: function() {
                                this.editor.blur(), this.setState({
                                    isFocus: !1
                                })
                            }
                        }, {
                            key: "onChange",
                            value: function(e) {
                                var t = this,
                                    o = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
                                    r = this.state.editorState.getCurrentContent();
                                this.setState({
                                    editorState: e
                                }, function() {
                                    var i = e.getCurrentContent();
                                    if (r !== i || o) {
                                        var n = i.hasText() ? (0, _draftJs.convertToRaw)(i) : "";
                                        t.props.onChange(t.props.rowIndex, t.props.cellIndex, n)
                                    }
                                })
                            }
                        }, {
                            key: "isEmpty",
                            value: function() {
                                return !this.state.editorState.getCurrentContent().hasText()
                            }
                        }, {
                            key: "onFocus",
                            value: function() {
                                this.setState({
                                    isFocus: !0
                                })
                            }
                        }, {
                            key: "onBlur",
                            value: function() {
                                this.setState({
                                    isFocus: !1
                                })
                            }
                        }, {
                            key: "setEditorRef",
                            value: function(e) {
                                e && (this.editor = e.getEditorRef())
                            }
                        }, {
                            key: "getSelectedBlock",
                            value: function(e) {
                                if (!e) return null;
                                var t = e.getCurrentContent(),
                                    o = e.getSelection().getStartKey();
                                return t.getBlockForKey(o)
                            }
                        }, {
                            key: "isSelectedBlockEmpty",
                            value: function() {
                                var e = this.getSelectedBlock(this.state.editorState);
                                return !e || !e.getLength()
                            }
                        }, {
                            key: "isEditorFocused",
                            value: function() {
                                var e = window.getSelection().anchorNode,
                                    t = this.editorWrapper.getEditorRef();
                                return this.state.isFocus || t && t.contains(e)
                            }
                        }, {
                            key: "shouldShowSelectionPopup",
                            value: function() {
                                return this.isEditorFocused() && this.isSelectedBlockEmpty()
                            }
                        }, {
                            key: "removeRow",
                            value: function(e) {
                                var t = this.props,
                                    o = t.removeRow,
                                    r = t.rowIndex;
                                this.blur(), o(r, e)
                            }
                        }, {
                            key: "removeColumn",
                            value: function(e) {
                                var t = this.props,
                                    o = t.removeColumn,
                                    r = t.cellIndex;
                                this.blur(), o(r, e)
                            }
                        }, {
                            key: "onLeftArrow",
                            value: function() {
                                (0, _draftUtils.isAtEditorStart)(this.state.editorState) && (0, this.props.changeFocus)(this.getEditorIndex() - 1, !0)
                            }
                        }, {
                            key: "onRightArrow",
                            value: function() {
                                (0, _draftUtils.isAtEditorEnd)(this.state.editorState) && (0, this.props.changeFocus)(this.getEditorIndex() + 1)
                            }
                        }, {
                            key: "onUpArrow",
                            value: function() {
                                if ((0, _draftUtils.isAtEditorStart)(this.state.editorState)) {
                                    var e = this.props,
                                        t = e.changeFocus,
                                        o = e.columnsCount;
                                    t(this.getEditorIndex() - o, !0)
                                }
                            }
                        }, {
                            key: "onDownArrow",
                            value: function() {
                                if ((0, _draftUtils.isAtEditorEnd)(this.state.editorState)) {
                                    var e = this.props,
                                        t = e.changeFocus,
                                        o = e.columnsCount;
                                    t(this.getEditorIndex() + o)
                                }
                            }
                        }, {
                            key: "onBackspace",
                            value: function(e) {
                                var t = this.props,
                                    o = t.onBackspace,
                                    r = t.rowIndex,
                                    i = t.columnsCount;
                                (0, _draftUtils.isAtEditorStart)(this.state.editorState) && this.isEmpty() && (e.preventDefault(), e.stopPropagation(), o(this.getEditorIndex(), i, r))
                            }
                        }, {
                            key: "onKeyDown",
                            value: function(e) {
                                switch (e.keyCode) {
                                    case LEFT_ARROW:
                                        this.onLeftArrow(e);
                                        break;
                                    case RIGHT_ARROW:
                                        this.onRightArrow(e);
                                        break;
                                    case BACKSPACE:
                                        this.onBackspace(e)
                                }
                            }
                        }, {
                            key: "renderSelectionPopup",
                            value: function() {
                                var e = this.props,
                                    t = e.isTableLocked,
                                    o = e.readOnly,
                                    r = this.state.editorState;
                                return o || t ? null : _react2.default.createElement(_SelectionPopup2.default, {
                                    editor: this.editorWrapper,
                                    editorState: r,
                                    fitLeft: this.shouldShowSelectionPopup(),
                                    forceVisibility: this.shouldShowSelectionPopup(),
                                    isEditorFocused: this.state.isFocus,
                                    paddingLeft: PADDING_LEFT,
                                    offsetLeft: AREA_OFFSET_LEFT,
                                    shouldIgnoreSelection: (0, _draftUtils.isAtomicBlockSelected)(this.state.editorState),
                                    wrapInsideLeft: !0
                                }, _react2.default.createElement(_RichEditorStylesCloud2.default, {
                                    availableActionTypes: this.availableActionTypes,
                                    codeEditorPlugin: this.codeEditorPlugin,
                                    currentBlock: this.getSelectedBlock(r),
                                    editorState: r,
                                    onChange: this.onChange,
                                    richEditorPlugin: this.richEditorPlugin
                                }))
                            }
                        }, {
                            key: "render",
                            value: function() {
                                var e = this.props,
                                    t = e.isTableLocked,
                                    o = e.placeholder,
                                    r = e.readOnly,
                                    i = e.value,
                                    n = this.state.editorState,
                                    a = n.getCurrentContent(),
                                    s = (0, _classnames2.default)("custom-text-field", {
                                        active: n.getSelection().hasFocus,
                                        empty: (0, _draftUtils.shouldHidePlaceholder)(a)
                                    });
                                return _react2.default.createElement("div", {
                                    className: "text-editor-wrapper"
                                }, _react2.default.createElement("div", {
                                    className: s,
                                    onClick: stopPropagation
                                }, _react2.default.createElement(_EditorWithPlugins2.default, {
                                    editorState: n,
                                    onChange: this.onChange,
                                    onFocus: this.onFocus,
                                    onBlur: this.onBlur,
                                    onUpArrow: this.onUpArrow,
                                    onDownArrow: this.onDownArrow,
                                    placeholder: o,
                                    plugins: this.plugins,
                                    readOnly: r || t,
                                    ref: this.setEditorRef,
                                    spellCheck: !0,
                                    value: i
                                }), this.renderSelectionPopup()))
                            }
                        }]), t
                    }()).prototype, "focus", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "focus"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onChange", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "onChange"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onFocus", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "onFocus"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onBlur", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "onBlur"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "setEditorRef", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "setEditorRef"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "isEditorFocused", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "isEditorFocused"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onLeftArrow", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "onLeftArrow"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onRightArrow", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "onRightArrow"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onUpArrow", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "onUpArrow"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onDownArrow", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "onDownArrow"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onBackspace", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "onBackspace"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onKeyDown", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "onKeyDown"), _class.prototype), _class);
                exports.default = NestedEditor, NestedEditor.propTypes = {
                    onChange: _propTypes2.default.func,
                    placeholder: _propTypes2.default.string,
                    readOnly: _propTypes2.default.bool,
                    value: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object])
                }, NestedEditor.defaultProps = {
                    onChange: _noop3.default,
                    placeholder: "",
                    readOnly: !1,
                    value: ""
                }
            }, {
                "../../../../utils/draftUtils": 38,
                "../../../SelectionPopup": 4,
                "../../../components/RichEditorStylesCloud": 5,
                "../../../enums/draft": 7,
                "../../CodeEditor/CodeEditorPlugin": 10,
                "../../EditorWithPlugins": 17,
                "../../Linkify/LinkifyPlugin": 21,
                "../../RichEditor/RichEditorPlugin": 24,
                "autobind-decorator": 43,
                classnames: 47,
                "draft-js": 61,
                "lodash/noop": 402,
                "prop-types": 435,
                react: 455,
                "react-dom": 438
            }],
            30: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
                var _propTypes = require("prop-types"),
                    _propTypes2 = _interopRequireDefault(_propTypes),
                    _react = require("react"),
                    _react2 = _interopRequireDefault(_react),
                    _Cell = require("./Cell"),
                    _Cell2 = _interopRequireDefault(_Cell),
                    getCells = function(e) {
                        for (var r = [], o = e.changeFocus, t = e.columnsCount, u = e.data, l = e.isTableLocked, p = e.renderNestedEditor, d = e.onCellChange, i = e.onCellEditorBackspace, s = e.registerEditor, n = e.removeColumn, a = e.removeRow, c = e.rowIndex, f = e.unregisterEditor, _ = 0; _ < t; _++) r.push(_react2.default.createElement(_Cell2.default, {
                            key: u[_].id,
                            changeFocus: o,
                            cellIndex: _,
                            columnsCount: t,
                            isTableLocked: l,
                            renderNestedEditor: p,
                            onCellChange: d,
                            onCellEditorBackspace: i,
                            registerEditor: s,
                            removeColumn: n,
                            removeRow: a,
                            rowIndex: c,
                            unregisterEditor: f,
                            value: u[_].value
                        }));
                        return r
                    },
                    Row = function(e) {
                        return _react2.default.createElement("tr", null, getCells(e))
                    };
                Row.propTypes = {
                    changeFocus: _propTypes2.default.func.isRequired,
                    data: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.object]),
                    columnsCount: _propTypes2.default.number.isRequired,
                    isTableLocked: _propTypes2.default.bool.isRequired,
                    onCellChange: _propTypes2.default.func.isRequired,
                    onCellEditorBackspace: _propTypes2.default.func.isRequired,
                    registerEditor: _propTypes2.default.func.isRequired,
                    removeColumn: _propTypes2.default.func.isRequired,
                    removeRow: _propTypes2.default.func.isRequired,
                    renderNestedEditor: _propTypes2.default.func.isRequired,
                    rowIndex: _propTypes2.default.number.isRequired,
                    unregisterEditor: _propTypes2.default.func.isRequired
                }, exports.default = Row
            }, {
                "./Cell": 28,
                "prop-types": 435,
                react: 455
            }],
            31: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function _toConsumableArray(e) {
                    if (Array.isArray(e)) {
                        for (var t = 0, o = Array(e.length); t < e.length; t++) o[t] = e[t];
                        return o
                    }
                    return Array.from(e)
                }

                function _classCallCheck(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }

                function _possibleConstructorReturn(e, t) {
                    if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != _typeof2(t) && "function" != typeof t ? e : t
                }

                function _inherits(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(t));
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }

                function _applyDecoratedDescriptor(e, t, o, r, a) {
                    var n = {};
                    return Object.keys(r).forEach(function(e) {
                        n[e] = r[e]
                    }), n.enumerable = !!n.enumerable, n.configurable = !!n.configurable, ("value" in n || n.initializer) && (n.writable = !0), n = o.slice().reverse().reduce(function(o, r) {
                        return r(e, t, o) || o
                    }, n), a && void 0 !== n.initializer && (n.value = n.initializer ? n.initializer.call(a) : void 0, n.initializer = void 0), void 0 === n.initializer && (Object.defineProperty(e, t, n), n = null), n
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _class, _size2 = require("lodash/size"),
                    _size3 = _interopRequireDefault(_size2),
                    _uniqueId2 = require("lodash/uniqueId"),
                    _uniqueId3 = _interopRequireDefault(_uniqueId2),
                    _noop2 = require("lodash/noop"),
                    _noop3 = _interopRequireDefault(_noop2),
                    _isUndefined2 = require("lodash/isUndefined"),
                    _isUndefined3 = _interopRequireDefault(_isUndefined2),
                    _isEqual2 = require("lodash/isEqual"),
                    _isEqual3 = _interopRequireDefault(_isEqual2),
                    _filter2 = require("lodash/filter"),
                    _filter3 = _interopRequireDefault(_filter2),
                    _find2 = require("lodash/find"),
                    _find3 = _interopRequireDefault(_find2),
                    _every2 = require("lodash/every"),
                    _every3 = _interopRequireDefault(_every2),
                    _each2 = require("lodash/each"),
                    _each3 = _interopRequireDefault(_each2),
                    _debounce2 = require("lodash/debounce"),
                    _debounce3 = _interopRequireDefault(_debounce2),
                    _createClass = function() {
                        function e(e, t) {
                            for (var o = 0; o < t.length; o++) {
                                var r = t[o];
                                r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r)
                            }
                        }
                        return function(t, o, r) {
                            return o && e(t.prototype, o), r && e(t, r), t
                        }
                    }(),
                    _autobindDecorator = require("autobind-decorator"),
                    _autobindDecorator2 = _interopRequireDefault(_autobindDecorator),
                    _classnames = require("classnames"),
                    _classnames2 = _interopRequireDefault(_classnames),
                    _propTypes = require("prop-types"),
                    _propTypes2 = _interopRequireDefault(_propTypes),
                    _react = require("react"),
                    _react2 = _interopRequireDefault(_react),
                    _draftJs = require("draft-js"),
                    _Row = require("./Row"),
                    _Row2 = _interopRequireDefault(_Row),
                    _draftUtils = require("../../../../utils/draftUtils"),
                    _behaviors = require("../behaviors"),
                    DEBOUNCE_TIME = 150,
                    MAX_COLUMNS_COUNT = 10,
                    Table = (_applyDecoratedDescriptor((_class = function(e) {
                        function t(e, o) {
                            _classCallCheck(this, t);
                            var r = _possibleConstructorReturn(this, (t.__proto__ || Object.getPrototypeOf(t)).call(this, e, o));
                            return r.state = {
                                isTableLocked: !1,
                                rows: [],
                                columnsCount: 0
                            }, r.editors = [], r.saveChanges = (0, _debounce3.default)(r.saveChanges, DEBOUNCE_TIME), r
                        }
                        return _inherits(t, _react.Component), _createClass(t, [{
                            key: "componentWillReceiveProps",
                            value: function(e) {
                                var t = this.props.block.getData(),
                                    o = e.block.getData();
                                (0, _isEqual3.default)(t, o) || this.updateRowsAndColumns(o)
                            }
                        }, {
                            key: "componentWillMount",
                            value: function() {
                                var e = this.props.block.getData();
                                this.updateRowsAndColumns(e)
                            }
                        }, {
                            key: "componentDidMount",
                            value: function() {
                                var e = this.props.block.getData();
                                document.addEventListener("mousedown", this.clickOutsideTable), e.get("shouldFocus") && (this.getEditorByIndex(0).focus(), this.saveChanges())
                            }
                        }, {
                            key: "componentWillUnmount",
                            value: function() {
                                document.removeEventListener("mousedown", this.clickOutsideTable)
                            }
                        }, {
                            key: "updateRowsAndColumns",
                            value: function(e) {
                                this.setState({
                                    rows: e.get("rows"),
                                    columnsCount: e.get("columnsCount")
                                })
                            }
                        }, {
                            key: "registerEditor",
                            value: function(e) {
                                this.editors.push(e)
                            }
                        }, {
                            key: "unregisterEditor",
                            value: function(e) {
                                this.editors = (0, _filter3.default)(this.editors, function(t) {
                                    return e !== t
                                })
                            }
                        }, {
                            key: "changeFocus",
                            value: function(e, t) {
                                var o = this.getEditorByIndex(e);
                                o && o.focus(t)
                            }
                        }, {
                            key: "getEditorByIndex",
                            value: function(e) {
                                return (0, _find3.default)(this.editors, function(t) {
                                    return t.getEditorIndex() === e
                                })
                            }
                        }, {
                            key: "blur",
                            value: function() {
                                (0, _each3.default)(this.editors, function(e) {
                                    return e.blur()
                                })
                            }
                        }, {
                            key: "getCellEditorsInRow",
                            value: function(e, t) {
                                for (var o = [], r = e; r < e + t; r++) o.push(this.getEditorByIndex(r));
                                return o
                            }
                        }, {
                            key: "getCellEditorsInColumn",
                            value: function(e, t, o) {
                                var r = [],
                                    a = t * o - 1,
                                    n = void 0,
                                    s = void 0;
                                for (r.push(this.getEditorByIndex(e)); r.length !== o;)(0, _isUndefined3.default)(n) && (0, _isUndefined3.default)(s) ? (n = e - t, s = e + t) : (n -= t, s += t), s <= a && r.push(this.getEditorByIndex(s)), n >= 0 && r.push(this.getEditorByIndex(n));
                                return r
                            }
                        }, {
                            key: "onCellEditorBackspace",
                            value: function(e, t, o) {
                                var r = this;
                                if (e % t == 0 && (0, _every3.default)(this.getCellEditorsInRow(e, t), function(e) {
                                        return e.isEmpty()
                                    })) return this.getEditorByIndex(e).removeRow(function() {
                                    return r.changeFocus(Math.max(0, e - 1), !0)
                                });
                                var a = (0, _size3.default)(this.editors) / t;
                                return (0, _every3.default)(this.getCellEditorsInColumn(e, t, a), function(e) {
                                    return e.isEmpty()
                                }) ? this.getEditorByIndex(e).removeColumn(function() {
                                    return r.changeFocus(e - (o + 1), !0)
                                }) : void this.changeFocus(e - 1, !0)
                            }
                        }, {
                            key: "onChange",
                            value: function(e) {
                                var t = this.props.blockProps.onChange,
                                    o = e.getCurrentContent(),
                                    r = o.hasText() ? (0, _draftJs.convertToRaw)(o) : "";
                                return t(r), r
                            }
                        }, {
                            key: "saveChanges",
                            value: function() {
                                var e = this.props,
                                    t = e.block,
                                    o = e.blockProps.getEditorState,
                                    r = t.getData().set("rows", this.state.rows);
                                r = (r = r.set("columnsCount", this.state.columnsCount)).set("shouldFocus", !1), this.onChange((0, _draftUtils.updateBlockData)(o(), t, r))
                            }
                        }, {
                            key: "handleCellChange",
                            value: function(e, t, o) {
                                this.setState(function(r) {
                                    return {
                                        rows: r.rows.map(function(r, a) {
                                            if (e === a) {
                                                var n = r.cells.map(function(e, r) {
                                                    return r === t ? Object.assign({}, e, {
                                                        value: o
                                                    }) : e
                                                });
                                                return Object.assign({}, r, {
                                                    cells: n
                                                })
                                            }
                                            return r
                                        })
                                    }
                                }, this.saveChanges)
                            }
                        }, {
                            key: "createNewRow",
                            value: function() {
                                for (var e = [], t = 0; t < this.state.columnsCount; t++) e.push({
                                    id: (0, _uniqueId3.default)(Date.now())
                                });
                                return Object.assign({
                                    id: (0, _uniqueId3.default)(Date.now())
                                }, {
                                    cells: e
                                })
                            }
                        }, {
                            key: "addCellToRows",
                            value: function(e) {
                                return e.reduce(function(e, t) {
                                    var o = t.cells;
                                    return e.push(Object.assign({}, t, {
                                        cells: [].concat(_toConsumableArray(o), [{
                                            id: (0, _uniqueId3.default)(Date.now())
                                        }])
                                    })), e
                                }, [])
                            }
                        }, {
                            key: "addRow",
                            value: function() {
                                var e = this;
                                this.blur(), this.setState(function(t) {
                                    return {
                                        rows: [].concat(_toConsumableArray(t.rows), [e.createNewRow()])
                                    }
                                }, function() {
                                    e.saveChanges()
                                })
                            }
                        }, {
                            key: "removeRow",
                            value: function(e) {
                                var t = this,
                                    o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : _noop3.default;
                                this.setState(function(t) {
                                    return {
                                        rows: t.rows.filter(function(t, o) {
                                            return o !== e
                                        })
                                    }
                                }, function() {
                                    0 === t.state.rows.length ? t.removeTable() : t.saveChanges(), o()
                                })
                            }
                        }, {
                            key: "addColumn",
                            value: function() {
                                var e = this;
                                this.blur(), this.state.columnsCount !== MAX_COLUMNS_COUNT && this.setState(function(t) {
                                    return {
                                        columnsCount: t.columnsCount + 1,
                                        rows: e.addCellToRows(t.rows)
                                    }
                                }, function() {
                                    e.saveChanges()
                                })
                            }
                        }, {
                            key: "removeColumn",
                            value: function(e) {
                                var t = this,
                                    o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : _noop3.default;
                                this.setState(function(t) {
                                    return {
                                        rows: t.rows.map(function(t) {
                                            var o = t.cells.filter(function(t, o) {
                                                return o !== e
                                            });
                                            return Object.assign({}, t, {
                                                cells: o
                                            })
                                        }),
                                        columnsCount: t.columnsCount - 1
                                    }
                                }, function() {
                                    0 === t.state.columnsCount ? t.removeTable() : t.saveChanges(), o()
                                })
                            }
                        }, {
                            key: "removeTable",
                            value: function() {
                                var e = this.props,
                                    t = e.block,
                                    o = e.blockProps,
                                    r = o.getMainEditor,
                                    a = o.getEditorState,
                                    n = (0, _behaviors.removeTable)(a(), t);
                                this.onChange(n), r().unlockEditor(n)
                            }
                        }, {
                            key: "clickOutsideTable",
                            value: function(e) {
                                this.table && !this.table.contains(e.target) && (this.blur(), this.setState({
                                    isTableLocked: !0
                                }))
                            }
                        }, {
                            key: "onMouseDown",
                            value: function(e) {
                                e.stopPropagation();
                                var t = this.props.blockProps.getMainEditor;
                                this.setState({
                                    isTableLocked: !1
                                }), t().lockEditor()
                            }
                        }, {
                            key: "setTableRef",
                            value: function(e) {
                                this.table = e
                            }
                        }, {
                            key: "render",
                            value: function() {
                                var e = this,
                                    t = this.state,
                                    o = t.columnsCount,
                                    r = t.rows,
                                    a = this.props.blockProps,
                                    n = a.readOnly,
                                    s = a.renderNestedEditor;
                                return _react2.default.createElement("div", {
                                    onMouseDown: this.onMouseDown
                                }, _react2.default.createElement("table", {
                                    ref: this.setTableRef
                                }, _react2.default.createElement("tbody", null, r.map(function(t, r) {
                                    return _react2.default.createElement(_Row2.default, {
                                        key: t.id,
                                        changeFocus: e.changeFocus,
                                        columnsCount: o,
                                        data: t.cells,
                                        isTableLocked: e.state.isTableLocked,
                                        onCellEditorBackspace: e.onCellEditorBackspace,
                                        onCellChange: e.handleCellChange,
                                        registerEditor: e.registerEditor,
                                        renderNestedEditor: s,
                                        removeColumn: e.removeColumn,
                                        removeRow: e.removeRow,
                                        rowIndex: r,
                                        unregisterEditor: e.unregisterEditor
                                    })
                                }))), !n && _react2.default.createElement("div", {
                                    className: (0, _classnames2.default)("add-column", "table-button", {
                                        disabled: o === MAX_COLUMNS_COUNT
                                    }),
                                    onClick: this.addColumn
                                }, _react2.default.createElement("span", {
                                    className: "action-label btn-icon ds-icon--font__plus",
                                    title: "Add column"
                                })), !n && _react2.default.createElement("div", {
                                    className: "add-row table-button",
                                    onClick: this.addRow
                                }, _react2.default.createElement("span", {
                                    className: "action-label btn-icon ds-icon--font__plus",
                                    title: "Add row"
                                })))
                            }
                        }]), t
                    }()).prototype, "registerEditor", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "registerEditor"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "unregisterEditor", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "unregisterEditor"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "changeFocus", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "changeFocus"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onCellEditorBackspace", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "onCellEditorBackspace"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "saveChanges", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "saveChanges"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "handleCellChange", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "handleCellChange"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "addRow", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "addRow"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "removeRow", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "removeRow"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "addColumn", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "addColumn"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "removeColumn", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "removeColumn"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "clickOutsideTable", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "clickOutsideTable"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "onMouseDown", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "onMouseDown"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, "setTableRef", [_autobindDecorator2.default], Object.getOwnPropertyDescriptor(_class.prototype, "setTableRef"), _class.prototype), _class);
                exports.default = Table, Table.propTypes = {
                    block: _propTypes2.default.shape({
                        getData: _propTypes2.default.func
                    }).isRequired,
                    blockProps: _propTypes2.default.shape({
                        getEditorState: _propTypes2.default.func,
                        getMainEditor: _propTypes2.default.func,
                        onChange: _propTypes2.default.func,
                        readOnly: _propTypes2.default.bool,
                        renderNestedEditor: _propTypes2.default.func
                    }).isRequired
                }
            }, {
                "../../../../utils/draftUtils": 38,
                "../behaviors": 27,
                "./Row": 30,
                "autobind-decorator": 43,
                classnames: 47,
                "draft-js": 61,
                "lodash/debounce": 364,
                "lodash/each": 365,
                "lodash/every": 368,
                "lodash/filter": 369,
                "lodash/find": 370,
                "lodash/isEqual": 384,
                "lodash/isUndefined": 395,
                "lodash/noop": 402,
                "lodash/size": 408,
                "lodash/uniqueId": 417,
                "prop-types": 435,
                react: 455
            }],
            32: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function _toConsumableArray(e) {
                    if (Array.isArray(e)) {
                        for (var r = 0, t = Array(e.length); r < e.length; r++) t[r] = e[r];
                        return t
                    }
                    return Array.from(e)
                }

                function _classCallCheck(e, r) {
                    if (!(e instanceof r)) throw new TypeError("Cannot call a class as a function")
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = void 0;
                var _isUndefined2 = require("lodash/isUndefined"),
                    _isUndefined3 = _interopRequireDefault(_isUndefined2),
                    _createClass = function() {
                        function e(e, r) {
                            for (var t = 0; t < r.length; t++) {
                                var o = r[t];
                                o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o)
                            }
                        }
                        return function(r, t, o) {
                            return t && e(r.prototype, t), o && e(r, o), r
                        }
                    }(),
                    _draftJs = require("draft-js"),
                    _immutable = require("immutable"),
                    _react = require("react"),
                    _react2 = _interopRequireDefault(_react),
                    KEY_SEPARATOR = "-",
                    getDecoratorsFromPlugins = function(e) {
                        return e.filter(function(e) {
                            return !(0, _isUndefined3.default)(e.decorator)
                        }).map(function(e) {
                            return e.decorator
                        })
                    },
                    isCustomDecorator = function(e) {
                        return "function" == typeof e.getDecorations && "function" == typeof e.getComponentForKey && "function" == typeof e.getPropsForKey
                    },
                    decorateComponentWithProps = function(e, r) {
                        return function(t) {
                            return _react2.default.createElement(e, Object.assign({}, t, r))
                        }
                    },
                    createCompositeDecorator = function(e, r) {
                        var t = e.map(function(e) {
                            return Object.assign({}, e, {
                                component: decorateComponentWithProps(e.component, r)
                            })
                        });
                        return new _draftJs.CompositeDecorator(t)
                    },
                    MultiDecorator = function() {
                        function e(r) {
                            _classCallCheck(this, e), this.decorators = (0, _immutable.List)(r)
                        }
                        return _createClass(e, [{
                            key: "getDecorations",
                            value: function(e, r) {
                                var t = new Array(e.getText().length).fill(null);
                                return this.decorators.forEach(function(o, n) {
                                    o.getDecorations(e, r).forEach(function(e, r) {
                                        e && (t[r] = n + KEY_SEPARATOR + e)
                                    })
                                }), (0, _immutable.List)(t)
                            }
                        }, {
                            key: "getComponentForKey",
                            value: function(r) {
                                return this.getDecoratorForKey(r).getComponentForKey(e.getInnerKey(r))
                            }
                        }, {
                            key: "getPropsForKey",
                            value: function(r) {
                                return this.getDecoratorForKey(r).getPropsForKey(e.getInnerKey(r))
                            }
                        }, {
                            key: "getDecoratorForKey",
                            value: function(e) {
                                var r = e.split(KEY_SEPARATOR),
                                    t = Number(r[0]);
                                return this.decorators.get(t)
                            }
                        }], [{
                            key: "getInnerKey",
                            value: function(e) {
                                return e.split(KEY_SEPARATOR).slice(1).join(KEY_SEPARATOR)
                            }
                        }, {
                            key: "fromPlugins",
                            value: function(r, t) {
                                var o = getDecoratorsFromPlugins(r),
                                    n = createCompositeDecorator(o.filter(function(e) {
                                        return !isCustomDecorator(e)
                                    }), t),
                                    a = o.filter(isCustomDecorator);
                                return new e([n].concat(_toConsumableArray(a)))
                            }
                        }]), e
                    }();
                exports.default = MultiDecorator
            }, {
                "draft-js": 61,
                immutable: 193,
                "lodash/isUndefined": 395,
                react: 455
            }],
            33: [function(require, module, exports) {
                "use strict";
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
                exports.EXTENSION = {
                    MAC_OS: "dmg",
                    WINDOWS: "exe"
                }, exports.DESKTOP_APP_LOADED = "desktop-app--loaded"
            }, {}],
            34: [function(require, module, exports) {
                "use strict";
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
                exports.genericFonts = {
                    MONOSPACE: "monospace",
                    SERIF: "serif",
                    SANS_SERIF: "sans-serif"
                }
            }, {}],
            35: [function(require, module, exports) {
                "use strict";
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
                exports.BROWSER = {
                    CHROME: "chrome",
                    FIREFOX: "firefox",
                    SAFARI: "safari",
                    UXPIN_DESKTOP: "uxpin desktop",
                    OPERA: "opr"
                }, exports.OS = {
                    LINUX: "linux",
                    MAC_OS: "mac",
                    WINDOWS: "win"
                }, exports.MAC_VERSION_REGEX = /os x (\d+)[_.](\d+)/
            }, {}],
            36: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                var _react = require("react"),
                    _react2 = _interopRequireDefault(_react),
                    _reactDom = require("react-dom"),
                    _reactDom2 = _interopRequireDefault(_reactDom),
                    _reactToastify = require("react-toastify"),
                    _LocalFontHandler = require("./LocalFontHandler/LocalFontHandler"),
                    _LocalFontHandler2 = _interopRequireDefault(_LocalFontHandler),
                    _RichTextEditor = require("./TextEditor/RichTextEditor"),
                    _RichTextEditor2 = _interopRequireDefault(_RichTextEditor),
                    _userAgentUtils = require("./utils/userAgentUtils"),
                    _desktopAppUtils = require("./utils/desktopAppUtils"),
                    _Widget = require("./Onboarding/Widget"),
                    _Widget2 = _interopRequireDefault(_Widget);
                module.exports = Object.freeze({
                    LocalFontHandler: _LocalFontHandler2.default,
                    getBrowserName: _userAgentUtils.getBrowserName,
                    getDesktopDownloadLink: _desktopAppUtils.getDesktopDownloadLink,
                    getOS: _userAgentUtils.getOS,
                    isDesktopApp: _userAgentUtils.isDesktopApp,
                    isMac: _userAgentUtils.isMac,
                    isWindows: _userAgentUtils.isWindows,
                    OnboardingWidget: _Widget2.default,
                    React: _react2.default,
                    ReactDOM: _reactDom2.default,
                    RichTextEditor: _RichTextEditor2.default,
                    Toastify: {
                        cssTransition: _reactToastify.cssTransition,
                        toast: _reactToastify.toast,
                        ToastContainer: _reactToastify.ToastContainer
                    },
                    setDesktopAppLoadedClassName: _desktopAppUtils.setDesktopAppLoadedClassName
                })
            }, {
                "./LocalFontHandler/LocalFontHandler": 1,
                "./Onboarding/Widget": 2,
                "./TextEditor/RichTextEditor": 3,
                "./utils/desktopAppUtils": 37,
                "./utils/userAgentUtils": 39,
                react: 455,
                "react-dom": 438,
                "react-toastify": 442
            }],
            37: [function(require, module, exports) {
                "use strict";

                function _defineProperty(e, t, s) {
                    return t in e ? Object.defineProperty(e, t, {
                        value: s,
                        enumerable: !0,
                        configurable: !0,
                        writable: !0
                    }) : e[t] = s, e
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.setDesktopAppLoadedClassName = exports.getDesktopDownloadLink = void 0;
                var _userAgent = require("../constants/userAgent.constants"),
                    _desktopApp = require("../constants/desktopApp.constants"),
                    _userAgentUtils = require("./userAgentUtils");
                exports.getDesktopDownloadLink = function() {
                    var e, t = (0, _userAgentUtils.getOS)(navigator.userAgent),
                        s = [_userAgent.OS.MAC_OS, _userAgent.OS.WINDOWS],
                        n = (_defineProperty(e = {}, _userAgent.OS.MAC_OS, _desktopApp.EXTENSION.MAC_OS), _defineProperty(e, _userAgent.OS.WINDOWS, _desktopApp.EXTENSION.WINDOWS), e);
                    return s.includes(t) ? "https://files.uxpin.com/desktop-app/latest/UXPin-" + t + "." + n[t] : null
                }, exports.setDesktopAppLoadedClassName = function() {
                    return window.addEventListener("load", function() {
                        document.body.classList.add(_desktopApp.DESKTOP_APP_LOADED)
                    })
                }
            }, {
                "../constants/desktopApp.constants": 33,
                "../constants/userAgent.constants": 35,
                "./userAgentUtils": 39
            }],
            38: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function _toConsumableArray(e) {
                    if (Array.isArray(e)) {
                        for (var t = 0, r = Array(e.length); t < e.length; t++) r[t] = e[t];
                        return r
                    }
                    return Array.from(e)
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.createEditorStateFromValue = exports.createContentStateFromValue = exports.findNotLoadedImageEntities = exports.findImageEntityById = exports.createBlockElementAndExtractFromSelection = exports.selectBlock = exports.isAtEditorEnd = exports.isAtEditorStart = exports.isAtEnd = exports.isAtStart = exports.getSelectedBlockType = exports.extendSelectionToWholeBlock = exports.shouldHidePlaceholder = exports.hasSelectionInBlock = exports.insertNewLine = exports.getLineAnchorForOffset = exports.getLines = exports.detectNewLineSeparator = exports.getIndentation = exports.updateBlockDataSyntax = exports.updateBlockData = exports.isAllBlockSelected = exports.isAtomicBlockSelected = exports.getSelectedText = exports.getSelectedBlocks = exports.isNewLineInSelection = void 0;
                var _find2 = require("lodash/find"),
                    _find3 = _interopRequireDefault(_find2),
                    _isString2 = require("lodash/isString"),
                    _isString3 = _interopRequireDefault(_isString2),
                    _isEmpty2 = require("lodash/isEmpty"),
                    _isEmpty3 = _interopRequireDefault(_isEmpty2),
                    _detectIndent = require("detect-indent"),
                    _detectIndent2 = _interopRequireDefault(_detectIndent),
                    _detectNewline = require("detect-newline"),
                    _detectNewline2 = _interopRequireDefault(_detectNewline),
                    _draftJs = require("draft-js"),
                    _immutable = require("immutable"),
                    _draft = require("../TextEditor/enums/draft"),
                    getSelectedBlocks = (exports.isNewLineInSelection = function(e) {
                        var t = e.getSelection(),
                            r = e.getCurrentContent(),
                            n = t.getAnchorKey();
                        if (n !== t.getFocusKey()) return !0;
                        var o = r.getBlockForKey(n).getText(),
                            a = t.getStartOffset(),
                            i = t.getEndOffset() - a;
                        return -1 !== o.slice(a, i).indexOf(_draft.NEW_LINE)
                    }, exports.getSelectedBlocks = function(e) {
                        for (var t = e.getSelection(), r = e.getCurrentContent(), n = t.getStartKey(), o = t.getEndKey(), a = [r.getBlockForKey(n)]; n !== o;) {
                            var i = r.getBlockAfter(n);
                            n = i.getKey(), a.push(i)
                        }
                        return a
                    }),
                    getSelectedText = exports.getSelectedText = function(e) {
                        var t = e.getSelection(),
                            r = t.getStartKey(),
                            n = t.getStartOffset(),
                            o = t.getEndKey(),
                            a = t.getEndOffset();
                        if (r === o) {
                            var i = e.getCurrentContent().getBlockForKey(r);
                            return {
                                text: i.getText().slice(0, a).slice(n),
                                characterList: i.getCharacterList().slice(0, a).slice(n)
                            }
                        }
                        return getSelectedBlocks(e).reduce(function(e, t) {
                            return t.getType() === _draft.ATOMIC && t.getEntityAt(0) ? e : t.getKey() === r ? Object.assign({
                                text: e.text + t.getText().slice(n) + _draft.NEW_LINE,
                                characterList: e.characterList.concat(t.getCharacterList().slice(n)).concat([_draftJs.CharacterMetadata.EMPTY])
                            }) : t.getKey() === o ? Object.assign({
                                text: e.text + t.getText().slice(0, a),
                                characterList: e.characterList.concat(t.getCharacterList().slice(0, a))
                            }) : Object.assign({
                                text: e.text + t.getText() + _draft.NEW_LINE,
                                characterList: e.characterList.concat(t.getCharacterList()).concat([_draftJs.CharacterMetadata.EMPTY])
                            })
                        }, {
                            text: "",
                            characterList: (0, _immutable.List)()
                        })
                    },
                    updateBlockData = (exports.isAtomicBlockSelected = function(e) {
                        var t = !!(0, _find3.default)(getSelectedBlocks(e), function(e) {
                                var t = e.getEntityAt(0);
                                return e.getType() === _draft.ATOMIC && t
                            }),
                            r = !getSelectedText(e).text.trim().length;
                        return t && r
                    }, exports.isAllBlockSelected = function(e) {
                        var t = e.getSelection(),
                            r = t.getAnchorKey(),
                            n = t.getFocusKey(),
                            o = e.getCurrentContent(),
                            a = o.getBlockForKey(r),
                            i = o.getBlockAfter(r),
                            c = o.getBlockForKey(n);
                        if (a !== c) return c === i && 0 === t.getStartOffset() && 0 === t.getEndOffset();
                        var s = a.getText();
                        return s === s.slice(t.getStartOffset(), t.getEndOffset())
                    }, exports.updateBlockData = function(e, t, r) {
                        var n = e.getCurrentContent(),
                            o = t.merge({
                                data: r
                            }),
                            a = n.merge({
                                blockMap: n.getBlockMap().set(t.getKey(), o)
                            });
                        return _draftJs.EditorState.push(e, a, "change-block-data")
                    }),
                    getIndentation = (exports.updateBlockDataSyntax = function(e, t, r) {
                        var n = t.getData().set("syntax", r);
                        return updateBlockData(e, t, n)
                    }, exports.getIndentation = function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
                        return (0, _detectIndent2.default)(e).indent || t
                    }),
                    detectNewLineSeparator = exports.detectNewLineSeparator = function(e) {
                        return (0, _detectNewline2.default)(e) || _draft.NEW_LINE
                    },
                    getLines = exports.getLines = function(e) {
                        var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : detectNewLineSeparator(e);
                        return (0, _immutable.List)(e.split(t))
                    },
                    getLineAnchorForOffset = exports.getLineAnchorForOffset = function(e, t) {
                        for (var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : detectNewLineSeparator(e), n = 0, o = 0, a = 0; o >= 0 && o < t;) n += 1, a = o, o = e.indexOf(r, o + r.length);
                        return {
                            line: n - 1,
                            offset: t - a - 1
                        }
                    },
                    isAtStart = (exports.insertNewLine = function(e) {
                        var t = e.getCurrentContent(),
                            r = e.getSelection(),
                            n = r.getStartKey(),
                            o = r.getStartOffset(),
                            a = t.getBlockForKey(n).getText(),
                            i = void 0,
                            c = detectNewLineSeparator(a);
                        if (r.isCollapsed()) {
                            var s = getLines(a, c),
                                l = getLineAnchorForOffset(a, o, c).line,
                                d = s.get(l),
                                g = c + getIndentation(d);
                            i = _draftJs.Modifier.insertText(t, r, g)
                        } else i = _draftJs.Modifier.replaceText(t, r, c);
                        var f = _draftJs.EditorState.push(e, i, "insert-characters");
                        return _draftJs.EditorState.forceSelection(f, i.getSelectionAfter())
                    }, exports.hasSelectionInBlock = function(e, t) {
                        var r = e.getSelection(),
                            n = e.getCurrentContent(),
                            o = r.getStartKey();
                        return n.getBlockForKey(o).getType() === t
                    }, exports.shouldHidePlaceholder = function(e) {
                        var t = e.getBlockMap();
                        return 1 === t.size && t.first().getType() !== _draft.UNSTYLED
                    }, exports.extendSelectionToWholeBlock = function(e, t) {
                        return e.isBackward ? e.merge({
                            anchorOffset: t.getBlockForKey(e.getAnchorKey()).getLength(),
                            focusOffset: 0
                        }) : e.merge({
                            anchorOffset: 0,
                            focusOffset: t.getBlockForKey(e.getFocusKey()).getLength()
                        })
                    }, exports.getSelectedBlockType = function(e) {
                        var t = e.getSelection();
                        return e.getCurrentContent().getBlockForKey(t.getStartKey()).getType()
                    }, exports.isAtStart = function(e, t) {
                        return t.getStartKey() === e.getKey() && 0 === t.getStartOffset()
                    }),
                    isAtEnd = exports.isAtEnd = function(e, t) {
                        return t.getEndKey() === e.getKey() && t.getEndOffset() === e.getLength()
                    },
                    insertBlockAfter = (exports.isAtEditorStart = function(e) {
                        var t = e.getSelection(),
                            r = e.getCurrentContent();
                        return isAtStart(r.getFirstBlock(), t)
                    }, exports.isAtEditorEnd = function(e) {
                        var t = e.getSelection(),
                            r = e.getCurrentContent();
                        return isAtEnd(r.getLastBlock(), t)
                    }, function(e, t, r) {
                        if (1 === e.length && "" === e[0].getText()) return [t];
                        if (!r) return [].concat(_toConsumableArray(e), [t]);
                        var n = e.indexOf(r);
                        return [].concat(_toConsumableArray(e.slice(0, n)), [t], _toConsumableArray(e.slice(n)))
                    }),
                    selectBlock = exports.selectBlock = function(e, t) {
                        var r = e.getCurrentContent(),
                            n = _draftJs.SelectionState.createEmpty(t);
                        n = n.merge({
                            anchorKey: t,
                            anchorOffset: 0,
                            hasFocus: !0
                        });
                        var o = r.getBlockAfter(t);
                        return o && o.getType() !== _draft.ATOMIC ? _draftJs.EditorState.forceSelection(e, n.merge({
                            focusKey: o.getKey(),
                            focusOffset: 0
                        })) : _draftJs.EditorState.forceSelection(e, n.merge({
                            focusKey: t,
                            focusOffset: r.getBlockForKey(t).getLength()
                        }))
                    },
                    createContentStateFromValue = (exports.createBlockElementAndExtractFromSelection = function(e, t) {
                        var r = getSelectedText(e),
                            n = r.text,
                            o = r.characterList,
                            a = e.getSelection(),
                            i = new _draftJs.ContentBlock({
                                characterList: o,
                                key: (0, _draftJs.genKey)(),
                                text: n,
                                type: t
                            }),
                            c = e.getCurrentContent(),
                            s = isAtStart(c.getBlockForKey(a.getStartKey()), a),
                            l = isAtEnd(c.getBlockForKey(a.getEndKey()), a),
                            d = (c = _draftJs.Modifier.removeRange(c, a, a.isBackward ? "backward" : "forward")).getSelectionAfter(),
                            g = c.getBlockForKey(d.getStartKey());
                        s || l || (d = (c = _draftJs.Modifier.splitBlock(c, d)).getSelectionAfter());
                        var f = l ? c.getBlockAfter(d.getStartKey()) : c.getBlockForKey(d.getStartKey()),
                            u = c.getBlockMap().toArray();
                        return "" === g.getText() && u.splice(u.indexOf(g), 1), u = insertBlockAfter(u, i, f), c = _draftJs.ContentState.createFromBlockArray(u).set("selectionBefore", a), selectBlock(_draftJs.EditorState.push(e, c), i.getKey())
                    }, exports.findImageEntityById = function(e, t) {
                        var r = e.getCurrentContent(),
                            n = r.getBlockMap(),
                            o = void 0,
                            a = void 0;
                        return n.valueSeq().forEach(function(e) {
                            var n = e.getEntityAt(0);
                            if (!n) return null;
                            var i = r.getEntity(n),
                                c = i.getData().id;
                            return i.getType() === _draft.IMAGE && c === t ? (o = i, a = n, !1) : void 0
                        }), {
                            entity: o,
                            entityKey: a
                        }
                    }, exports.findNotLoadedImageEntities = function(e) {
                        var t = e.getCurrentContent();
                        return t.getBlockMap().valueSeq().reduce(function(e, r) {
                            var n = r.getEntityAt(0);
                            if (!n) return e;
                            var o = t.getEntity(n);
                            return o.getType() === _draft.IMAGE && o.getData().isLoading && e.push({
                                entity: o,
                                entityKey: n
                            }), e
                        }, [])
                    }, exports.createContentStateFromValue = function(e) {
                        if ((0, _isString3.default)(e)) {
                            var t = (0, _draftJs.convertFromHTML)(e),
                                r = t.contentBlocks,
                                n = t.entityMap;
                            return _draftJs.ContentState.createFromBlockArray(r, n)
                        }
                        return (0, _draftJs.convertFromRaw)(e)
                    });
                exports.createEditorStateFromValue = function(e) {
                    if ((0, _isEmpty3.default)(e)) return _draftJs.EditorState.createEmpty();
                    try {
                        var t = createContentStateFromValue(e);
                        return _draftJs.EditorState.createWithContent(t)
                    } catch (e) {
                        return console.error(e), _draftJs.EditorState.createEmpty()
                    }
                }
            }, {
                "../TextEditor/enums/draft": 7,
                "detect-indent": 48,
                "detect-newline": 49,
                "draft-js": 61,
                immutable: 193,
                "lodash/find": 370,
                "lodash/isEmpty": 383,
                "lodash/isString": 392
            }],
            39: [function(require, module, exports) {
                "use strict";
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.getWindowsOsVersion = exports.getMacOsVersion = exports.isDesktopApp = exports.isSafari = exports.isFirefox = exports.isChrome = exports.isLinux = exports.isWindows = exports.isMac = exports.getOS = exports.getBrowserName = void 0;
                var _userAgent = require("../constants/userAgent.constants"),
                    WINDOWS_NT_VERSION_REGEX = /Windows NT ([\d.]+);/,
                    getBrowserName = exports.getBrowserName = function() {
                        var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window.navigator.userAgent,
                            r = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
                            t = e.toLowerCase(),
                            s = -1 === t.indexOf(_userAgent.BROWSER.OPERA) && -1 === t.indexOf(_userAgent.BROWSER.UXPIN_DESKTOP);
                        return -1 !== t.indexOf(_userAgent.BROWSER.SAFARI) && -1 === t.indexOf(_userAgent.BROWSER.CHROME) && s ? _userAgent.BROWSER.SAFARI : t.indexOf(_userAgent.BROWSER.CHROME) > -1 && s ? _userAgent.BROWSER.CHROME : t.indexOf(_userAgent.BROWSER.FIREFOX) > -1 ? _userAgent.BROWSER.FIREFOX : t.indexOf(_userAgent.BROWSER.UXPIN_DESKTOP) > -1 && !r ? _userAgent.BROWSER.UXPIN_DESKTOP.replace(/\s/g, "-") : void 0
                    },
                    getOS = exports.getOS = function() {
                        var e = (arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window.navigator.userAgent).toLowerCase();
                        return e.indexOf(_userAgent.OS.MAC_OS) > -1 ? _userAgent.OS.MAC_OS : e.indexOf(_userAgent.OS.WINDOWS) > -1 ? _userAgent.OS.WINDOWS : e.indexOf(_userAgent.OS.LINUX) > -1 ? _userAgent.OS.LINUX : void 0
                    };
                exports.isMac = getOS(navigator.userAgent) === _userAgent.OS.MAC_OS, exports.isWindows = getOS(navigator.userAgent) === _userAgent.OS.WINDOWS, exports.isLinux = getOS(navigator.userAgent) === _userAgent.OS.LINUX, exports.isChrome = getBrowserName(navigator.userAgent) === _userAgent.BROWSER.CHROME, exports.isFirefox = getBrowserName(navigator.userAgent) === _userAgent.BROWSER.FIREFOX, exports.isSafari = getBrowserName(navigator.userAgent) === _userAgent.BROWSER.SAFARI, exports.isDesktopApp = "uxpin-desktop" === getBrowserName(navigator.userAgent, !1), exports.getMacOsVersion = function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window.navigator.userAgent;
                    if (getOS(e) !== _userAgent.OS.MAC_OS) return null;
                    var r = e.toLowerCase().match(_userAgent.MAC_VERSION_REGEX);
                    return r ? {
                        major: parseInt(r[1], 10),
                        minor: parseInt(r[2], 10)
                    } : null
                }, exports.getWindowsOsVersion = function() {
                    var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : window.navigator.userAgent;
                    if (getOS(e) !== _userAgent.OS.WINDOWS) return null;
                    var r = e.match(WINDOWS_NT_VERSION_REGEX);
                    return r ? parseFloat(r[1]) : null
                }
            }, {
                "../constants/userAgent.constants": 35
            }],
            40: [function(require, module, exports) {
                function _extends() {
                    return module.exports = _extends = Object.assign || function(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var n = arguments[t];
                            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                        }
                        return e
                    }, _extends.apply(this, arguments)
                }
                module.exports = _extends
            }, {}],
            41: [function(require, module, exports) {
                function _inheritsLoose(o, t) {
                    o.prototype = Object.create(t.prototype), o.prototype.constructor = o, o.__proto__ = t
                }
                module.exports = _inheritsLoose
            }, {}],
            42: [function(require, module, exports) {
                function _objectWithoutPropertiesLoose(e, o) {
                    if (null == e) return {};
                    var t, r, i = {},
                        n = Object.keys(e);
                    for (r = 0; r < n.length; r++) t = n[r], o.indexOf(t) >= 0 || (i[t] = e[t]);
                    return i
                }
                module.exports = _objectWithoutPropertiesLoose
            }, {}],
            43: [function(require, module, exports) {
                "use strict";

                function autobind() {
                    for (var t = arguments.length, e = Array(t), o = 0; o < t; o++) e[o] = arguments[o];
                    return 1 === e.length ? boundClass.apply(void 0, e) : boundMethod.apply(void 0, e)
                }

                function boundClass(t) {
                    var e = void 0;
                    return "undefined" != typeof Reflect && "function" == typeof Reflect.ownKeys ? e = Reflect.ownKeys(t.prototype) : (e = Object.getOwnPropertyNames(t.prototype),
                        "function" == typeof Object.getOwnPropertySymbols && (e = e.concat(Object.getOwnPropertySymbols(t.prototype)))), e.forEach(function(e) {
                        if ("constructor" !== e) {
                            var o = Object.getOwnPropertyDescriptor(t.prototype, e);
                            "function" == typeof o.value && Object.defineProperty(t.prototype, e, boundMethod(t, e, o))
                        }
                    }), t
                }

                function boundMethod(t, e, o) {
                    var r = o.value;
                    if ("function" != typeof r) throw new Error("@autobind decorator can only be applied to methods not: " + _typeof2(r));
                    var n = !1;
                    return {
                        configurable: !0,
                        get: function() {
                            if (n || this === t.prototype || this.hasOwnProperty(e)) return r;
                            var o = r.bind(this);
                            return n = !0, Object.defineProperty(this, e, {
                                value: o,
                                configurable: !0,
                                writable: !0
                            }), n = !1, o
                        }
                    }
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), exports.default = autobind, module.exports = exports.default
            }, {}],
            44: [function(require, module, exports) {
                var g = function() {
                        return this
                    }() || Function("return this")(),
                    hadRuntime = g.regeneratorRuntime && Object.getOwnPropertyNames(g).indexOf("regeneratorRuntime") >= 0,
                    oldRuntime = hadRuntime && g.regeneratorRuntime;
                if (g.regeneratorRuntime = void 0, module.exports = require("./runtime"), hadRuntime) g.regeneratorRuntime = oldRuntime;
                else try {
                    delete g.regeneratorRuntime
                } catch (e) {
                    g.regeneratorRuntime = void 0
                }
            }, {
                "./runtime": 45
            }],
            45: [function(require, module, exports) {
                ! function(t) {
                    "use strict";

                    function w(t, r, e, n) {
                        var o = r && r.prototype instanceof x ? r : x,
                            i = Object.create(o.prototype),
                            a = new N(n || []);
                        return i._invoke = function(t, r, e) {
                            var n = s;
                            return function(o, i) {
                                if (n === l) throw new Error("Generator is already running");
                                if (n === p) {
                                    if ("throw" === o) throw i;
                                    return F()
                                }
                                for (e.method = o, e.arg = i;;) {
                                    var a = e.delegate;
                                    if (a) {
                                        var c = O(a, e);
                                        if (c) {
                                            if (c === y) continue;
                                            return c
                                        }
                                    }
                                    if ("next" === e.method) e.sent = e._sent = e.arg;
                                    else if ("throw" === e.method) {
                                        if (n === s) throw n = p, e.arg;
                                        e.dispatchException(e.arg)
                                    } else "return" === e.method && e.abrupt("return", e.arg);
                                    n = l;
                                    var u = L(t, r, e);
                                    if ("normal" === u.type) {
                                        if (n = e.done ? p : f, u.arg === y) continue;
                                        return {
                                            value: u.arg,
                                            done: e.done
                                        }
                                    }
                                    "throw" === u.type && (n = p, e.method = "throw", e.arg = u.arg)
                                }
                            }
                        }(t, e, a), i
                    }

                    function L(t, r, e) {
                        try {
                            return {
                                type: "normal",
                                arg: t.call(r, e)
                            }
                        } catch (t) {
                            return {
                                type: "throw",
                                arg: t
                            }
                        }
                    }

                    function x() {}

                    function E() {}

                    function b() {}

                    function _(t) {
                        ["next", "throw", "return"].forEach(function(r) {
                            t[r] = function(t) {
                                return this._invoke(r, t)
                            }
                        })
                    }

                    function j(t) {
                        var r;
                        this._invoke = function(e, o) {
                            function i() {
                                return new Promise(function(r, i) {
                                    ! function r(e, o, i, a) {
                                        var c = L(t[e], t, o);
                                        if ("throw" !== c.type) {
                                            var u = c.arg,
                                                h = u.value;
                                            return h && "object" == _typeof2(h) && n.call(h, "__await") ? Promise.resolve(h.__await).then(function(t) {
                                                r("next", t, i, a)
                                            }, function(t) {
                                                r("throw", t, i, a)
                                            }) : Promise.resolve(h).then(function(t) {
                                                u.value = t, i(u)
                                            }, a)
                                        }
                                        a(c.arg)
                                    }(e, o, r, i)
                                })
                            }
                            return r = r ? r.then(i, i) : i()
                        }
                    }

                    function O(t, e) {
                        var n = t.iterator[e.method];
                        if (n === r) {
                            if (e.delegate = null, "throw" === e.method) {
                                if (t.iterator.return && (e.method = "return", e.arg = r, O(t, e), "throw" === e.method)) return y;
                                e.method = "throw", e.arg = new TypeError("The iterator does not provide a 'throw' method")
                            }
                            return y
                        }
                        var o = L(n, t.iterator, e.arg);
                        if ("throw" === o.type) return e.method = "throw", e.arg = o.arg, e.delegate = null, y;
                        var i = o.arg;
                        return i ? i.done ? (e[t.resultName] = i.value, e.next = t.nextLoc, "return" !== e.method && (e.method = "next", e.arg = r), e.delegate = null, y) : i : (e.method = "throw", e.arg = new TypeError("iterator result is not an object"), e.delegate = null, y)
                    }

                    function k(t) {
                        var r = {
                            tryLoc: t[0]
                        };
                        1 in t && (r.catchLoc = t[1]), 2 in t && (r.finallyLoc = t[2], r.afterLoc = t[3]), this.tryEntries.push(r)
                    }

                    function G(t) {
                        var r = t.completion || {};
                        r.type = "normal", delete r.arg, t.completion = r
                    }

                    function N(t) {
                        this.tryEntries = [{
                            tryLoc: "root"
                        }], t.forEach(k, this), this.reset(!0)
                    }

                    function P(t) {
                        if (t) {
                            var e = t[i];
                            if (e) return e.call(t);
                            if ("function" == typeof t.next) return t;
                            if (!isNaN(t.length)) {
                                var o = -1,
                                    a = function e() {
                                        for (; ++o < t.length;)
                                            if (n.call(t, o)) return e.value = t[o], e.done = !1, e;
                                        return e.value = r, e.done = !0, e
                                    };
                                return a.next = a
                            }
                        }
                        return {
                            next: F
                        }
                    }

                    function F() {
                        return {
                            value: r,
                            done: !0
                        }
                    }
                    var r, e = Object.prototype,
                        n = e.hasOwnProperty,
                        o = "function" == typeof Symbol ? Symbol : {},
                        i = o.iterator || "@@iterator",
                        a = o.asyncIterator || "@@asyncIterator",
                        c = o.toStringTag || "@@toStringTag",
                        u = "object" == _typeof2(module),
                        h = t.regeneratorRuntime;
                    if (h) u && (module.exports = h);
                    else {
                        (h = t.regeneratorRuntime = u ? module.exports : {}).wrap = w;
                        var s = "suspendedStart",
                            f = "suspendedYield",
                            l = "executing",
                            p = "completed",
                            y = {},
                            v = {};
                        v[i] = function() {
                            return this
                        };
                        var d = Object.getPrototypeOf,
                            g = d && d(d(P([])));
                        g && g !== e && n.call(g, i) && (v = g);
                        var m = b.prototype = x.prototype = Object.create(v);
                        E.prototype = m.constructor = b, b.constructor = E, b[c] = E.displayName = "GeneratorFunction", h.isGeneratorFunction = function(t) {
                            var r = "function" == typeof t && t.constructor;
                            return !!r && (r === E || "GeneratorFunction" === (r.displayName || r.name))
                        }, h.mark = function(t) {
                            return Object.setPrototypeOf ? Object.setPrototypeOf(t, b) : (t.__proto__ = b, c in t || (t[c] = "GeneratorFunction")), t.prototype = Object.create(m), t
                        }, h.awrap = function(t) {
                            return {
                                __await: t
                            }
                        }, _(j.prototype), j.prototype[a] = function() {
                            return this
                        }, h.AsyncIterator = j, h.async = function(t, r, e, n) {
                            var o = new j(w(t, r, e, n));
                            return h.isGeneratorFunction(r) ? o : o.next().then(function(t) {
                                return t.done ? t.value : o.next()
                            })
                        }, _(m), m[c] = "Generator", m[i] = function() {
                            return this
                        }, m.toString = function() {
                            return "[object Generator]"
                        }, h.keys = function(t) {
                            var r = [];
                            for (var e in t) r.push(e);
                            return r.reverse(),
                                function e() {
                                    for (; r.length;) {
                                        var n = r.pop();
                                        if (n in t) return e.value = n, e.done = !1, e
                                    }
                                    return e.done = !0, e
                                }
                        }, h.values = P, N.prototype = {
                            constructor: N,
                            reset: function(t) {
                                if (this.prev = 0, this.next = 0, this.sent = this._sent = r, this.done = !1, this.delegate = null, this.method = "next", this.arg = r, this.tryEntries.forEach(G), !t)
                                    for (var e in this) "t" === e.charAt(0) && n.call(this, e) && !isNaN(+e.slice(1)) && (this[e] = r)
                            },
                            stop: function() {
                                this.done = !0;
                                var t = this.tryEntries[0].completion;
                                if ("throw" === t.type) throw t.arg;
                                return this.rval
                            },
                            dispatchException: function(t) {
                                function o(n, o) {
                                    return c.type = "throw", c.arg = t, e.next = n, o && (e.method = "next", e.arg = r), !!o
                                }
                                if (this.done) throw t;
                                for (var e = this, i = this.tryEntries.length - 1; i >= 0; --i) {
                                    var a = this.tryEntries[i],
                                        c = a.completion;
                                    if ("root" === a.tryLoc) return o("end");
                                    if (a.tryLoc <= this.prev) {
                                        var u = n.call(a, "catchLoc"),
                                            h = n.call(a, "finallyLoc");
                                        if (u && h) {
                                            if (this.prev < a.catchLoc) return o(a.catchLoc, !0);
                                            if (this.prev < a.finallyLoc) return o(a.finallyLoc)
                                        } else if (u) {
                                            if (this.prev < a.catchLoc) return o(a.catchLoc, !0)
                                        } else {
                                            if (!h) throw new Error("try statement without catch or finally");
                                            if (this.prev < a.finallyLoc) return o(a.finallyLoc)
                                        }
                                    }
                                }
                            },
                            abrupt: function(t, r) {
                                for (var e = this.tryEntries.length - 1; e >= 0; --e) {
                                    var o = this.tryEntries[e];
                                    if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
                                        var i = o;
                                        break
                                    }
                                }
                                i && ("break" === t || "continue" === t) && i.tryLoc <= r && r <= i.finallyLoc && (i = null);
                                var a = i ? i.completion : {};
                                return a.type = t, a.arg = r, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a)
                            },
                            complete: function(t, r) {
                                if ("throw" === t.type) throw t.arg;
                                return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && r && (this.next = r), y
                            },
                            finish: function(t) {
                                for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                                    var e = this.tryEntries[r];
                                    if (e.finallyLoc === t) return this.complete(e.completion, e.afterLoc), G(e), y
                                }
                            },
                            catch: function(t) {
                                for (var r = this.tryEntries.length - 1; r >= 0; --r) {
                                    var e = this.tryEntries[r];
                                    if (e.tryLoc === t) {
                                        var n = e.completion;
                                        if ("throw" === n.type) {
                                            var o = n.arg;
                                            G(e)
                                        }
                                        return o
                                    }
                                }
                                throw new Error("illegal catch attempt")
                            },
                            delegateYield: function(t, e, n) {
                                return this.delegate = {
                                    iterator: P(t),
                                    resultName: e,
                                    nextLoc: n
                                }, "next" === this.method && (this.arg = r), y
                            }
                        }
                    }
                }(function() {
                    return this
                }() || Function("return this")())
            }, {}],
            46: [function(require, module, exports) {
                module.exports = require("regenerator-runtime")
            }, {
                "regenerator-runtime": 44
            }],
            47: [function(require, module, exports) {
                ! function() {
                    "use strict";

                    function n() {
                        for (var r = [], o = 0; o < arguments.length; o++) {
                            var f = arguments[o];
                            if (f) {
                                var i = _typeof2(f);
                                if ("string" === i || "number" === i) r.push(f);
                                else if (Array.isArray(f)) r.push(n.apply(null, f));
                                else if ("object" === i)
                                    for (var t in f) e.call(f, t) && f[t] && r.push(t)
                            }
                        }
                        return r.join(" ")
                    }
                    var e = {}.hasOwnProperty;
                    "undefined" != typeof module && module.exports ? module.exports = n : "function" == typeof define && "object" == _typeof2(define.amd) && define.amd ? define("classnames", [], function() {
                        return n
                    }) : window.classNames = n
                }()
            }, {}],
            48: [function(require, module, exports) {
                "use strict";

                function getMostUsed(t) {
                    var e = 0,
                        r = 0,
                        n = 0;
                    for (var a in t) {
                        var i = t[a],
                            o = i[0],
                            p = i[1];
                        (o > r || o === r && p > n) && (r = o, n = p, e = +a)
                    }
                    return e
                }
                var repeating = require("repeating"),
                    INDENT_RE = /^(?:( )+|\t+)/;
                module.exports = function(t) {
                    if ("string" != typeof t) throw new TypeError("Expected a string");
                    var e, r, n = 0,
                        a = 0,
                        i = 0,
                        o = {};
                    t.split(/\n/g).forEach(function(t) {
                        if (t) {
                            var p, s = t.match(INDENT_RE);
                            s ? (p = s[0].length, s[1] ? a++ : n++) : p = 0;
                            var g = p - i;
                            i = p, g ? (e = o[(r = g > 0) ? g : -g]) ? e[0]++ : e = o[g] = [1, 0] : e && (e[1] += +r)
                        }
                    });
                    var p, s, g = getMostUsed(o);
                    return g ? a >= n ? (p = "space", s = repeating(" ", g)) : (p = "tab", s = repeating("\t", g)) : (p = null, s = ""), {
                        amount: g,
                        type: p,
                        indent: s
                    }
                }
            }, {
                repeating: 456
            }],
            49: [function(require, module, exports) {
                "use strict";
                module.exports = function(r) {
                    if ("string" != typeof r) throw new TypeError("Expected a string");
                    var n = r.match(/(?:\r?\n)/g) || [];
                    if (0 === n.length) return null;
                    var t = n.filter(function(r) {
                        return "\r\n" === r
                    }).length;
                    return t > n.length - t ? "\r\n" : "\n"
                }, module.exports.graceful = function(r) {
                    return module.exports(r) || "\n"
                }
            }, {}],
            50: [function(require, module, exports) {
                function SimpleDecorator(t, e) {
                    this.decorated = {}, this.strategy = t, this.getComponent = e
                }

                function decorateRange(t, e, o, r) {
                    for (var n = e; n < o; n++) t[n] = r
                }
                var Immutable = require("immutable"),
                    KEY_SEPARATOR = "-";
                SimpleDecorator.prototype.getDecorations = function(t, e) {
                    var r, o = Array(t.getText().length).fill(null),
                        n = t.getKey(),
                        i = 0,
                        a = this.decorated;
                    return a[n] = {}, this.strategy(t, function(t, e, c) {
                        void 0 === c && (c = {}), r = n + KEY_SEPARATOR + i, a[n][i] = c, decorateRange(o, t, e, r), i++
                    }, e), Immutable.List(o)
                }, SimpleDecorator.prototype.getComponentForKey = function(t) {
                    return this.getComponent
                }, SimpleDecorator.prototype.getPropsForKey = function(t) {
                    var e = t.split(KEY_SEPARATOR),
                        o = e[0],
                        r = e[1];
                    return this.decorated[o][r]
                }, module.exports = SimpleDecorator
            }, {
                immutable: 193
            }],
            51: [function(require, module, exports) {
                "use strict";
                var BlockMapBuilder = require("./BlockMapBuilder"),
                    CharacterMetadata = require("./CharacterMetadata"),
                    ContentBlock = require("./ContentBlock"),
                    DraftModifier = require("./DraftModifier"),
                    EditorState = require("./EditorState"),
                    Immutable = require("immutable"),
                    generateRandomKey = (require("./SelectionState"), require("./generateRandomKey")),
                    moveBlockInContentState = require("./moveBlockInContentState"),
                    List = Immutable.List,
                    Repeat = Immutable.Repeat,
                    AtomicBlockUtils = {
                        insertAtomicBlock: function(e, t, r) {
                            var o = e.getCurrentContent(),
                                a = e.getSelection(),
                                i = DraftModifier.removeRange(o, a, "backward"),
                                n = i.getSelectionAfter(),
                                c = DraftModifier.splitBlock(i, n),
                                l = c.getSelectionAfter(),
                                f = DraftModifier.setBlockType(c, l, "atomic"),
                                s = CharacterMetadata.create({
                                    entity: t
                                }),
                                m = [new ContentBlock({
                                    key: generateRandomKey(),
                                    type: "atomic",
                                    text: r,
                                    characterList: List(Repeat(s, r.length))
                                }), new ContentBlock({
                                    key: generateRandomKey(),
                                    type: "unstyled",
                                    text: "",
                                    characterList: List()
                                })],
                                g = BlockMapBuilder.createFromArray(m),
                                u = DraftModifier.replaceWithFragment(f, l, g),
                                d = u.merge({
                                    selectionBefore: a,
                                    selectionAfter: u.getSelectionAfter().set("hasFocus", !0)
                                });
                            return EditorState.push(e, d, "insert-fragment")
                        },
                        moveAtomicBlock: function(e, t, r, o) {
                            var a = e.getCurrentContent(),
                                i = e.getSelection(),
                                n = void 0;
                            if ("before" === o || "after" === o) {
                                var c = a.getBlockForKey("before" === o ? r.getStartKey() : r.getEndKey());
                                n = moveBlockInContentState(a, t, c, o)
                            } else {
                                var l = DraftModifier.removeRange(a, r, "backward"),
                                    f = l.getSelectionAfter(),
                                    s = l.getBlockForKey(f.getFocusKey());
                                if (0 === f.getStartOffset()) n = moveBlockInContentState(l, t, s, "before");
                                else if (f.getEndOffset() === s.getLength()) n = moveBlockInContentState(l, t, s, "after");
                                else {
                                    var m = DraftModifier.splitBlock(l, f),
                                        g = m.getSelectionAfter(),
                                        u = m.getBlockForKey(g.getFocusKey());
                                    n = moveBlockInContentState(m, t, u, "before")
                                }
                            }
                            var d = n.merge({
                                selectionBefore: i,
                                selectionAfter: n.getSelectionAfter().set("hasFocus", !0)
                            });
                            return EditorState.push(e, d, "move-block")
                        }
                    };
                module.exports = AtomicBlockUtils
            }, {
                "./BlockMapBuilder": 52,
                "./CharacterMetadata": 54,
                "./ContentBlock": 56,
                "./DraftModifier": 77,
                "./EditorState": 83,
                "./SelectionState": 87,
                "./generateRandomKey": 114,
                "./moveBlockInContentState": 146,
                immutable: 156
            }],
            52: [function(require, module, exports) {
                "use strict";
                var Immutable = require("immutable"),
                    OrderedMap = Immutable.OrderedMap,
                    BlockMapBuilder = {
                        createFromArray: function(e) {
                            return OrderedMap(e.map(function(e) {
                                return [e.getKey(), e]
                            }))
                        }
                    };
                module.exports = BlockMapBuilder
            }, {
                immutable: 156
            }],
            53: [function(require, module, exports) {
                "use strict";

                function generateLeaves(e, t) {
                    var r = [],
                        n = e.map(function(e) {
                            return e.getStyle()
                        }).toList();
                    return findRangesImmutable(n, areEqual, returnTrue, function(e, n) {
                        r.push(new LeafRange({
                            start: e + t,
                            end: n + t
                        }))
                    }), List(r)
                }

                function areEqual(e, t) {
                    return e === t
                }
                var Immutable = require("immutable"),
                    emptyFunction = require("fbjs/lib/emptyFunction"),
                    findRangesImmutable = require("./findRangesImmutable"),
                    List = Immutable.List,
                    Repeat = Immutable.Repeat,
                    Record = Immutable.Record,
                    returnTrue = emptyFunction.thatReturnsTrue,
                    FINGERPRINT_DELIMITER = "-",
                    defaultLeafRange = {
                        start: null,
                        end: null
                    },
                    LeafRange = Record(defaultLeafRange),
                    defaultDecoratorRange = {
                        start: null,
                        end: null,
                        decoratorKey: null,
                        leaves: null
                    },
                    DecoratorRange = Record(defaultDecoratorRange),
                    BlockTree = {
                        generate: function(e, t, r) {
                            var n = t.getLength();
                            if (!n) return List.of(new DecoratorRange({
                                start: 0,
                                end: 0,
                                decoratorKey: null,
                                leaves: List.of(new LeafRange({
                                    start: 0,
                                    end: 0
                                }))
                            }));
                            var a = [],
                                u = r ? r.getDecorations(t, e) : List(Repeat(null, n)),
                                l = t.getCharacterList();
                            return findRangesImmutable(u, areEqual, returnTrue, function(e, t) {
                                a.push(new DecoratorRange({
                                    start: e,
                                    end: t,
                                    decoratorKey: u.get(e),
                                    leaves: generateLeaves(l.slice(e, t).toList(), e)
                                }))
                            }), List(a)
                        },
                        getFingerprint: function(e) {
                            return e.map(function(e) {
                                var t = e.get("decoratorKey");
                                return (null !== t ? t + "." + (e.get("end") - e.get("start")) : "") + "." + e.get("leaves").size
                            }).join(FINGERPRINT_DELIMITER)
                        }
                    };
                module.exports = BlockTree
            }, {
                "./findRangesImmutable": 113,
                "fbjs/lib/emptyFunction": 175,
                immutable: 156
            }],
            54: [function(require, module, exports) {
                "use strict";

                function _classCallCheck(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }

                function _possibleConstructorReturn(e, t) {
                    if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != _typeof2(t) && "function" != typeof t ? e : t
                }

                function _inherits(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(t));
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }
                var _require = require("immutable"),
                    Map = _require.Map,
                    OrderedSet = _require.OrderedSet,
                    Record = _require.Record,
                    EMPTY_SET = OrderedSet(),
                    defaultRecord = {
                        style: EMPTY_SET,
                        entity: null
                    },
                    CharacterMetadataRecord = Record(defaultRecord),
                    CharacterMetadata = function(e) {
                        function t() {
                            return _classCallCheck(this, t), _possibleConstructorReturn(this, e.apply(this, arguments))
                        }
                        return _inherits(t, e), t.prototype.getStyle = function() {
                            return this.get("style")
                        }, t.prototype.getEntity = function() {
                            return this.get("entity")
                        }, t.prototype.hasStyle = function(e) {
                            return this.getStyle().includes(e)
                        }, t.applyStyle = function(e, r) {
                            var n = e.set("style", e.getStyle().add(r));
                            return t.create(n)
                        }, t.removeStyle = function(e, r) {
                            var n = e.set("style", e.getStyle().remove(r));
                            return t.create(n)
                        }, t.applyEntity = function(e, r) {
                            var n = e.getEntity() === r ? e : e.set("entity", r);
                            return t.create(n)
                        }, t.create = function(e) {
                            if (!e) return EMPTY;
                            var r = Map({
                                    style: EMPTY_SET,
                                    entity: null
                                }).merge(e),
                                n = pool.get(r);
                            if (n) return n;
                            var o = new t(r);
                            return pool = pool.set(r, o), o
                        }, t
                    }(CharacterMetadataRecord),
                    EMPTY = new CharacterMetadata,
                    pool = Map([
                        [Map(defaultRecord), EMPTY]
                    ]);
                CharacterMetadata.EMPTY = EMPTY, module.exports = CharacterMetadata
            }, {
                immutable: 156
            }],
            55: [function(require, module, exports) {
                "use strict";

                function _classCallCheck(t, r) {
                    if (!(t instanceof r)) throw new TypeError("Cannot call a class as a function")
                }

                function canOccupySlice(t, r, o) {
                    for (var e = r; e < o; e++)
                        if (null != t[e]) return !1;
                    return !0
                }

                function occupySlice(t, r, o, e) {
                    for (var n = r; n < o; n++) t[n] = e
                }
                var Immutable = require("immutable"),
                    List = Immutable.List,
                    DELIMITER = ".",
                    CompositeDraftDecorator = function() {
                        function t(r) {
                            _classCallCheck(this, t), this._decorators = r.slice()
                        }
                        return t.prototype.getDecorations = function(t, r) {
                            var o = Array(t.getText().length).fill(null);
                            return this._decorators.forEach(function(e, n) {
                                var c = 0;
                                (0, e.strategy)(t, function(t, r) {
                                    canOccupySlice(o, t, r) && (occupySlice(o, t, r, n + DELIMITER + c), c++)
                                }, r)
                            }), List(o)
                        }, t.prototype.getComponentForKey = function(t) {
                            var r = parseInt(t.split(DELIMITER)[0], 10);
                            return this._decorators[r].component
                        }, t.prototype.getPropsForKey = function(t) {
                            var r = parseInt(t.split(DELIMITER)[0], 10);
                            return this._decorators[r].props
                        }, t
                    }();
                module.exports = CompositeDraftDecorator
            }, {
                immutable: 156
            }],
            56: [function(require, module, exports) {
                "use strict";

                function _classCallCheck(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }

                function _possibleConstructorReturn(t, e) {
                    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !e || "object" != _typeof2(e) && "function" != typeof e ? t : e
                }

                function _inherits(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(e));
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                }

                function haveEqualStyle(t, e) {
                    return t.getStyle() === e.getStyle()
                }

                function haveEqualEntity(t, e) {
                    return t.getEntity() === e.getEntity()
                }
                var Immutable = require("immutable"),
                    findRangesImmutable = require("./findRangesImmutable"),
                    List = Immutable.List,
                    Map = Immutable.Map,
                    OrderedSet = Immutable.OrderedSet,
                    Record = Immutable.Record,
                    EMPTY_SET = OrderedSet(),
                    defaultRecord = {
                        key: "",
                        type: "unstyled",
                        text: "",
                        characterList: List(),
                        depth: 0,
                        data: Map()
                    },
                    ContentBlockRecord = Record(defaultRecord),
                    ContentBlock = function(t) {
                        function e() {
                            return _classCallCheck(this, e), _possibleConstructorReturn(this, t.apply(this, arguments))
                        }
                        return _inherits(e, t), e.prototype.getKey = function() {
                            return this.get("key")
                        }, e.prototype.getType = function() {
                            return this.get("type")
                        }, e.prototype.getText = function() {
                            return this.get("text")
                        }, e.prototype.getCharacterList = function() {
                            return this.get("characterList")
                        }, e.prototype.getLength = function() {
                            return this.getText().length
                        }, e.prototype.getDepth = function() {
                            return this.get("depth")
                        }, e.prototype.getData = function() {
                            return this.get("data")
                        }, e.prototype.getInlineStyleAt = function(t) {
                            var e = this.getCharacterList().get(t);
                            return e ? e.getStyle() : EMPTY_SET
                        }, e.prototype.getEntityAt = function(t) {
                            var e = this.getCharacterList().get(t);
                            return e ? e.getEntity() : null
                        }, e.prototype.findStyleRanges = function(t, e) {
                            findRangesImmutable(this.getCharacterList(), haveEqualStyle, t, e)
                        }, e.prototype.findEntityRanges = function(t, e) {
                            findRangesImmutable(this.getCharacterList(), haveEqualEntity, t, e)
                        }, e
                    }(ContentBlockRecord);
                module.exports = ContentBlock
            }, {
                "./findRangesImmutable": 113,
                immutable: 156
            }],
            57: [function(require, module, exports) {
                "use strict";

                function _classCallCheck(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }

                function _possibleConstructorReturn(t, e) {
                    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !e || "object" != _typeof2(e) && "function" != typeof e ? t : e
                }

                function _inherits(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(e));
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                }
                var BlockMapBuilder = require("./BlockMapBuilder"),
                    CharacterMetadata = require("./CharacterMetadata"),
                    ContentBlock = require("./ContentBlock"),
                    DraftEntity = require("./DraftEntity"),
                    Immutable = require("immutable"),
                    SelectionState = require("./SelectionState"),
                    generateRandomKey = require("./generateRandomKey"),
                    sanitizeDraftText = require("./sanitizeDraftText"),
                    List = Immutable.List,
                    Record = Immutable.Record,
                    Repeat = Immutable.Repeat,
                    defaultRecord = {
                        entityMap: null,
                        blockMap: null,
                        selectionBefore: null,
                        selectionAfter: null
                    },
                    ContentStateRecord = Record(defaultRecord),
                    ContentState = function(t) {
                        function e() {
                            return _classCallCheck(this, e), _possibleConstructorReturn(this, t.apply(this, arguments))
                        }
                        return _inherits(e, t), e.prototype.getEntityMap = function() {
                            return DraftEntity
                        }, e.prototype.getBlockMap = function() {
                            return this.get("blockMap")
                        }, e.prototype.getSelectionBefore = function() {
                            return this.get("selectionBefore")
                        }, e.prototype.getSelectionAfter = function() {
                            return this.get("selectionAfter")
                        }, e.prototype.getBlockForKey = function(t) {
                            return this.getBlockMap().get(t)
                        }, e.prototype.getKeyBefore = function(t) {
                            return this.getBlockMap().reverse().keySeq().skipUntil(function(e) {
                                return e === t
                            }).skip(1).first()
                        }, e.prototype.getKeyAfter = function(t) {
                            return this.getBlockMap().keySeq().skipUntil(function(e) {
                                return e === t
                            }).skip(1).first()
                        }, e.prototype.getBlockAfter = function(t) {
                            return this.getBlockMap().skipUntil(function(e, r) {
                                return r === t
                            }).skip(1).first()
                        }, e.prototype.getBlockBefore = function(t) {
                            return this.getBlockMap().reverse().skipUntil(function(e, r) {
                                return r === t
                            }).skip(1).first()
                        }, e.prototype.getBlocksAsArray = function() {
                            return this.getBlockMap().toArray()
                        }, e.prototype.getFirstBlock = function() {
                            return this.getBlockMap().first()
                        }, e.prototype.getLastBlock = function() {
                            return this.getBlockMap().last()
                        }, e.prototype.getPlainText = function(t) {
                            return this.getBlockMap().map(function(t) {
                                return t ? t.getText() : ""
                            }).join(t || "\n")
                        }, e.prototype.getLastCreatedEntityKey = function() {
                            return DraftEntity.__getLastCreatedEntityKey()
                        }, e.prototype.hasText = function() {
                            var t = this.getBlockMap();
                            return t.size > 1 || t.first().getLength() > 0
                        }, e.prototype.createEntity = function(t, e, r) {
                            return DraftEntity.__create(t, e, r), this
                        }, e.prototype.mergeEntityData = function(t, e) {
                            return DraftEntity.__mergeData(t, e), this
                        }, e.prototype.replaceEntityData = function(t, e) {
                            return DraftEntity.__replaceData(t, e), this
                        }, e.prototype.addEntity = function(t) {
                            return DraftEntity.__add(t), this
                        }, e.prototype.getEntity = function(t) {
                            return DraftEntity.__get(t)
                        }, e.createFromBlockArray = function(t, r) {
                            var n = Array.isArray(t) ? t : t.contentBlocks,
                                o = BlockMapBuilder.createFromArray(n),
                                i = o.isEmpty() ? new SelectionState : SelectionState.createEmpty(o.first().getKey());
                            return new e({
                                blockMap: o,
                                entityMap: r || DraftEntity,
                                selectionBefore: i,
                                selectionAfter: i
                            })
                        }, e.createFromText = function(t) {
                            var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : /\r\n?|\n/g,
                                n = t.split(r).map(function(t) {
                                    return t = sanitizeDraftText(t), new ContentBlock({
                                        key: generateRandomKey(),
                                        text: t,
                                        type: "unstyled",
                                        characterList: List(Repeat(CharacterMetadata.EMPTY, t.length))
                                    })
                                });
                            return e.createFromBlockArray(n)
                        }, e
                    }(ContentStateRecord);
                module.exports = ContentState
            }, {
                "./BlockMapBuilder": 52,
                "./CharacterMetadata": 54,
                "./ContentBlock": 56,
                "./DraftEntity": 71,
                "./SelectionState": 87,
                "./generateRandomKey": 114,
                "./sanitizeDraftText": 152,
                immutable: 156
            }],
            58: [function(require, module, exports) {
                "use strict";

                function modifyInlineStyle(e, t, r, a) {
                    var n = e.getBlockMap(),
                        i = t.getStartKey(),
                        o = t.getStartOffset(),
                        l = t.getEndKey(),
                        c = t.getEndOffset(),
                        u = n.skipUntil(function(e, t) {
                            return t === i
                        }).takeUntil(function(e, t) {
                            return t === l
                        }).concat(Map([
                            [l, n.get(l)]
                        ])).map(function(e, t) {
                            var n, u;
                            i === l ? (n = o, u = c) : (n = t === i ? o : 0, u = t === l ? c : e.getLength());
                            for (var f, y = e.getCharacterList(); n < u;) f = y.get(n), y = y.set(n, a ? CharacterMetadata.applyStyle(f, r) : CharacterMetadata.removeStyle(f, r)), n++;
                            return e.set("characterList", y)
                        });
                    return e.merge({
                        blockMap: n.merge(u),
                        selectionBefore: t,
                        selectionAfter: t
                    })
                }
                var CharacterMetadata = require("./CharacterMetadata"),
                    _require = require("immutable"),
                    Map = _require.Map,
                    ContentStateInlineStyle = {
                        add: function(e, t, r) {
                            return modifyInlineStyle(e, t, r, !0)
                        },
                        remove: function(e, t, r) {
                            return modifyInlineStyle(e, t, r, !1)
                        }
                    };
                module.exports = ContentStateInlineStyle
            }, {
                "./CharacterMetadata": 54,
                immutable: 156
            }],
            59: [function(require, module, exports) {
                "use strict";
                var _require = require("immutable"),
                    Map = _require.Map,
                    React = require("react"),
                    cx = require("fbjs/lib/cx"),
                    UL_WRAP = React.createElement("ul", {
                        className: cx("public/DraftStyleDefault/ul")
                    }),
                    OL_WRAP = React.createElement("ol", {
                        className: cx("public/DraftStyleDefault/ol")
                    }),
                    PRE_WRAP = React.createElement("pre", {
                        className: cx("public/DraftStyleDefault/pre")
                    }),
                    DefaultDraftBlockRenderMap = Map({
                        "header-one": {
                            element: "h1"
                        },
                        "header-two": {
                            element: "h2"
                        },
                        "header-three": {
                            element: "h3"
                        },
                        "header-four": {
                            element: "h4"
                        },
                        "header-five": {
                            element: "h5"
                        },
                        "header-six": {
                            element: "h6"
                        },
                        "unordered-list-item": {
                            element: "li",
                            wrapper: UL_WRAP
                        },
                        "ordered-list-item": {
                            element: "li",
                            wrapper: OL_WRAP
                        },
                        blockquote: {
                            element: "blockquote"
                        },
                        atomic: {
                            element: "figure"
                        },
                        "code-block": {
                            element: "pre",
                            wrapper: PRE_WRAP
                        },
                        unstyled: {
                            element: "div",
                            aliasedElements: ["p"]
                        }
                    });
                module.exports = DefaultDraftBlockRenderMap
            }, {
                "fbjs/lib/cx": 174,
                immutable: 156,
                react: 455
            }],
            60: [function(require, module, exports) {
                "use strict";
                module.exports = {
                    BOLD: {
                        fontWeight: "bold"
                    },
                    CODE: {
                        fontFamily: "monospace",
                        wordWrap: "break-word"
                    },
                    ITALIC: {
                        fontStyle: "italic"
                    },
                    STRIKETHROUGH: {
                        textDecoration: "line-through"
                    },
                    UNDERLINE: {
                        textDecoration: "underline"
                    }
                }
            }, {}],
            61: [function(require, module, exports) {
                "use strict";
                var AtomicBlockUtils = require("./AtomicBlockUtils"),
                    BlockMapBuilder = require("./BlockMapBuilder"),
                    CharacterMetadata = require("./CharacterMetadata"),
                    CompositeDraftDecorator = require("./CompositeDraftDecorator"),
                    ContentBlock = require("./ContentBlock"),
                    ContentState = require("./ContentState"),
                    DefaultDraftBlockRenderMap = require("./DefaultDraftBlockRenderMap"),
                    DefaultDraftInlineStyle = require("./DefaultDraftInlineStyle"),
                    DraftEditor = require("./DraftEditor.react"),
                    DraftEditorBlock = require("./DraftEditorBlock.react"),
                    DraftEntity = require("./DraftEntity"),
                    DraftModifier = require("./DraftModifier"),
                    DraftEntityInstance = require("./DraftEntityInstance"),
                    EditorState = require("./EditorState"),
                    KeyBindingUtil = require("./KeyBindingUtil"),
                    RichTextEditorUtil = require("./RichTextEditorUtil"),
                    SelectionState = require("./SelectionState"),
                    convertFromDraftStateToRaw = require("./convertFromDraftStateToRaw"),
                    convertFromHTMLToContentBlocks = require("./convertFromHTMLToContentBlocks"),
                    convertFromRawToDraftState = require("./convertFromRawToDraftState"),
                    generateRandomKey = require("./generateRandomKey"),
                    getDefaultKeyBinding = require("./getDefaultKeyBinding"),
                    getVisibleSelectionRect = require("./getVisibleSelectionRect"),
                    DraftPublic = {
                        Editor: DraftEditor,
                        EditorBlock: DraftEditorBlock,
                        EditorState: EditorState,
                        CompositeDecorator: CompositeDraftDecorator,
                        Entity: DraftEntity,
                        EntityInstance: DraftEntityInstance,
                        BlockMapBuilder: BlockMapBuilder,
                        CharacterMetadata: CharacterMetadata,
                        ContentBlock: ContentBlock,
                        ContentState: ContentState,
                        SelectionState: SelectionState,
                        AtomicBlockUtils: AtomicBlockUtils,
                        KeyBindingUtil: KeyBindingUtil,
                        Modifier: DraftModifier,
                        RichUtils: RichTextEditorUtil,
                        DefaultDraftBlockRenderMap: DefaultDraftBlockRenderMap,
                        DefaultDraftInlineStyle: DefaultDraftInlineStyle,
                        convertFromHTML: convertFromHTMLToContentBlocks,
                        convertFromRaw: convertFromRawToDraftState,
                        convertToRaw: convertFromDraftStateToRaw,
                        genKey: generateRandomKey,
                        getDefaultKeyBinding: getDefaultKeyBinding,
                        getVisibleSelectionRect: getVisibleSelectionRect
                    };
                module.exports = DraftPublic
            }, {
                "./AtomicBlockUtils": 51,
                "./BlockMapBuilder": 52,
                "./CharacterMetadata": 54,
                "./CompositeDraftDecorator": 55,
                "./ContentBlock": 56,
                "./ContentState": 57,
                "./DefaultDraftBlockRenderMap": 59,
                "./DefaultDraftInlineStyle": 60,
                "./DraftEditor.react": 62,
                "./DraftEditorBlock.react": 63,
                "./DraftEntity": 71,
                "./DraftEntityInstance": 72,
                "./DraftModifier": 77,
                "./EditorState": 83,
                "./KeyBindingUtil": 84,
                "./RichTextEditorUtil": 85,
                "./SelectionState": 87,
                "./convertFromDraftStateToRaw": 91,
                "./convertFromHTMLToContentBlocks": 92,
                "./convertFromRawToDraftState": 93,
                "./generateRandomKey": 114,
                "./getDefaultKeyBinding": 117,
                "./getVisibleSelectionRect": 129
            }],
            62: [function(require, module, exports) {
                (function(process) {
                    "use strict";

                    function _classCallCheck(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }

                    function _possibleConstructorReturn(t, e) {
                        if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return !e || "object" != _typeof2(e) && "function" != typeof e ? t : e
                    }

                    function _inherits(t, e) {
                        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(e));
                        t.prototype = Object.create(e && e.prototype, {
                            constructor: {
                                value: t,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                    }
                    var _assign = require("object-assign"),
                        _extends = _assign || function(t) {
                            for (var e = 1; e < arguments.length; e++) {
                                var o = arguments[e];
                                for (var r in o) Object.prototype.hasOwnProperty.call(o, r) && (t[r] = o[r])
                            }
                            return t
                        },
                        DefaultDraftBlockRenderMap = require("./DefaultDraftBlockRenderMap"),
                        DefaultDraftInlineStyle = require("./DefaultDraftInlineStyle"),
                        DraftEditorCompositionHandler = require("./DraftEditorCompositionHandler"),
                        DraftEditorContents = require("./DraftEditorContents.react"),
                        DraftEditorDragHandler = require("./DraftEditorDragHandler"),
                        DraftEditorEditHandler = require("./DraftEditorEditHandler"),
                        DraftEditorPlaceholder = require("./DraftEditorPlaceholder.react"),
                        EditorState = require("./EditorState"),
                        React = require("react"),
                        ReactDOM = require("react-dom"),
                        Scroll = require("fbjs/lib/Scroll"),
                        Style = require("fbjs/lib/Style"),
                        UserAgent = require("fbjs/lib/UserAgent"),
                        cx = require("fbjs/lib/cx"),
                        emptyFunction = require("fbjs/lib/emptyFunction"),
                        generateRandomKey = require("./generateRandomKey"),
                        getDefaultKeyBinding = require("./getDefaultKeyBinding"),
                        getScrollPosition = require("fbjs/lib/getScrollPosition"),
                        invariant = require("fbjs/lib/invariant"),
                        nullthrows = require("fbjs/lib/nullthrows"),
                        isIE = UserAgent.isBrowser("IE"),
                        allowSpellCheck = !isIE,
                        handlerMap = {
                            edit: DraftEditorEditHandler,
                            composite: DraftEditorCompositionHandler,
                            drag: DraftEditorDragHandler,
                            cut: null,
                            render: null
                        },
                        DraftEditor = function(t) {
                            function e(o) {
                                _classCallCheck(this, e);
                                var r = _possibleConstructorReturn(this, t.call(this, o));
                                return r._blockSelectEvents = !1, r._clipboard = null, r._handler = null, r._dragCount = 0, r._editorKey = o.editorKey || generateRandomKey(), r._placeholderAccessibilityID = "placeholder-" + r._editorKey, r._latestEditorState = o.editorState, r._latestCommittedEditorState = o.editorState, r._onBeforeInput = r._buildHandler("onBeforeInput"), r._onBlur = r._buildHandler("onBlur"), r._onCharacterData = r._buildHandler("onCharacterData"), r._onCompositionEnd = r._buildHandler("onCompositionEnd"), r._onCompositionStart = r._buildHandler("onCompositionStart"), r._onCopy = r._buildHandler("onCopy"), r._onCut = r._buildHandler("onCut"), r._onDragEnd = r._buildHandler("onDragEnd"), r._onDragOver = r._buildHandler("onDragOver"), r._onDragStart = r._buildHandler("onDragStart"), r._onDrop = r._buildHandler("onDrop"), r._onInput = r._buildHandler("onInput"), r._onFocus = r._buildHandler("onFocus"), r._onKeyDown = r._buildHandler("onKeyDown"), r._onKeyPress = r._buildHandler("onKeyPress"), r._onKeyUp = r._buildHandler("onKeyUp"), r._onMouseDown = r._buildHandler("onMouseDown"), r._onMouseUp = r._buildHandler("onMouseUp"), r._onPaste = r._buildHandler("onPaste"), r._onSelect = r._buildHandler("onSelect"), r.focus = r._focus.bind(r), r.blur = r._blur.bind(r), r.setMode = r._setMode.bind(r), r.exitCurrentMode = r._exitCurrentMode.bind(r), r.restoreEditorDOM = r._restoreEditorDOM.bind(r), r.setClipboard = r._setClipboard.bind(r), r.getClipboard = r._getClipboard.bind(r), r.getEditorKey = function() {
                                    return r._editorKey
                                }, r.update = r._update.bind(r), r.onDragEnter = r._onDragEnter.bind(r), r.onDragLeave = r._onDragLeave.bind(r), r.state = {
                                    contentsKey: 0
                                }, r
                            }
                            return _inherits(e, t), e.prototype._buildHandler = function(t) {
                                var e = this;
                                return function(o) {
                                    if (!e.props.readOnly) {
                                        var r = e._handler && e._handler[t];
                                        r && r(e, o)
                                    }
                                }
                            }, e.prototype._showPlaceholder = function() {
                                return !!this.props.placeholder && !this.props.editorState.isInCompositionMode() && !this.props.editorState.getCurrentContent().hasText()
                            }, e.prototype._renderPlaceholder = function() {
                                return this._showPlaceholder() ? React.createElement(DraftEditorPlaceholder, {
                                    text: nullthrows(this.props.placeholder),
                                    editorState: this.props.editorState,
                                    textAlignment: this.props.textAlignment,
                                    accessibilityID: this._placeholderAccessibilityID
                                }) : null
                            }, e.prototype.render = function() {
                                var t = this.props,
                                    e = t.readOnly,
                                    o = t.textAlignment,
                                    r = cx({
                                        "DraftEditor/root": !0,
                                        "DraftEditor/alignLeft": "left" === o,
                                        "DraftEditor/alignRight": "right" === o,
                                        "DraftEditor/alignCenter": "center" === o
                                    }),
                                    n = this.props.role || "textbox",
                                    i = "combobox" === n ? !!this.props.ariaExpanded : null;
                                return React.createElement("div", {
                                    className: r
                                }, this._renderPlaceholder(), React.createElement("div", {
                                    className: cx("DraftEditor/editorContainer"),
                                    ref: "editorContainer"
                                }, React.createElement("div", {
                                    "aria-activedescendant": e ? null : this.props.ariaActiveDescendantID,
                                    "aria-autocomplete": e ? null : this.props.ariaAutoComplete,
                                    "aria-controls": e ? null : this.props.ariaControls,
                                    "aria-describedby": this._showPlaceholder() ? this._placeholderAccessibilityID : null,
                                    "aria-expanded": e ? null : i,
                                    "aria-label": this.props.ariaLabel,
                                    "aria-multiline": this.props.ariaMultiline,
                                    autoCapitalize: this.props.autoCapitalize,
                                    autoComplete: this.props.autoComplete,
                                    autoCorrect: this.props.autoCorrect,
                                    className: cx({
                                        notranslate: !e,
                                        "public/DraftEditor/content": !0
                                    }),
                                    contentEditable: !e,
                                    "data-testid": this.props.webDriverTestID,
                                    onBeforeInput: this._onBeforeInput,
                                    onBlur: this._onBlur,
                                    onCompositionEnd: this._onCompositionEnd,
                                    onCompositionStart: this._onCompositionStart,
                                    onCopy: this._onCopy,
                                    onCut: this._onCut,
                                    onDragEnd: this._onDragEnd,
                                    onDragEnter: this.onDragEnter,
                                    onDragLeave: this.onDragLeave,
                                    onDragOver: this._onDragOver,
                                    onDragStart: this._onDragStart,
                                    onDrop: this._onDrop,
                                    onFocus: this._onFocus,
                                    onInput: this._onInput,
                                    onKeyDown: this._onKeyDown,
                                    onKeyPress: this._onKeyPress,
                                    onKeyUp: this._onKeyUp,
                                    onMouseUp: this._onMouseUp,
                                    onPaste: this._onPaste,
                                    onSelect: this._onSelect,
                                    ref: "editor",
                                    role: e ? null : n,
                                    spellCheck: allowSpellCheck && this.props.spellCheck,
                                    style: {
                                        outline: "none",
                                        userSelect: "text",
                                        WebkitUserSelect: "text",
                                        whiteSpace: "pre-wrap",
                                        wordWrap: "break-word"
                                    },
                                    suppressContentEditableWarning: !0,
                                    tabIndex: this.props.tabIndex
                                }, React.createElement(DraftEditorContents, {
                                    blockRenderMap: this.props.blockRenderMap,
                                    blockRendererFn: this.props.blockRendererFn,
                                    blockStyleFn: this.props.blockStyleFn,
                                    customStyleMap: _extends({}, DefaultDraftInlineStyle, this.props.customStyleMap),
                                    customStyleFn: this.props.customStyleFn,
                                    editorKey: this._editorKey,
                                    editorState: this.props.editorState,
                                    key: "contents" + this.state.contentsKey,
                                    textDirectionality: this.props.textDirectionality
                                }))))
                            }, e.prototype.componentDidMount = function() {
                                this.setMode("edit"), isIE && document.execCommand("AutoUrlDetect", !1, !1)
                            }, e.prototype.componentWillUpdate = function(t) {
                                this._blockSelectEvents = !0, this._latestEditorState = t.editorState
                            }, e.prototype.componentDidUpdate = function() {
                                this._blockSelectEvents = !1, this._latestCommittedEditorState = this.props.editorState
                            }, e.prototype._focus = function(t) {
                                var e = this.props.editorState,
                                    o = e.getSelection().getHasFocus(),
                                    r = ReactDOM.findDOMNode(this.refs.editor);
                                if (r) {
                                    var n = Style.getScrollParent(r),
                                        i = t || getScrollPosition(n),
                                        a = i.x,
                                        l = i.y;
                                    r instanceof HTMLElement || ("production" !== process.env.NODE_ENV ? invariant(!1, "editorNode is not an HTMLElement") : invariant(!1)), r.focus(), n === window ? window.scrollTo(a, l) : Scroll.setTop(n, l), o || this.update(EditorState.forceSelection(e, e.getSelection()))
                                }
                            }, e.prototype._blur = function() {
                                var t = ReactDOM.findDOMNode(this.refs.editor);
                                t instanceof HTMLElement || ("production" !== process.env.NODE_ENV ? invariant(!1, "editorNode is not an HTMLElement") : invariant(!1)), t.blur()
                            }, e.prototype._setMode = function(t) {
                                this._handler = handlerMap[t]
                            }, e.prototype._exitCurrentMode = function() {
                                this.setMode("edit")
                            }, e.prototype._restoreEditorDOM = function(t) {
                                var e = this;
                                this.setState({
                                    contentsKey: this.state.contentsKey + 1
                                }, function() {
                                    e._focus(t)
                                })
                            }, e.prototype._setClipboard = function(t) {
                                this._clipboard = t
                            }, e.prototype._getClipboard = function() {
                                return this._clipboard
                            }, e.prototype._update = function(t) {
                                this._latestEditorState = t, this.props.onChange(t)
                            }, e.prototype._onDragEnter = function() {
                                this._dragCount++
                            }, e.prototype._onDragLeave = function() {
                                this._dragCount--, 0 === this._dragCount && this.exitCurrentMode()
                            }, e
                        }(React.Component);
                    DraftEditor.defaultProps = {
                        blockRenderMap: DefaultDraftBlockRenderMap,
                        blockRendererFn: emptyFunction.thatReturnsNull,
                        blockStyleFn: emptyFunction.thatReturns(""),
                        keyBindingFn: getDefaultKeyBinding,
                        readOnly: !1,
                        spellCheck: !1,
                        stripPastedStyles: !1
                    }, module.exports = DraftEditor
                }).call(this, require("_process"))
            }, {
                "./DefaultDraftBlockRenderMap": 59,
                "./DefaultDraftInlineStyle": 60,
                "./DraftEditorCompositionHandler": 64,
                "./DraftEditorContents.react": 65,
                "./DraftEditorDragHandler": 66,
                "./DraftEditorEditHandler": 67,
                "./DraftEditorPlaceholder.react": 69,
                "./EditorState": 83,
                "./generateRandomKey": 114,
                "./getDefaultKeyBinding": 117,
                _process: 433,
                "fbjs/lib/Scroll": 160,
                "fbjs/lib/Style": 161,
                "fbjs/lib/UserAgent": 168,
                "fbjs/lib/cx": 174,
                "fbjs/lib/emptyFunction": 175,
                "fbjs/lib/getScrollPosition": 180,
                "fbjs/lib/invariant": 185,
                "fbjs/lib/nullthrows": 191,
                "object-assign": 421,
                react: 455,
                "react-dom": 438
            }],
            63: [function(require, module, exports) {
                (function(process) {
                    "use strict";

                    function _classCallCheck(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }

                    function _possibleConstructorReturn(e, t) {
                        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return !t || "object" != _typeof2(t) && "function" != typeof t ? e : t
                    }

                    function _inherits(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(t));
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                    }

                    function isBlockOnSelectionEdge(e, t) {
                        return e.getAnchorKey() === t || e.getFocusKey() === t
                    }
                    var _assign = require("object-assign"),
                        _extends = _assign || function(e) {
                            for (var t = 1; t < arguments.length; t++) {
                                var r = arguments[t];
                                for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (e[o] = r[o])
                            }
                            return e
                        },
                        DraftEditorLeaf = require("./DraftEditorLeaf.react"),
                        DraftOffsetKey = require("./DraftOffsetKey"),
                        React = require("react"),
                        ReactDOM = require("react-dom"),
                        Scroll = require("fbjs/lib/Scroll"),
                        Style = require("fbjs/lib/Style"),
                        UnicodeBidi = require("fbjs/lib/UnicodeBidi"),
                        UnicodeBidiDirection = require("fbjs/lib/UnicodeBidiDirection"),
                        cx = require("fbjs/lib/cx"),
                        getElementPosition = require("fbjs/lib/getElementPosition"),
                        getScrollPosition = require("fbjs/lib/getScrollPosition"),
                        getViewportDimensions = require("fbjs/lib/getViewportDimensions"),
                        invariant = require("fbjs/lib/invariant"),
                        nullthrows = require("fbjs/lib/nullthrows"),
                        SCROLL_BUFFER = 10,
                        DraftEditorBlock = function(e) {
                            function t() {
                                return _classCallCheck(this, t), _possibleConstructorReturn(this, e.apply(this, arguments))
                            }
                            return _inherits(t, e), t.prototype.shouldComponentUpdate = function(e) {
                                return this.props.block !== e.block || this.props.tree !== e.tree || this.props.direction !== e.direction || isBlockOnSelectionEdge(e.selection, e.block.getKey()) && e.forceSelection
                            }, t.prototype.componentDidMount = function() {
                                var e = this.props.selection,
                                    t = e.getEndKey();
                                if (e.getHasFocus() && t === this.props.block.getKey()) {
                                    var r, o = ReactDOM.findDOMNode(this),
                                        i = Style.getScrollParent(o),
                                        n = getScrollPosition(i);
                                    if (i === window) {
                                        var s = getElementPosition(o);
                                        (r = s.y + s.height - getViewportDimensions().height) > 0 && window.scrollTo(n.x, n.y + r + SCROLL_BUFFER)
                                    } else o instanceof HTMLElement || ("production" !== process.env.NODE_ENV ? invariant(!1, "blockNode is not an HTMLElement") : invariant(!1)), (r = o.offsetHeight + o.offsetTop - (i.offsetHeight + n.y)) > 0 && Scroll.setTop(i, Scroll.getTop(i) + r + SCROLL_BUFFER)
                                }
                            }, t.prototype._renderChildren = function() {
                                var e = this,
                                    t = this.props.block,
                                    r = t.getKey(),
                                    o = t.getText(),
                                    i = this.props.tree.size - 1,
                                    n = isBlockOnSelectionEdge(this.props.selection, r);
                                return this.props.tree.map(function(s, c) {
                                    var l = s.get("leaves"),
                                        a = l.size - 1,
                                        f = l.map(function(s, l) {
                                            var f = DraftOffsetKey.encode(r, c, l),
                                                p = s.get("start"),
                                                u = s.get("end");
                                            return React.createElement(DraftEditorLeaf, {
                                                key: f,
                                                offsetKey: f,
                                                block: t,
                                                start: p,
                                                selection: n ? e.props.selection : void 0,
                                                forceSelection: e.props.forceSelection,
                                                text: o.slice(p, u),
                                                styleSet: t.getInlineStyleAt(p),
                                                customStyleMap: e.props.customStyleMap,
                                                customStyleFn: e.props.customStyleFn,
                                                isLast: c === i && l === a
                                            })
                                        }).toArray(),
                                        p = s.get("decoratorKey");
                                    if (null == p) return f;
                                    if (!e.props.decorator) return f;
                                    var u = nullthrows(e.props.decorator),
                                        d = u.getComponentForKey(p);
                                    if (!d) return f;
                                    var y = u.getPropsForKey(p),
                                        b = DraftOffsetKey.encode(r, c, 0),
                                        g = o.slice(l.first().get("start"), l.last().get("end")),
                                        h = UnicodeBidiDirection.getHTMLDirIfDifferent(UnicodeBidi.getDirection(g), e.props.direction);
                                    return React.createElement(d, _extends({}, y, {
                                        contentState: e.props.contentState,
                                        decoratedText: g,
                                        dir: h,
                                        key: b,
                                        entityKey: t.getEntityAt(s.get("start")),
                                        offsetKey: b
                                    }), f)
                                }).toArray()
                            }, t.prototype.render = function() {
                                var e = this.props,
                                    t = e.direction,
                                    r = e.offsetKey,
                                    o = cx({
                                        "public/DraftStyleDefault/block": !0,
                                        "public/DraftStyleDefault/ltr": "LTR" === t,
                                        "public/DraftStyleDefault/rtl": "RTL" === t
                                    });
                                return React.createElement("div", {
                                    "data-offset-key": r,
                                    className: o
                                }, this._renderChildren())
                            }, t
                        }(React.Component);
                    module.exports = DraftEditorBlock
                }).call(this, require("_process"))
            }, {
                "./DraftEditorLeaf.react": 68,
                "./DraftOffsetKey": 78,
                _process: 433,
                "fbjs/lib/Scroll": 160,
                "fbjs/lib/Style": 161,
                "fbjs/lib/UnicodeBidi": 164,
                "fbjs/lib/UnicodeBidiDirection": 165,
                "fbjs/lib/cx": 174,
                "fbjs/lib/getElementPosition": 178,
                "fbjs/lib/getScrollPosition": 180,
                "fbjs/lib/getViewportDimensions": 183,
                "fbjs/lib/invariant": 185,
                "fbjs/lib/nullthrows": 191,
                "object-assign": 421,
                react: 455,
                "react-dom": 438
            }],
            64: [function(require, module, exports) {
                "use strict";
                var DraftModifier = require("./DraftModifier"),
                    EditorState = require("./EditorState"),
                    Keys = require("fbjs/lib/Keys"),
                    getEntityKeyForSelection = require("./getEntityKeyForSelection"),
                    isSelectionAtLeafStart = require("./isSelectionAtLeafStart"),
                    RESOLVE_DELAY = 20,
                    resolved = !1,
                    stillComposing = !1,
                    textInputData = "",
                    DraftEditorCompositionHandler = {
                        onBeforeInput: function(t, e) {
                            textInputData = (textInputData || "") + e.data
                        },
                        onCompositionStart: function(t) {
                            stillComposing = !0
                        },
                        onCompositionEnd: function(t) {
                            resolved = !1, stillComposing = !1, setTimeout(function() {
                                resolved || DraftEditorCompositionHandler.resolveComposition(t)
                            }, RESOLVE_DELAY)
                        },
                        onKeyDown: function(t, e) {
                            return stillComposing ? void(e.which !== Keys.RIGHT && e.which !== Keys.LEFT || e.preventDefault()) : (DraftEditorCompositionHandler.resolveComposition(t), void t._onKeyDown(e))
                        },
                        onKeyPress: function(t, e) {
                            e.which === Keys.RETURN && e.preventDefault()
                        },
                        resolveComposition: function(t) {
                            if (!stillComposing) {
                                resolved = !0;
                                var e = textInputData;
                                textInputData = "";
                                var o = EditorState.set(t._latestEditorState, {
                                        inCompositionMode: !1
                                    }),
                                    i = o.getCurrentInlineStyle(),
                                    n = getEntityKeyForSelection(o.getCurrentContent(), o.getSelection()),
                                    r = !e || isSelectionAtLeafStart(o) || i.size > 0 || null !== n;
                                if (r && t.restoreEditorDOM(), t.exitCurrentMode(), e) {
                                    var s = DraftModifier.replaceText(o.getCurrentContent(), o.getSelection(), e, i, n);
                                    t.update(EditorState.push(o, s, "insert-characters"))
                                } else r && t.update(EditorState.set(o, {
                                    nativelyRenderedContent: null,
                                    forceSelection: !0
                                }))
                            }
                        }
                    };
                module.exports = DraftEditorCompositionHandler
            }, {
                "./DraftModifier": 77,
                "./EditorState": 83,
                "./getEntityKeyForSelection": 120,
                "./isSelectionAtLeafStart": 134,
                "fbjs/lib/Keys": 158
            }],
            65: [function(require, module, exports) {
                "use strict";

                function _classCallCheck(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }

                function _possibleConstructorReturn(e, t) {
                    if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !t || "object" != _typeof2(t) && "function" != typeof t ? e : t
                }

                function _inherits(e, t) {
                    if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(t));
                    e.prototype = Object.create(t && t.prototype, {
                        constructor: {
                            value: e,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                }

                function getListItemClasses(e, t, r, o) {
                    return cx({
                        "public/DraftStyleDefault/unorderedListItem": "unordered-list-item" === e,
                        "public/DraftStyleDefault/orderedListItem": "ordered-list-item" === e,
                        "public/DraftStyleDefault/reset": r,
                        "public/DraftStyleDefault/depth0": 0 === t,
                        "public/DraftStyleDefault/depth1": 1 === t,
                        "public/DraftStyleDefault/depth2": 2 === t,
                        "public/DraftStyleDefault/depth3": 3 === t,
                        "public/DraftStyleDefault/depth4": 4 === t,
                        "public/DraftStyleDefault/listLTR": "LTR" === o,
                        "public/DraftStyleDefault/listRTL": "RTL" === o
                    })
                }
                var _assign = require("object-assign"),
                    _extends = _assign || function(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var r = arguments[t];
                            for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (e[o] = r[o])
                        }
                        return e
                    },
                    DraftEditorBlock = require("./DraftEditorBlock.react"),
                    DraftOffsetKey = require("./DraftOffsetKey"),
                    React = (require("./EditorState"), require("react")),
                    cx = require("fbjs/lib/cx"),
                    joinClasses = require("fbjs/lib/joinClasses"),
                    nullthrows = require("fbjs/lib/nullthrows"),
                    DraftEditorContents = function(e) {
                        function t() {
                            return _classCallCheck(this, t), _possibleConstructorReturn(this, e.apply(this, arguments))
                        }
                        return _inherits(t, e), t.prototype.shouldComponentUpdate = function(e) {
                            var t = this.props.editorState,
                                r = e.editorState;
                            if (t.getDirectionMap() !== r.getDirectionMap()) return !0;
                            if (t.getSelection().getHasFocus() !== r.getSelection().getHasFocus()) return !0;
                            var o = r.getNativelyRenderedContent(),
                                n = t.isInCompositionMode(),
                                a = r.isInCompositionMode();
                            if (t === r || null !== o && r.getCurrentContent() === o || n && a) return !1;
                            var l = t.getCurrentContent(),
                                i = r.getCurrentContent(),
                                s = t.getDecorator(),
                                c = r.getDecorator();
                            return n !== a || l !== i || s !== c || r.mustForceSelection()
                        }, t.prototype.render = function() {
                            for (var e = this.props, t = e.blockRenderMap, r = e.blockRendererFn, o = e.customStyleMap, n = e.customStyleFn, a = e.editorState, l = a.getCurrentContent(), i = a.getSelection(), s = a.mustForceSelection(), c = a.getDecorator(), u = nullthrows(a.getDirectionMap()), p = l.getBlocksAsArray(), f = [], d = null, y = null, b = 0; b < p.length; b++) {
                                var h = p[b],
                                    g = h.getKey(),
                                    D = h.getType(),
                                    m = r(h),
                                    C = void 0,
                                    S = void 0,
                                    v = void 0;
                                m && (C = m.component, S = m.props, v = m.editable);
                                var k = this.props.textDirectionality,
                                    w = k || u.get(g),
                                    E = DraftOffsetKey.encode(g, 0, 0),
                                    R = {
                                        contentState: l,
                                        block: h,
                                        blockProps: S,
                                        customStyleMap: o,
                                        customStyleFn: n,
                                        decorator: c,
                                        direction: w,
                                        forceSelection: s,
                                        key: g,
                                        offsetKey: E,
                                        selection: i,
                                        tree: a.getBlockTree(g)
                                    },
                                    _ = t.get(D) || t.get("unstyled"),
                                    T = _.wrapper,
                                    j = _.element || t.get("unstyled").element,
                                    O = h.getDepth(),
                                    q = this.props.blockStyleFn(h);
                                "li" === j && (q = joinClasses(q, getListItemClasses(D, O, y !== T || null === d || O > d, w)));
                                var x = C || DraftEditorBlock,
                                    F = {
                                        className: q,
                                        "data-block": !0,
                                        "data-editor": this.props.editorKey,
                                        "data-offset-key": E,
                                        key: g
                                    };
                                void 0 !== v && (F = _extends({}, F, {
                                    contentEditable: v,
                                    suppressContentEditableWarning: !0
                                }));
                                var K = React.createElement(j, F, React.createElement(x, R));
                                f.push({
                                    block: K,
                                    wrapperTemplate: T,
                                    key: g,
                                    offsetKey: E
                                }), d = T ? h.getDepth() : null, y = T
                            }
                            for (var L = [], M = 0; M < f.length;) {
                                var I = f[M];
                                if (I.wrapperTemplate) {
                                    var B = [];
                                    do B.push(f[M].block), M++; while (M < f.length && f[M].wrapperTemplate === I.wrapperTemplate);
                                    var P = React.cloneElement(I.wrapperTemplate, {
                                        key: I.key + "-wrap",
                                        "data-offset-key": I.offsetKey
                                    }, B);
                                    L.push(P)
                                } else L.push(I.block), M++
                            }
                            return React.createElement("div", {
                                "data-contents": "true"
                            }, L)
                        }, t
                    }(React.Component);
                module.exports = DraftEditorContents
            }, {
                "./DraftEditorBlock.react": 63,
                "./DraftOffsetKey": 78,
                "./EditorState": 83,
                "fbjs/lib/cx": 174,
                "fbjs/lib/joinClasses": 188,
                "fbjs/lib/nullthrows": 191,
                "object-assign": 421,
                react: 455
            }],
            66: [function(require, module, exports) {
                "use strict";

                function getSelectionForEvent(e, t) {
                    var r = null,
                        n = null;
                    if ("function" == typeof document.caretRangeFromPoint) {
                        var a = document.caretRangeFromPoint(e.x, e.y);
                        r = a.startContainer, n = a.startOffset
                    } else {
                        if (!e.rangeParent) return null;
                        r = e.rangeParent, n = e.rangeOffset
                    }
                    r = nullthrows(r), n = nullthrows(n);
                    var i = nullthrows(findAncestorOffsetKey(r));
                    return getUpdatedSelectionState(t, i, n, i, n)
                }

                function moveText(e, t) {
                    var r = DraftModifier.moveText(e.getCurrentContent(), e.getSelection(), t);
                    return EditorState.push(e, r, "insert-fragment")
                }

                function insertTextAtSelection(e, t, r) {
                    var n = DraftModifier.insertText(e.getCurrentContent(), t, r, e.getCurrentInlineStyle());
                    return EditorState.push(e, n, "insert-fragment")
                }
                var DataTransfer = require("fbjs/lib/DataTransfer"),
                    DraftModifier = require("./DraftModifier"),
                    EditorState = require("./EditorState"),
                    findAncestorOffsetKey = require("./findAncestorOffsetKey"),
                    getTextContentFromFiles = require("./getTextContentFromFiles"),
                    getUpdatedSelectionState = require("./getUpdatedSelectionState"),
                    isEventHandled = require("./isEventHandled"),
                    nullthrows = require("fbjs/lib/nullthrows"),
                    DraftEditorDragHandler = {
                        onDragEnd: function(e) {
                            e.exitCurrentMode()
                        },
                        onDrop: function(e, t) {
                            var r = new DataTransfer(t.nativeEvent.dataTransfer),
                                n = e._latestEditorState,
                                a = getSelectionForEvent(t.nativeEvent, n);
                            if (t.preventDefault(), e.exitCurrentMode(), null != a) {
                                var i = r.getFiles();
                                if (i.length > 0) {
                                    if (e.props.handleDroppedFiles && isEventHandled(e.props.handleDroppedFiles(a, i))) return;
                                    getTextContentFromFiles(i, function(t) {
                                        t && e.update(insertTextAtSelection(n, a, t))
                                    })
                                } else {
                                    var o = e._internalDrag ? "internal" : "external";
                                    e.props.handleDrop && isEventHandled(e.props.handleDrop(a, r, o)) || (e._internalDrag ? e.update(moveText(n, a)) : e.update(insertTextAtSelection(n, a, r.getText())))
                                }
                            }
                        }
                    };
                module.exports = DraftEditorDragHandler
            }, {
                "./DraftModifier": 77,
                "./EditorState": 83,
                "./findAncestorOffsetKey": 112,
                "./getTextContentFromFiles": 127,
                "./getUpdatedSelectionState": 128,
                "./isEventHandled": 133,
                "fbjs/lib/DataTransfer": 157,
                "fbjs/lib/nullthrows": 191
            }],
            67: [function(require, module, exports) {
                "use strict";
                var onBeforeInput = require("./editOnBeforeInput"),
                    onBlur = require("./editOnBlur"),
                    onCompositionStart = require("./editOnCompositionStart"),
                    onCopy = require("./editOnCopy"),
                    onCut = require("./editOnCut"),
                    onDragOver = require("./editOnDragOver"),
                    onDragStart = require("./editOnDragStart"),
                    onFocus = require("./editOnFocus"),
                    onInput = require("./editOnInput"),
                    onKeyDown = require("./editOnKeyDown"),
                    onPaste = require("./editOnPaste"),
                    onSelect = require("./editOnSelect"),
                    DraftEditorEditHandler = {
                        onBeforeInput: onBeforeInput,
                        onBlur: onBlur,
                        onCompositionStart: onCompositionStart,
                        onCopy: onCopy,
                        onCut: onCut,
                        onDragOver: onDragOver,
                        onDragStart: onDragStart,
                        onFocus: onFocus,
                        onInput: onInput,
                        onKeyDown: onKeyDown,
                        onPaste: onPaste,
                        onSelect: onSelect
                    };
                module.exports = DraftEditorEditHandler
            }, {
                "./editOnBeforeInput": 97,
                "./editOnBlur": 98,
                "./editOnCompositionStart": 99,
                "./editOnCopy": 100,
                "./editOnCut": 101,
                "./editOnDragOver": 102,
                "./editOnDragStart": 103,
                "./editOnFocus": 104,
                "./editOnInput": 105,
                "./editOnKeyDown": 106,
                "./editOnPaste": 107,
                "./editOnSelect": 108
            }],
            68: [function(require, module, exports) {
                (function(process) {
                    "use strict";

                    function _classCallCheck(t, e) {
                        if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                    }

                    function _possibleConstructorReturn(t, e) {
                        if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return !e || "object" != _typeof2(e) && "function" != typeof e ? t : e
                    }

                    function _inherits(t, e) {
                        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(e));
                        t.prototype = Object.create(e && e.prototype, {
                            constructor: {
                                value: t,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                    }
                    var _assign = require("object-assign"),
                        DraftEditorTextNode = (require("./ContentBlock"), require("./DraftEditorTextNode.react")),
                        React = require("react"),
                        ReactDOM = require("react-dom"),
                        invariant = require("fbjs/lib/invariant"),
                        setDraftEditorSelection = require("./setDraftEditorSelection"),
                        DraftEditorLeaf = function(t) {
                            function e() {
                                return _classCallCheck(this, e), _possibleConstructorReturn(this, t.apply(this, arguments))
                            }
                            return _inherits(e, t), e.prototype._setSelection = function() {
                                var t = this.props.selection;
                                if (null != t && t.getHasFocus()) {
                                    var e = this.props,
                                        o = e.block,
                                        r = e.start,
                                        n = e.text,
                                        i = o.getKey(),
                                        s = r + n.length;
                                    if (t.hasEdgeWithin(i, r, s)) {
                                        var a = ReactDOM.findDOMNode(this);
                                        a || ("production" !== process.env.NODE_ENV ? invariant(!1, "Missing node") : invariant(!1));
                                        var c = a.firstChild;
                                        c || ("production" !== process.env.NODE_ENV ? invariant(!1, "Missing child") : invariant(!1));
                                        var p = void 0;
                                        c.nodeType === Node.TEXT_NODE ? p = c : "BR" === c.tagName ? p = a : (p = c.firstChild) || ("production" !== process.env.NODE_ENV ? invariant(!1, "Missing targetNode") : invariant(!1)), setDraftEditorSelection(t, p, i, r, s)
                                    }
                                }
                            }, e.prototype.shouldComponentUpdate = function(t) {
                                var e = ReactDOM.findDOMNode(this.refs.leaf);
                                return e || ("production" !== process.env.NODE_ENV ? invariant(!1, "Missing leafNode") : invariant(!1)), e.textContent !== t.text || t.styleSet !== this.props.styleSet || t.forceSelection
                            }, e.prototype.componentDidUpdate = function() {
                                this._setSelection()
                            }, e.prototype.componentDidMount = function() {
                                this._setSelection()
                            }, e.prototype.render = function() {
                                var t = this.props.block,
                                    e = this.props.text;
                                e.endsWith("\n") && this.props.isLast && (e += "\n");
                                var o = this.props,
                                    r = o.customStyleMap,
                                    n = o.customStyleFn,
                                    i = o.offsetKey,
                                    s = o.styleSet,
                                    a = s.reduce(function(t, e) {
                                        var o = {},
                                            n = r[e];
                                        return void 0 !== n && t.textDecoration !== n.textDecoration && (o.textDecoration = [t.textDecoration, n.textDecoration].join(" ").trim()), _assign(t, n, o)
                                    }, {});
                                if (n) {
                                    var c = n(s, t);
                                    a = _assign(a, c)
                                }
                                return React.createElement("span", {
                                    "data-offset-key": i,
                                    ref: "leaf",
                                    style: a
                                }, React.createElement(DraftEditorTextNode, null, e))
                            }, e
                        }(React.Component);
                    module.exports = DraftEditorLeaf
                }).call(this, require("_process"))
            }, {
                "./ContentBlock": 56,
                "./DraftEditorTextNode.react": 70,
                "./setDraftEditorSelection": 153,
                _process: 433,
                "fbjs/lib/invariant": 185,
                "object-assign": 421,
                react: 455,
                "react-dom": 438
            }],
            69: [function(require, module, exports) {
                "use strict";

                function _classCallCheck(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }

                function _possibleConstructorReturn(t, e) {
                    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !e || "object" != _typeof2(e) && "function" != typeof e ? t : e
                }

                function _inherits(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(e));
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                }
                var React = require("react"),
                    cx = require("fbjs/lib/cx"),
                    DraftEditorPlaceholder = function(t) {
                        function e() {
                            return _classCallCheck(this, e), _possibleConstructorReturn(this, t.apply(this, arguments))
                        }
                        return _inherits(e, t), e.prototype.shouldComponentUpdate = function(t) {
                            return this.props.text !== t.text || this.props.editorState.getSelection().getHasFocus() !== t.editorState.getSelection().getHasFocus()
                        }, e.prototype.render = function() {
                            var t = this.props.editorState.getSelection().getHasFocus(),
                                e = cx({
                                    "public/DraftEditorPlaceholder/root": !0,
                                    "public/DraftEditorPlaceholder/hasFocus": t
                                });
                            return React.createElement("div", {
                                className: e
                            }, React.createElement("div", {
                                className: cx("public/DraftEditorPlaceholder/inner"),
                                id: this.props.accessibilityID
                            }, this.props.text))
                        }, e
                    }(React.Component);
                module.exports = DraftEditorPlaceholder
            }, {
                "fbjs/lib/cx": 174,
                react: 455
            }],
            70: [function(require, module, exports) {
                (function(process) {
                    "use strict";

                    function _classCallCheck(e, t) {
                        if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                    }

                    function _possibleConstructorReturn(e, t) {
                        if (!e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                        return !t || "object" != _typeof2(t) && "function" != typeof t ? e : t
                    }

                    function _inherits(e, t) {
                        if ("function" != typeof t && null !== t) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(t));
                        e.prototype = Object.create(t && t.prototype, {
                            constructor: {
                                value: e,
                                enumerable: !1,
                                writable: !0,
                                configurable: !0
                            }
                        }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t)
                    }

                    function isNewline(e) {
                        return useNewlineChar ? "\n" === e.textContent : "BR" === e.tagName
                    }
                    var React = require("react"),
                        ReactDOM = require("react-dom"),
                        UserAgent = require("fbjs/lib/UserAgent"),
                        invariant = require("fbjs/lib/invariant"),
                        useNewlineChar = UserAgent.isBrowser("IE <= 11"),
                        NEWLINE_A = useNewlineChar ? React.createElement("span", {
                            key: "A",
                            "data-text": "true"
                        }, "\n") : React.createElement("br", {
                            key: "A",
                            "data-text": "true"
                        }),
                        NEWLINE_B = useNewlineChar ? React.createElement("span", {
                            key: "B",
                            "data-text": "true"
                        }, "\n") : React.createElement("br", {
                            key: "B",
                            "data-text": "true"
                        }),
                        DraftEditorTextNode = function(e) {
                            function t(r) {
                                _classCallCheck(this, t);
                                var n = _possibleConstructorReturn(this, e.call(this, r));
                                return n._forceFlag = !1, n
                            }
                            return _inherits(t, e), t.prototype.shouldComponentUpdate = function(e) {
                                var t = ReactDOM.findDOMNode(this),
                                    r = "" === e.children;
                                return t instanceof Element || ("production" !== process.env.NODE_ENV ? invariant(!1, "node is not an Element") : invariant(!1)), r ? !isNewline(t) : t.textContent !== e.children
                            }, t.prototype.componentWillUpdate = function() {
                                this._forceFlag = !this._forceFlag
                            }, t.prototype.render = function() {
                                return "" === this.props.children ? this._forceFlag ? NEWLINE_A : NEWLINE_B : React.createElement("span", {
                                    key: this._forceFlag ? "A" : "B",
                                    "data-text": "true"
                                }, this.props.children)
                            }, t
                        }(React.Component);
                    module.exports = DraftEditorTextNode
                }).call(this, require("_process"))
            }, {
                _process: 433,
                "fbjs/lib/UserAgent": 168,
                "fbjs/lib/invariant": 185,
                react: 455,
                "react-dom": 438
            }],
            71: [function(require, module, exports) {
                (function(process) {
                    "use strict";

                    function logWarning(t, n) {
                        console.warn("WARNING: " + t + ' will be deprecated soon!\nPlease use "' + n + '" instead.')
                    }
                    var _assign = require("object-assign"),
                        _extends = _assign || function(t) {
                            for (var n = 1; n < arguments.length; n++) {
                                var e = arguments[n];
                                for (var a in e) Object.prototype.hasOwnProperty.call(e, a) && (t[a] = e[a])
                            }
                            return t
                        },
                        DraftEntityInstance = require("./DraftEntityInstance"),
                        Immutable = require("immutable"),
                        invariant = require("fbjs/lib/invariant"),
                        Map = Immutable.Map,
                        instances = Map(),
                        instanceKey = 0,
                        DraftEntity = {
                            getLastCreatedEntityKey: function() {
                                return logWarning("DraftEntity.getLastCreatedEntityKey", "contentState.getLastCreatedEntityKey"), DraftEntity.__getLastCreatedEntityKey()
                            },
                            create: function(t, n, e) {
                                return logWarning("DraftEntity.create", "contentState.createEntity"), DraftEntity.__create(t, n, e)
                            },
                            add: function(t) {
                                return logWarning("DraftEntity.add", "contentState.addEntity"), DraftEntity.__add(t)
                            },
                            get: function(t) {
                                return logWarning("DraftEntity.get", "contentState.getEntity"), DraftEntity.__get(t)
                            },
                            mergeData: function(t, n) {
                                return logWarning("DraftEntity.mergeData", "contentState.mergeEntityData"), DraftEntity.__mergeData(t, n)
                            },
                            replaceData: function(t, n) {
                                return logWarning("DraftEntity.replaceData", "contentState.replaceEntityData"), DraftEntity.__replaceData(t, n)
                            },
                            __getLastCreatedEntityKey: function() {
                                return "" + instanceKey
                            },
                            __create: function(t, n, e) {
                                return DraftEntity.__add(new DraftEntityInstance({
                                    type: t,
                                    mutability: n,
                                    data: e || {}
                                }))
                            },
                            __add: function(t) {
                                var n = "" + ++instanceKey;
                                return instances = instances.set(n, t), n
                            },
                            __get: function(t) {
                                var n = instances.get(t);
                                return n || ("production" !== process.env.NODE_ENV ? invariant(!1, "Unknown DraftEntity key: %s.", t) : invariant(!1)), n
                            },
                            __mergeData: function(t, n) {
                                var e = DraftEntity.__get(t),
                                    a = _extends({}, e.getData(), n),
                                    r = e.set("data", a);
                                return instances = instances.set(t, r), r
                            },
                            __replaceData: function(t, n) {
                                var e = DraftEntity.__get(t).set("data", n);
                                return instances = instances.set(t, e), e
                            }
                        };
                    module.exports = DraftEntity
                }).call(this, require("_process"))
            }, {
                "./DraftEntityInstance": 72,
                _process: 433,
                "fbjs/lib/invariant": 185,
                immutable: 156,
                "object-assign": 421
            }],
            72: [function(require, module, exports) {
                "use strict";

                function _classCallCheck(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }

                function _possibleConstructorReturn(t, e) {
                    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !e || "object" != _typeof2(e) && "function" != typeof e ? t : e
                }

                function _inherits(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(e));
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                }
                var Immutable = require("immutable"),
                    Record = Immutable.Record,
                    DraftEntityInstanceRecord = Record({
                        type: "TOKEN",
                        mutability: "IMMUTABLE",
                        data: Object
                    }),
                    DraftEntityInstance = function(t) {
                        function e() {
                            return _classCallCheck(this, e), _possibleConstructorReturn(this, t.apply(this, arguments))
                        }
                        return _inherits(e, t), e.prototype.getType = function() {
                            return this.get("type")
                        }, e.prototype.getMutability = function() {
                            return this.get("mutability")
                        }, e.prototype.getData = function() {
                            return this.get("data")
                        }, e
                    }(DraftEntityInstanceRecord);
                module.exports = DraftEntityInstance
            }, {
                immutable: 156
            }],
            73: [function(require, module, exports) {
                "use strict";
                var DraftEntitySegments = {
                    getRemovalRange: function(t, e, r, n, l) {
                        var a = r.split(" ");
                        a = a.map(function(t, e) {
                            if ("forward" === l) {
                                if (e > 0) return " " + t
                            } else if (e < a.length - 1) return t + " ";
                            return t
                        });
                        for (var f, u = n, i = null, s = null, g = 0; g < a.length; g++) {
                            if (t < (f = u + a[g].length) && u < e) null !== i ? s = f : (i = u, s = f);
                            else if (null !== i) break;
                            u = f
                        }
                        var o = n + r.length,
                            m = i === n,
                            v = s === o;
                        return (!m && v || m && !v) && ("forward" === l ? s !== o && s++ : i !== n && i--), {
                            start: i,
                            end: s
                        }
                    }
                };
                module.exports = DraftEntitySegments
            }, {}],
            74: [function(require, module, exports) {
                "use strict";
                var DraftFeatureFlags = {
                    draft_killswitch_allow_nontextnodes: !1,
                    draft_segmented_entities_behavior: !1
                };
                module.exports = DraftFeatureFlags
            }, {}],
            75: [function(require, module, exports) {
                "use strict";
                var DraftFeatureFlags = require("./DraftFeatureFlags-core");
                module.exports = DraftFeatureFlags
            }, {
                "./DraftFeatureFlags-core": 74
            }],
            76: [function(require, module, exports) {
                "use strict";
                module.exports = {
                    logSelectionStateFailure: function() {
                        return null
                    }
                }
            }, {}],
            77: [function(require, module, exports) {
                (function(process) {
                    "use strict";
                    var CharacterMetadata = require("./CharacterMetadata"),
                        ContentStateInlineStyle = require("./ContentStateInlineStyle"),
                        DraftFeatureFlags = require("./DraftFeatureFlags"),
                        Immutable = require("immutable"),
                        applyEntityToContentState = require("./applyEntityToContentState"),
                        getCharacterRemovalRange = require("./getCharacterRemovalRange"),
                        getContentStateFragment = require("./getContentStateFragment"),
                        insertFragmentIntoContentState = require("./insertFragmentIntoContentState"),
                        insertTextIntoContentState = require("./insertTextIntoContentState"),
                        invariant = require("fbjs/lib/invariant"),
                        modifyBlockForContentState = require("./modifyBlockForContentState"),
                        removeEntitiesAtEdges = require("./removeEntitiesAtEdges"),
                        removeRangeFromContentState = require("./removeRangeFromContentState"),
                        splitBlockInContentState = require("./splitBlockInContentState"),
                        OrderedSet = Immutable.OrderedSet,
                        DraftModifier = {
                            replaceText: function(e, t, n, r, a) {
                                var o = removeEntitiesAtEdges(e, t),
                                    i = removeRangeFromContentState(o, t),
                                    g = CharacterMetadata.create({
                                        style: r || OrderedSet(),
                                        entity: a || null
                                    });
                                return insertTextIntoContentState(i, i.getSelectionAfter(), n, g)
                            },
                            insertText: function(e, t, n, r, a) {
                                return t.isCollapsed() || ("production" !== process.env.NODE_ENV ? invariant(!1, "Target range must be collapsed for `insertText`.") : invariant(!1)), DraftModifier.replaceText(e, t, n, r, a)
                            },
                            moveText: function(e, t, n) {
                                var r = getContentStateFragment(e, t),
                                    a = DraftModifier.removeRange(e, t, "backward");
                                return DraftModifier.replaceWithFragment(a, n, r)
                            },
                            replaceWithFragment: function(e, t, n) {
                                var r = removeEntitiesAtEdges(e, t),
                                    a = removeRangeFromContentState(r, t);
                                return insertFragmentIntoContentState(a, a.getSelectionAfter(), n)
                            },
                            removeRange: function(e, t, n) {
                                var r, a, o = void 0,
                                    i = void 0;
                                t.getIsBackward() && (t = t.merge({
                                    anchorKey: t.getFocusKey(),
                                    anchorOffset: t.getFocusOffset(),
                                    focusKey: t.getAnchorKey(),
                                    focusOffset: t.getAnchorOffset(),
                                    isBackward: !1
                                })), r = t.getAnchorKey(), a = t.getFocusKey(), o = e.getBlockForKey(r), i = e.getBlockForKey(a);
                                var g = t.getStartOffset(),
                                    c = t.getEndOffset(),
                                    l = o.getEntityAt(g),
                                    u = i.getEntityAt(c - 1);
                                if (r === a && l && l === u) {
                                    var m = getCharacterRemovalRange(e.getEntityMap(), o, i, t, n);
                                    return removeRangeFromContentState(e, m)
                                }
                                var s = t;
                                DraftFeatureFlags.draft_segmented_entities_behavior && (s = getCharacterRemovalRange(e.getEntityMap(), o, i, t, n));
                                var f = removeEntitiesAtEdges(e, s);
                                return removeRangeFromContentState(f, s)
                            },
                            splitBlock: function(e, t) {
                                var n = removeEntitiesAtEdges(e, t),
                                    r = removeRangeFromContentState(n, t);
                                return splitBlockInContentState(r, r.getSelectionAfter())
                            },
                            applyInlineStyle: function(e, t, n) {
                                return ContentStateInlineStyle.add(e, t, n)
                            },
                            removeInlineStyle: function(e, t, n) {
                                return ContentStateInlineStyle.remove(e, t, n)
                            },
                            setBlockType: function(e, t, n) {
                                return modifyBlockForContentState(e, t, function(e) {
                                    return e.merge({
                                        type: n,
                                        depth: 0
                                    })
                                })
                            },
                            setBlockData: function(e, t, n) {
                                return modifyBlockForContentState(e, t, function(e) {
                                    return e.merge({
                                        data: n
                                    })
                                })
                            },
                            mergeBlockData: function(e, t, n) {
                                return modifyBlockForContentState(e, t, function(e) {
                                    return e.merge({
                                        data: e.getData().merge(n)
                                    })
                                })
                            },
                            applyEntity: function(e, t, n) {
                                var r = removeEntitiesAtEdges(e, t);
                                return applyEntityToContentState(r, t, n)
                            }
                        };
                    module.exports = DraftModifier
                }).call(this, require("_process"))
            }, {
                "./CharacterMetadata": 54,
                "./ContentStateInlineStyle": 58,
                "./DraftFeatureFlags": 75,
                "./applyEntityToContentState": 90,
                "./getCharacterRemovalRange": 115,
                "./getContentStateFragment": 116,
                "./insertFragmentIntoContentState": 130,
                "./insertTextIntoContentState": 132,
                "./modifyBlockForContentState": 145,
                "./removeEntitiesAtEdges": 149,
                "./removeRangeFromContentState": 150,
                "./splitBlockInContentState": 154,
                _process: 433,
                "fbjs/lib/invariant": 185,
                immutable: 156
            }],
            78: [function(require, module, exports) {
                "use strict";
                var KEY_DELIMITER = "-",
                    DraftOffsetKey = {
                        encode: function(e, t, r) {
                            return e + KEY_DELIMITER + t + KEY_DELIMITER + r
                        },
                        decode: function(e) {
                            var t = e.split(KEY_DELIMITER),
                                r = t[0],
                                E = t[1],
                                I = t[2];
                            return {
                                blockKey: r,
                                decoratorKey: parseInt(E, 10),
                                leafKey: parseInt(I, 10)
                            }
                        }
                    };
                module.exports = DraftOffsetKey
            }, {}],
            79: [function(require, module, exports) {
                "use strict";
                var ContentBlock = (require("./CharacterMetadata"), require("./ContentBlock")),
                    Immutable = require("immutable"),
                    convertFromHTMLtoContentBlocks = require("./convertFromHTMLToContentBlocks"),
                    generateRandomKey = require("./generateRandomKey"),
                    getSafeBodyFromHTML = require("./getSafeBodyFromHTML"),
                    sanitizeDraftText = require("./sanitizeDraftText"),
                    List = Immutable.List,
                    Repeat = Immutable.Repeat,
                    DraftPasteProcessor = {
                        processHTML: function(e, t) {
                            return convertFromHTMLtoContentBlocks(e, getSafeBodyFromHTML, t)
                        },
                        processText: function(e, t, r) {
                            return e.map(function(e) {
                                return e = sanitizeDraftText(e), new ContentBlock({
                                    key: generateRandomKey(),
                                    type: r,
                                    text: e,
                                    characterList: List(Repeat(t, e.length))
                                })
                            })
                        }
                    };
                module.exports = DraftPasteProcessor
            }, {
                "./CharacterMetadata": 54,
                "./ContentBlock": 56,
                "./convertFromHTMLToContentBlocks": 92,
                "./generateRandomKey": 114,
                "./getSafeBodyFromHTML": 125,
                "./sanitizeDraftText": 152,
                immutable: 156
            }],
            80: [function(require, module, exports) {
                "use strict";

                function getRemovableWord(E, e) {
                    var A = e ? BACKSPACE_REGEX.exec(E) : DELETE_REGEX.exec(E);
                    return A ? A[0] : E
                }
                var TokenizeUtil = require("fbjs/lib/TokenizeUtil"),
                    punctuation = TokenizeUtil.getPunctuation(),
                    CHAMELEON_CHARS = "[']",
                    WHITESPACE_AND_PUNCTUATION = "\\s|(?![_])" + punctuation,
                    DELETE_STRING = "^(?:" + WHITESPACE_AND_PUNCTUATION + ")*(?:" + CHAMELEON_CHARS + "|(?!" + WHITESPACE_AND_PUNCTUATION + ").)*(?:(?!" + WHITESPACE_AND_PUNCTUATION + ").)",
                    DELETE_REGEX = new RegExp(DELETE_STRING),
                    BACKSPACE_STRING = "(?:(?!" + WHITESPACE_AND_PUNCTUATION + ").)(?:" + CHAMELEON_CHARS + "|(?!" + WHITESPACE_AND_PUNCTUATION + ").)*(?:" + WHITESPACE_AND_PUNCTUATION + ")*$",
                    BACKSPACE_REGEX = new RegExp(BACKSPACE_STRING),
                    DraftRemovableWord = {
                        getBackward: function(E) {
                            return getRemovableWord(E, !0)
                        },
                        getForward: function(E) {
                            return getRemovableWord(E, !1)
                        }
                    };
                module.exports = DraftRemovableWord
            }, {
                "fbjs/lib/TokenizeUtil": 162
            }],
            81: [function(require, module, exports) {
                "use strict";
                var DraftStringKey = {
                    stringify: function(r) {
                        return "_" + String(r)
                    },
                    unstringify: function(r) {
                        return r.slice(1)
                    }
                };
                module.exports = DraftStringKey
            }, {}],
            82: [function(require, module, exports) {
                "use strict";
                var bidiService, Immutable = require("immutable"),
                    UnicodeBidiService = require("fbjs/lib/UnicodeBidiService"),
                    nullthrows = require("fbjs/lib/nullthrows"),
                    OrderedMap = Immutable.OrderedMap,
                    EditorBidiService = {
                        getDirectionMap: function(e, i) {
                            bidiService ? bidiService.reset() : bidiService = new UnicodeBidiService;
                            var r = e.getBlockMap(),
                                t = r.valueSeq().map(function(e) {
                                    return nullthrows(bidiService).getDirection(e.getText())
                                }),
                                d = OrderedMap(r.keySeq().zip(t));
                            return null != i && Immutable.is(i, d) ? i : d
                        }
                    };
                module.exports = EditorBidiService
            }, {
                "fbjs/lib/UnicodeBidiService": 166,
                "fbjs/lib/nullthrows": 191,
                immutable: 156
            }],
            83: [function(require, module, exports) {
                "use strict";

                function _classCallCheck(e, t) {
                    if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function")
                }

                function updateSelection(e, t, n) {
                    return EditorState.set(e, {
                        selection: t,
                        forceSelection: n,
                        nativelyRenderedContent: null,
                        inlineStyleOverride: null
                    })
                }

                function generateNewTreeMap(e, t) {
                    return e.getBlockMap().map(function(n) {
                        return BlockTree.generate(e, n, t)
                    }).toOrderedMap()
                }

                function regenerateTreeForNewBlocks(e, t, n, r) {
                    var o = e.getCurrentContent().set("entityMap", n),
                        i = o.getBlockMap();
                    return e.getImmutable().get("treeMap").merge(t.toSeq().filter(function(e, t) {
                        return e !== i.get(t)
                    }).map(function(e) {
                        return BlockTree.generate(o, e, r)
                    }))
                }

                function regenerateTreeForNewDecorator(e, t, n, r, o) {
                    return n.merge(t.toSeq().filter(function(t) {
                        return r.getDecorations(t, e) !== o.getDecorations(t, e)
                    }).map(function(t) {
                        return BlockTree.generate(e, t, r)
                    }))
                }

                function mustBecomeBoundary(e, t) {
                    return t !== e.getLastChangeType() || "insert-characters" !== t && "backspace-character" !== t && "delete-character" !== t
                }

                function getInlineStyleForCollapsedSelection(e, t) {
                    var n = t.getStartKey(),
                        r = t.getStartOffset(),
                        o = e.getBlockForKey(n);
                    return r > 0 ? o.getInlineStyleAt(r - 1) : o.getLength() ? o.getInlineStyleAt(0) : lookUpwardForInlineStyle(e, n)
                }

                function getInlineStyleForNonCollapsedSelection(e, t) {
                    var n = t.getStartKey(),
                        r = t.getStartOffset(),
                        o = e.getBlockForKey(n);
                    return r < o.getLength() ? o.getInlineStyleAt(r) : r > 0 ? o.getInlineStyleAt(r - 1) : lookUpwardForInlineStyle(e, n)
                }

                function lookUpwardForInlineStyle(e, t) {
                    var n = e.getBlockMap().reverse().skipUntil(function(e, n) {
                        return n === t
                    }).skip(1).skipUntil(function(e, t) {
                        return e.getLength()
                    }).first();
                    return n ? n.getInlineStyleAt(n.getLength() - 1) : OrderedSet()
                }
                var _assign = require("object-assign"),
                    _extends = _assign || function(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var n = arguments[t];
                            for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r])
                        }
                        return e
                    },
                    BlockTree = require("./BlockTree"),
                    ContentState = require("./ContentState"),
                    EditorBidiService = require("./EditorBidiService"),
                    Immutable = require("immutable"),
                    SelectionState = require("./SelectionState"),
                    OrderedSet = Immutable.OrderedSet,
                    Record = Immutable.Record,
                    Stack = Immutable.Stack,
                    defaultRecord = {
                        allowUndo: !0,
                        currentContent: null,
                        decorator: null,
                        directionMap: null,
                        forceSelection: !1,
                        inCompositionMode: !1,
                        inlineStyleOverride: null,
                        lastChangeType: null,
                        nativelyRenderedContent: null,
                        redoStack: Stack(),
                        selection: null,
                        treeMap: null,
                        undoStack: Stack()
                    },
                    EditorStateRecord = Record(defaultRecord),
                    EditorState = function() {
                        function e(t) {
                            _classCallCheck(this, e), this._immutable = t
                        }
                        return e.createEmpty = function(t) {
                            return e.createWithContent(ContentState.createFromText(""), t)
                        }, e.createWithContent = function(t, n) {
                            var r = t.getBlockMap().first().getKey();
                            return e.create({
                                currentContent: t,
                                undoStack: Stack(),
                                redoStack: Stack(),
                                decorator: n || null,
                                selection: SelectionState.createEmpty(r)
                            })
                        }, e.create = function(t) {
                            var n = t.currentContent,
                                r = t.decorator,
                                o = _extends({}, t, {
                                    treeMap: generateNewTreeMap(n, r),
                                    directionMap: EditorBidiService.getDirectionMap(n)
                                });
                            return new e(new EditorStateRecord(o))
                        }, e.set = function(t, n) {
                            return new e(t.getImmutable().withMutations(function(e) {
                                var r = e.get("decorator"),
                                    o = r;
                                null === n.decorator ? o = null : n.decorator && (o = n.decorator);
                                var i = n.currentContent || t.getCurrentContent();
                                if (o !== r) {
                                    var c, a = e.get("treeMap");
                                    return c = o && r ? regenerateTreeForNewDecorator(i, i.getBlockMap(), a, o, r) : generateNewTreeMap(i, o), void e.merge({
                                        decorator: o,
                                        treeMap: c,
                                        nativelyRenderedContent: null
                                    })
                                }
                                i !== t.getCurrentContent() && e.set("treeMap", regenerateTreeForNewBlocks(t, i.getBlockMap(), i.getEntityMap(), o)), e.merge(n)
                            }))
                        }, e.prototype.toJS = function() {
                            return this.getImmutable().toJS()
                        }, e.prototype.getAllowUndo = function() {
                            return this.getImmutable().get("allowUndo")
                        }, e.prototype.getCurrentContent = function() {
                            return this.getImmutable().get("currentContent")
                        }, e.prototype.getUndoStack = function() {
                            return this.getImmutable().get("undoStack")
                        }, e.prototype.getRedoStack = function() {
                            return this.getImmutable().get("redoStack")
                        }, e.prototype.getSelection = function() {
                            return this.getImmutable().get("selection")
                        }, e.prototype.getDecorator = function() {
                            return this.getImmutable().get("decorator")
                        }, e.prototype.isInCompositionMode = function() {
                            return this.getImmutable().get("inCompositionMode")
                        }, e.prototype.mustForceSelection = function() {
                            return this.getImmutable().get("forceSelection")
                        }, e.prototype.getNativelyRenderedContent = function() {
                            return this.getImmutable().get("nativelyRenderedContent")
                        }, e.prototype.getLastChangeType = function() {
                            return this.getImmutable().get("lastChangeType")
                        }, e.prototype.getInlineStyleOverride = function() {
                            return this.getImmutable().get("inlineStyleOverride")
                        }, e.setInlineStyleOverride = function(t, n) {
                            return e.set(t, {
                                inlineStyleOverride: n
                            })
                        }, e.prototype.getCurrentInlineStyle = function() {
                            var e = this.getInlineStyleOverride();
                            if (null != e) return e;
                            var t = this.getCurrentContent(),
                                n = this.getSelection();
                            return n.isCollapsed() ? getInlineStyleForCollapsedSelection(t, n) : getInlineStyleForNonCollapsedSelection(t, n)
                        }, e.prototype.getBlockTree = function(e) {
                            return this.getImmutable().getIn(["treeMap", e])
                        }, e.prototype.isSelectionAtStartOfContent = function() {
                            var e = this.getCurrentContent().getBlockMap().first().getKey();
                            return this.getSelection().hasEdgeWithin(e, 0, 0)
                        }, e.prototype.isSelectionAtEndOfContent = function() {
                            var e = this.getCurrentContent().getBlockMap().last(),
                                t = e.getLength();
                            return this.getSelection().hasEdgeWithin(e.getKey(), t, t)
                        }, e.prototype.getDirectionMap = function() {
                            return this.getImmutable().get("directionMap")
                        }, e.acceptSelection = function(e, t) {
                            return updateSelection(e, t, !1)
                        }, e.forceSelection = function(e, t) {
                            return t.getHasFocus() || (t = t.set("hasFocus", !0)), updateSelection(e, t, !0)
                        }, e.moveSelectionToEnd = function(t) {
                            var n = t.getCurrentContent().getLastBlock(),
                                r = n.getKey(),
                                o = n.getLength();
                            return e.acceptSelection(t, new SelectionState({
                                anchorKey: r,
                                anchorOffset: o,
                                focusKey: r,
                                focusOffset: o,
                                isBackward: !1
                            }))
                        }, e.moveFocusToEnd = function(t) {
                            var n = e.moveSelectionToEnd(t);
                            return e.forceSelection(n, n.getSelection())
                        }, e.push = function(t, n, r) {
                            if (t.getCurrentContent() === n) return t;
                            var o = "insert-characters" !== r,
                                i = EditorBidiService.getDirectionMap(n, t.getDirectionMap());
                            if (!t.getAllowUndo()) return e.set(t, {
                                currentContent: n,
                                directionMap: i,
                                lastChangeType: r,
                                selection: n.getSelectionAfter(),
                                forceSelection: o,
                                inlineStyleOverride: null
                            });
                            var c = t.getSelection(),
                                a = t.getCurrentContent(),
                                l = t.getUndoStack(),
                                u = n;
                            c !== a.getSelectionAfter() || mustBecomeBoundary(t, r) ? (l = l.push(a), u = u.set("selectionBefore", c)) : "insert-characters" !== r && "backspace-character" !== r && "delete-character" !== r || (u = u.set("selectionBefore", a.getSelectionBefore()));
                            var g = t.getInlineStyleOverride(); - 1 === ["adjust-depth", "change-block-type", "split-block"].indexOf(r) && (g = null);
                            var d = {
                                currentContent: u,
                                directionMap: i,
                                undoStack: l,
                                redoStack: Stack(),
                                lastChangeType: r,
                                selection: n.getSelectionAfter(),
                                forceSelection: o,
                                inlineStyleOverride: g
                            };
                            return e.set(t, d)
                        }, e.undo = function(t) {
                            if (!t.getAllowUndo()) return t;
                            var n = t.getUndoStack(),
                                r = n.peek();
                            if (!r) return t;
                            var o = t.getCurrentContent(),
                                i = EditorBidiService.getDirectionMap(r, t.getDirectionMap());
                            return e.set(t, {
                                currentContent: r,
                                directionMap: i,
                                undoStack: n.shift(),
                                redoStack: t.getRedoStack().push(o),
                                forceSelection: !0,
                                inlineStyleOverride: null,
                                lastChangeType: "undo",
                                nativelyRenderedContent: null,
                                selection: o.getSelectionBefore()
                            })
                        }, e.redo = function(t) {
                            if (!t.getAllowUndo()) return t;
                            var n = t.getRedoStack(),
                                r = n.peek();
                            if (!r) return t;
                            var o = t.getCurrentContent(),
                                i = EditorBidiService.getDirectionMap(r, t.getDirectionMap());
                            return e.set(t, {
                                currentContent: r,
                                directionMap: i,
                                undoStack: t.getUndoStack().push(o),
                                redoStack: n.shift(),
                                forceSelection: !0,
                                inlineStyleOverride: null,
                                lastChangeType: "redo",
                                nativelyRenderedContent: null,
                                selection: r.getSelectionAfter()
                            })
                        }, e.prototype.getImmutable = function() {
                            return this._immutable
                        }, e
                    }();
                module.exports = EditorState
            }, {
                "./BlockTree": 53,
                "./ContentState": 57,
                "./EditorBidiService": 82,
                "./SelectionState": 87,
                immutable: 156,
                "object-assign": 421
            }],
            84: [function(require, module, exports) {
                "use strict";
                var UserAgent = require("fbjs/lib/UserAgent"),
                    isOSX = UserAgent.isPlatform("Mac OS X"),
                    KeyBindingUtil = {
                        isCtrlKeyCommand: function(e) {
                            return !!e.ctrlKey && !e.altKey
                        },
                        isOptionKeyCommand: function(e) {
                            return isOSX && e.altKey
                        },
                        hasCommandModifier: function(e) {
                            return isOSX ? !!e.metaKey && !e.altKey : KeyBindingUtil.isCtrlKeyCommand(e)
                        }
                    };
                module.exports = KeyBindingUtil
            }, {
                "fbjs/lib/UserAgent": 168
            }],
            85: [function(require, module, exports) {
                "use strict";
                var DraftModifier = require("./DraftModifier"),
                    EditorState = require("./EditorState"),
                    adjustBlockDepthForContentState = (require("./SelectionState"), require("./adjustBlockDepthForContentState")),
                    nullthrows = require("fbjs/lib/nullthrows"),
                    RichTextEditorUtil = {
                        currentBlockContainsLink: function(e) {
                            var t = e.getSelection(),
                                r = e.getCurrentContent(),
                                n = r.getEntityMap();
                            return r.getBlockForKey(t.getAnchorKey()).getCharacterList().slice(t.getStartOffset(), t.getEndOffset()).some(function(e) {
                                var t = e.getEntity();
                                return !!t && "LINK" === n.__get(t).getType()
                            })
                        },
                        getCurrentBlockType: function(e) {
                            var t = e.getSelection();
                            return e.getCurrentContent().getBlockForKey(t.getStartKey()).getType()
                        },
                        getDataObjectForLinkURL: function(e) {
                            return {
                                url: e.toString()
                            }
                        },
                        handleKeyCommand: function(e, t) {
                            switch (t) {
                                case "bold":
                                    return RichTextEditorUtil.toggleInlineStyle(e, "BOLD");
                                case "italic":
                                    return RichTextEditorUtil.toggleInlineStyle(e, "ITALIC");
                                case "underline":
                                    return RichTextEditorUtil.toggleInlineStyle(e, "UNDERLINE");
                                case "code":
                                    return RichTextEditorUtil.toggleCode(e);
                                case "backspace":
                                case "backspace-word":
                                case "backspace-to-start-of-line":
                                    return RichTextEditorUtil.onBackspace(e);
                                case "delete":
                                case "delete-word":
                                case "delete-to-end-of-block":
                                    return RichTextEditorUtil.onDelete(e);
                                default:
                                    return null
                            }
                        },
                        insertSoftNewline: function(e) {
                            var t = DraftModifier.insertText(e.getCurrentContent(), e.getSelection(), "\n", e.getCurrentInlineStyle(), null),
                                r = EditorState.push(e, t, "insert-characters");
                            return EditorState.forceSelection(r, t.getSelectionAfter())
                        },
                        onBackspace: function(e) {
                            var t = e.getSelection();
                            if (!t.isCollapsed() || t.getAnchorOffset() || t.getFocusOffset()) return null;
                            var r = e.getCurrentContent(),
                                n = t.getStartKey(),
                                o = r.getBlockBefore(n);
                            if (o && "atomic" === o.getType()) {
                                var i = r.getBlockMap().delete(o.getKey()),
                                    l = r.merge({
                                        blockMap: i,
                                        selectionAfter: t
                                    });
                                if (l !== r) return EditorState.push(e, l, "remove-range")
                            }
                            var c = RichTextEditorUtil.tryToRemoveBlockStyle(e);
                            return c ? EditorState.push(e, c, "change-block-type") : null
                        },
                        onDelete: function(e) {
                            var t = e.getSelection();
                            if (!t.isCollapsed()) return null;
                            var r = e.getCurrentContent(),
                                n = t.getStartKey(),
                                o = r.getBlockForKey(n).getLength();
                            if (t.getStartOffset() < o) return null;
                            var i = r.getBlockAfter(n);
                            if (!i || "atomic" !== i.getType()) return null;
                            var l = t.merge({
                                    focusKey: i.getKey(),
                                    focusOffset: i.getLength()
                                }),
                                c = DraftModifier.removeRange(r, l, "forward");
                            return c !== r ? EditorState.push(e, c, "remove-range") : null
                        },
                        onTab: function(e, t, r) {
                            var n = t.getSelection(),
                                o = n.getAnchorKey();
                            if (o !== n.getFocusKey()) return t;
                            var i = t.getCurrentContent(),
                                l = i.getBlockForKey(o),
                                c = l.getType();
                            if ("unordered-list-item" !== c && "ordered-list-item" !== c) return t;
                            e.preventDefault();
                            var a = i.getBlockBefore(o);
                            if (!a) return t;
                            var u = a.getType();
                            if ("unordered-list-item" !== u && "ordered-list-item" !== u) return t;
                            var g = l.getDepth();
                            if (!e.shiftKey && g === r) return t;
                            r = Math.min(a.getDepth() + 1, r);
                            var f = adjustBlockDepthForContentState(i, n, e.shiftKey ? -1 : 1, r);
                            return EditorState.push(t, f, "adjust-depth")
                        },
                        toggleBlockType: function(e, t) {
                            var r = e.getSelection(),
                                n = r.getStartKey(),
                                o = r.getEndKey(),
                                i = e.getCurrentContent(),
                                l = r;
                            if (n !== o && 0 === r.getEndOffset()) {
                                var c = nullthrows(i.getBlockBefore(o));
                                o = c.getKey(), l = l.merge({
                                    anchorKey: n,
                                    anchorOffset: r.getStartOffset(),
                                    focusKey: o,
                                    focusOffset: c.getLength(),
                                    isBackward: !1
                                })
                            }
                            if (i.getBlockMap().skipWhile(function(e, t) {
                                    return t !== n
                                }).reverse().skipWhile(function(e, t) {
                                    return t !== o
                                }).some(function(e) {
                                    return "atomic" === e.getType()
                                })) return e;
                            var a = i.getBlockForKey(n).getType() === t ? "unstyled" : t;
                            return EditorState.push(e, DraftModifier.setBlockType(i, l, a), "change-block-type")
                        },
                        toggleCode: function(e) {
                            var t = e.getSelection(),
                                r = t.getAnchorKey(),
                                n = t.getFocusKey();
                            return t.isCollapsed() || r !== n ? RichTextEditorUtil.toggleBlockType(e, "code-block") : RichTextEditorUtil.toggleInlineStyle(e, "CODE")
                        },
                        toggleInlineStyle: function(e, t) {
                            var r = e.getSelection(),
                                n = e.getCurrentInlineStyle();
                            if (r.isCollapsed()) return EditorState.setInlineStyleOverride(e, n.has(t) ? n.remove(t) : n.add(t));
                            var o, i = e.getCurrentContent();
                            return o = n.has(t) ? DraftModifier.removeInlineStyle(i, r, t) : DraftModifier.applyInlineStyle(i, r, t), EditorState.push(e, o, "change-inline-style")
                        },
                        toggleLink: function(e, t, r) {
                            var n = DraftModifier.applyEntity(e.getCurrentContent(), t, r);
                            return EditorState.push(e, n, "apply-entity")
                        },
                        tryToRemoveBlockStyle: function(e) {
                            var t = e.getSelection(),
                                r = t.getAnchorOffset();
                            if (t.isCollapsed() && 0 === r) {
                                var n = t.getAnchorKey(),
                                    o = e.getCurrentContent(),
                                    i = o.getBlockForKey(n),
                                    l = o.getFirstBlock();
                                if (i.getLength() > 0 && i !== l) return null;
                                var c = i.getType(),
                                    a = o.getBlockBefore(n);
                                if ("code-block" === c && a && "code-block" === a.getType()) return null;
                                if ("unstyled" !== c) return DraftModifier.setBlockType(o, t, "unstyled")
                            }
                            return null
                        }
                    };
                module.exports = RichTextEditorUtil
            }, {
                "./DraftModifier": 77,
                "./EditorState": 83,
                "./SelectionState": 87,
                "./adjustBlockDepthForContentState": 88,
                "fbjs/lib/nullthrows": 191
            }],
            86: [function(require, module, exports) {
                "use strict";
                var DraftModifier = require("./DraftModifier"),
                    EditorState = require("./EditorState"),
                    getContentStateFragment = require("./getContentStateFragment"),
                    nullthrows = require("fbjs/lib/nullthrows"),
                    clipboard = null,
                    SecondaryClipboard = {
                        cut: function(e) {
                            var t = e.getCurrentContent(),
                                r = e.getSelection(),
                                n = null;
                            if (r.isCollapsed()) {
                                var o = r.getAnchorKey(),
                                    a = t.getBlockForKey(o).getLength();
                                if (a === r.getAnchorOffset()) return e;
                                n = r.set("focusOffset", a)
                            } else n = r;
                            n = nullthrows(n), clipboard = getContentStateFragment(t, n);
                            var i = DraftModifier.removeRange(t, n, "forward");
                            return i === t ? e : EditorState.push(e, i, "remove-range")
                        },
                        paste: function(e) {
                            if (!clipboard) return e;
                            var t = DraftModifier.replaceWithFragment(e.getCurrentContent(), e.getSelection(), clipboard);
                            return EditorState.push(e, t, "insert-fragment")
                        }
                    };
                module.exports = SecondaryClipboard
            }, {
                "./DraftModifier": 77,
                "./EditorState": 83,
                "./getContentStateFragment": 116,
                "fbjs/lib/nullthrows": 191
            }],
            87: [function(require, module, exports) {
                "use strict";

                function _classCallCheck(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }

                function _possibleConstructorReturn(t, e) {
                    if (!t) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return !e || "object" != _typeof2(e) && "function" != typeof e ? t : e
                }

                function _inherits(t, e) {
                    if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function, not " + _typeof2(e));
                    t.prototype = Object.create(e && e.prototype, {
                        constructor: {
                            value: t,
                            enumerable: !1,
                            writable: !0,
                            configurable: !0
                        }
                    }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e)
                }
                var Immutable = require("immutable"),
                    Record = Immutable.Record,
                    defaultRecord = {
                        anchorKey: "",
                        anchorOffset: 0,
                        focusKey: "",
                        focusOffset: 0,
                        isBackward: !1,
                        hasFocus: !1
                    },
                    SelectionStateRecord = Record(defaultRecord),
                    SelectionState = function(t) {
                        function e() {
                            return _classCallCheck(this, e), _possibleConstructorReturn(this, t.apply(this, arguments))
                        }
                        return _inherits(e, t), e.prototype.serialize = function() {
                            return "Anchor: " + this.getAnchorKey() + ":" + this.getAnchorOffset() + ", Focus: " + this.getFocusKey() + ":" + this.getFocusOffset() + ", Is Backward: " + String(this.getIsBackward()) + ", Has Focus: " + String(this.getHasFocus())
                        }, e.prototype.getAnchorKey = function() {
                            return this.get("anchorKey")
                        }, e.prototype.getAnchorOffset = function() {
                            return this.get("anchorOffset")
                        }, e.prototype.getFocusKey = function() {
                            return this.get("focusKey")
                        }, e.prototype.getFocusOffset = function() {
                            return this.get("focusOffset")
                        }, e.prototype.getIsBackward = function() {
                            return this.get("isBackward")
                        }, e.prototype.getHasFocus = function() {
                            return this.get("hasFocus")
                        }, e.prototype.hasEdgeWithin = function(t, e, o) {
                            var r = this.getAnchorKey(),
                                s = this.getFocusKey();
                            if (r === s && r === t) {
                                var n = this.getStartOffset();
                                return e <= this.getEndOffset() && n <= o
                            }
                            if (t !== r && t !== s) return !1;
                            var c = t === r ? this.getAnchorOffset() : this.getFocusOffset();
                            return e <= c && o >= c
                        }, e.prototype.isCollapsed = function() {
                            return this.getAnchorKey() === this.getFocusKey() && this.getAnchorOffset() === this.getFocusOffset()
                        }, e.prototype.getStartKey = function() {
                            return this.getIsBackward() ? this.getFocusKey() : this.getAnchorKey()
                        }, e.prototype.getStartOffset = function() {
                            return this.getIsBackward() ? this.getFocusOffset() : this.getAnchorOffset()
                        }, e.prototype.getEndKey = function() {
                            return this.getIsBackward() ? this.getAnchorKey() : this.getFocusKey()
                        }, e.prototype.getEndOffset = function() {
                            return this.getIsBackward() ? this.getAnchorOffset() : this.getFocusOffset()
                        }, e.createEmpty = function(t) {
                            return new e({
                                anchorKey: t,
                                anchorOffset: 0,
                                focusKey: t,
                                focusOffset: 0,
                                isBackward: !1,
                                hasFocus: !1
                            })
                        }, e
                    }(SelectionStateRecord);
                module.exports = SelectionState
            }, {
                immutable: 156
            }],
            88: [function(require, module, exports) {
                "use strict";

                function adjustBlockDepthForContentState(t, e, n, o) {
                    var r = e.getStartKey(),
                        a = e.getEndKey(),
                        c = t.getBlockMap(),
                        u = c.toSeq().skipUntil(function(t, e) {
                            return e === r
                        }).takeUntil(function(t, e) {
                            return e === a
                        }).concat([
                            [a, c.get(a)]
                        ]).map(function(t) {
                            var e = t.getDepth() + n;
                            return e = Math.max(0, Math.min(e, o)), t.set("depth", e)
                        });
                    return c = c.merge(u), t.merge({
                        blockMap: c,
                        selectionBefore: e,
                        selectionAfter: e
                    })
                }
                module.exports = adjustBlockDepthForContentState
            }, {}],
            89: [function(require, module, exports) {
                "use strict";

                function applyEntityToContentBlock(t, a, e, r) {
                    for (var c = t.getCharacterList(); a < e;) c = c.set(a, CharacterMetadata.applyEntity(c.get(a), r)), a++;
                    return t.set("characterList", c)
                }
                var CharacterMetadata = require("./CharacterMetadata");
                module.exports = applyEntityToContentBlock
            }, {
                "./CharacterMetadata": 54
            }],
            90: [function(require, module, exports) {
                "use strict";

                function applyEntityToContentState(t, e, n) {
                    var r = t.getBlockMap(),
                        o = e.getStartKey(),
                        a = e.getStartOffset(),
                        i = e.getEndKey(),
                        l = e.getEndOffset(),
                        p = r.skipUntil(function(t, e) {
                            return e === o
                        }).takeUntil(function(t, e) {
                            return e === i
                        }).toOrderedMap().merge(Immutable.OrderedMap([
                            [i, r.get(i)]
                        ])).map(function(t, e) {
                            var r = e === o ? a : 0,
                                p = e === i ? l : t.getLength();
                            return applyEntityToContentBlock(t, r, p, n)
                        });
                    return t.merge({
                        blockMap: r.merge(p),
                        selectionBefore: e,
                        selectionAfter: e
                    })
                }
                var Immutable = require("immutable"),
                    applyEntityToContentBlock = require("./applyEntityToContentBlock");
                module.exports = applyEntityToContentState
            }, {
                "./applyEntityToContentBlock": 89,
                immutable: 156
            }],
            91: [function(require, module, exports) {
                "use strict";

                function convertFromDraftStateToRaw(t) {
                    var e = 0,
                        n = {},
                        a = [];
                    t.getBlockMap().forEach(function(t, r) {
                        t.findEntityRanges(function(t) {
                            return null !== t.getEntity()
                        }, function(a) {
                            var r = DraftStringKey.stringify(t.getEntityAt(a));
                            n.hasOwnProperty(r) || (n[r] = "" + e++)
                        }), a.push({
                            key: r,
                            text: t.getText(),
                            type: t.getType(),
                            depth: t.getDepth(),
                            inlineStyleRanges: encodeInlineStyleRanges(t),
                            entityRanges: encodeEntityRanges(t, n),
                            data: t.getData().toObject()
                        })
                    });
                    var r = Object.keys(n),
                        i = {};
                    return r.forEach(function(e, n) {
                        var a = t.getEntity(DraftStringKey.unstringify(e));
                        i[n] = {
                            type: a.getType(),
                            mutability: a.getMutability(),
                            data: a.getData()
                        }
                    }), {
                        entityMap: i,
                        blocks: a
                    }
                }
                var DraftStringKey = require("./DraftStringKey"),
                    encodeEntityRanges = require("./encodeEntityRanges"),
                    encodeInlineStyleRanges = require("./encodeInlineStyleRanges");
                module.exports = convertFromDraftStateToRaw
            }, {
                "./DraftStringKey": 81,
                "./encodeEntityRanges": 109,
                "./encodeInlineStyleRanges": 110
            }],
            92: [function(require, module, exports) {
                (function(process) {
                    "use strict";

                    function getEmptyChunk() {
                        return {
                            text: "",
                            inlines: [],
                            entities: [],
                            blocks: []
                        }
                    }

                    function getWhitespaceChunk(e) {
                        var t = new Array(1);
                        return e && (t[0] = e), {
                            text: SPACE,
                            inlines: [OrderedSet()],
                            entities: t,
                            blocks: []
                        }
                    }

                    function getSoftNewlineChunk() {
                        return {
                            text: "\n",
                            inlines: [OrderedSet()],
                            entities: new Array(1),
                            blocks: []
                        }
                    }

                    function getBlockDividerChunk(e, t) {
                        return {
                            text: "\r",
                            inlines: [OrderedSet()],
                            entities: new Array(1),
                            blocks: [{
                                type: e,
                                depth: Math.max(0, Math.min(MAX_DEPTH, t))
                            }]
                        }
                    }

                    function getListBlockType(e, t) {
                        return "li" === e ? "ol" === t ? "ordered-list-item" : "unordered-list-item" : null
                    }

                    function getBlockMapSupportedTags(e) {
                        var t = e.get("unstyled").element,
                            n = Set([]);
                        return e.forEach(function(e) {
                            e.aliasedElements && e.aliasedElements.forEach(function(e) {
                                n = n.add(e)
                            }), n = n.add(e.element)
                        }), n.filter(function(e) {
                            return e && e !== t
                        }).toArray().sort()
                    }

                    function getMultiMatchedType(e, t, n) {
                        for (var r = 0; r < n.length; r++) {
                            var i = n[r](e, t);
                            if (i) return i
                        }
                        return null
                    }

                    function getBlockTypeForTag(e, t, n) {
                        var r = n.filter(function(t) {
                            return t.element === e || t.wrapper === e || t.aliasedElements && t.aliasedElements.some(function(t) {
                                return t === e
                            })
                        }).keySeq().toSet().toArray().sort();
                        switch (r.length) {
                            case 0:
                                return "unstyled";
                            case 1:
                                return r[0];
                            default:
                                return getMultiMatchedType(e, t, [getListBlockType]) || "unstyled"
                        }
                    }

                    function processInlineTag(e, t, n) {
                        var r = inlineTags[e];
                        if (r) n = n.add(r).toOrderedSet();
                        else if (t instanceof HTMLElement) {
                            var i = t;
                            n = n.withMutations(function(e) {
                                var t = i.style.fontWeight,
                                    n = i.style.fontStyle,
                                    r = i.style.textDecoration;
                                boldValues.indexOf(t) >= 0 ? e.add("BOLD") : notBoldValues.indexOf(t) >= 0 && e.remove("BOLD"), "italic" === n ? e.add("ITALIC") : "normal" === n && e.remove("ITALIC"), "underline" === r && e.add("UNDERLINE"), "line-through" === r && e.add("STRIKETHROUGH"), "none" === r && (e.remove("UNDERLINE"), e.remove("STRIKETHROUGH"))
                            }).toOrderedSet()
                        }
                        return n
                    }

                    function joinChunks(e, t) {
                        var n = e.text.slice(-1),
                            r = t.text.slice(0, 1);
                        if ("\r" === n && "\r" === r && (e.text = e.text.slice(0, -1), e.inlines.pop(), e.entities.pop(), e.blocks.pop()), "\r" === n) {
                            if (t.text === SPACE || "\n" === t.text) return e;
                            r !== SPACE && "\n" !== r || (t.text = t.text.slice(1), t.inlines.shift(), t.entities.shift())
                        }
                        return {
                            text: e.text + t.text,
                            inlines: e.inlines.concat(t.inlines),
                            entities: e.entities.concat(t.entities),
                            blocks: e.blocks.concat(t.blocks)
                        }
                    }

                    function containsSemanticBlockMarkup(e, t) {
                        return t.some(function(t) {
                            return -1 !== e.indexOf("<" + t)
                        })
                    }

                    function hasValidLinkText(e) {
                        e instanceof HTMLAnchorElement || ("production" !== process.env.NODE_ENV ? invariant(!1, "Link must be an HTMLAnchorElement.") : invariant(!1));
                        var t = e.protocol;
                        return "http:" === t || "https:" === t || "mailto:" === t
                    }

                    function genFragment(e, t, n, r, i, l, a, o, s) {
                        var u = t.nodeName.toLowerCase(),
                            c = !1,
                            d = "unstyled",
                            f = lastBlock,
                            h = e;
                        if ("#text" === u) {
                            var g = t.textContent;
                            return "" === g.trim() && "pre" !== i ? {
                                chunk: getWhitespaceChunk(s),
                                entityMap: e
                            } : ("pre" !== i && (g = g.replace(REGEX_LF, SPACE)), lastBlock = u, {
                                chunk: {
                                    text: g,
                                    inlines: Array(g.length).fill(n),
                                    entities: Array(g.length).fill(s),
                                    blocks: []
                                },
                                entityMap: e
                            })
                        }
                        if (lastBlock = u, "br" === u) return "br" !== f || i && "unstyled" !== getBlockTypeForTag(i, r, o) ? {
                            chunk: getSoftNewlineChunk(),
                            entityMap: e
                        } : {
                            chunk: getBlockDividerChunk("unstyled", a),
                            entityMap: e
                        };
                        if ("img" === u && t instanceof HTMLImageElement && t.attributes.getNamedItem("src") && t.attributes.getNamedItem("src").value) {
                            var k = t,
                                p = {};
                            imgAttr.forEach(function(e) {
                                var t = k.getAttribute(e);
                                t && (p[e] = t)
                            }), t.textContent = "", s = DraftEntity.__create("IMAGE", "MUTABLE", p || {})
                        }
                        var E = getEmptyChunk();
                        n = processInlineTag(u, t, n), "ul" !== u && "ol" !== u || (r && (a += 1), r = u), i || -1 === l.indexOf(u) ? r && "li" === i && "li" === u && (E = getBlockDividerChunk(getBlockTypeForTag(u, r, o), a), i = u, c = !0, d = "ul" === r ? "unordered-list-item" : "ordered-list-item") : (E = getBlockDividerChunk(getBlockTypeForTag(u, r, o), a), i = u, c = !0);
                        var m = t.firstChild;
                        null != m && (u = m.nodeName.toLowerCase());
                        for (var y = null; m;) {
                            m instanceof HTMLAnchorElement && m.href && hasValidLinkText(m) ? function() {
                                var e = m,
                                    t = {};
                                anchorAttr.forEach(function(n) {
                                    var r = e.getAttribute(n);
                                    r && (t[n] = r)
                                }), t.url = new URI(e.href).toString(), y = DraftEntity.__create("LINK", "MUTABLE", t || {})
                            }() : y = void 0;
                            var T = genFragment(h, m, n, r, i, l, a, o, y || s),
                                v = T.chunk;
                            h = T.entityMap, E = joinChunks(E, v);
                            var x = m.nextSibling;
                            x && l.indexOf(u) >= 0 && i && (E = joinChunks(E, getSoftNewlineChunk())), x && (u = x.nodeName.toLowerCase()), m = x
                        }
                        return c && (E = joinChunks(E, getBlockDividerChunk(d, a))), {
                            chunk: E,
                            entityMap: h
                        }
                    }

                    function getChunkForHTML(e, t, n, r) {
                        e = e.trim().replace(REGEX_CR, "").replace(REGEX_NBSP, SPACE).replace(REGEX_CARRIAGE, "").replace(REGEX_ZWS, "");
                        var i = getBlockMapSupportedTags(n),
                            l = t(e);
                        if (!l) return null;
                        lastBlock = null;
                        var a = containsSemanticBlockMarkup(e, i) ? i : ["div"],
                            o = genFragment(r, l, OrderedSet(), "ul", null, a, -1, n),
                            s = o.chunk,
                            u = o.entityMap;
                        return 0 === s.text.indexOf("\r") && (s = {
                            text: s.text.slice(1),
                            inlines: s.inlines.slice(1),
                            entities: s.entities.slice(1),
                            blocks: s.blocks
                        }), "\r" === s.text.slice(-1) && (s.text = s.text.slice(0, -1), s.inlines = s.inlines.slice(0, -1), s.entities = s.entities.slice(0, -1), s.blocks.pop()), 0 === s.blocks.length && s.blocks.push({
                            type: "unstyled",
                            depth: 0
                        }), s.text.split("\r").length === s.blocks.length + 1 && s.blocks.unshift({
                            type: "unstyled",
                            depth: 0
                        }), {
                            chunk: s,
                            entityMap: u
                        }
                    }

                    function convertFromHTMLtoContentBlocks(e) {
                        var t = getChunkForHTML(e, arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : getSafeBodyFromHTML, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : DefaultDraftBlockRenderMap, DraftEntity);
                        if (null == t) return null;
                        var n = t.chunk,
                            r = t.entityMap,
                            i = 0;
                        return {
                            contentBlocks: n.text.split("\r").map(function(e, t) {
                                e = sanitizeDraftText(e);
                                var r = i + e.length,
                                    l = nullthrows(n).inlines.slice(i, r),
                                    a = nullthrows(n).entities.slice(i, r),
                                    o = List(l.map(function(e, t) {
                                        var n = {
                                            style: e,
                                            entity: null
                                        };
                                        return a[t] && (n.entity = a[t]), CharacterMetadata.create(n)
                                    }));
                                return i = r + 1, new ContentBlock({
                                    key: generateRandomKey(),
                                    type: nullthrows(n).blocks[t].type,
                                    depth: nullthrows(n).blocks[t].depth,
                                    text: e,
                                    characterList: o
                                })
                            }),
                            entityMap: r
                        }
                    }
                    var lastBlock, CharacterMetadata = require("./CharacterMetadata"),
                        ContentBlock = require("./ContentBlock"),
                        DefaultDraftBlockRenderMap = require("./DefaultDraftBlockRenderMap"),
                        DraftEntity = require("./DraftEntity"),
                        Immutable = require("immutable"),
                        _require = require("immutable"),
                        Set = _require.Set,
                        URI = require("fbjs/lib/URI"),
                        generateRandomKey = require("./generateRandomKey"),
                        getSafeBodyFromHTML = require("./getSafeBodyFromHTML"),
                        invariant = require("fbjs/lib/invariant"),
                        nullthrows = require("fbjs/lib/nullthrows"),
                        sanitizeDraftText = require("./sanitizeDraftText"),
                        List = Immutable.List,
                        OrderedSet = Immutable.OrderedSet,
                        NBSP = "&nbsp;",
                        SPACE = " ",
                        MAX_DEPTH = 4,
                        REGEX_CR = new RegExp("\r", "g"),
                        REGEX_LF = new RegExp("\n", "g"),
                        REGEX_NBSP = new RegExp(NBSP, "g"),
                        REGEX_CARRIAGE = new RegExp("&#13;?", "g"),
                        REGEX_ZWS = new RegExp("&#8203;?", "g"),
                        boldValues = ["bold", "bolder", "500", "600", "700", "800", "900"],
                        notBoldValues = ["light", "lighter", "100", "200", "300", "400"],
                        inlineTags = {
                            b: "BOLD",
                            code: "CODE",
                            del: "STRIKETHROUGH",
                            em: "ITALIC",
                            i: "ITALIC",
                            s: "STRIKETHROUGH",
                            strike: "STRIKETHROUGH",
                            strong: "BOLD",
                            u: "UNDERLINE"
                        },
                        anchorAttr = ["className", "href", "rel", "target", "title"],
                        imgAttr = ["alt", "className", "height", "src", "width"];
                    module.exports = convertFromHTMLtoContentBlocks
                }).call(this, require("_process"))
            }, {
                "./CharacterMetadata": 54,
                "./ContentBlock": 56,
                "./DefaultDraftBlockRenderMap": 59,
                "./DraftEntity": 71,
                "./generateRandomKey": 114,
                "./getSafeBodyFromHTML": 125,
                "./sanitizeDraftText": 152,
                _process: 433,
                "fbjs/lib/URI": 163,
                "fbjs/lib/invariant": 185,
                "fbjs/lib/nullthrows": 191,
                immutable: 156
            }],
            93: [function(require, module, exports) {
                "use strict";

                function convertFromRawToDraftState(e) {
                    var t = e.blocks,
                        r = e.entityMap,
                        a = {};
                    Object.keys(r).forEach(function(e) {
                        var t = r[e],
                            n = t.type,
                            o = t.mutability,
                            i = t.data,
                            c = DraftEntity.__create(n, o, i || {});
                        a[e] = c
                    });
                    var n = t.map(function(e) {
                        var t = e.key,
                            r = e.type,
                            n = e.text,
                            o = e.depth,
                            i = e.inlineStyleRanges,
                            c = e.entityRanges,
                            y = e.data;
                        t = t || generateRandomKey(), r = r || "unstyled", o = o || 0, i = i || [], c = c || [], y = Map(y);
                        var s = decodeInlineStyleRanges(n, i),
                            u = c.filter(function(e) {
                                return a.hasOwnProperty(e.key)
                            }).map(function(e) {
                                return _extends({}, e, {
                                    key: a[e.key]
                                })
                            }),
                            d = decodeEntityRanges(n, u),
                            l = createCharacterList(s, d);
                        return new ContentBlock({
                            key: t,
                            type: r,
                            text: n,
                            depth: o,
                            characterList: l,
                            data: y
                        })
                    });
                    return ContentState.createFromBlockArray(n)
                }
                var _assign = require("object-assign"),
                    _extends = _assign || function(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var r = arguments[t];
                            for (var a in r) Object.prototype.hasOwnProperty.call(r, a) && (e[a] = r[a])
                        }
                        return e
                    },
                    ContentBlock = require("./ContentBlock"),
                    ContentState = require("./ContentState"),
                    DraftEntity = require("./DraftEntity"),
                    Immutable = require("immutable"),
                    createCharacterList = require("./createCharacterList"),
                    decodeEntityRanges = require("./decodeEntityRanges"),
                    decodeInlineStyleRanges = require("./decodeInlineStyleRanges"),
                    generateRandomKey = require("./generateRandomKey"),
                    Map = Immutable.Map;
                module.exports = convertFromRawToDraftState
            }, {
                "./ContentBlock": 56,
                "./ContentState": 57,
                "./DraftEntity": 71,
                "./createCharacterList": 94,
                "./decodeEntityRanges": 95,
                "./decodeInlineStyleRanges": 96,
                "./generateRandomKey": 114,
                immutable: 156,
                "object-assign": 421
            }],
            94: [function(require, module, exports) {
                "use strict";

                function createCharacterList(t, a) {
                    var e = t.map(function(t, e) {
                        var r = a[e];
                        return CharacterMetadata.create({
                            style: t,
                            entity: r
                        })
                    });
                    return List(e)
                }
                var CharacterMetadata = require("./CharacterMetadata"),
                    Immutable = require("immutable"),
                    List = Immutable.List;
                module.exports = createCharacterList
            }, {
                "./CharacterMetadata": 54,
                immutable: 156
            }],
            95: [function(require, module, exports) {
                "use strict";

                function decodeEntityRanges(t, e) {
                    var s = Array(t.length).fill(null);
                    return e && e.forEach(function(e) {
                        for (var n = substr(t, 0, e.offset).length, r = n + substr(t, e.offset, e.length).length, i = n; i < r; i++) s[i] = e.key
                    }), s
                }
                var UnicodeUtils = require("fbjs/lib/UnicodeUtils"),
                    substr = UnicodeUtils.substr;
                module.exports = decodeEntityRanges
            }, {
                "fbjs/lib/UnicodeUtils": 167
            }],
            96: [function(require, module, exports) {
                "use strict";

                function decodeInlineStyleRanges(e, r) {
                    var t = Array(e.length).fill(EMPTY_SET);
                    return r && r.forEach(function(r) {
                        for (var s = substr(e, 0, r.offset).length, i = s + substr(e, r.offset, r.length).length; s < i;) t[s] = t[s].add(r.style), s++
                    }), t
                }
                var _require = require("immutable"),
                    OrderedSet = _require.OrderedSet,
                    UnicodeUtils = require("fbjs/lib/UnicodeUtils"),
                    substr = UnicodeUtils.substr,
                    EMPTY_SET = OrderedSet();
                module.exports = decodeInlineStyleRanges
            }, {
                "fbjs/lib/UnicodeUtils": 167,
                immutable: 156
            }],
            97: [function(require, module, exports) {
                (function(global) {
                    "use strict";

                    function mustPreventDefaultForCharacter(e) {
                        return isFirefox && (e == FF_QUICKFIND_CHAR || e == FF_QUICKFIND_LINK_CHAR)
                    }

                    function replaceText(e, t, r, n) {
                        var i = DraftModifier.replaceText(e.getCurrentContent(), e.getSelection(), t, r, n);
                        return EditorState.push(e, i, "insert-characters")
                    }

                    function editOnBeforeInput(e, t) {
                        void 0 !== e._pendingStateFromBeforeInput && (e.update(e._pendingStateFromBeforeInput), e._pendingStateFromBeforeInput = void 0);
                        var r = e._latestEditorState,
                            n = t.data;
                        if (n)
                            if (e.props.handleBeforeInput && isEventHandled(e.props.handleBeforeInput(n, r))) t.preventDefault();
                            else {
                                var i = r.getSelection(),
                                    o = i.getStartOffset(),
                                    a = i.getEndOffset(),
                                    l = i.getAnchorKey();
                                if (!i.isCollapsed()) return t.preventDefault(), void(n === r.getCurrentContent().getPlainText().slice(o, a) ? this.update(EditorState.forceSelection(r, i.merge({
                                    focusOffset: a
                                }))) : e.update(replaceText(r, n, r.getCurrentInlineStyle(), getEntityKeyForSelection(r.getCurrentContent(), r.getSelection()))));
                                var d = replaceText(r, n, r.getCurrentInlineStyle(), getEntityKeyForSelection(r.getCurrentContent(), r.getSelection())),
                                    u = !1;
                                if (u || (u = isSelectionAtLeafStart(e._latestCommittedEditorState)), !u) {
                                    var f = global.getSelection();
                                    if (f.anchorNode && f.anchorNode.nodeType === Node.TEXT_NODE) {
                                        var s = f.anchorNode.parentNode;
                                        u = "SPAN" === s.nodeName && s.firstChild.nodeType === Node.TEXT_NODE && -1 !== s.firstChild.nodeValue.indexOf("\t")
                                    }
                                }
                                if (u || (u = BlockTree.getFingerprint(r.getBlockTree(l)) !== BlockTree.getFingerprint(d.getBlockTree(l))), u || (u = mustPreventDefaultForCharacter(n)), u || (u = nullthrows(d.getDirectionMap()).get(l) !== nullthrows(r.getDirectionMap()).get(l)), u) return t.preventDefault(), void e.update(d);
                                d = EditorState.set(d, {
                                    nativelyRenderedContent: d.getCurrentContent()
                                }), e._pendingStateFromBeforeInput = d, setImmediate(function() {
                                    void 0 !== e._pendingStateFromBeforeInput && (e.update(e._pendingStateFromBeforeInput), e._pendingStateFromBeforeInput = void 0)
                                })
                            }
                    }
                    var BlockTree = require("./BlockTree"),
                        DraftModifier = require("./DraftModifier"),
                        EditorState = require("./EditorState"),
                        UserAgent = require("fbjs/lib/UserAgent"),
                        getEntityKeyForSelection = require("./getEntityKeyForSelection"),
                        isEventHandled = require("./isEventHandled"),
                        isSelectionAtLeafStart = require("./isSelectionAtLeafStart"),
                        nullthrows = require("fbjs/lib/nullthrows"),
                        setImmediate = require("fbjs/lib/setImmediate"),
                        FF_QUICKFIND_CHAR = "'",
                        FF_QUICKFIND_LINK_CHAR = "/",
                        isFirefox = UserAgent.isBrowser("Firefox");
                    module.exports = editOnBeforeInput
                }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
            }, {
                "./BlockTree": 53,
                "./DraftModifier": 77,
                "./EditorState": 83,
                "./getEntityKeyForSelection": 120,
                "./isEventHandled": 133,
                "./isSelectionAtLeafStart": 134,
                "fbjs/lib/UserAgent": 168,
                "fbjs/lib/nullthrows": 191,
                "fbjs/lib/setImmediate": 192
            }],
            98: [function(require, module, exports) {
                (function(global) {
                    "use strict";

                    function editOnBlur(e, t) {
                        if (getActiveElement() === document.body) {
                            var o = global.getSelection(),
                                r = e.refs.editor;
                            1 === o.rangeCount && containsNode(r, o.anchorNode) && containsNode(r, o.focusNode) && o.removeAllRanges()
                        }
                        var i = e._latestEditorState,
                            n = i.getSelection();
                        if (n.getHasFocus()) {
                            var a = n.set("hasFocus", !1);
                            e.props.onBlur && e.props.onBlur(t), e.update(EditorState.acceptSelection(i, a))
                        }
                    }
                    var EditorState = require("./EditorState"),
                        containsNode = require("fbjs/lib/containsNode"),
                        getActiveElement = require("fbjs/lib/getActiveElement");
                    module.exports = editOnBlur
                }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
            }, {
                "./EditorState": 83,
                "fbjs/lib/containsNode": 172,
                "fbjs/lib/getActiveElement": 176
            }],
            99: [function(require, module, exports) {
                "use strict";

                function editOnCompositionStart(t, o) {
                    t.setMode("composite"), t.update(EditorState.set(t._latestEditorState, {
                        inCompositionMode: !0
                    })), t._onCompositionStart(o)
                }
                var EditorState = require("./EditorState");
                module.exports = editOnCompositionStart
            }, {
                "./EditorState": 83
            }],
            100: [function(require, module, exports) {
                "use strict";

                function editOnCopy(e, t) {
                    e._latestEditorState.getSelection().isCollapsed() ? t.preventDefault() : e.setClipboard(getFragmentFromSelection(e._latestEditorState))
                }
                var getFragmentFromSelection = require("./getFragmentFromSelection");
                module.exports = editOnCopy
            }, {
                "./getFragmentFromSelection": 121
            }],
            101: [function(require, module, exports) {
                "use strict";

                function editOnCut(e, t) {
                    var r = e._latestEditorState;
                    if (r.getSelection().isCollapsed()) t.preventDefault();
                    else {
                        var o = Style.getScrollParent(t.target),
                            i = getScrollPosition(o),
                            n = i.x,
                            a = i.y,
                            l = getFragmentFromSelection(r);
                        e.setClipboard(l), e.setMode("cut"), setTimeout(function() {
                            e.restoreEditorDOM({
                                x: n,
                                y: a
                            }), e.exitCurrentMode(), e.update(removeFragment(r))
                        }, 0)
                    }
                }

                function removeFragment(e) {
                    var t = DraftModifier.removeRange(e.getCurrentContent(), e.getSelection(), "forward");
                    return EditorState.push(e, t, "remove-range")
                }
                var DraftModifier = require("./DraftModifier"),
                    EditorState = require("./EditorState"),
                    Style = require("fbjs/lib/Style"),
                    getFragmentFromSelection = require("./getFragmentFromSelection"),
                    getScrollPosition = require("fbjs/lib/getScrollPosition");
                module.exports = editOnCut
            }, {
                "./DraftModifier": 77,
                "./EditorState": 83,
                "./getFragmentFromSelection": 121,
                "fbjs/lib/Style": 161,
                "fbjs/lib/getScrollPosition": 180
            }],
            102: [function(require, module, exports) {
                "use strict";

                function editOnDragOver(e, r) {
                    e._internalDrag = !1, e.setMode("drag"), r.preventDefault()
                }
                module.exports = editOnDragOver
            }, {}],
            103: [function(require, module, exports) {
                "use strict";

                function editOnDragStart(t) {
                    t._internalDrag = !0, t.setMode("drag")
                }
                module.exports = editOnDragStart
            }, {}],
            104: [function(require, module, exports) {
                "use strict";

                function editOnFocus(e, t) {
                    var o = e._latestEditorState,
                        r = o.getSelection();
                    if (!r.getHasFocus()) {
                        var s = r.set("hasFocus", !0);
                        e.props.onFocus && e.props.onFocus(t), UserAgent.isBrowser("Chrome < 60.0.3081.0") ? e.update(EditorState.forceSelection(o, s)) : e.update(EditorState.acceptSelection(o, s))
                    }
                }
                var EditorState = require("./EditorState"),
                    UserAgent = require("fbjs/lib/UserAgent");
                module.exports = editOnFocus
            }, {
                "./EditorState": 83,
                "fbjs/lib/UserAgent": 168
            }],
            105: [function(require, module, exports) {
                (function(global) {
                    "use strict";

                    function editOnInput(e) {
                        void 0 !== e._pendingStateFromBeforeInput && (e.update(e._pendingStateFromBeforeInput), e._pendingStateFromBeforeInput = void 0);
                        var t = global.getSelection(),
                            r = t.anchorNode,
                            n = t.isCollapsed,
                            i = r.nodeType !== Node.TEXT_NODE,
                            o = r.nodeType !== Node.TEXT_NODE && r.nodeType !== Node.ELEMENT_NODE;
                        if (DraftFeatureFlags.draft_killswitch_allow_nontextnodes) {
                            if (i) return
                        } else if (o) return;
                        if (r.nodeType === Node.TEXT_NODE && (null !== r.previousSibling || null !== r.nextSibling)) {
                            var f = r.parentNode;
                            r.nodeValue = f.textContent;
                            for (var l = f.firstChild; null !== l; l = l.nextSibling) l !== r && f.removeChild(l)
                        }
                        var a = r.textContent,
                            s = e._latestEditorState,
                            d = nullthrows(findAncestorOffsetKey(r)),
                            u = DraftOffsetKey.decode(d),
                            g = u.blockKey,
                            c = u.decoratorKey,
                            E = u.leafKey,
                            p = s.getBlockTree(g).getIn([c, "leaves", E]),
                            O = p.start,
                            y = p.end,
                            h = s.getCurrentContent(),
                            D = h.getBlockForKey(g),
                            N = D.getText().slice(O, y);
                        if (a.endsWith(DOUBLE_NEWLINE) && (a = a.slice(0, -1)), a !== N) {
                            var S, T, v, _, A = s.getSelection(),
                                b = A.merge({
                                    anchorOffset: O,
                                    focusOffset: y,
                                    isBackward: !1
                                }),
                                B = D.getEntityAt(O),
                                F = B && h.getEntity(B),
                                K = "MUTABLE" === (F && F.getMutability()),
                                k = K ? "spellcheck-change" : "apply-entity",
                                m = DraftModifier.replaceText(h, b, a, D.getInlineStyleAt(O), K ? D.getEntityAt(O) : null);
                            if (isGecko) S = t.anchorOffset, T = t.focusOffset, _ = (v = O + Math.min(S, T)) + Math.abs(S - T), S = v, T = _;
                            else {
                                var I = a.length - N.length;
                                v = A.getStartOffset(), _ = A.getEndOffset(), S = n ? _ + I : v, T = _ + I
                            }
                            var x = m.merge({
                                selectionBefore: h.getSelectionAfter(),
                                selectionAfter: A.merge({
                                    anchorOffset: S,
                                    focusOffset: T
                                })
                            });
                            e.update(EditorState.push(s, x, k))
                        }
                    }
                    var DraftFeatureFlags = require("./DraftFeatureFlags"),
                        DraftModifier = require("./DraftModifier"),
                        DraftOffsetKey = require("./DraftOffsetKey"),
                        EditorState = require("./EditorState"),
                        UserAgent = require("fbjs/lib/UserAgent"),
                        findAncestorOffsetKey = require("./findAncestorOffsetKey"),
                        nullthrows = require("fbjs/lib/nullthrows"),
                        isGecko = UserAgent.isEngine("Gecko"),
                        DOUBLE_NEWLINE = "\n\n";
                    module.exports = editOnInput
                }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
            }, {
                "./DraftFeatureFlags": 75,
                "./DraftModifier": 77,
                "./DraftOffsetKey": 78,
                "./EditorState": 83,
                "./findAncestorOffsetKey": 112,
                "fbjs/lib/UserAgent": 168,
                "fbjs/lib/nullthrows": 191
            }],
            106: [function(require, module, exports) {
                "use strict";

                function onKeyCommand(e, r) {
                    switch (e) {
                        case "redo":
                            return EditorState.redo(r);
                        case "delete":
                            return keyCommandPlainDelete(r);
                        case "delete-word":
                            return keyCommandDeleteWord(r);
                        case "backspace":
                            return keyCommandPlainBackspace(r);
                        case "backspace-word":
                            return keyCommandBackspaceWord(r);
                        case "backspace-to-start-of-line":
                            return keyCommandBackspaceToStartOfLine(r);
                        case "split-block":
                            return keyCommandInsertNewline(r);
                        case "transpose-characters":
                            return keyCommandTransposeCharacters(r);
                        case "move-selection-to-start-of-block":
                            return keyCommandMoveSelectionToStartOfBlock(r);
                        case "move-selection-to-end-of-block":
                            return keyCommandMoveSelectionToEndOfBlock(r);
                        case "secondary-cut":
                            return SecondaryClipboard.cut(r);
                        case "secondary-paste":
                            return SecondaryClipboard.paste(r);
                        default:
                            return r
                    }
                }

                function editOnKeyDown(e, r) {
                    var o = r.which,
                        n = e._latestEditorState;
                    switch (o) {
                        case Keys.RETURN:
                            if (r.preventDefault(), e.props.handleReturn && isEventHandled(e.props.handleReturn(r, n))) return;
                            break;
                        case Keys.ESC:
                            return r.preventDefault(), void(e.props.onEscape && e.props.onEscape(r));
                        case Keys.TAB:
                            return void(e.props.onTab && e.props.onTab(r));
                        case Keys.UP:
                            return void(e.props.onUpArrow && e.props.onUpArrow(r));
                        case Keys.RIGHT:
                            return void(e.props.onRightArrow && e.props.onRightArrow(r));
                        case Keys.DOWN:
                            return void(e.props.onDownArrow && e.props.onDownArrow(r));
                        case Keys.LEFT:
                            return void(e.props.onLeftArrow && e.props.onLeftArrow(r));
                        case Keys.SPACE:
                            if (isChrome && isOptionKeyCommand(r)) {
                                r.preventDefault();
                                var a = DraftModifier.replaceText(n.getCurrentContent(), n.getSelection(), "");
                                return void e.update(EditorState.push(n, a, "insert-characters"))
                            }
                    }
                    var t = e.props.keyBindingFn(r);
                    if (t)
                        if ("undo" !== t) {
                            if (r.preventDefault(), !e.props.handleKeyCommand || !isEventHandled(e.props.handleKeyCommand(t, n))) {
                                var s = onKeyCommand(t, n);
                                s !== n && e.update(s)
                            }
                        } else keyCommandUndo(r, n, e.update)
                }
                var DraftModifier = require("./DraftModifier"),
                    EditorState = require("./EditorState"),
                    KeyBindingUtil = require("./KeyBindingUtil"),
                    Keys = require("fbjs/lib/Keys"),
                    SecondaryClipboard = require("./SecondaryClipboard"),
                    UserAgent = require("fbjs/lib/UserAgent"),
                    isEventHandled = require("./isEventHandled"),
                    keyCommandBackspaceToStartOfLine = require("./keyCommandBackspaceToStartOfLine"),
                    keyCommandBackspaceWord = require("./keyCommandBackspaceWord"),
                    keyCommandDeleteWord = require("./keyCommandDeleteWord"),
                    keyCommandInsertNewline = require("./keyCommandInsertNewline"),
                    keyCommandMoveSelectionToEndOfBlock = require("./keyCommandMoveSelectionToEndOfBlock"),
                    keyCommandMoveSelectionToStartOfBlock = require("./keyCommandMoveSelectionToStartOfBlock"),
                    keyCommandPlainBackspace = require("./keyCommandPlainBackspace"),
                    keyCommandPlainDelete = require("./keyCommandPlainDelete"),
                    keyCommandTransposeCharacters = require("./keyCommandTransposeCharacters"),
                    keyCommandUndo = require("./keyCommandUndo"),
                    isOptionKeyCommand = KeyBindingUtil.isOptionKeyCommand,
                    isChrome = UserAgent.isBrowser("Chrome");
                module.exports = editOnKeyDown
            }, {
                "./DraftModifier": 77,
                "./EditorState": 83,
                "./KeyBindingUtil": 84,
                "./SecondaryClipboard": 86,
                "./isEventHandled": 133,
                "./keyCommandBackspaceToStartOfLine": 135,
                "./keyCommandBackspaceWord": 136,
                "./keyCommandDeleteWord": 137,
                "./keyCommandInsertNewline": 138,
                "./keyCommandMoveSelectionToEndOfBlock": 139,
                "./keyCommandMoveSelectionToStartOfBlock": 140,
                "./keyCommandPlainBackspace": 141,
                "./keyCommandPlainDelete": 142,
                "./keyCommandTransposeCharacters": 143,
                "./keyCommandUndo": 144,
                "fbjs/lib/Keys": 158,
                "fbjs/lib/UserAgent": 168
            }],
            107: [function(require, module, exports) {
                "use strict";

                function editOnPaste(e, t) {
                    t.preventDefault();
                    var r = new DataTransfer(t.clipboardData);
                    if (!r.isRichText()) {
                        var a = r.getFiles(),
                            i = r.getText();
                        if (a.length > 0) {
                            if (e.props.handlePastedFiles && isEventHandled(e.props.handlePastedFiles(a))) return;
                            return void getTextContentFromFiles(a, function(t) {
                                if (t = t || i) {
                                    var r = e._latestEditorState,
                                        a = splitTextIntoTextBlocks(t),
                                        n = CharacterMetadata.create({
                                            style: r.getCurrentInlineStyle(),
                                            entity: getEntityKeyForSelection(r.getCurrentContent(), r.getSelection())
                                        }),
                                        o = RichTextEditorUtil.getCurrentBlockType(r),
                                        s = DraftPasteProcessor.processText(a, n, o),
                                        l = BlockMapBuilder.createFromArray(s),
                                        d = DraftModifier.replaceWithFragment(r.getCurrentContent(), r.getSelection(), l);
                                    e.update(EditorState.push(r, d, "insert-fragment"))
                                }
                            })
                        }
                    }
                    var n = [],
                        o = r.getText(),
                        s = r.getHTML(),
                        l = e._latestEditorState;
                    if (!e.props.handlePastedText || !isEventHandled(e.props.handlePastedText(o, s, l))) {
                        if (o && (n = splitTextIntoTextBlocks(o)), !e.props.stripPastedStyles) {
                            var d = e.getClipboard();
                            if (r.isRichText() && d) {
                                if (-1 !== s.indexOf(e.getEditorKey()) || 1 === n.length && 1 === d.size && d.first().getText() === o) return void e.update(insertFragment(e._latestEditorState, d))
                            } else if (d && r.types.includes("com.apple.webarchive") && !r.types.includes("text/html") && areTextBlocksAndClipboardEqual(n, d)) return void e.update(insertFragment(e._latestEditorState, d));
                            if (s) {
                                var c = DraftPasteProcessor.processHTML(s, e.props.blockRenderMap);
                                if (c) {
                                    var u = c.contentBlocks,
                                        p = c.entityMap;
                                    if (u) {
                                        var f = BlockMapBuilder.createFromArray(u);
                                        return void e.update(insertFragment(e._latestEditorState, f, p))
                                    }
                                }
                            }
                            e.setClipboard(null)
                        }
                        if (n.length) {
                            var g = CharacterMetadata.create({
                                    style: l.getCurrentInlineStyle(),
                                    entity: getEntityKeyForSelection(l.getCurrentContent(), l.getSelection())
                                }),
                                T = RichTextEditorUtil.getCurrentBlockType(l),
                                x = DraftPasteProcessor.processText(n, g, T),
                                y = BlockMapBuilder.createFromArray(x);
                            e.update(insertFragment(e._latestEditorState, y))
                        }
                    }
                }

                function insertFragment(e, t, r) {
                    var a = DraftModifier.replaceWithFragment(e.getCurrentContent(), e.getSelection(), t);
                    return EditorState.push(e, a.set("entityMap", r), "insert-fragment")
                }

                function areTextBlocksAndClipboardEqual(e, t) {
                    return e.length === t.size && t.valueSeq().every(function(t, r) {
                        return t.getText() === e[r]
                    })
                }
                var BlockMapBuilder = require("./BlockMapBuilder"),
                    CharacterMetadata = require("./CharacterMetadata"),
                    DataTransfer = require("fbjs/lib/DataTransfer"),
                    DraftModifier = require("./DraftModifier"),
                    DraftPasteProcessor = require("./DraftPasteProcessor"),
                    EditorState = require("./EditorState"),
                    RichTextEditorUtil = require("./RichTextEditorUtil"),
                    getEntityKeyForSelection = require("./getEntityKeyForSelection"),
                    getTextContentFromFiles = require("./getTextContentFromFiles"),
                    isEventHandled = require("./isEventHandled"),
                    splitTextIntoTextBlocks = require("./splitTextIntoTextBlocks");
                module.exports = editOnPaste
            }, {
                "./BlockMapBuilder": 52,
                "./CharacterMetadata": 54,
                "./DraftModifier": 77,
                "./DraftPasteProcessor": 79,
                "./EditorState": 83,
                "./RichTextEditorUtil": 85,
                "./getEntityKeyForSelection": 120,
                "./getTextContentFromFiles": 127,
                "./isEventHandled": 133,
                "./splitTextIntoTextBlocks": 155,
                "fbjs/lib/DataTransfer": 157
            }],
            108: [function(require, module, exports) {
                (function(process) {
                    "use strict";

                    function editOnSelect(e) {
                        if (!e._blockSelectEvents && e._latestEditorState === e.props.editorState) {
                            var t = e.props.editorState,
                                i = ReactDOM.findDOMNode(e.refs.editorContainer);
                            i || ("production" !== process.env.NODE_ENV ? invariant(!1, "Missing editorNode") : invariant(!1)), i.firstChild instanceof HTMLElement || ("production" !== process.env.NODE_ENV ? invariant(!1, "editorNode.firstChild is not an HTMLElement") : invariant(!1));
                            var r = getDraftEditorSelection(t, i.firstChild),
                                o = r.selectionState;
                            o !== t.getSelection() && (t = r.needsRecovery ? EditorState.forceSelection(t, o) : EditorState.acceptSelection(t, o), e.update(t))
                        }
                    }
                    var EditorState = require("./EditorState"),
                        ReactDOM = require("react-dom"),
                        getDraftEditorSelection = require("./getDraftEditorSelection"),
                        invariant = require("fbjs/lib/invariant");
                    module.exports = editOnSelect
                }).call(this, require("_process"))
            }, {
                "./EditorState": 83,
                "./getDraftEditorSelection": 118,
                _process: 433,
                "fbjs/lib/invariant": 185,
                "react-dom": 438
            }],
            109: [function(require, module, exports) {
                "use strict";

                function encodeEntityRanges(t, e) {
                    var n = [];
                    return t.findEntityRanges(function(t) {
                        return !!t.getEntity()
                    }, function(i, r) {
                        var s = t.getText(),
                            l = t.getEntityAt(i);
                        n.push({
                            offset: strlen(s.slice(0, i)),
                            length: strlen(s.slice(i, r)),
                            key: Number(e[DraftStringKey.stringify(l)])
                        })
                    }), n
                }
                var DraftStringKey = require("./DraftStringKey"),
                    UnicodeUtils = require("fbjs/lib/UnicodeUtils"),
                    strlen = UnicodeUtils.strlen;
                module.exports = encodeEntityRanges
            }, {
                "./DraftStringKey": 81,
                "fbjs/lib/UnicodeUtils": 167
            }],
            110: [function(require, module, exports) {
                "use strict";

                function getEncodedInlinesForType(e, t, n) {
                    var r = [],
                        i = t.map(function(e) {
                            return e.has(n)
                        }).toList();
                    return findRangesImmutable(i, areEqual, isTruthy, function(t, i) {
                        var o = e.getText();
                        r.push({
                            offset: UnicodeUtils.strlen(o.slice(0, t)),
                            length: UnicodeUtils.strlen(o.slice(t, i)),
                            style: n
                        })
                    }), r
                }

                function encodeInlineStyleRanges(e) {
                    var t = e.getCharacterList().map(function(e) {
                            return e.getStyle()
                        }).toList(),
                        n = t.flatten().toSet().map(function(n) {
                            return getEncodedInlinesForType(e, t, n)
                        });
                    return Array.prototype.concat.apply(EMPTY_ARRAY, n.toJS())
                }
                var UnicodeUtils = require("fbjs/lib/UnicodeUtils"),
                    findRangesImmutable = require("./findRangesImmutable"),
                    areEqual = function(e, t) {
                        return e === t
                    },
                    isTruthy = function(e) {
                        return !!e
                    },
                    EMPTY_ARRAY = [];
                module.exports = encodeInlineStyleRanges
            }, {
                "./findRangesImmutable": 113,
                "fbjs/lib/UnicodeUtils": 167
            }],
            111: [function(require, module, exports) {
                (function(process) {
                    "use strict";

                    function getLineHeightPx(e) {
                        var t = getComputedStyle(e),
                            n = document.createElement("div");
                        n.style.fontFamily = t.fontFamily, n.style.fontSize = t.fontSize, n.style.fontStyle = t.fontStyle, n.style.fontWeight = t.fontWeight, n.style.lineHeight = t.lineHeight, n.style.position = "absolute", n.textContent = "M";
                        var i = document.body;
                        i || ("production" !== process.env.NODE_ENV ? invariant(!1, "Missing document.body") : invariant(!1)), i.appendChild(n);
                        var a = n.getBoundingClientRect();
                        return i.removeChild(n), a.height
                    }

                    function areRectsOnOneLine(e, t) {
                        for (var n = 1 / 0, i = 1 / 0, a = -1 / 0, r = -1 / 0, o = 0; o < e.length; o++) {
                            var s = e[o];
                            0 !== s.width && 1 !== s.width && (n = Math.min(n, s.top), i = Math.min(i, s.bottom), a = Math.max(a, s.top), r = Math.max(r, s.bottom))
                        }
                        return a <= i && a - n < t && r - i < t
                    }

                    function getNodeLength(e) {
                        switch (e.nodeType) {
                            case Node.DOCUMENT_TYPE_NODE:
                                return 0;
                            case Node.TEXT_NODE:
                            case Node.PROCESSING_INSTRUCTION_NODE:
                            case Node.COMMENT_NODE:
                                return e.length;
                            default:
                                return e.childNodes.length
                        }
                    }

                    function expandRangeToStartOfLine(e) {
                        e.collapsed || ("production" !== process.env.NODE_ENV ? invariant(!1, "expandRangeToStartOfLine: Provided range is not collapsed.") : invariant(!1));
                        var t = (e = e.cloneRange()).startContainer;
                        1 !== t.nodeType && (t = t.parentNode);
                        var n = getLineHeightPx(t),
                            i = e.endContainer,
                            a = e.endOffset;
                        for (e.setStart(e.startContainer, 0); areRectsOnOneLine(getRangeClientRects(e), n) && (i = e.startContainer, a = e.startOffset, i.parentNode || ("production" !== process.env.NODE_ENV ? invariant(!1, "Found unexpected detached subtree when traversing.") : invariant(!1)), e.setStartBefore(i), 1 !== i.nodeType || "inline" === getComputedStyle(i).display););
                        for (var r = i, o = a - 1;;) {
                            for (var s = r.nodeValue, d = o; d >= 0; d--)
                                if (!(null != s && d > 0 && UnicodeUtils.isSurrogatePair(s, d - 1))) {
                                    if (e.setStart(r, d), !areRectsOnOneLine(getRangeClientRects(e), n)) break;
                                    i = r, a = d
                                } if (-1 === d || 0 === r.childNodes.length) break;
                            o = getNodeLength(r = r.childNodes[d])
                        }
                        return e.setStart(i, a), e
                    }
                    var UnicodeUtils = require("fbjs/lib/UnicodeUtils"),
                        getRangeClientRects = require("./getRangeClientRects"),
                        invariant = require("fbjs/lib/invariant");
                    module.exports = expandRangeToStartOfLine
                }).call(this, require("_process"))
            }, {
                "./getRangeClientRects": 123,
                _process: 433,
                "fbjs/lib/UnicodeUtils": 167,
                "fbjs/lib/invariant": 185
            }],
            112: [function(require, module, exports) {
                "use strict";

                function findAncestorOffsetKey(e) {
                    for (var t = e; t && t !== document.documentElement;) {
                        var o = getSelectionOffsetKeyForNode(t);
                        if (null != o) return o;
                        t = t.parentNode
                    }
                    return null
                }
                var getSelectionOffsetKeyForNode = require("./getSelectionOffsetKeyForNode");
                module.exports = findAncestorOffsetKey
            }, {
                "./getSelectionOffsetKeyForNode": 126
            }],
            113: [function(require, module, exports) {
                "use strict";

                function findRangesImmutable(e, n, t, u) {
                    if (e.size) {
                        var i = 0;
                        e.reduce(function(e, s, a) {
                            return n(e, s) || (t(e) && u(i, a), i = a), s
                        }), t(e.last()) && u(i, e.count())
                    }
                }
                module.exports = findRangesImmutable
            }, {}],
            114: [function(require, module, exports) {
                "use strict";

                function generateRandomKey() {
                    for (var e = void 0; void 0 === e || seenKeys.hasOwnProperty(e) || !isNaN(+e);) e = Math.floor(Math.random() * MULTIPLIER).toString(32);
                    return seenKeys[e] = !0, e
                }
                var seenKeys = {},
                    MULTIPLIER = Math.pow(2, 24);
                module.exports = generateRandomKey
            }, {}],
            115: [function(require, module, exports) {
                (function(process) {
                    "use strict";

                    function getCharacterRemovalRange(t, e, r, a, n) {
                        var f = a.getStartOffset(),
                            i = a.getEndOffset(),
                            s = e.getEntityAt(f),
                            g = r.getEntityAt(i - 1);
                        if (!s && !g) return a;
                        var o = a;
                        if (s && s === g) o = getEntityRemovalRange(t, e, o, n, s, !0, !0);
                        else if (s && g) {
                            var v = getEntityRemovalRange(t, e, o, n, s, !1, !0),
                                c = getEntityRemovalRange(t, r, o, n, g, !1, !1);
                            o = o.merge({
                                anchorOffset: v.getAnchorOffset(),
                                focusOffset: c.getFocusOffset(),
                                isBackward: !1
                            })
                        } else if (s) {
                            var u = getEntityRemovalRange(t, e, o, n, s, !1, !0);
                            o = o.merge({
                                anchorOffset: u.getStartOffset(),
                                isBackward: !1
                            })
                        } else if (g) {
                            var l = getEntityRemovalRange(t, r, o, n, g, !1, !1);
                            o = o.merge({
                                focusOffset: l.getEndOffset(),
                                isBackward: !1
                            })
                        }
                        return o
                    }

                    function getEntityRemovalRange(t, e, r, a, n, f, i) {
                        var s = r.getStartOffset(),
                            g = r.getEndOffset(),
                            o = t.__get(n).getMutability(),
                            v = i ? s : g;
                        if ("MUTABLE" === o) return r;
                        var c = getRangesForDraftEntity(e, n).filter(function(t) {
                            return v <= t.end && v >= t.start
                        });
                        1 != c.length && ("production" !== process.env.NODE_ENV ? invariant(!1, "There should only be one entity range within this removal range.") : invariant(!1));
                        var u = c[0];
                        if ("IMMUTABLE" === o) return r.merge({
                            anchorOffset: u.start,
                            focusOffset: u.end,
                            isBackward: !1
                        });
                        f || (i ? g = u.end : s = u.start);
                        var l = DraftEntitySegments.getRemovalRange(s, g, e.getText().slice(u.start, u.end), u.start, a);
                        return r.merge({
                            anchorOffset: l.start,
                            focusOffset: l.end,
                            isBackward: !1
                        })
                    }
                    var DraftEntitySegments = require("./DraftEntitySegments"),
                        getRangesForDraftEntity = require("./getRangesForDraftEntity"),
                        invariant = require("fbjs/lib/invariant");
                    module.exports = getCharacterRemovalRange
                }).call(this, require("_process"))
            }, {
                "./DraftEntitySegments": 73,
                "./getRangesForDraftEntity": 124,
                _process: 433,
                "fbjs/lib/invariant": 185
            }],
            116: [function(require, module, exports) {
                "use strict";

                function getContentStateFragment(e, t) {
                    var r = t.getStartKey(),
                        a = t.getStartOffset(),
                        n = t.getEndKey(),
                        i = t.getEndOffset(),
                        s = removeEntitiesAtEdges(e, t).getBlockMap(),
                        g = s.keySeq(),
                        c = g.indexOf(r),
                        o = g.indexOf(n) + 1;
                    return s.slice(c, o).map(function(e, t) {
                        var s = generateRandomKey(),
                            g = e.getText(),
                            c = e.getCharacterList();
                        return r === n ? e.merge({
                            key: s,
                            text: g.slice(a, i),
                            characterList: c.slice(a, i)
                        }) : t === r ? e.merge({
                            key: s,
                            text: g.slice(a),
                            characterList: c.slice(a)
                        }) : t === n ? e.merge({
                            key: s,
                            text: g.slice(0, i),
                            characterList: c.slice(0, i)
                        }) : e.set("key", s)
                    }).toOrderedMap()
                }
                var generateRandomKey = require("./generateRandomKey"),
                    removeEntitiesAtEdges = require("./removeEntitiesAtEdges");
                module.exports = getContentStateFragment
            }, {
                "./generateRandomKey": 114,
                "./removeEntitiesAtEdges": 149
            }],
            117: [function(require, module, exports) {
                "use strict";

                function shouldRemoveWord(e) {
                    return isOSX && e.altKey || isCtrlKeyCommand(e)
                }

                function getZCommand(e) {
                    return hasCommandModifier(e) ? e.shiftKey ? "redo" : "undo" : null
                }

                function getDeleteCommand(e) {
                    return isWindows && e.shiftKey ? null : shouldRemoveWord(e) ? "delete-word" : "delete"
                }

                function getBackspaceCommand(e) {
                    return hasCommandModifier(e) && isOSX ? "backspace-to-start-of-line" : shouldRemoveWord(e) ? "backspace-word" : "backspace"
                }

                function getDefaultKeyBinding(e) {
                    switch (e.keyCode) {
                        case 66:
                            return hasCommandModifier(e) ? "bold" : null;
                        case 68:
                            return isCtrlKeyCommand(e) ? "delete" : null;
                        case 72:
                            return isCtrlKeyCommand(e) ? "backspace" : null;
                        case 73:
                            return hasCommandModifier(e) ? "italic" : null;
                        case 74:
                            return hasCommandModifier(e) ? "code" : null;
                        case 75:
                            return !isWindows && isCtrlKeyCommand(e) ? "secondary-cut" : null;
                        case 77:
                        case 79:
                            return isCtrlKeyCommand(e) ? "split-block" : null;
                        case 84:
                            return isOSX && isCtrlKeyCommand(e) ? "transpose-characters" : null;
                        case 85:
                            return hasCommandModifier(e) ? "underline" : null;
                        case 87:
                            return isOSX && isCtrlKeyCommand(e) ? "backspace-word" : null;
                        case 89:
                            return isCtrlKeyCommand(e) ? isWindows ? "redo" : "secondary-paste" : null;
                        case 90:
                            return getZCommand(e) || null;
                        case Keys.RETURN:
                            return "split-block";
                        case Keys.DELETE:
                            return getDeleteCommand(e);
                        case Keys.BACKSPACE:
                            return getBackspaceCommand(e);
                        case Keys.LEFT:
                            return shouldFixFirefoxMovement && hasCommandModifier(e) ? "move-selection-to-start-of-block" : null;
                        case Keys.RIGHT:
                            return shouldFixFirefoxMovement && hasCommandModifier(e) ? "move-selection-to-end-of-block" : null;
                        default:
                            return null
                    }
                }
                var KeyBindingUtil = require("./KeyBindingUtil"),
                    Keys = require("fbjs/lib/Keys"),
                    UserAgent = require("fbjs/lib/UserAgent"),
                    isOSX = UserAgent.isPlatform("Mac OS X"),
                    isWindows = UserAgent.isPlatform("Windows"),
                    shouldFixFirefoxMovement = isOSX && UserAgent.isBrowser("Firefox < 29"),
                    hasCommandModifier = KeyBindingUtil.hasCommandModifier,
                    isCtrlKeyCommand = KeyBindingUtil.isCtrlKeyCommand;
                module.exports = getDefaultKeyBinding
            }, {
                "./KeyBindingUtil": 84,
                "fbjs/lib/Keys": 158,
                "fbjs/lib/UserAgent": 168
            }],
            118: [function(require, module, exports) {
                (function(global) {
                    "use strict";

                    function getDraftEditorSelection(e, t) {
                        var o = global.getSelection();
                        return 0 === o.rangeCount ? {
                            selectionState: e.getSelection().set("hasFocus", !1),
                            needsRecovery: !1
                        } : getDraftEditorSelectionWithNodes(e, t, o.anchorNode, o.anchorOffset, o.focusNode, o.focusOffset)
                    }
                    var getDraftEditorSelectionWithNodes = require("./getDraftEditorSelectionWithNodes");
                    module.exports = getDraftEditorSelection
                }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
            }, {
                "./getDraftEditorSelectionWithNodes": 119
            }],
            119: [function(require, module, exports) {
                (function(process) {
                    "use strict";

                    function getDraftEditorSelectionWithNodes(e, t, n, o, r, i) {
                        var f = n.nodeType === Node.TEXT_NODE,
                            s = r.nodeType === Node.TEXT_NODE;
                        if (f && s) return {
                            selectionState: getUpdatedSelectionState(e, nullthrows(findAncestorOffsetKey(n)), o, nullthrows(findAncestorOffsetKey(r)), i),
                            needsRecovery: !1
                        };
                        var l = null,
                            d = null,
                            a = !0;
                        return f ? (l = {
                            key: nullthrows(findAncestorOffsetKey(n)),
                            offset: o
                        }, d = getPointForNonTextNode(t, r, i)) : s ? (d = {
                            key: nullthrows(findAncestorOffsetKey(r)),
                            offset: i
                        }, l = getPointForNonTextNode(t, n, o)) : (l = getPointForNonTextNode(t, n, o), d = getPointForNonTextNode(t, r, i), n === r && o === i && (a = !!n.firstChild && "BR" !== n.firstChild.nodeName)), {
                            selectionState: getUpdatedSelectionState(e, l.key, l.offset, d.key, d.offset),
                            needsRecovery: a
                        }
                    }

                    function getFirstLeaf(e) {
                        for (; e.firstChild && getSelectionOffsetKeyForNode(e.firstChild);) e = e.firstChild;
                        return e
                    }

                    function getLastLeaf(e) {
                        for (; e.lastChild && getSelectionOffsetKeyForNode(e.lastChild);) e = e.lastChild;
                        return e
                    }

                    function getPointForNonTextNode(e, t, n) {
                        var o = t,
                            r = findAncestorOffsetKey(o);
                        if (null != r || e && (e === o || e.firstChild === o) || ("production" !== process.env.NODE_ENV ? invariant(!1, "Unknown node in selection range.") : invariant(!1)), e === o && ((o = o.firstChild) instanceof Element && "true" === o.getAttribute("data-contents") || ("production" !== process.env.NODE_ENV ? invariant(!1, "Invalid DraftEditorContents structure.") : invariant(!1)), n > 0 && (n = o.childNodes.length)), 0 === n) {
                            var i = null;
                            if (null != r) i = r;
                            else {
                                var f = getFirstLeaf(o);
                                i = nullthrows(getSelectionOffsetKeyForNode(f))
                            }
                            return {
                                key: i,
                                offset: 0
                            }
                        }
                        var s = o.childNodes[n - 1],
                            l = null,
                            d = null;
                        if (getSelectionOffsetKeyForNode(s)) {
                            var a = getLastLeaf(s);
                            l = nullthrows(getSelectionOffsetKeyForNode(a)), d = getTextContentLength(a)
                        } else l = nullthrows(r), d = getTextContentLength(s);
                        return {
                            key: l,
                            offset: d
                        }
                    }

                    function getTextContentLength(e) {
                        var t = e.textContent;
                        return "\n" === t ? 0 : t.length
                    }
                    var findAncestorOffsetKey = require("./findAncestorOffsetKey"),
                        getSelectionOffsetKeyForNode = require("./getSelectionOffsetKeyForNode"),
                        getUpdatedSelectionState = require("./getUpdatedSelectionState"),
                        invariant = require("fbjs/lib/invariant"),
                        nullthrows = require("fbjs/lib/nullthrows");
                    module.exports = getDraftEditorSelectionWithNodes
                }).call(this, require("_process"))
            }, {
                "./findAncestorOffsetKey": 112,
                "./getSelectionOffsetKeyForNode": 126,
                "./getUpdatedSelectionState": 128,
                _process: 433,
                "fbjs/lib/invariant": 185,
                "fbjs/lib/nullthrows": 191
            }],
            120: [function(require, module, exports) {
                "use strict";

                function getEntityKeyForSelection(t, e) {
                    var r;
                    if (e.isCollapsed()) {
                        var n = e.getAnchorKey(),
                            i = e.getAnchorOffset();
                        return i > 0 ? (r = t.getBlockForKey(n).getEntityAt(i - 1), filterKey(t.getEntityMap(), r)) : null
                    }
                    var l = e.getStartKey(),
                        g = e.getStartOffset(),
                        y = t.getBlockForKey(l);
                    return r = g === y.getLength() ? null : y.getEntityAt(g), filterKey(t.getEntityMap(), r)
                }

                function filterKey(t, e) {
                    return e && "MUTABLE" === t.__get(e).getMutability() ? e : null
                }
                module.exports = getEntityKeyForSelection
            }, {}],
            121: [function(require, module, exports) {
                "use strict";

                function getFragmentFromSelection(t) {
                    var e = t.getSelection();
                    return e.isCollapsed() ? null : getContentStateFragment(t.getCurrentContent(), e)
                }
                var getContentStateFragment = require("./getContentStateFragment");
                module.exports = getFragmentFromSelection
            }, {
                "./getContentStateFragment": 116
            }],
            122: [function(require, module, exports) {
                "use strict";

                function getRangeBoundingClientRect(t) {
                    var e = getRangeClientRects(t),
                        i = 0,
                        n = 0,
                        g = 0,
                        h = 0;
                    if (e.length) {
                        if (e.length > 1 && 0 === e[0].width) {
                            var o = e[1];
                            i = o.top, n = o.right, g = o.bottom, h = o.left
                        } else {
                            var a = e[0];
                            i = a.top, n = a.right, g = a.bottom, h = a.left
                        }
                        for (var r = 1; r < e.length; r++) {
                            var l = e[r];
                            0 !== l.height && 0 !== l.width && (i = Math.min(i, l.top), n = Math.max(n, l.right), g = Math.max(g, l.bottom), h = Math.min(h, l.left))
                        }
                    }
                    return {
                        top: i,
                        right: n,
                        bottom: g,
                        left: h,
                        width: n - h,
                        height: g - i
                    }
                }
                var getRangeClientRects = require("./getRangeClientRects");
                module.exports = getRangeBoundingClientRect
            }, {
                "./getRangeClientRects": 123
            }],
            123: [function(require, module, exports) {
                (function(process) {
                    "use strict";

                    function getRangeClientRectsChrome(e) {
                        for (var t = e.cloneRange(), n = [], r = e.endContainer; null != r; r = r.parentNode) {
                            var a = r === e.commonAncestorContainer;
                            a ? t.setStart(e.startContainer, e.startOffset) : t.setStart(t.endContainer, 0);
                            var i, s = Array.from(t.getClientRects());
                            if (n.push(s), a) return n.reverse(), (i = []).concat.apply(i, n);
                            t.setEndBefore(r)
                        }
                        "production" !== process.env.NODE_ENV ? invariant(!1, "Found an unexpected detached subtree when getting range client rects.") : invariant(!1)
                    }
                    var UserAgent = require("fbjs/lib/UserAgent"),
                        invariant = require("fbjs/lib/invariant"),
                        isChrome = UserAgent.isBrowser("Chrome"),
                        getRangeClientRects = isChrome ? getRangeClientRectsChrome : function(e) {
                            return Array.from(e.getClientRects())
                        };
                    module.exports = getRangeClientRects
                }).call(this, require("_process"))
            }, {
                _process: 433,
                "fbjs/lib/UserAgent": 168,
                "fbjs/lib/invariant": 185
            }],
            124: [function(require, module, exports) {
                (function(process) {
                    "use strict";

                    function getRangesForDraftEntity(n, t) {
                        var i = [];
                        return n.findEntityRanges(function(n) {
                            return n.getEntity() === t
                        }, function(n, t) {
                            i.push({
                                start: n,
                                end: t
                            })
                        }), i.length || ("production" !== process.env.NODE_ENV ? invariant(!1, "Entity key not found in this range.") : invariant(!1)), i
                    }
                    var invariant = require("fbjs/lib/invariant");
                    module.exports = getRangesForDraftEntity
                }).call(this, require("_process"))
            }, {
                _process: 433,
                "fbjs/lib/invariant": 185
            }],
            125: [function(require, module, exports) {
                (function(process) {
                    "use strict";

                    function getSafeBodyFromHTML(e) {
                        var n, t = null;
                        return !isOldIE && document.implementation && document.implementation.createHTMLDocument && ((n = document.implementation.createHTMLDocument("foo")).documentElement || ("production" !== process.env.NODE_ENV ? invariant(!1, "Missing doc.documentElement") : invariant(!1)), n.documentElement.innerHTML = e, t = n.getElementsByTagName("body")[0]), t
                    }
                    var UserAgent = require("fbjs/lib/UserAgent"),
                        invariant = require("fbjs/lib/invariant"),
                        isOldIE = UserAgent.isBrowser("IE <= 9");
                    module.exports = getSafeBodyFromHTML
                }).call(this, require("_process"))
            }, {
                _process: 433,
                "fbjs/lib/UserAgent": 168,
                "fbjs/lib/invariant": 185
            }],
            126: [function(require, module, exports) {
                "use strict";

                function getSelectionOffsetKeyForNode(e) {
                    if (e instanceof Element) {
                        var t = e.getAttribute("data-offset-key");
                        if (t) return t;
                        for (var o = 0; o < e.childNodes.length; o++) {
                            var r = getSelectionOffsetKeyForNode(e.childNodes[o]);
                            if (r) return r
                        }
                    }
                    return null
                }
                module.exports = getSelectionOffsetKeyForNode
            }, {}],
            127: [function(require, module, exports) {
                (function(process, global) {
                    "use strict";

                    function getTextContentFromFiles(e, t) {
                        var n = 0,
                            i = [];
                        e.forEach(function(r) {
                            readFile(r, function(r) {
                                n++, r && i.push(r.slice(0, TEXT_SIZE_UPPER_BOUND)), n == e.length && t(i.join("\r"))
                            })
                        })
                    }

                    function readFile(e, t) {
                        if (global.FileReader && (!e.type || e.type in TEXT_TYPES)) {
                            if ("" === e.type) {
                                var n = "";
                                return TEXT_CLIPPING_REGEX.test(e.name) && (n = e.name.replace(TEXT_CLIPPING_REGEX, "")), void t(n)
                            }
                            var i = new FileReader;
                            i.onload = function() {
                                var e = i.result;
                                "string" != typeof e && ("production" !== process.env.NODE_ENV ? invariant(!1, 'We should be calling "FileReader.readAsText" which returns a string') : invariant(!1)), t(e)
                            }, i.onerror = function() {
                                t("")
                            }, i.readAsText(e)
                        } else t("")
                    }
                    var invariant = require("fbjs/lib/invariant"),
                        TEXT_CLIPPING_REGEX = /\.textClipping$/,
                        TEXT_TYPES = {
                            "text/plain": !0,
                            "text/html": !0,
                            "text/rtf": !0
                        },
                        TEXT_SIZE_UPPER_BOUND = 5e3;
                    module.exports = getTextContentFromFiles
                }).call(this, require("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
            }, {
                _process: 433,
                "fbjs/lib/invariant": 185
            }],
            128: [function(require, module, exports) {
                (function(process) {
                    "use strict";

                    function getUpdatedSelectionState(e, t, r, o, n) {
                        var s = nullthrows(e.getSelection());
                        if (!("production" === process.env.NODE_ENV || t && o)) return console.warn("Invalid selection state.", arguments, e.toJS()), s;
                        var f = DraftOffsetKey.decode(t),
                            a = f.blockKey,
                            l = e.getBlockTree(a).getIn([f.decoratorKey, "leaves", f.leafKey]),
                            c = DraftOffsetKey.decode(o),
                            u = c.blockKey,
                            i = e.getBlockTree(u).getIn([c.decoratorKey, "leaves", c.leafKey]),
                            g = l.get("start"),
                            d = i.get("start"),
                            y = l ? g + r : null,
                            K = i ? d + n : null;
                        if (s.getAnchorKey() === a && s.getAnchorOffset() === y && s.getFocusKey() === u && s.getFocusOffset() === K) return s;
                        var v = !1;
                        if (a === u) {
                            var O = l.get("end"),
                                k = i.get("end");
                            v = d === g && k === O ? n < r : d < g
                        } else v = e.getCurrentContent().getBlockMap().keySeq().skipUntil(function(e) {
                            return e === a || e === u
                        }).first() === u;
                        return s.merge({
                            anchorKey: a,
                            anchorOffset: y,
                            focusKey: u,
                            focusOffset: K,
                            isBackward: v
                        })
                    }
                    var DraftOffsetKey = require("./DraftOffsetKey"),
                        nullthrows = require("fbjs/lib/nullthrows");
                    module.exports = getUpdatedSelectionState
                }).call(this, require("_process"))
            }, {
                "./DraftOffsetKey": 78,
                _process: 433,
                "fbjs/lib/nullthrows": 191
            }],
            129: [function(require, module, exports) {
                "use strict";

                function getVisibleSelectionRect(e) {
                    var t = e.getSelection();
                    if (!t.rangeCount) return null;
                    var n = t.getRangeAt(0),
                        i = getRangeBoundingClientRect(n),
                        g = i.top,
                        l = i.right,
                        o = i.bottom,
                        r = i.left;
                    return 0 === g && 0 === l && 0 === o && 0 === r ? null : i
                }
                var getRangeBoundingClientRect = require("./getRangeBoundingClientRect");
                module.exports = getVisibleSelectionRect
            }, {
                "./getRangeBoundingClientRect": 122
            }],
            130: [function(require, module, exports) {
                (function(process) {
                    "use strict";

                    function insertFragmentIntoContentState(e, t, a) {
                        t.isCollapsed() || ("production" !== process.env.NODE_ENV ? invariant(!1, "`insertFragment` should only be called with a collapsed selection state.") : invariant(!1));
                        var r, s, i = t.getStartKey(),
                            n = t.getStartOffset(),
                            c = e.getBlockMap(),
                            o = a.size;
                        if (1 === o) {
                            var g = c.get(i),
                                l = a.first(),
                                f = g.getText(),
                                u = g.getCharacterList(),
                                h = g.merge({
                                    text: f.slice(0, n) + l.getText() + f.slice(n),
                                    characterList: insertIntoList(u, l.getCharacterList(), n),
                                    data: l.getData()
                                });
                            return r = i, s = n + l.getText().length, e.merge({
                                blockMap: c.set(i, h),
                                selectionBefore: t,
                                selectionAfter: t.merge({
                                    anchorKey: r,
                                    anchorOffset: s,
                                    focusKey: r,
                                    focusOffset: s,
                                    isBackward: !1
                                })
                            })
                        }
                        var p = [];
                        return e.getBlockMap().forEach(function(e, t) {
                            if (t === i) {
                                var s = e.getText(),
                                    c = e.getCharacterList(),
                                    g = s.length,
                                    l = s.slice(0, n),
                                    f = c.slice(0, n),
                                    u = a.first(),
                                    h = e.merge({
                                        text: l + u.getText(),
                                        characterList: f.concat(u.getCharacterList()),
                                        type: l ? e.getType() : u.getType(),
                                        data: u.getData()
                                    });
                                p.push(h), a.slice(1, o - 1).forEach(function(e) {
                                    p.push(e.set("key", generateRandomKey()))
                                });
                                var d = s.slice(n, g),
                                    m = c.slice(n, g),
                                    y = a.last();
                                r = generateRandomKey();
                                var v = y.merge({
                                    key: r,
                                    text: y.getText() + d,
                                    characterList: y.getCharacterList().concat(m),
                                    data: y.getData()
                                });
                                p.push(v)
                            } else p.push(e)
                        }), s = a.last().getLength(), e.merge({
                            blockMap: BlockMapBuilder.createFromArray(p),
                            selectionBefore: t,
                            selectionAfter: t.merge({
                                anchorKey: r,
                                anchorOffset: s,
                                focusKey: r,
                                focusOffset: s,
                                isBackward: !1
                            })
                        })
                    }
                    var BlockMapBuilder = require("./BlockMapBuilder"),
                        generateRandomKey = require("./generateRandomKey"),
                        insertIntoList = require("./insertIntoList"),
                        invariant = require("fbjs/lib/invariant");
                    module.exports = insertFragmentIntoContentState
                }).call(this, require("_process"))
            }, {
                "./BlockMapBuilder": 52,
                "./generateRandomKey": 114,
                "./insertIntoList": 131,
                _process: 433,
                "fbjs/lib/invariant": 185
            }],
            131: [function(require, module, exports) {
                "use strict";

                function insertIntoList(t, e, s) {
                    if (s === t.count()) e.forEach(function(e) {
                        t = t.push(e)
                    });
                    else if (0 === s) e.reverse().forEach(function(e) {
                        t = t.unshift(e)
                    });
                    else {
                        var i = t.slice(0, s),
                            n = t.slice(s);
                        t = i.concat(e, n).toList()
                    }
                    return t
                }
                module.exports = insertIntoList
            }, {}],
            132: [function(require, module, exports) {
                (function(process) {
                    "use strict";

                    function insertTextIntoContentState(t, e, r, n) {
                        e.isCollapsed() || ("production" !== process.env.NODE_ENV ? invariant(!1, "`insertText` should only be called with a collapsed range.") : invariant(!1));
                        var i = r.length;
                        if (!i) return t;
                        var a = t.getBlockMap(),
                            s = e.getStartKey(),
                            o = e.getStartOffset(),
                            l = a.get(s),
                            c = l.getText(),
                            u = l.merge({
                                text: c.slice(0, o) + r + c.slice(o, l.getLength()),
                                characterList: insertIntoList(l.getCharacterList(), Repeat(n, i).toList(), o)
                            }),
                            g = o + i;
                        return t.merge({
                            blockMap: a.set(s, u),
                            selectionAfter: e.merge({
                                anchorOffset: g,
                                focusOffset: g
                            })
                        })
                    }
                    var Immutable = require("immutable"),
                        insertIntoList = require("./insertIntoList"),
                        invariant = require("fbjs/lib/invariant"),
                        Repeat = Immutable.Repeat;
                    module.exports = insertTextIntoContentState
                }).call(this, require("_process"))
            }, {
                "./insertIntoList": 131,
                _process: 433,
                "fbjs/lib/invariant": 185,
                immutable: 156
            }],
            133: [function(require, module, exports) {
                "use strict";

                function isEventHandled(e) {
                    return "handled" === e || !0 === e
                }
                module.exports = isEventHandled
            }, {}],
            134: [function(require, module, exports) {
                "use strict";

                function isSelectionAtLeafStart(t) {
                    var e = t.getSelection(),
                        r = e.getAnchorKey(),
                        n = t.getBlockTree(r),
                        o = e.getStartOffset(),
                        s = !1;
                    return n.some(function(t) {
                        return o === t.get("start") ? (s = !0, !0) : o < t.get("end") && t.get("leaves").some(function(t) {
                            var e = t.get("start");
                            return o === e && (s = !0, !0)
                        })
                    }), s
                }
                module.exports = isSelectionAtLeafStart
            }, {}],
            135: [function(require, module, exports) {
                (function(global) {
                    "use strict";

                    function keyCommandBackspaceToStartOfLine(e) {
                        var t = removeTextWithStrategy(e, function(e) {
                            var t = e.getSelection();
                            if (t.isCollapsed() && 0 === t.getAnchorOffset()) return moveSelectionBackward(e, 1);
                            var r = global.getSelection().getRangeAt(0);
                            return r = expandRangeToStartOfLine(r), getDraftEditorSelectionWithNodes(e, null, r.endContainer, r.endOffset, r.startContainer, r.startOffset).selectionState
                        }, "backward");
                        return t === e.getCurrentContent() ? e : EditorState.push(e, t, "remove-range")
                    }
                    var EditorState = require("./EditorState"),
                        expandRangeToStartOfLine = require("./expandRangeToStartOfLine"),
                        getDraftEditorSelectionWithNodes = require("./getDraftEditorSelectionWithNodes"),
                        moveSelectionBackward = require("./moveSelectionBackward"),
                        removeTextWithStrategy = require("./removeTextWithStrategy");
                    module.exports = keyCommandBackspaceToStartOfLine
                }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
            }, {
                "./EditorState": 83,
                "./expandRangeToStartOfLine": 111,
                "./getDraftEditorSelectionWithNodes": 119,
                "./moveSelectionBackward": 147,
                "./removeTextWithStrategy": 151
            }],
            136: [function(require, module, exports) {
                "use strict";

                function keyCommandBackspaceWord(e) {
                    var t = removeTextWithStrategy(e, function(e) {
                        var t = e.getSelection(),
                            r = t.getStartOffset();
                        if (0 === r) return moveSelectionBackward(e, 1);
                        var a = t.getStartKey(),
                            o = e.getCurrentContent().getBlockForKey(a).getText().slice(0, r),
                            n = DraftRemovableWord.getBackward(o);
                        return moveSelectionBackward(e, n.length || 1)
                    }, "backward");
                    return t === e.getCurrentContent() ? e : EditorState.push(e, t, "remove-range")
                }
                var DraftRemovableWord = require("./DraftRemovableWord"),
                    EditorState = require("./EditorState"),
                    moveSelectionBackward = require("./moveSelectionBackward"),
                    removeTextWithStrategy = require("./removeTextWithStrategy");
                module.exports = keyCommandBackspaceWord
            }, {
                "./DraftRemovableWord": 80,
                "./EditorState": 83,
                "./moveSelectionBackward": 147,
                "./removeTextWithStrategy": 151
            }],
            137: [function(require, module, exports) {
                "use strict";

                function keyCommandDeleteWord(e) {
                    var t = removeTextWithStrategy(e, function(e) {
                        var t = e.getSelection(),
                            r = t.getStartOffset(),
                            o = t.getStartKey(),
                            a = e.getCurrentContent().getBlockForKey(o).getText().slice(r),
                            n = DraftRemovableWord.getForward(a);
                        return moveSelectionForward(e, n.length || 1)
                    }, "forward");
                    return t === e.getCurrentContent() ? e : EditorState.push(e, t, "remove-range")
                }
                var DraftRemovableWord = require("./DraftRemovableWord"),
                    EditorState = require("./EditorState"),
                    moveSelectionForward = require("./moveSelectionForward"),
                    removeTextWithStrategy = require("./removeTextWithStrategy");
                module.exports = keyCommandDeleteWord
            }, {
                "./DraftRemovableWord": 80,
                "./EditorState": 83,
                "./moveSelectionForward": 148,
                "./removeTextWithStrategy": 151
            }],
            138: [function(require, module, exports) {
                "use strict";

                function keyCommandInsertNewline(e) {
                    var t = DraftModifier.splitBlock(e.getCurrentContent(), e.getSelection());
                    return EditorState.push(e, t, "split-block")
                }
                var DraftModifier = require("./DraftModifier"),
                    EditorState = require("./EditorState");
                module.exports = keyCommandInsertNewline
            }, {
                "./DraftModifier": 77,
                "./EditorState": 83
            }],
            139: [function(require, module, exports) {
                "use strict";

                function keyCommandMoveSelectionToEndOfBlock(e) {
                    var t = e.getSelection(),
                        o = t.getEndKey(),
                        n = e.getCurrentContent().getBlockForKey(o).getLength();
                    return EditorState.set(e, {
                        selection: t.merge({
                            anchorKey: o,
                            anchorOffset: n,
                            focusKey: o,
                            focusOffset: n,
                            isBackward: !1
                        }),
                        forceSelection: !0
                    })
                }
                var EditorState = require("./EditorState");
                module.exports = keyCommandMoveSelectionToEndOfBlock
            }, {
                "./EditorState": 83
            }],
            140: [function(require, module, exports) {
                "use strict";

                function keyCommandMoveSelectionToStartOfBlock(e) {
                    var t = e.getSelection(),
                        o = t.getStartKey();
                    return EditorState.set(e, {
                        selection: t.merge({
                            anchorKey: o,
                            anchorOffset: 0,
                            focusKey: o,
                            focusOffset: 0,
                            isBackward: !1
                        }),
                        forceSelection: !0
                    })
                }
                var EditorState = require("./EditorState");
                module.exports = keyCommandMoveSelectionToStartOfBlock
            }, {
                "./EditorState": 83
            }],
            141: [function(require, module, exports) {
                "use strict";

                function keyCommandPlainBackspace(e) {
                    var t = removeTextWithStrategy(e, function(e) {
                        var t = e.getSelection(),
                            r = e.getCurrentContent(),
                            o = t.getAnchorKey(),
                            a = t.getAnchorOffset(),
                            i = r.getBlockForKey(o).getText()[a - 1];
                        return moveSelectionBackward(e, i ? UnicodeUtils.getUTF16Length(i, 0) : 1)
                    }, "backward");
                    if (t === e.getCurrentContent()) return e;
                    var r = e.getSelection();
                    return EditorState.push(e, t.set("selectionBefore", r), r.isCollapsed() ? "backspace-character" : "remove-range")
                }
                var EditorState = require("./EditorState"),
                    UnicodeUtils = require("fbjs/lib/UnicodeUtils"),
                    moveSelectionBackward = require("./moveSelectionBackward"),
                    removeTextWithStrategy = require("./removeTextWithStrategy");
                module.exports = keyCommandPlainBackspace
            }, {
                "./EditorState": 83,
                "./moveSelectionBackward": 147,
                "./removeTextWithStrategy": 151,
                "fbjs/lib/UnicodeUtils": 167
            }],
            142: [function(require, module, exports) {
                "use strict";

                function keyCommandPlainDelete(e) {
                    var t = removeTextWithStrategy(e, function(e) {
                        var t = e.getSelection(),
                            r = e.getCurrentContent(),
                            o = t.getAnchorKey(),
                            i = t.getAnchorOffset(),
                            n = r.getBlockForKey(o).getText()[i];
                        return moveSelectionForward(e, n ? UnicodeUtils.getUTF16Length(n, 0) : 1)
                    }, "forward");
                    if (t === e.getCurrentContent()) return e;
                    var r = e.getSelection();
                    return EditorState.push(e, t.set("selectionBefore", r), r.isCollapsed() ? "delete-character" : "remove-range")
                }
                var EditorState = require("./EditorState"),
                    UnicodeUtils = require("fbjs/lib/UnicodeUtils"),
                    moveSelectionForward = require("./moveSelectionForward"),
                    removeTextWithStrategy = require("./removeTextWithStrategy");
                module.exports = keyCommandPlainDelete
            }, {
                "./EditorState": 83,
                "./moveSelectionForward": 148,
                "./removeTextWithStrategy": 151,
                "fbjs/lib/UnicodeUtils": 167
            }],
            143: [function(require, module, exports) {
                "use strict";

                function keyCommandTransposeCharacters(e) {
                    var t = e.getSelection();
                    if (!t.isCollapsed()) return e;
                    var r = t.getAnchorOffset();
                    if (0 === r) return e;
                    var a, n, o = t.getAnchorKey(),
                        f = e.getCurrentContent(),
                        i = f.getBlockForKey(o).getLength();
                    if (i <= 1) return e;
                    r === i ? (a = t.set("anchorOffset", r - 1), n = t) : n = (a = t.set("focusOffset", r + 1)).set("anchorOffset", r + 1);
                    var s = getContentStateFragment(f, a),
                        c = DraftModifier.removeRange(f, a, "backward"),
                        g = c.getSelectionAfter(),
                        u = g.getAnchorOffset() - 1,
                        d = g.merge({
                            anchorOffset: u,
                            focusOffset: u
                        }),
                        m = DraftModifier.replaceWithFragment(c, d, s),
                        h = EditorState.push(e, m, "insert-fragment");
                    return EditorState.acceptSelection(h, n)
                }
                var DraftModifier = require("./DraftModifier"),
                    EditorState = require("./EditorState"),
                    getContentStateFragment = require("./getContentStateFragment");
                module.exports = keyCommandTransposeCharacters
            }, {
                "./DraftModifier": 77,
                "./EditorState": 83,
                "./getContentStateFragment": 116
            }],
            144: [function(require, module, exports) {
                "use strict";

                function keyCommandUndo(e, t, n) {
                    var o = EditorState.undo(t);
                    if ("spellcheck-change" !== t.getLastChangeType()) e.preventDefault(), t.getNativelyRenderedContent() ? (n(EditorState.set(t, {
                        nativelyRenderedContent: null
                    })), setTimeout(function() {
                        n(o)
                    }, 0)) : n(o);
                    else {
                        var r = o.getCurrentContent();
                        n(EditorState.set(o, {
                            nativelyRenderedContent: r
                        }))
                    }
                }
                var EditorState = require("./EditorState");
                module.exports = keyCommandUndo
            }, {
                "./EditorState": 83
            }],
            145: [function(require, module, exports) {
                "use strict";

                function modifyBlockForContentState(e, t, o) {
                    var n = t.getStartKey(),
                        r = t.getEndKey(),
                        a = e.getBlockMap(),
                        i = a.toSeq().skipUntil(function(e, t) {
                            return t === n
                        }).takeUntil(function(e, t) {
                            return t === r
                        }).concat(Map([
                            [r, a.get(r)]
                        ])).map(o);
                    return e.merge({
                        blockMap: a.merge(i),
                        selectionBefore: t,
                        selectionAfter: t
                    })
                }
                var Immutable = require("immutable"),
                    Map = Immutable.Map;
                module.exports = modifyBlockForContentState
            }, {
                immutable: 156
            }],
            146: [function(require, module, exports) {
                (function(process) {
                    "use strict";

                    function moveBlockInContentState(e, t, n, o) {
                        t.getKey() === n.getKey() && ("production" !== process.env.NODE_ENV ? invariant(!1, "Block cannot be moved next to itself.") : invariant(!1)), "replace" === o && ("production" !== process.env.NODE_ENV ? invariant(!1, "Replacing blocks is not supported.") : invariant(!1));
                        var r = n.getKey(),
                            i = e.getBlockBefore(r),
                            a = e.getBlockAfter(r),
                            c = e.getBlockMap().delete(t.getKey()),
                            l = c.toSeq().takeUntil(function(e) {
                                return e === n
                            }),
                            s = c.toSeq().skipUntil(function(e) {
                                return e === n
                            }).skip(1),
                            g = void 0;
                        return "before" === o ? (i && i.getKey() === t.getKey() && ("production" !== process.env.NODE_ENV ? invariant(!1, "Block cannot be moved next to itself.") : invariant(!1)), g = l.concat([
                            [t.getKey(), t],
                            [n.getKey(), n]
                        ], s).toOrderedMap()) : "after" === o && (a && a.getKey() === t.getKey() && ("production" !== process.env.NODE_ENV ? invariant(!1, "Block cannot be moved next to itself.") : invariant(!1)), g = l.concat([
                            [n.getKey(), n],
                            [t.getKey(), t]
                        ], s).toOrderedMap()), e.merge({
                            blockMap: g,
                            selectionBefore: e.getSelectionAfter(),
                            selectionAfter: e.getSelectionAfter().merge({
                                anchorKey: t.getKey(),
                                focusKey: t.getKey()
                            })
                        })
                    }
                    var invariant = require("fbjs/lib/invariant");
                    module.exports = moveBlockInContentState
                }).call(this, require("_process"))
            }, {
                _process: 433,
                "fbjs/lib/invariant": 185
            }],
            147: [function(require, module, exports) {
                "use strict";

                function moveSelectionBackward(e, t) {
                    var r = e.getSelection(),
                        o = e.getCurrentContent(),
                        c = r.getStartKey(),
                        n = r.getStartOffset(),
                        a = c,
                        f = 0;
                    if (t > n) {
                        var l = o.getKeyBefore(c);
                        null == l ? a = c : (a = l, f = o.getBlockForKey(l).getText().length)
                    } else f = n - t;
                    return r.merge({
                        focusKey: a,
                        focusOffset: f,
                        isBackward: !0
                    })
                }
                module.exports = moveSelectionBackward
            }, {}],
            148: [function(require, module, exports) {
                "use strict";

                function moveSelectionForward(e, t) {
                    var r, o = e.getSelection(),
                        n = o.getStartKey(),
                        g = o.getStartOffset(),
                        c = e.getCurrentContent(),
                        f = n;
                    return t > c.getBlockForKey(n).getText().length - g ? (f = c.getKeyAfter(n), r = 0) : r = g + t, o.merge({
                        focusKey: f,
                        focusOffset: r
                    })
                }
                module.exports = moveSelectionForward
            }, {}],
            149: [function(require, module, exports) {
                (function(process) {
                    "use strict";

                    function removeEntitiesAtEdges(t, e) {
                        var r = t.getBlockMap(),
                            a = t.getEntityMap(),
                            n = {},
                            i = e.getStartKey(),
                            o = e.getStartOffset(),
                            g = r.get(i),
                            s = removeForBlock(a, g, o);
                        s !== g && (n[i] = s);
                        var c = e.getEndKey(),
                            u = e.getEndOffset(),
                            v = r.get(c);
                        i === c && (v = s);
                        var l = removeForBlock(a, v, u);
                        return l !== v && (n[c] = l), Object.keys(n).length ? t.merge({
                            blockMap: r.merge(n),
                            selectionAfter: e
                        }) : t.set("selectionAfter", e)
                    }

                    function getRemovalRange(t, e, r) {
                        var a;
                        return findRangesImmutable(t, function(t, e) {
                            return t.getEntity() === e.getEntity()
                        }, function(t) {
                            return t.getEntity() === e
                        }, function(t, e) {
                            t <= r && e >= r && (a = {
                                start: t,
                                end: e
                            })
                        }), "object" != _typeof2(a) && ("production" !== process.env.NODE_ENV ? invariant(!1, "Removal range must exist within character list.") : invariant(!1)), a
                    }

                    function removeForBlock(t, e, r) {
                        var a = e.getCharacterList(),
                            n = r > 0 ? a.get(r - 1) : void 0,
                            i = r < a.count() ? a.get(r) : void 0,
                            o = n ? n.getEntity() : void 0,
                            g = i ? i.getEntity() : void 0;
                        if (g && g === o && "MUTABLE" !== t.__get(g).getMutability()) {
                            for (var s, c = getRemovalRange(a, g, r), u = c.start, v = c.end; u < v;) s = a.get(u), a = a.set(u, CharacterMetadata.applyEntity(s, null)), u++;
                            return e.set("characterList", a)
                        }
                        return e
                    }
                    var CharacterMetadata = require("./CharacterMetadata"),
                        findRangesImmutable = require("./findRangesImmutable"),
                        invariant = require("fbjs/lib/invariant");
                    module.exports = removeEntitiesAtEdges
                }).call(this, require("_process"))
            }, {
                "./CharacterMetadata": 54,
                "./findRangesImmutable": 113,
                _process: 433,
                "fbjs/lib/invariant": 185
            }],
            150: [function(require, module, exports) {
                "use strict";

                function removeRangeFromContentState(e, t) {
                    if (t.isCollapsed()) return e;
                    var r, n = e.getBlockMap(),
                        o = t.getStartKey(),
                        a = t.getStartOffset(),
                        c = t.getEndKey(),
                        i = t.getEndOffset(),
                        s = n.get(o),
                        f = n.get(c);
                    r = s === f ? removeFromList(s.getCharacterList(), a, i) : s.getCharacterList().slice(0, a).concat(f.getCharacterList().slice(i));
                    var l = s.merge({
                            text: s.getText().slice(0, a) + f.getText().slice(i),
                            characterList: r
                        }),
                        u = n.toSeq().skipUntil(function(e, t) {
                            return t === o
                        }).takeUntil(function(e, t) {
                            return t === c
                        }).concat(Immutable.Map([
                            [c, null]
                        ])).map(function(e, t) {
                            return t === o ? l : null
                        });
                    return n = n.merge(u).filter(function(e) {
                        return !!e
                    }), e.merge({
                        blockMap: n,
                        selectionBefore: t,
                        selectionAfter: t.merge({
                            anchorKey: o,
                            anchorOffset: a,
                            focusKey: o,
                            focusOffset: a,
                            isBackward: !1
                        })
                    })
                }

                function removeFromList(e, t, r) {
                    if (0 === t)
                        for (; t < r;) e = e.shift(), t++;
                    else if (r === e.count())
                        for (; r > t;) e = e.pop(), r--;
                    else {
                        var n = e.slice(0, t),
                            o = e.slice(r);
                        e = n.concat(o).toList()
                    }
                    return e
                }
                var Immutable = require("immutable");
                module.exports = removeRangeFromContentState
            }, {
                immutable: 156
            }],
            151: [function(require, module, exports) {
                "use strict";

                function removeTextWithStrategy(e, t, r) {
                    var i = e.getSelection(),
                        n = e.getCurrentContent(),
                        o = i;
                    if (i.isCollapsed()) {
                        if ("forward" === r) {
                            if (e.isSelectionAtEndOfContent()) return n
                        } else if (e.isSelectionAtStartOfContent()) return n;
                        if ((o = t(e)) === i) return n
                    }
                    return DraftModifier.removeRange(n, o, r)
                }
                var DraftModifier = require("./DraftModifier");
                module.exports = removeTextWithStrategy
            }, {
                "./DraftModifier": 77
            }],
            152: [function(require, module, exports) {
                "use strict";

                function sanitizeDraftText(e) {
                    return e.replace(REGEX_BLOCK_DELIMITER, "")
                }
                var REGEX_BLOCK_DELIMITER = new RegExp("\r", "g");
                module.exports = sanitizeDraftText
            }, {}],
            153: [function(require, module, exports) {
                (function(process, global) {
                    "use strict";

                    function getAnonymizedDOM(e, t) {
                        if (!e) return "[empty]";
                        var n = anonymizeTextWithin(e, t);
                        return n.nodeType === Node.TEXT_NODE ? n.textContent : (n instanceof Element || ("production" !== process.env.NODE_ENV ? invariant(!1, "Node must be an Element if it is not a text node.") : invariant(!1)), n.outerHTML)
                    }

                    function anonymizeTextWithin(e, t) {
                        var n = void 0 !== t ? t(e) : [];
                        if (e.nodeType === Node.TEXT_NODE) {
                            var o = e.textContent.length;
                            return document.createTextNode("[text " + o + (n.length ? " | " + n.join(", ") : "") + "]")
                        }
                        var i = e.cloneNode();
                        1 === i.nodeType && n.length && i.setAttribute("data-labels", n.join(", "));
                        for (var a = e.childNodes, r = 0; r < a.length; r++) i.appendChild(anonymizeTextWithin(a[r], t));
                        return i
                    }

                    function getAnonymizedEditorDOM(e, t) {
                        for (var n = e; n;) {
                            if (n instanceof Element && n.hasAttribute("contenteditable")) return getAnonymizedDOM(n, t);
                            n = n.parentNode
                        }
                        return "Could not find contentEditable parent of node"
                    }

                    function getNodeLength(e) {
                        return null === e.nodeValue ? e.childNodes.length : e.nodeValue.length
                    }

                    function setDraftEditorSelection(e, t, n, o, i) {
                        if (containsNode(document.documentElement, t)) {
                            var a = global.getSelection(),
                                r = e.getAnchorKey(),
                                d = e.getAnchorOffset(),
                                s = e.getFocusKey(),
                                c = e.getFocusOffset(),
                                l = e.getIsBackward();
                            if (!a.extend && l) {
                                var u = r,
                                    g = d;
                                r = s, d = c, s = u, c = g, l = !1
                            }
                            var f = r === n && o <= d && i >= d,
                                m = s === n && o <= c && i >= c;
                            if (f && m) return a.removeAllRanges(), addPointToSelection(a, t, d - o, e), void addFocusToSelection(a, t, c - o, e);
                            if (l) {
                                if (m && (a.removeAllRanges(), addPointToSelection(a, t, c - o, e)), f) {
                                    var N = a.focusNode,
                                        v = a.focusOffset;
                                    a.removeAllRanges(), addPointToSelection(a, t, d - o, e), addFocusToSelection(a, N, v, e)
                                }
                            } else f && (a.removeAllRanges(), addPointToSelection(a, t, d - o, e)), m && addFocusToSelection(a, t, c - o, e)
                        }
                    }

                    function addFocusToSelection(e, t, n, o) {
                        var i = getActiveElement();
                        if (e.extend && containsNode(i, t)) {
                            n > getNodeLength(t) && DraftJsDebugLogging.logSelectionStateFailure({
                                anonymizedDom: getAnonymizedEditorDOM(t),
                                extraParams: JSON.stringify({
                                    offset: n
                                }),
                                selectionState: JSON.stringify(o.toJS())
                            });
                            var a = t === e.focusNode;
                            try {
                                e.extend(t, n)
                            } catch (r) {
                                throw DraftJsDebugLogging.logSelectionStateFailure({
                                    anonymizedDom: getAnonymizedEditorDOM(t, function(t) {
                                        var n = [];
                                        return t === i && n.push("active element"), t === e.anchorNode && n.push("selection anchor node"), t === e.focusNode && n.push("selection focus node"), n
                                    }),
                                    extraParams: JSON.stringify({
                                        activeElementName: i ? i.nodeName : null,
                                        nodeIsFocus: t === e.focusNode,
                                        nodeWasFocus: a,
                                        selectionRangeCount: e.rangeCount,
                                        selectionAnchorNodeName: e.anchorNode ? e.anchorNode.nodeName : null,
                                        selectionAnchorOffset: e.anchorOffset,
                                        selectionFocusNodeName: e.focusNode ? e.focusNode.nodeName : null,
                                        selectionFocusOffset: e.focusOffset,
                                        message: r ? "" + r : null,
                                        offset: n
                                    }, null, 2),
                                    selectionState: JSON.stringify(o.toJS(), null, 2)
                                }), r
                            }
                        } else {
                            var r = e.getRangeAt(0);
                            r.setEnd(t, n), e.addRange(r.cloneRange())
                        }
                    }

                    function addPointToSelection(e, t, n, o) {
                        var i = document.createRange();
                        n > getNodeLength(t) && DraftJsDebugLogging.logSelectionStateFailure({
                            anonymizedDom: getAnonymizedEditorDOM(t),
                            extraParams: JSON.stringify({
                                offset: n
                            }),
                            selectionState: JSON.stringify(o.toJS())
                        }), i.setStart(t, n), e.addRange(i)
                    }
                    var DraftJsDebugLogging = require("./DraftJsDebugLogging"),
                        containsNode = require("fbjs/lib/containsNode"),
                        getActiveElement = require("fbjs/lib/getActiveElement"),
                        invariant = require("fbjs/lib/invariant");
                    module.exports = setDraftEditorSelection
                }).call(this, require("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
            }, {
                "./DraftJsDebugLogging": 76,
                _process: 433,
                "fbjs/lib/containsNode": 172,
                "fbjs/lib/getActiveElement": 176,
                "fbjs/lib/invariant": 185
            }],
            154: [function(require, module, exports) {
                (function(process) {
                    "use strict";

                    function splitBlockInContentState(e, t) {
                        t.isCollapsed() || ("production" !== process.env.NODE_ENV ? invariant(!1, "Selection range must be collapsed.") : invariant(!1));
                        var r = t.getAnchorKey(),
                            a = t.getAnchorOffset(),
                            n = e.getBlockMap(),
                            i = n.get(r),
                            o = i.getText(),
                            c = i.getCharacterList(),
                            s = i.merge({
                                text: o.slice(0, a),
                                characterList: c.slice(0, a)
                            }),
                            l = generateRandomKey(),
                            u = s.merge({
                                key: l,
                                text: o.slice(a),
                                characterList: c.slice(a),
                                data: Map()
                            }),
                            g = n.toSeq().takeUntil(function(e) {
                                return e === i
                            }),
                            m = n.toSeq().skipUntil(function(e) {
                                return e === i
                            }).rest(),
                            f = g.concat([
                                [s.getKey(), s],
                                [u.getKey(), u]
                            ], m).toOrderedMap();
                        return e.merge({
                            blockMap: f,
                            selectionBefore: t,
                            selectionAfter: t.merge({
                                anchorKey: l,
                                anchorOffset: 0,
                                focusKey: l,
                                focusOffset: 0,
                                isBackward: !1
                            })
                        })
                    }
                    var Immutable = require("immutable"),
                        generateRandomKey = require("./generateRandomKey"),
                        invariant = require("fbjs/lib/invariant"),
                        Map = Immutable.Map;
                    module.exports = splitBlockInContentState
                }).call(this, require("_process"))
            }, {
                "./generateRandomKey": 114,
                _process: 433,
                "fbjs/lib/invariant": 185,
                immutable: 156
            }],
            155: [function(require, module, exports) {
                "use strict";

                function splitTextIntoTextBlocks(t) {
                    return t.split(NEWLINE_REGEX)
                }
                var NEWLINE_REGEX = /\r\n?|\n/g;
                module.exports = splitTextIntoTextBlocks
            }, {}],
            156: [function(require, module, exports) {
                ! function(t, e) {
                    "object" == _typeof2(exports) && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : t.Immutable = e()
                }(this, function() {
                    "use strict";

                    function e(t, e) {
                        e && (t.prototype = Object.create(e.prototype)), t.prototype.constructor = t
                    }

                    function r(t) {
                        return u(t) ? t : V(t)
                    }

                    function n(t) {
                        return s(t) ? t : Y(t)
                    }

                    function i(t) {
                        return a(t) ? t : Q(t)
                    }

                    function o(t) {
                        return u(t) && !h(t) ? t : X(t)
                    }

                    function u(t) {
                        return !(!t || !t[c])
                    }

                    function s(t) {
                        return !(!t || !t[_])
                    }

                    function a(t) {
                        return !(!t || !t[p])
                    }

                    function h(t) {
                        return s(t) || a(t)
                    }

                    function f(t) {
                        return !(!t || !t[l])
                    }

                    function S(t) {
                        return t.value = !1, t
                    }

                    function z(t) {
                        t && (t.value = !0)
                    }

                    function I() {}

                    function b(t, e) {
                        e = e || 0;
                        for (var r = Math.max(0, t.length - e), n = new Array(r), i = 0; i < r; i++) n[i] = t[i + e];
                        return n
                    }

                    function q(t) {
                        return void 0 === t.size && (t.size = t.__iterate(M)), t.size
                    }

                    function D(t, e) {
                        if ("number" != typeof e) {
                            var r = e >>> 0;
                            if ("" + r !== e || 4294967295 === r) return NaN;
                            e = r
                        }
                        return e < 0 ? q(t) + e : e
                    }

                    function M() {
                        return !0
                    }

                    function E(t, e, r) {
                        return (0 === t || void 0 !== r && t <= -r) && (void 0 === e || void 0 !== r && e >= r)
                    }

                    function O(t, e) {
                        return k(t, e, 0)
                    }

                    function x(t, e) {
                        return k(t, e, e)
                    }

                    function k(t, e, r) {
                        return void 0 === t ? r : t < 0 ? Math.max(0, e + t) : void 0 === e ? t : Math.min(e, t)
                    }

                    function T(t) {
                        this.next = t
                    }

                    function W(t, e, r, n) {
                        var i = 0 === t ? e : 1 === t ? r : [e, r];
                        return n ? n.value = i : n = {
                            value: i,
                            done: !1
                        }, n
                    }

                    function B() {
                        return {
                            value: void 0,
                            done: !0
                        }
                    }

                    function C(t) {
                        return !!P(t)
                    }

                    function J(t) {
                        return t && "function" == typeof t.next
                    }

                    function N(t) {
                        var e = P(t);
                        return e && e.call(t)
                    }

                    function P(t) {
                        var e = t && (R && t[R] || t[U]);
                        if ("function" == typeof e) return e
                    }

                    function H(t) {
                        return t && "number" == typeof t.length
                    }

                    function V(t) {
                        return null == t ? ot() : u(t) ? t.toSeq() : function(t) {
                            var e = at(t) || "object" == _typeof2(t) && new et(t);
                            if (!e) throw new TypeError("Expected Array or iterable object of values, or keyed object: " + t);
                            return e
                        }(t)
                    }

                    function Y(t) {
                        return null == t ? ot().toKeyedSeq() : u(t) ? s(t) ? t.toSeq() : t.fromEntrySeq() : ut(t)
                    }

                    function Q(t) {
                        return null == t ? ot() : u(t) ? s(t) ? t.entrySeq() : t.toIndexedSeq() : st(t)
                    }

                    function X(t) {
                        return (null == t ? ot() : u(t) ? s(t) ? t.entrySeq() : t : st(t)).toSetSeq()
                    }

                    function tt(t) {
                        this._array = t, this.size = t.length
                    }

                    function et(t) {
                        var e = Object.keys(t);
                        this._object = t, this._keys = e, this.size = e.length
                    }

                    function rt(t) {
                        this._iterable = t, this.size = t.length || t.size
                    }

                    function nt(t) {
                        this._iterator = t, this._iteratorCache = []
                    }

                    function it(t) {
                        return !(!t || !t[$])
                    }

                    function ot() {
                        return F || (F = new tt([]))
                    }

                    function ut(t) {
                        var e = Array.isArray(t) ? new tt(t).fromEntrySeq() : J(t) ? new nt(t).fromEntrySeq() : C(t) ? new rt(t).fromEntrySeq() : "object" == _typeof2(t) ? new et(t) : void 0;
                        if (!e) throw new TypeError("Expected Array or iterable object of [k, v] entries, or keyed object: " + t);
                        return e
                    }

                    function st(t) {
                        var e = at(t);
                        if (!e) throw new TypeError("Expected Array or iterable object of values: " + t);
                        return e
                    }

                    function at(t) {
                        return H(t) ? new tt(t) : J(t) ? new nt(t) : C(t) ? new rt(t) : void 0
                    }

                    function ht(t, e, r, n) {
                        var i = t._cache;
                        if (i) {
                            for (var o = i.length - 1, u = 0; u <= o; u++) {
                                var s = i[r ? o - u : u];
                                if (!1 === e(s[1], n ? s[0] : u, t)) return u + 1
                            }
                            return u
                        }
                        return t.__iterateUncached(e, r)
                    }

                    function ft(t, e, r, n) {
                        var i = t._cache;
                        if (i) {
                            var o = i.length - 1,
                                u = 0;
                            return new T(function() {
                                var t = i[r ? o - u : u];
                                return u++ > o ? {
                                    value: void 0,
                                    done: !0
                                } : W(e, n ? t[0] : u - 1, t[1])
                            })
                        }
                        return t.__iteratorUncached(e, r)
                    }

                    function ct(t, e) {
                        return e ? function t(e, r, n, i) {
                            return Array.isArray(r) ? e.call(i, n, Q(r).map(function(n, i) {
                                return t(e, n, i, r)
                            })) : pt(r) ? e.call(i, n, Y(r).map(function(n, i) {
                                return t(e, n, i, r)
                            })) : r
                        }(e, t, "", {
                            "": t
                        }) : _t(t)
                    }

                    function _t(t) {
                        return Array.isArray(t) ? Q(t).map(_t).toList() : pt(t) ? Y(t).map(_t).toMap() : t
                    }

                    function pt(t) {
                        return t && (t.constructor === Object || void 0 === t.constructor)
                    }

                    function lt(t, e) {
                        if (t === e || t != t && e != e) return !0;
                        if (!t || !e) return !1;
                        if ("function" == typeof t.valueOf && "function" == typeof e.valueOf) {
                            if ((t = t.valueOf()) === (e = e.valueOf()) || t != t && e != e) return !0;
                            if (!t || !e) return !1
                        }
                        return !("function" != typeof t.equals || "function" != typeof e.equals || !t.equals(e))
                    }

                    function vt(t, e) {
                        if (t === e) return !0;
                        if (!u(e) || void 0 !== t.size && void 0 !== e.size && t.size !== e.size || void 0 !== t.__hash && void 0 !== e.__hash && t.__hash !== e.__hash || s(t) !== s(e) || a(t) !== a(e) || f(t) !== f(e)) return !1;
                        if (0 === t.size && 0 === e.size) return !0;
                        var r = !h(t);
                        if (f(t)) {
                            var n = t.entries();
                            return e.every(function(t, e) {
                                var i = n.next().value;
                                return i && lt(i[1], t) && (r || lt(i[0], e))
                            }) && n.next().done
                        }
                        var i = !1;
                        if (void 0 === t.size)
                            if (void 0 === e.size) "function" == typeof t.cacheResult && t.cacheResult();
                            else {
                                i = !0;
                                var o = t;
                                t = e, e = o
                            } var c = !0,
                            _ = e.__iterate(function(e, n) {
                                if (r ? !t.has(e) : i ? !lt(e, t.get(n, m)) : !lt(t.get(n, m), e)) return c = !1, !1
                            });
                        return c && t.size === _
                    }

                    function yt(t, e) {
                        if (!(this instanceof yt)) return new yt(t, e);
                        if (this._value = t, this.size = void 0 === e ? 1 / 0 : Math.max(0, e), 0 === this.size) {
                            if (G) return G;
                            G = this
                        }
                    }

                    function dt(t, e) {
                        if (!t) throw new Error(e)
                    }

                    function mt(t, e, r) {
                        if (!(this instanceof mt)) return new mt(t, e, r);
                        if (dt(0 !== r, "Cannot step a Range by 0"), t = t || 0, void 0 === e && (e = 1 / 0), r = void 0 === r ? 1 : Math.abs(r), e < t && (r = -r), this._start = t, this._end = e, this._step = r, this.size = Math.max(0, Math.ceil((e - t) / r - 1) + 1), 0 === this.size) {
                            if (Z) return Z;
                            Z = this
                        }
                    }

                    function gt() {
                        throw TypeError("Abstract")
                    }

                    function wt() {}

                    function St() {}

                    function zt() {}

                    function bt(t) {
                        return t >>> 1 & 1073741824 | 3221225471 & t
                    }

                    function qt(t) {
                        if (!1 === t || null == t) return 0;
                        if ("function" == typeof t.valueOf && (!1 === (t = t.valueOf()) || null == t)) return 0;
                        if (!0 === t) return 1;
                        var e = _typeof2(t);
                        if ("number" === e) {
                            var r = 0 | t;
                            for (r !== t && (r ^= 4294967295 * t); t > 4294967295;) r ^= t /= 4294967295;
                            return bt(r)
                        }
                        if ("string" === e) return t.length > jt ? function(t) {
                            var e = Ut[t];
                            return void 0 === e && (e = Dt(t), Rt === Kt && (Rt = 0, Ut = {}), Rt++, Ut[t] = e), e
                        }(t) : Dt(t);
                        if ("function" == typeof t.hashCode) return t.hashCode();
                        if ("object" === e) return function(t) {
                            var e;
                            if (xt && void 0 !== (e = Ot.get(t))) return e;
                            if (void 0 !== (e = t[At])) return e;
                            if (!Et) {
                                if (void 0 !== (e = t.propertyIsEnumerable && t.propertyIsEnumerable[At])) return e;
                                if (void 0 !== (e = function(t) {
                                        if (t && t.nodeType > 0) switch (t.nodeType) {
                                            case 1:
                                                return t.uniqueID;
                                            case 9:
                                                return t.documentElement && t.documentElement.uniqueID
                                        }
                                    }(t))) return e
                            }
                            if (e = ++kt, 1073741824 & kt && (kt = 0), xt) Ot.set(t, e);
                            else {
                                if (void 0 !== Mt && !1 === Mt(t)) throw new Error("Non-extensible objects are not allowed as keys.");
                                if (Et) Object.defineProperty(t, At, {
                                    enumerable: !1,
                                    configurable: !1,
                                    writable: !1,
                                    value: e
                                });
                                else if (void 0 !== t.propertyIsEnumerable && t.propertyIsEnumerable === t.constructor.prototype.propertyIsEnumerable) t.propertyIsEnumerable = function() {
                                    return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments)
                                }, t.propertyIsEnumerable[At] = e;
                                else {
                                    if (void 0 === t.nodeType) throw new Error("Unable to set a non-enumerable property on object.");
                                    t[At] = e
                                }
                            }
                            return e
                        }(t);
                        if ("function" == typeof t.toString) return Dt(t.toString());
                        throw new Error("Value type " + e + " cannot be hashed.")
                    }

                    function Dt(t) {
                        for (var e = 0, r = 0; r < t.length; r++) e = 31 * e + t.charCodeAt(r) | 0;
                        return bt(e)
                    }

                    function Lt(t) {
                        dt(t !== 1 / 0, "Cannot perform this action with an infinite size.")
                    }

                    function Tt(t) {
                        return null == t ? Zt() : Wt(t) && !f(t) ? t : Zt().withMutations(function(e) {
                            var r = n(t);
                            Lt(r.size), r.forEach(function(t, r) {
                                return e.set(r, t)
                            })
                        })
                    }

                    function Wt(t) {
                        return !(!t || !t[Ct])
                    }

                    function Nt(t, e) {
                        this.ownerID = t, this.entries = e
                    }

                    function Pt(t, e, r) {
                        this.ownerID = t, this.bitmap = e, this.nodes = r
                    }

                    function Ht(t, e, r) {
                        this.ownerID = t, this.count = e, this.nodes = r
                    }

                    function Vt(t, e, r) {
                        this.ownerID = t, this.keyHash = e, this.entries = r
                    }

                    function Yt(t, e, r) {
                        this.ownerID = t, this.keyHash = e, this.entry = r
                    }

                    function Qt(t, e, r) {
                        this._type = e, this._reverse = r, this._stack = t._root && Ft(t._root)
                    }

                    function Xt(t, e) {
                        return W(t, e[0], e[1])
                    }

                    function Ft(t, e) {
                        return {
                            node: t,
                            index: 0,
                            __prev: e
                        }
                    }

                    function Gt(t, e, r, n) {
                        var i = Object.create(Jt);
                        return i.size = t, i._root = e, i.__ownerID = r, i.__hash = n, i.__altered = !1, i
                    }

                    function Zt() {
                        return Bt || (Bt = Gt(0))
                    }

                    function $t(t, e, r) {
                        var n, i;
                        if (t._root) {
                            var o = S(g),
                                u = S(w);
                            if (n = te(t._root, t.__ownerID, 0, void 0, e, r, o, u), !u.value) return t;
                            i = t.size + (o.value ? r === m ? -1 : 1 : 0)
                        } else {
                            if (r === m) return t;
                            i = 1, n = new Nt(t.__ownerID, [
                                [e, r]
                            ])
                        }
                        return t.__ownerID ? (t.size = i, t._root = n, t.__hash = void 0, t.__altered = !0, t) : n ? Gt(i, n) : Zt()
                    }

                    function te(t, e, r, n, i, o, u, s) {
                        return t ? t.update(e, r, n, i, o, u, s) : o === m ? t : (z(s), z(u), new Yt(e, n, [i, o]))
                    }

                    function ee(t) {
                        return t.constructor === Yt || t.constructor === Vt
                    }

                    function re(t, e, r, n, i) {
                        if (t.keyHash === n) return new Vt(e, n, [t.entry, i]);
                        var o, u = (0 === r ? t.keyHash : t.keyHash >>> r) & d,
                            s = (0 === r ? n : n >>> r) & d;
                        return new Pt(e, 1 << u | 1 << s, u === s ? [re(t, e, r + v, n, i)] : (o = new Yt(e, n, i), u < s ? [t, o] : [o, t]))
                    }

                    function ne(t, e, r) {
                        for (var i = [], o = 0; o < r.length; o++) {
                            var s = r[o],
                                a = n(s);
                            u(s) || (a = a.map(function(t) {
                                return ct(t)
                            })), i.push(a)
                        }
                        return ue(t, e, i)
                    }

                    function ie(t, e, r) {
                        return t && t.mergeDeep && u(e) ? t.mergeDeep(e) : lt(t, e) ? t : e
                    }

                    function oe(t) {
                        return function(e, r, n) {
                            if (e && e.mergeDeepWith && u(r)) return e.mergeDeepWith(t, r);
                            var i = t(e, r, n);
                            return lt(e, i) ? e : i
                        }
                    }

                    function ue(t, e, r) {
                        return 0 === (r = r.filter(function(t) {
                            return 0 !== t.size
                        })).length ? t : 0 !== t.size || t.__ownerID || 1 !== r.length ? t.withMutations(function(t) {
                            for (var n = e ? function(r, n) {
                                    t.update(n, m, function(t) {
                                        return t === m ? r : e(t, r, n)
                                    })
                                } : function(e, r) {
                                    t.set(r, e)
                                }, i = 0; i < r.length; i++) r[i].forEach(n)
                        }) : t.constructor(r[0])
                    }

                    function se(t) {
                        return t = (t = (858993459 & (t -= t >> 1 & 1431655765)) + (t >> 2 & 858993459)) + (t >> 4) & 252645135, t += t >> 8, 127 & (t += t >> 16)
                    }

                    function ae(t, e, r, n) {
                        var i = n ? t : b(t);
                        return i[e] = r, i
                    }

                    function _e(t) {
                        var e = ze();
                        if (null == t) return e;
                        if (pe(t)) return t;
                        var r = i(t),
                            n = r.size;
                        return 0 === n ? e : (Lt(n), n > 0 && n < y ? Se(0, n, v, null, new ye(r.toArray())) : e.withMutations(function(t) {
                            t.setSize(n), r.forEach(function(e, r) {
                                return t.set(r, e)
                            })
                        }))
                    }

                    function pe(t) {
                        return !(!t || !t[le])
                    }

                    function ye(t, e) {
                        this.array = t, this.ownerID = e
                    }

                    function we(t, e) {
                        function u(t, s, a) {
                            return 0 === s ? function(t, u) {
                                var s = u === i ? o && o.array : t && t.array,
                                    a = u > r ? 0 : r - u,
                                    h = n - u;
                                return h > y && (h = y),
                                    function() {
                                        if (a === h) return ge;
                                        var t = e ? --h : a++;
                                        return s && s[t]
                                    }
                            }(t, a) : function(t, i, o) {
                                var s, a = t && t.array,
                                    h = o > r ? 0 : r - o >> i,
                                    f = 1 + (n - o >> i);
                                return f > y && (f = y),
                                    function() {
                                        for (;;) {
                                            if (s) {
                                                var t = s();
                                                if (t !== ge) return t;
                                                s = null
                                            }
                                            if (h === f) return ge;
                                            var r = e ? --f : h++;
                                            s = u(a && a[r], i - v, o + (r << i))
                                        }
                                    }
                            }(t, s, a)
                        }
                        var r = t._origin,
                            n = t._capacity,
                            i = Ee(n),
                            o = t._tail;
                        return u(t._root, t._level, 0)
                    }

                    function Se(t, e, r, n, i, o, u) {
                        var s = Object.create(ve);
                        return s.size = e - t, s._origin = t, s._capacity = e, s._level = r, s._root = n, s._tail = i, s.__ownerID = o, s.__hash = u, s.__altered = !1, s
                    }

                    function ze() {
                        return de || (de = Se(0, 0, v))
                    }

                    function Ie(t, e, r, n, i, o) {
                        var u, s = n >>> r & d,
                            a = t && s < t.array.length;
                        if (!a && void 0 === i) return t;
                        if (r > 0) {
                            var h = t && t.array[s],
                                f = Ie(h, e, r - v, n, i, o);
                            return f === h ? t : ((u = be(t, e)).array[s] = f, u)
                        }
                        return a && t.array[s] === i ? t : (z(o), u = be(t, e), void 0 === i && s === u.array.length - 1 ? u.array.pop() : u.array[s] = i, u)
                    }

                    function be(t, e) {
                        return e && t && e === t.ownerID ? t : new ye(t ? t.array.slice() : [], e)
                    }

                    function qe(t, e) {
                        if (e >= Ee(t._capacity)) return t._tail;
                        if (e < 1 << t._level + v) {
                            for (var r = t._root, n = t._level; r && n > 0;) r = r.array[e >>> n & d], n -= v;
                            return r
                        }
                    }

                    function De(t, e, r) {
                        void 0 !== e && (e |= 0), void 0 !== r && (r |= 0);
                        var n = t.__ownerID || new I,
                            i = t._origin,
                            o = t._capacity,
                            u = i + e,
                            s = void 0 === r ? o : r < 0 ? o + r : i + r;
                        if (u === i && s === o) return t;
                        if (u >= s) return t.clear();
                        for (var a = t._level, h = t._root, f = 0; u + f < 0;) h = new ye(h && h.array.length ? [void 0, h] : [], n), f += 1 << (a += v);
                        f && (u += f, i += f, s += f, o += f);
                        for (var c = Ee(o), _ = Ee(s); _ >= 1 << a + v;) h = new ye(h && h.array.length ? [h] : [], n), a += v;
                        var p = t._tail,
                            l = _ < c ? qe(t, s - 1) : _ > c ? new ye([], n) : p;
                        if (p && _ > c && u < o && p.array.length) {
                            for (var y = h = be(h, n), m = a; m > v; m -= v) {
                                var g = c >>> m & d;
                                y = y.array[g] = be(y.array[g], n)
                            }
                            y.array[c >>> v & d] = p
                        }
                        if (s < o && (l = l && l.removeAfter(n, 0, s)), u >= _) u -= _, s -= _, a = v, h = null, l = l && l.removeBefore(n, 0, u);
                        else if (u > i || _ < c) {
                            for (f = 0; h;) {
                                var w = u >>> a & d;
                                if (w !== _ >>> a & d) break;
                                w && (f += (1 << a) * w), a -= v, h = h.array[w]
                            }
                            h && u > i && (h = h.removeBefore(n, a, u - f)), h && _ < c && (h = h.removeAfter(n, a, _ - f)), f && (u -= f, s -= f)
                        }
                        return t.__ownerID ? (t.size = s - u, t._origin = u, t._capacity = s, t._level = a, t._root = h, t._tail = l, t.__hash = void 0, t.__altered = !0, t) : Se(u, s, a, h, l)
                    }

                    function Me(t, e, r) {
                        for (var n = [], o = 0, s = 0; s < r.length; s++) {
                            var a = r[s],
                                h = i(a);
                            h.size > o && (o = h.size), u(a) || (h = h.map(function(t) {
                                return ct(t)
                            })), n.push(h)
                        }
                        return o > t.size && (t = t.setSize(o)), ue(t, e, n)
                    }

                    function Ee(t) {
                        return t < y ? 0 : t - 1 >>> v << v
                    }

                    function Oe(t) {
                        return null == t ? Ae() : xe(t) ? t : Ae().withMutations(function(e) {
                            var r = n(t);
                            Lt(r.size), r.forEach(function(t, r) {
                                return e.set(r, t)
                            })
                        })
                    }

                    function xe(t) {
                        return Wt(t) && f(t)
                    }

                    function ke(t, e, r, n) {
                        var i = Object.create(Oe.prototype);
                        return i.size = t ? t.size : 0, i._map = t, i._list = e, i.__ownerID = r, i.__hash = n, i
                    }

                    function Ae() {
                        return me || (me = ke(Zt(), ze()))
                    }

                    function je(t, e, r) {
                        var n, i, o = t._map,
                            u = t._list,
                            s = o.get(e),
                            a = void 0 !== s;
                        if (r === m) {
                            if (!a) return t;
                            u.size >= y && u.size >= 2 * o.size ? (n = (i = u.filter(function(t, e) {
                                return void 0 !== t && s !== e
                            })).toKeyedSeq().map(function(t) {
                                return t[0]
                            }).flip().toMap(), t.__ownerID && (n.__ownerID = i.__ownerID = t.__ownerID)) : (n = o.remove(e), i = s === u.size - 1 ? u.pop() : u.set(s, void 0))
                        } else if (a) {
                            if (r === u.get(s)[1]) return t;
                            n = o, i = u.set(s, [e, r])
                        } else n = o.set(e, u.size), i = u.set(u.size, [e, r]);
                        return t.__ownerID ? (t.size = n.size, t._map = n, t._list = i, t.__hash = void 0, t) : ke(n, i)
                    }

                    function Ke(t, e) {
                        this._iter = t, this._useKeys = e, this.size = t.size
                    }

                    function Re(t) {
                        this._iter = t, this.size = t.size
                    }

                    function Ue(t) {
                        this._iter = t, this.size = t.size
                    }

                    function Le(t) {
                        this._iter = t, this.size = t.size
                    }

                    function Te(t) {
                        var e = $e(t);
                        return e._iter = t, e.size = t.size, e.flip = function() {
                            return t
                        }, e.reverse = function() {
                            var e = t.reverse.apply(this);
                            return e.flip = function() {
                                return t.reverse()
                            }, e
                        }, e.has = function(e) {
                            return t.includes(e)
                        }, e.includes = function(e) {
                            return t.has(e)
                        }, e.cacheResult = tr, e.__iterateUncached = function(e, r) {
                            var n = this;
                            return t.__iterate(function(t, r) {
                                return !1 !== e(r, t, n)
                            }, r)
                        }, e.__iteratorUncached = function(e, r) {
                            if (e === K) {
                                var n = t.__iterator(e, r);
                                return new T(function() {
                                    var t = n.next();
                                    if (!t.done) {
                                        var e = t.value[0];
                                        t.value[0] = t.value[1], t.value[1] = e
                                    }
                                    return t
                                })
                            }
                            return t.__iterator(e === j ? A : j, r)
                        }, e
                    }

                    function We(t, e, r) {
                        var n = $e(t);
                        return n.size = t.size, n.has = function(e) {
                            return t.has(e)
                        }, n.get = function(n, i) {
                            var o = t.get(n, m);
                            return o === m ? i : e.call(r, o, n, t)
                        }, n.__iterateUncached = function(n, i) {
                            var o = this;
                            return t.__iterate(function(t, i, u) {
                                return !1 !== n(e.call(r, t, i, u), i, o)
                            }, i)
                        }, n.__iteratorUncached = function(n, i) {
                            var o = t.__iterator(K, i);
                            return new T(function() {
                                var i = o.next();
                                if (i.done) return i;
                                var u = i.value,
                                    s = u[0];
                                return W(n, s, e.call(r, u[1], s, t), i)
                            })
                        }, n
                    }

                    function Be(t, e) {
                        var r = $e(t);
                        return r._iter = t, r.size = t.size, r.reverse = function() {
                            return t
                        }, t.flip && (r.flip = function() {
                            var e = Te(t);
                            return e.reverse = function() {
                                return t.flip()
                            }, e
                        }), r.get = function(r, n) {
                            return t.get(e ? r : -1 - r, n)
                        }, r.has = function(r) {
                            return t.has(e ? r : -1 - r)
                        }, r.includes = function(e) {
                            return t.includes(e)
                        }, r.cacheResult = tr, r.__iterate = function(e, r) {
                            var n = this;
                            return t.__iterate(function(t, r) {
                                return e(t, r, n)
                            }, !r)
                        }, r.__iterator = function(e, r) {
                            return t.__iterator(e, !r)
                        }, r
                    }

                    function Ce(t, e, r, n) {
                        var i = $e(t);
                        return n && (i.has = function(n) {
                            var i = t.get(n, m);
                            return i !== m && !!e.call(r, i, n, t)
                        }, i.get = function(n, i) {
                            var o = t.get(n, m);
                            return o !== m && e.call(r, o, n, t) ? o : i
                        }), i.__iterateUncached = function(i, o) {
                            var u = this,
                                s = 0;
                            return t.__iterate(function(t, o, a) {
                                if (e.call(r, t, o, a)) return s++, i(t, n ? o : s - 1, u)
                            }, o), s
                        }, i.__iteratorUncached = function(i, o) {
                            var u = t.__iterator(K, o),
                                s = 0;
                            return new T(function() {
                                for (;;) {
                                    var o = u.next();
                                    if (o.done) return o;
                                    var a = o.value,
                                        h = a[0],
                                        f = a[1];
                                    if (e.call(r, f, h, t)) return W(i, n ? h : s++, f, o)
                                }
                            })
                        }, i
                    }

                    function Je(t, e, r, n) {
                        var i = t.size;
                        if (void 0 !== e && (e |= 0), void 0 !== r && (r |= 0), E(e, r, i)) return t;
                        var o = O(e, i),
                            u = x(r, i);
                        if (o != o || u != u) return Je(t.toSeq().cacheResult(), e, r, n);
                        var s, a = u - o;
                        a == a && (s = a < 0 ? 0 : a);
                        var h = $e(t);
                        return h.size = 0 === s ? s : t.size && s || void 0, !n && it(t) && s >= 0 && (h.get = function(e, r) {
                            return (e = D(this, e)) >= 0 && e < s ? t.get(e + o, r) : r
                        }), h.__iterateUncached = function(e, r) {
                            var i = this;
                            if (0 === s) return 0;
                            if (r) return this.cacheResult().__iterate(e, r);
                            var u = 0,
                                a = !0,
                                h = 0;
                            return t.__iterate(function(t, r) {
                                if (!a || !(a = u++ < o)) return h++, !1 !== e(t, n ? r : h - 1, i) && h !== s
                            }), h
                        }, h.__iteratorUncached = function(e, r) {
                            if (0 !== s && r) return this.cacheResult().__iterator(e, r);
                            var i = 0 !== s && t.__iterator(e, r),
                                u = 0,
                                a = 0;
                            return new T(function() {
                                for (; u++ < o;) i.next();
                                if (++a > s) return {
                                    value: void 0,
                                    done: !0
                                };
                                var t = i.next();
                                return n || e === j ? t : W(e, a - 1, e === A ? void 0 : t.value[1], t)
                            })
                        }, h
                    }

                    function Ne(t, e, r, n) {
                        var i = $e(t);
                        return i.__iterateUncached = function(i, o) {
                            var u = this;
                            if (o) return this.cacheResult().__iterate(i, o);
                            var s = !0,
                                a = 0;
                            return t.__iterate(function(t, o, h) {
                                if (!s || !(s = e.call(r, t, o, h))) return a++, i(t, n ? o : a - 1, u)
                            }), a
                        }, i.__iteratorUncached = function(i, o) {
                            var u = this;
                            if (o) return this.cacheResult().__iterator(i, o);
                            var s = t.__iterator(K, o),
                                a = !0,
                                h = 0;
                            return new T(function() {
                                var t, o, f;
                                do {
                                    if ((t = s.next()).done) return n || i === j ? t : W(i, h++, i === A ? void 0 : t.value[1], t);
                                    var c = t.value;
                                    o = c[0], f = c[1], a && (a = e.call(r, f, o, u))
                                } while (a);
                                return i === K ? t : W(i, o, f, t)
                            })
                        }, i
                    }

                    function Pe(t, e, r) {
                        var n = $e(t);
                        return n.__iterateUncached = function(n, i) {
                            var o = 0,
                                s = !1;
                            return function t(a, h) {
                                var f = this;
                                a.__iterate(function(i, a) {
                                    return (!e || h < e) && u(i) ? t(i, h + 1) : !1 === n(i, r ? a : o++, f) && (s = !0), !s
                                }, i)
                            }(t, 0), o
                        }, n.__iteratorUncached = function(n, i) {
                            var o = t.__iterator(n, i),
                                s = [],
                                a = 0;
                            return new T(function() {
                                for (; o;) {
                                    var t = o.next();
                                    if (!1 === t.done) {
                                        var h = t.value;
                                        if (n === K && (h = h[1]), e && !(s.length < e) || !u(h)) return r ? t : W(n, a++, h, t);
                                        s.push(o), o = h.__iterator(n, i)
                                    } else o = s.pop()
                                }
                                return {
                                    value: void 0,
                                    done: !0
                                }
                            })
                        }, n
                    }

                    function He(t, e, r) {
                        e || (e = er);
                        var n = s(t),
                            i = 0,
                            o = t.toSeq().map(function(e, n) {
                                return [n, e, i++, r ? r(e, n, t) : e]
                            }).toArray();
                        return o.sort(function(t, r) {
                            return e(t[3], r[3]) || t[2] - r[2]
                        }).forEach(n ? function(t, e) {
                            o[e].length = 2
                        } : function(t, e) {
                            o[e] = t[1]
                        }), n ? Y(o) : a(t) ? Q(o) : X(o)
                    }

                    function Ve(t, e, r) {
                        if (e || (e = er), r) {
                            var n = t.toSeq().map(function(e, n) {
                                return [e, r(e, n, t)]
                            }).reduce(function(t, r) {
                                return Ye(e, t[1], r[1]) ? r : t
                            });
                            return n && n[0]
                        }
                        return t.reduce(function(t, r) {
                            return Ye(e, t, r) ? r : t
                        })
                    }

                    function Ye(t, e, r) {
                        var n = t(r, e);
                        return 0 === n && r !== e && (null == r || r != r) || n > 0
                    }

                    function Qe(t, e, n) {
                        var i = $e(t);
                        return i.size = new tt(n).map(function(t) {
                            return t.size
                        }).min(), i.__iterate = function(t, e) {
                            for (var r, n = this.__iterator(j, e), i = 0; !(r = n.next()).done && !1 !== t(r.value, i++, this););
                            return i
                        }, i.__iteratorUncached = function(t, i) {
                            var o = n.map(function(t) {
                                    return t = r(t), N(i ? t.reverse() : t)
                                }),
                                u = 0,
                                s = !1;
                            return new T(function() {
                                var r;
                                return s || (r = o.map(function(t) {
                                    return t.next()
                                }), s = r.some(function(t) {
                                    return t.done
                                })), s ? {
                                    value: void 0,
                                    done: !0
                                } : W(t, u++, e.apply(null, r.map(function(t) {
                                    return t.value
                                })))
                            })
                        }, i
                    }

                    function Xe(t, e) {
                        return it(t) ? e : t.constructor(e)
                    }

                    function Fe(t) {
                        if (t !== Object(t)) throw new TypeError("Expected [K, V] tuple: " + t)
                    }

                    function Ge(t) {
                        return Lt(t.size), q(t)
                    }

                    function Ze(t) {
                        return s(t) ? n : a(t) ? i : o
                    }

                    function $e(t) {
                        return Object.create((s(t) ? Y : a(t) ? Q : X).prototype)
                    }

                    function tr() {
                        return this._iter.cacheResult ? (this._iter.cacheResult(), this.size = this._iter.size, this) : V.prototype.cacheResult.call(this)
                    }

                    function er(t, e) {
                        return t > e ? 1 : t < e ? -1 : 0
                    }

                    function rr(t) {
                        var e = N(t);
                        if (!e) {
                            if (!H(t)) throw new TypeError("Expected iterable or array-like: " + t);
                            e = N(r(t))
                        }
                        return e
                    }

                    function nr(t, e) {
                        var r, n = function n(o) {
                                if (o instanceof n) return o;
                                if (!(this instanceof n)) return new n(o);
                                if (!r) {
                                    r = !0;
                                    var u = Object.keys(t);
                                    ! function(t, e) {
                                        try {
                                            e.forEach(function(t, e) {
                                                Object.defineProperty(t, e, {
                                                    get: function() {
                                                        return this.get(e)
                                                    },
                                                    set: function(t) {
                                                        dt(this.__ownerID, "Cannot set on an immutable record."), this.set(e, t)
                                                    }
                                                })
                                            }.bind(void 0, t))
                                        } catch (t) {}
                                    }(i, u), i.size = u.length, i._name = e, i._keys = u, i._defaultValues = t
                                }
                                this._map = Tt(o)
                            },
                            i = n.prototype = Object.create(ir);
                        return i.constructor = n, n
                    }

                    function or(t, e, r) {
                        var n = Object.create(Object.getPrototypeOf(t));
                        return n._map = e, n.__ownerID = r, n
                    }

                    function ur(t) {
                        return t._name || t.constructor.name || "Record"
                    }

                    function sr(t) {
                        return null == t ? lr() : ar(t) && !f(t) ? t : lr().withMutations(function(e) {
                            var r = o(t);
                            Lt(r.size), r.forEach(function(t) {
                                return e.add(t)
                            })
                        })
                    }

                    function ar(t) {
                        return !(!t || !t[fr])
                    }

                    function _r(t, e) {
                        return t.__ownerID ? (t.size = e.size, t._map = e, t) : e === t._map ? t : 0 === e.size ? t.__empty() : t.__make(e)
                    }

                    function pr(t, e) {
                        var r = Object.create(cr);
                        return r.size = t ? t.size : 0, r._map = t, r.__ownerID = e, r
                    }

                    function lr() {
                        return hr || (hr = pr(Zt()))
                    }

                    function vr(t) {
                        return null == t ? wr() : yr(t) ? t : wr().withMutations(function(e) {
                            var r = o(t);
                            Lt(r.size), r.forEach(function(t) {
                                return e.add(t)
                            })
                        })
                    }

                    function yr(t) {
                        return ar(t) && f(t)
                    }

                    function gr(t, e) {
                        var r = Object.create(mr);
                        return r.size = t ? t.size : 0, r._map = t, r.__ownerID = e, r
                    }

                    function wr() {
                        return dr || (dr = gr(Ae()))
                    }

                    function Sr(t) {
                        return null == t ? Mr() : zr(t) ? t : Mr().unshiftAll(t)
                    }

                    function zr(t) {
                        return !(!t || !t[br])
                    }

                    function Dr(t, e, r, n) {
                        var i = Object.create(qr);
                        return i.size = t, i._head = e, i.__ownerID = r, i.__hash = n, i.__altered = !1, i
                    }

                    function Mr() {
                        return Ir || (Ir = Dr(0))
                    }

                    function Er(t, e) {
                        var r = function(_r2) {
                            t.prototype[_r2] = e[_r2]
                        };
                        return Object.keys(e).forEach(r), Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(e).forEach(r), t
                    }

                    function kr(t, e) {
                        return e
                    }

                    function Ar(t, e) {
                        return [e, t]
                    }

                    function jr(t) {
                        return function() {
                            return !t.apply(this, arguments)
                        }
                    }

                    function Kr(t) {
                        return function() {
                            return -t.apply(this, arguments)
                        }
                    }

                    function Rr(t) {
                        return "string" == typeof t ? JSON.stringify(t) : t
                    }

                    function Ur() {
                        return b(arguments)
                    }

                    function Lr(t, e) {
                        return t < e ? 1 : t > e ? -1 : 0
                    }

                    function Tr(t, e) {
                        return t ^ e + 2654435769 + (t << 6) + (t >> 2) | 0
                    }
                    var t = Array.prototype.slice;
                    e(n, r), e(i, r), e(o, r), r.isIterable = u, r.isKeyed = s, r.isIndexed = a, r.isAssociative = h, r.isOrdered = f, r.Keyed = n, r.Indexed = i, r.Set = o;
                    var c = "@@__IMMUTABLE_ITERABLE__@@",
                        _ = "@@__IMMUTABLE_KEYED__@@",
                        p = "@@__IMMUTABLE_INDEXED__@@",
                        l = "@@__IMMUTABLE_ORDERED__@@",
                        v = 5,
                        y = 1 << v,
                        d = y - 1,
                        m = {},
                        g = {
                            value: !1
                        },
                        w = {
                            value: !1
                        },
                        A = 0,
                        j = 1,
                        K = 2,
                        R = "function" == typeof Symbol && Symbol.iterator,
                        U = "@@iterator",
                        L = R || U;
                    T.prototype.toString = function() {
                        return "[Iterator]"
                    }, T.KEYS = A, T.VALUES = j, T.ENTRIES = K, T.prototype.inspect = T.prototype.toSource = function() {
                        return this.toString()
                    }, T.prototype[L] = function() {
                        return this
                    }, e(V, r), V.of = function() {
                        return V(arguments)
                    }, V.prototype.toSeq = function() {
                        return this
                    }, V.prototype.toString = function() {
                        return this.__toString("Seq {", "}")
                    }, V.prototype.cacheResult = function() {
                        return !this._cache && this.__iterateUncached && (this._cache = this.entrySeq().toArray(), this.size = this._cache.length), this
                    }, V.prototype.__iterate = function(t, e) {
                        return ht(this, t, e, !0)
                    }, V.prototype.__iterator = function(t, e) {
                        return ft(this, t, e, !0)
                    }, e(Y, V), Y.prototype.toKeyedSeq = function() {
                        return this
                    }, e(Q, V), Q.of = function() {
                        return Q(arguments)
                    }, Q.prototype.toIndexedSeq = function() {
                        return this
                    }, Q.prototype.toString = function() {
                        return this.__toString("Seq [", "]")
                    }, Q.prototype.__iterate = function(t, e) {
                        return ht(this, t, e, !1)
                    }, Q.prototype.__iterator = function(t, e) {
                        return ft(this, t, e, !1)
                    }, e(X, V), X.of = function() {
                        return X(arguments)
                    }, X.prototype.toSetSeq = function() {
                        return this
                    }, V.isSeq = it, V.Keyed = Y, V.Set = X, V.Indexed = Q;
                    var F, G, Z, $ = "@@__IMMUTABLE_SEQ__@@";
                    V.prototype[$] = !0, e(tt, Q), tt.prototype.get = function(t, e) {
                        return this.has(t) ? this._array[D(this, t)] : e
                    }, tt.prototype.__iterate = function(t, e) {
                        for (var r = this._array, n = r.length - 1, i = 0; i <= n; i++)
                            if (!1 === t(r[e ? n - i : i], i, this)) return i + 1;
                        return i
                    }, tt.prototype.__iterator = function(t, e) {
                        var r = this._array,
                            n = r.length - 1,
                            i = 0;
                        return new T(function() {
                            return i > n ? {
                                value: void 0,
                                done: !0
                            } : W(t, i, r[e ? n - i++ : i++])
                        })
                    }, e(et, Y), et.prototype.get = function(t, e) {
                        return void 0 === e || this.has(t) ? this._object[t] : e
                    }, et.prototype.has = function(t) {
                        return this._object.hasOwnProperty(t)
                    }, et.prototype.__iterate = function(t, e) {
                        for (var r = this._object, n = this._keys, i = n.length - 1, o = 0; o <= i; o++) {
                            var u = n[e ? i - o : o];
                            if (!1 === t(r[u], u, this)) return o + 1
                        }
                        return o
                    }, et.prototype.__iterator = function(t, e) {
                        var r = this._object,
                            n = this._keys,
                            i = n.length - 1,
                            o = 0;
                        return new T(function() {
                            var u = n[e ? i - o : o];
                            return o++ > i ? {
                                value: void 0,
                                done: !0
                            } : W(t, u, r[u])
                        })
                    }, et.prototype[l] = !0, e(rt, Q), rt.prototype.__iterateUncached = function(t, e) {
                        if (e) return this.cacheResult().__iterate(t, e);
                        var r = N(this._iterable),
                            n = 0;
                        if (J(r))
                            for (var i; !(i = r.next()).done && !1 !== t(i.value, n++, this););
                        return n
                    }, rt.prototype.__iteratorUncached = function(t, e) {
                        if (e) return this.cacheResult().__iterator(t, e);
                        var r = N(this._iterable);
                        if (!J(r)) return new T(B);
                        var n = 0;
                        return new T(function() {
                            var e = r.next();
                            return e.done ? e : W(t, n++, e.value)
                        })
                    }, e(nt, Q), nt.prototype.__iterateUncached = function(t, e) {
                        if (e) return this.cacheResult().__iterate(t, e);
                        for (var r, n = this._iterator, i = this._iteratorCache, o = 0; o < i.length;)
                            if (!1 === t(i[o], o++, this)) return o;
                        for (; !(r = n.next()).done;) {
                            var u = r.value;
                            if (i[o] = u, !1 === t(u, o++, this)) break
                        }
                        return o
                    }, nt.prototype.__iteratorUncached = function(t, e) {
                        if (e) return this.cacheResult().__iterator(t, e);
                        var r = this._iterator,
                            n = this._iteratorCache,
                            i = 0;
                        return new T(function() {
                            if (i >= n.length) {
                                var e = r.next();
                                if (e.done) return e;
                                n[i] = e.value
                            }
                            return W(t, i, n[i++])
                        })
                    }, e(yt, Q), yt.prototype.toString = function() {
                        return 0 === this.size ? "Repeat []" : "Repeat [ " + this._value + " " + this.size + " times ]"
                    }, yt.prototype.get = function(t, e) {
                        return this.has(t) ? this._value : e
                    }, yt.prototype.includes = function(t) {
                        return lt(this._value, t)
                    }, yt.prototype.slice = function(t, e) {
                        var r = this.size;
                        return E(t, e, r) ? this : new yt(this._value, x(e, r) - O(t, r))
                    }, yt.prototype.reverse = function() {
                        return this
                    }, yt.prototype.indexOf = function(t) {
                        return lt(this._value, t) ? 0 : -1
                    }, yt.prototype.lastIndexOf = function(t) {
                        return lt(this._value, t) ? this.size : -1
                    }, yt.prototype.__iterate = function(t, e) {
                        for (var r = 0; r < this.size; r++)
                            if (!1 === t(this._value, r, this)) return r + 1;
                        return r
                    }, yt.prototype.__iterator = function(t, e) {
                        var r = this,
                            n = 0;
                        return new T(function() {
                            return n < r.size ? W(t, n++, r._value) : {
                                value: void 0,
                                done: !0
                            }
                        })
                    }, yt.prototype.equals = function(t) {
                        return t instanceof yt ? lt(this._value, t._value) : vt(t)
                    }, e(mt, Q), mt.prototype.toString = function() {
                        return 0 === this.size ? "Range []" : "Range [ " + this._start + "..." + this._end + (this._step > 1 ? " by " + this._step : "") + " ]"
                    }, mt.prototype.get = function(t, e) {
                        return this.has(t) ? this._start + D(this, t) * this._step : e
                    }, mt.prototype.includes = function(t) {
                        var e = (t - this._start) / this._step;
                        return e >= 0 && e < this.size && e === Math.floor(e)
                    }, mt.prototype.slice = function(t, e) {
                        return E(t, e, this.size) ? this : (t = O(t, this.size), (e = x(e, this.size)) <= t ? new mt(0, 0) : new mt(this.get(t, this._end), this.get(e, this._end), this._step))
                    }, mt.prototype.indexOf = function(t) {
                        var e = t - this._start;
                        if (e % this._step == 0) {
                            var r = e / this._step;
                            if (r >= 0 && r < this.size) return r
                        }
                        return -1
                    }, mt.prototype.lastIndexOf = function(t) {
                        return this.indexOf(t)
                    }, mt.prototype.__iterate = function(t, e) {
                        for (var r = this.size - 1, n = this._step, i = e ? this._start + r * n : this._start, o = 0; o <= r; o++) {
                            if (!1 === t(i, o, this)) return o + 1;
                            i += e ? -n : n
                        }
                        return o
                    }, mt.prototype.__iterator = function(t, e) {
                        var r = this.size - 1,
                            n = this._step,
                            i = e ? this._start + r * n : this._start,
                            o = 0;
                        return new T(function() {
                            var u = i;
                            return i += e ? -n : n, o > r ? {
                                value: void 0,
                                done: !0
                            } : W(t, o++, u)
                        })
                    }, mt.prototype.equals = function(t) {
                        return t instanceof mt ? this._start === t._start && this._end === t._end && this._step === t._step : vt(this, t)
                    }, e(gt, r), e(wt, gt), e(St, gt), e(zt, gt), gt.Keyed = wt, gt.Indexed = St, gt.Set = zt;
                    var Ot, It = "function" == typeof Math.imul && -2 === Math.imul(4294967295, 2) ? Math.imul : function(t, e) {
                            var r = 65535 & (t |= 0),
                                n = 65535 & (e |= 0);
                            return r * n + ((t >>> 16) * n + r * (e >>> 16) << 16 >>> 0) | 0
                        },
                        Mt = Object.isExtensible,
                        Et = function() {
                            try {
                                return Object.defineProperty({}, "@", {}), !0
                            } catch (t) {
                                return !1
                            }
                        }(),
                        xt = "function" == typeof WeakMap;
                    xt && (Ot = new WeakMap);
                    var kt = 0,
                        At = "__immutablehash__";
                    "function" == typeof Symbol && (At = Symbol(At));
                    var jt = 16,
                        Kt = 255,
                        Rt = 0,
                        Ut = {};
                    e(Tt, wt), Tt.prototype.toString = function() {
                        return this.__toString("Map {", "}")
                    }, Tt.prototype.get = function(t, e) {
                        return this._root ? this._root.get(0, void 0, t, e) : e
                    }, Tt.prototype.set = function(t, e) {
                        return $t(this, t, e)
                    }, Tt.prototype.setIn = function(t, e) {
                        return this.updateIn(t, m, function() {
                            return e
                        })
                    }, Tt.prototype.remove = function(t) {
                        return $t(this, t, m)
                    }, Tt.prototype.deleteIn = function(t) {
                        return this.updateIn(t, function() {
                            return m
                        })
                    }, Tt.prototype.update = function(t, e, r) {
                        return 1 === arguments.length ? t(this) : this.updateIn([t], e, r)
                    }, Tt.prototype.updateIn = function(t, e, r) {
                        r || (r = e, e = void 0);
                        var n = function t(e, r, n, i) {
                            var o = e === m,
                                u = r.next();
                            if (u.done) {
                                var s = o ? n : e,
                                    a = i(s);
                                return a === s ? e : a
                            }
                            dt(o || e && e.set, "invalid keyPath");
                            var h = u.value,
                                f = o ? m : e.get(h, m),
                                c = t(f, r, n, i);
                            return c === f ? e : c === m ? e.remove(h) : (o ? Zt() : e).set(h, c)
                        }(this, rr(t), e, r);
                        return n === m ? void 0 : n
                    }, Tt.prototype.clear = function() {
                        return 0 === this.size ? this : this.__ownerID ? (this.size = 0, this._root = null, this.__hash = void 0, this.__altered = !0, this) : Zt()
                    }, Tt.prototype.merge = function() {
                        return ne(this, void 0, arguments)
                    }, Tt.prototype.mergeWith = function(e) {
                        return ne(this, e, t.call(arguments, 1))
                    }, Tt.prototype.mergeIn = function(e) {
                        var r = t.call(arguments, 1);
                        return this.updateIn(e, Zt(), function(t) {
                            return "function" == typeof t.merge ? t.merge.apply(t, r) : r[r.length - 1]
                        })
                    }, Tt.prototype.mergeDeep = function() {
                        return ne(this, ie, arguments)
                    }, Tt.prototype.mergeDeepWith = function(e) {
                        var r = t.call(arguments, 1);
                        return ne(this, oe(e), r)
                    }, Tt.prototype.mergeDeepIn = function(e) {
                        var r = t.call(arguments, 1);
                        return this.updateIn(e, Zt(), function(t) {
                            return "function" == typeof t.mergeDeep ? t.mergeDeep.apply(t, r) : r[r.length - 1]
                        })
                    }, Tt.prototype.sort = function(t) {
                        return Oe(He(this, t))
                    }, Tt.prototype.sortBy = function(t, e) {
                        return Oe(He(this, e, t))
                    }, Tt.prototype.withMutations = function(t) {
                        var e = this.asMutable();
                        return t(e), e.wasAltered() ? e.__ensureOwner(this.__ownerID) : this
                    }, Tt.prototype.asMutable = function() {
                        return this.__ownerID ? this : this.__ensureOwner(new I)
                    }, Tt.prototype.asImmutable = function() {
                        return this.__ensureOwner()
                    }, Tt.prototype.wasAltered = function() {
                        return this.__altered
                    }, Tt.prototype.__iterator = function(t, e) {
                        return new Qt(this, t, e)
                    }, Tt.prototype.__iterate = function(t, e) {
                        var r = this,
                            n = 0;
                        return this._root && this._root.iterate(function(e) {
                            return n++, t(e[1], e[0], r)
                        }, e), n
                    }, Tt.prototype.__ensureOwner = function(t) {
                        return t === this.__ownerID ? this : t ? Gt(this.size, this._root, t, this.__hash) : (this.__ownerID = t, this.__altered = !1, this)
                    }, Tt.isMap = Wt;
                    var Bt, Ct = "@@__IMMUTABLE_MAP__@@",
                        Jt = Tt.prototype;
                    Jt[Ct] = !0, Jt.delete = Jt.remove, Jt.removeIn = Jt.deleteIn, Nt.prototype.get = function(t, e, r, n) {
                        for (var i = this.entries, o = 0, u = i.length; o < u; o++)
                            if (lt(r, i[o][0])) return i[o][1];
                        return n
                    }, Nt.prototype.update = function(t, e, r, n, i, o, u) {
                        for (var s = i === m, a = this.entries, h = 0, f = a.length; h < f && !lt(n, a[h][0]); h++);
                        var c = h < f;
                        if (c ? a[h][1] === i : s) return this;
                        if (z(u), (s || !c) && z(o), !s || 1 !== a.length) {
                            if (!c && !s && a.length >= he) return function(t, e, r, n) {
                                t || (t = new I);
                                for (var i = new Yt(t, qt(r), [r, n]), o = 0; o < e.length; o++) {
                                    var u = e[o];
                                    i = i.update(t, 0, void 0, u[0], u[1])
                                }
                                return i
                            }(t, a, n, i);
                            var _ = t && t === this.ownerID,
                                p = _ ? a : b(a);
                            return c ? s ? h === f - 1 ? p.pop() : p[h] = p.pop() : p[h] = [n, i] : p.push([n, i]), _ ? (this.entries = p, this) : new Nt(t, p)
                        }
                    }, Pt.prototype.get = function(t, e, r, n) {
                        void 0 === e && (e = qt(r));
                        var i = 1 << ((0 === t ? e : e >>> t) & d),
                            o = this.bitmap;
                        return 0 == (o & i) ? n : this.nodes[se(o & i - 1)].get(t + v, e, r, n)
                    }, Pt.prototype.update = function(t, e, r, n, i, o, u) {
                        void 0 === r && (r = qt(n));
                        var s = (0 === e ? r : r >>> e) & d,
                            a = 1 << s,
                            h = this.bitmap,
                            f = 0 != (h & a);
                        if (!f && i === m) return this;
                        var c = se(h & a - 1),
                            _ = this.nodes,
                            p = f ? _[c] : void 0,
                            l = te(p, t, e + v, r, n, i, o, u);
                        if (l === p) return this;
                        if (!f && l && _.length >= fe) return function(t, e, r, n, i) {
                            for (var o = 0, u = new Array(y), s = 0; 0 !== r; s++, r >>>= 1) u[s] = 1 & r ? e[o++] : void 0;
                            return u[n] = i, new Ht(t, o + 1, u)
                        }(t, _, h, s, l);
                        if (f && !l && 2 === _.length && ee(_[1 ^ c])) return _[1 ^ c];
                        if (f && l && 1 === _.length && ee(l)) return l;
                        var g = t && t === this.ownerID,
                            w = f ? l ? h : h ^ a : h | a,
                            S = f ? l ? ae(_, c, l, g) : function(t, e, r) {
                                var n = t.length - 1;
                                if (r && e === n) return t.pop(), t;
                                for (var i = new Array(n), o = 0, u = 0; u < n; u++) u === e && (o = 1), i[u] = t[u + o];
                                return i
                            }(_, c, g) : function(t, e, r, n) {
                                var i = t.length + 1;
                                if (n && e + 1 === i) return t[e] = r, t;
                                for (var o = new Array(i), u = 0, s = 0; s < i; s++) s === e ? (o[s] = r, u = -1) : o[s] = t[s + u];
                                return o
                            }(_, c, l, g);
                        return g ? (this.bitmap = w, this.nodes = S, this) : new Pt(t, w, S)
                    }, Ht.prototype.get = function(t, e, r, n) {
                        void 0 === e && (e = qt(r));
                        var i = (0 === t ? e : e >>> t) & d,
                            o = this.nodes[i];
                        return o ? o.get(t + v, e, r, n) : n
                    }, Ht.prototype.update = function(t, e, r, n, i, o, u) {
                        void 0 === r && (r = qt(n));
                        var s = (0 === e ? r : r >>> e) & d,
                            a = i === m,
                            h = this.nodes,
                            f = h[s];
                        if (a && !f) return this;
                        var c = te(f, t, e + v, r, n, i, o, u);
                        if (c === f) return this;
                        var _ = this.count;
                        if (f) {
                            if (!c && --_ < ce) return function(t, e, r, n) {
                                for (var i = 0, o = 0, u = new Array(r), s = 0, a = 1, h = e.length; s < h; s++, a <<= 1) {
                                    var f = e[s];
                                    void 0 !== f && s !== n && (i |= a, u[o++] = f)
                                }
                                return new Pt(t, i, u)
                            }(t, h, _, s)
                        } else _++;
                        var p = t && t === this.ownerID,
                            l = ae(h, s, c, p);
                        return p ? (this.count = _, this.nodes = l, this) : new Ht(t, _, l)
                    }, Vt.prototype.get = function(t, e, r, n) {
                        for (var i = this.entries, o = 0, u = i.length; o < u; o++)
                            if (lt(r, i[o][0])) return i[o][1];
                        return n
                    }, Vt.prototype.update = function(t, e, r, n, i, o, u) {
                        void 0 === r && (r = qt(n));
                        var s = i === m;
                        if (r !== this.keyHash) return s ? this : (z(u), z(o), re(this, t, e, r, [n, i]));
                        for (var a = this.entries, h = 0, f = a.length; h < f && !lt(n, a[h][0]); h++);
                        var c = h < f;
                        if (c ? a[h][1] === i : s) return this;
                        if (z(u), (s || !c) && z(o), s && 2 === f) return new Yt(t, this.keyHash, a[1 ^ h]);
                        var _ = t && t === this.ownerID,
                            p = _ ? a : b(a);
                        return c ? s ? h === f - 1 ? p.pop() : p[h] = p.pop() : p[h] = [n, i] : p.push([n, i]), _ ? (this.entries = p, this) : new Vt(t, this.keyHash, p)
                    }, Yt.prototype.get = function(t, e, r, n) {
                        return lt(r, this.entry[0]) ? this.entry[1] : n
                    }, Yt.prototype.update = function(t, e, r, n, i, o, u) {
                        var s = i === m,
                            a = lt(n, this.entry[0]);
                        return (a ? i === this.entry[1] : s) ? this : (z(u), s ? void z(o) : a ? t && t === this.ownerID ? (this.entry[1] = i, this) : new Yt(t, this.keyHash, [n, i]) : (z(o), re(this, t, e, qt(n), [n, i])))
                    }, Nt.prototype.iterate = Vt.prototype.iterate = function(t, e) {
                        for (var r = this.entries, n = 0, i = r.length - 1; n <= i; n++)
                            if (!1 === t(r[e ? i - n : n])) return !1
                    }, Pt.prototype.iterate = Ht.prototype.iterate = function(t, e) {
                        for (var r = this.nodes, n = 0, i = r.length - 1; n <= i; n++) {
                            var o = r[e ? i - n : n];
                            if (o && !1 === o.iterate(t, e)) return !1
                        }
                    }, Yt.prototype.iterate = function(t, e) {
                        return t(this.entry)
                    }, e(Qt, T), Qt.prototype.next = function() {
                        for (var t = this._type, e = this._stack; e;) {
                            var r, n = e.node,
                                i = e.index++;
                            if (n.entry) {
                                if (0 === i) return Xt(t, n.entry)
                            } else if (n.entries) {
                                if (i <= (r = n.entries.length - 1)) return Xt(t, n.entries[this._reverse ? r - i : i])
                            } else if (i <= (r = n.nodes.length - 1)) {
                                var o = n.nodes[this._reverse ? r - i : i];
                                if (o) {
                                    if (o.entry) return Xt(t, o.entry);
                                    e = this._stack = Ft(o, e)
                                }
                                continue
                            }
                            e = this._stack = this._stack.__prev
                        }
                        return {
                            value: void 0,
                            done: !0
                        }
                    };
                    var he = y / 4,
                        fe = y / 2,
                        ce = y / 4;
                    e(_e, St), _e.of = function() {
                        return this(arguments)
                    }, _e.prototype.toString = function() {
                        return this.__toString("List [", "]")
                    }, _e.prototype.get = function(t, e) {
                        if ((t = D(this, t)) >= 0 && t < this.size) {
                            var r = qe(this, t += this._origin);
                            return r && r.array[t & d]
                        }
                        return e
                    }, _e.prototype.set = function(t, e) {
                        return function(t, e, r) {
                            if ((e = D(t, e)) != e) return t;
                            if (e >= t.size || e < 0) return t.withMutations(function(t) {
                                e < 0 ? De(t, e).set(0, r) : De(t, 0, e + 1).set(e, r)
                            });
                            e += t._origin;
                            var n = t._tail,
                                i = t._root,
                                o = S(w);
                            return e >= Ee(t._capacity) ? n = Ie(n, t.__ownerID, 0, e, r, o) : i = Ie(i, t.__ownerID, t._level, e, r, o), o.value ? t.__ownerID ? (t._root = i, t._tail = n, t.__hash = void 0, t.__altered = !0, t) : Se(t._origin, t._capacity, t._level, i, n) : t
                        }(this, t, e)
                    }, _e.prototype.remove = function(t) {
                        return this.has(t) ? 0 === t ? this.shift() : t === this.size - 1 ? this.pop() : this.splice(t, 1) : this
                    }, _e.prototype.insert = function(t, e) {
                        return this.splice(t, 0, e)
                    }, _e.prototype.clear = function() {
                        return 0 === this.size ? this : this.__ownerID ? (this.size = this._origin = this._capacity = 0, this._level = v, this._root = this._tail = null, this.__hash = void 0, this.__altered = !0, this) : ze()
                    }, _e.prototype.push = function() {
                        var t = arguments,
                            e = this.size;
                        return this.withMutations(function(r) {
                            De(r, 0, e + t.length);
                            for (var n = 0; n < t.length; n++) r.set(e + n, t[n])
                        })
                    }, _e.prototype.pop = function() {
                        return De(this, 0, -1)
                    }, _e.prototype.unshift = function() {
                        var t = arguments;
                        return this.withMutations(function(e) {
                            De(e, -t.length);
                            for (var r = 0; r < t.length; r++) e.set(r, t[r])
                        })
                    }, _e.prototype.shift = function() {
                        return De(this, 1)
                    }, _e.prototype.merge = function() {
                        return Me(this, void 0, arguments)
                    }, _e.prototype.mergeWith = function(e) {
                        return Me(this, e, t.call(arguments, 1))
                    }, _e.prototype.mergeDeep = function() {
                        return Me(this, ie, arguments)
                    }, _e.prototype.mergeDeepWith = function(e) {
                        var r = t.call(arguments, 1);
                        return Me(this, oe(e), r)
                    }, _e.prototype.setSize = function(t) {
                        return De(this, 0, t)
                    }, _e.prototype.slice = function(t, e) {
                        var r = this.size;
                        return E(t, e, r) ? this : De(this, O(t, r), x(e, r))
                    }, _e.prototype.__iterator = function(t, e) {
                        var r = 0,
                            n = we(this, e);
                        return new T(function() {
                            var e = n();
                            return e === ge ? {
                                value: void 0,
                                done: !0
                            } : W(t, r++, e)
                        })
                    }, _e.prototype.__iterate = function(t, e) {
                        for (var r, n = 0, i = we(this, e);
                            (r = i()) !== ge && !1 !== t(r, n++, this););
                        return n
                    }, _e.prototype.__ensureOwner = function(t) {
                        return t === this.__ownerID ? this : t ? Se(this._origin, this._capacity, this._level, this._root, this._tail, t, this.__hash) : (this.__ownerID = t, this)
                    }, _e.isList = pe;
                    var le = "@@__IMMUTABLE_LIST__@@",
                        ve = _e.prototype;
                    ve[le] = !0, ve.delete = ve.remove, ve.setIn = Jt.setIn, ve.deleteIn = ve.removeIn = Jt.removeIn, ve.update = Jt.update, ve.updateIn = Jt.updateIn, ve.mergeIn = Jt.mergeIn, ve.mergeDeepIn = Jt.mergeDeepIn, ve.withMutations = Jt.withMutations, ve.asMutable = Jt.asMutable, ve.asImmutable = Jt.asImmutable, ve.wasAltered = Jt.wasAltered, ye.prototype.removeBefore = function(t, e, r) {
                        if (r === e ? 1 << e : 0 === this.array.length) return this;
                        var n = r >>> e & d;
                        if (n >= this.array.length) return new ye([], t);
                        var i, o = 0 === n;
                        if (e > 0) {
                            var u = this.array[n];
                            if ((i = u && u.removeBefore(t, e - v, r)) === u && o) return this
                        }
                        if (o && !i) return this;
                        var s = be(this, t);
                        if (!o)
                            for (var a = 0; a < n; a++) s.array[a] = void 0;
                        return i && (s.array[n] = i), s
                    }, ye.prototype.removeAfter = function(t, e, r) {
                        if (r === (e ? 1 << e : 0) || 0 === this.array.length) return this;
                        var n, i = r - 1 >>> e & d;
                        if (i >= this.array.length) return this;
                        if (e > 0) {
                            var o = this.array[i];
                            if ((n = o && o.removeAfter(t, e - v, r)) === o && i === this.array.length - 1) return this
                        }
                        var u = be(this, t);
                        return u.array.splice(i + 1), n && (u.array[i] = n), u
                    };
                    var de, me, ge = {};
                    e(Oe, Tt), Oe.of = function() {
                        return this(arguments)
                    }, Oe.prototype.toString = function() {
                        return this.__toString("OrderedMap {", "}")
                    }, Oe.prototype.get = function(t, e) {
                        var r = this._map.get(t);
                        return void 0 !== r ? this._list.get(r)[1] : e
                    }, Oe.prototype.clear = function() {
                        return 0 === this.size ? this : this.__ownerID ? (this.size = 0, this._map.clear(), this._list.clear(), this) : Ae()
                    }, Oe.prototype.set = function(t, e) {
                        return je(this, t, e)
                    }, Oe.prototype.remove = function(t) {
                        return je(this, t, m)
                    }, Oe.prototype.wasAltered = function() {
                        return this._map.wasAltered() || this._list.wasAltered()
                    }, Oe.prototype.__iterate = function(t, e) {
                        var r = this;
                        return this._list.__iterate(function(e) {
                            return e && t(e[1], e[0], r)
                        }, e)
                    }, Oe.prototype.__iterator = function(t, e) {
                        return this._list.fromEntrySeq().__iterator(t, e)
                    }, Oe.prototype.__ensureOwner = function(t) {
                        if (t === this.__ownerID) return this;
                        var e = this._map.__ensureOwner(t),
                            r = this._list.__ensureOwner(t);
                        return t ? ke(e, r, t, this.__hash) : (this.__ownerID = t, this._map = e, this._list = r, this)
                    }, Oe.isOrderedMap = xe, Oe.prototype[l] = !0, Oe.prototype.delete = Oe.prototype.remove, e(Ke, Y), Ke.prototype.get = function(t, e) {
                        return this._iter.get(t, e)
                    }, Ke.prototype.has = function(t) {
                        return this._iter.has(t)
                    }, Ke.prototype.valueSeq = function() {
                        return this._iter.valueSeq()
                    }, Ke.prototype.reverse = function() {
                        var t = this,
                            e = Be(this, !0);
                        return this._useKeys || (e.valueSeq = function() {
                            return t._iter.toSeq().reverse()
                        }), e
                    }, Ke.prototype.map = function(t, e) {
                        var r = this,
                            n = We(this, t, e);
                        return this._useKeys || (n.valueSeq = function() {
                            return r._iter.toSeq().map(t, e)
                        }), n
                    }, Ke.prototype.__iterate = function(t, e) {
                        var r, n = this;
                        return this._iter.__iterate(this._useKeys ? function(e, r) {
                            return t(e, r, n)
                        } : (r = e ? Ge(this) : 0, function(i) {
                            return t(i, e ? --r : r++, n)
                        }), e)
                    }, Ke.prototype.__iterator = function(t, e) {
                        if (this._useKeys) return this._iter.__iterator(t, e);
                        var r = this._iter.__iterator(j, e),
                            n = e ? Ge(this) : 0;
                        return new T(function() {
                            var i = r.next();
                            return i.done ? i : W(t, e ? --n : n++, i.value, i)
                        })
                    }, Ke.prototype[l] = !0, e(Re, Q), Re.prototype.includes = function(t) {
                        return this._iter.includes(t)
                    }, Re.prototype.__iterate = function(t, e) {
                        var r = this,
                            n = 0;
                        return this._iter.__iterate(function(e) {
                            return t(e, n++, r)
                        }, e)
                    }, Re.prototype.__iterator = function(t, e) {
                        var r = this._iter.__iterator(j, e),
                            n = 0;
                        return new T(function() {
                            var e = r.next();
                            return e.done ? e : W(t, n++, e.value, e)
                        })
                    }, e(Ue, X), Ue.prototype.has = function(t) {
                        return this._iter.includes(t)
                    }, Ue.prototype.__iterate = function(t, e) {
                        var r = this;
                        return this._iter.__iterate(function(e) {
                            return t(e, e, r)
                        }, e)
                    }, Ue.prototype.__iterator = function(t, e) {
                        var r = this._iter.__iterator(j, e);
                        return new T(function() {
                            var e = r.next();
                            return e.done ? e : W(t, e.value, e.value, e)
                        })
                    }, e(Le, Y), Le.prototype.entrySeq = function() {
                        return this._iter.toSeq()
                    }, Le.prototype.__iterate = function(t, e) {
                        var r = this;
                        return this._iter.__iterate(function(e) {
                            if (e) {
                                Fe(e);
                                var n = u(e);
                                return t(n ? e.get(1) : e[1], n ? e.get(0) : e[0], r)
                            }
                        }, e)
                    }, Le.prototype.__iterator = function(t, e) {
                        var r = this._iter.__iterator(j, e);
                        return new T(function() {
                            for (;;) {
                                var e = r.next();
                                if (e.done) return e;
                                var n = e.value;
                                if (n) {
                                    Fe(n);
                                    var i = u(n);
                                    return W(t, i ? n.get(0) : n[0], i ? n.get(1) : n[1], e)
                                }
                            }
                        })
                    }, Re.prototype.cacheResult = Ke.prototype.cacheResult = Ue.prototype.cacheResult = Le.prototype.cacheResult = tr, e(nr, wt), nr.prototype.toString = function() {
                        return this.__toString(ur(this) + " {", "}")
                    }, nr.prototype.has = function(t) {
                        return this._defaultValues.hasOwnProperty(t)
                    }, nr.prototype.get = function(t, e) {
                        if (!this.has(t)) return e;
                        var r = this._defaultValues[t];
                        return this._map ? this._map.get(t, r) : r
                    }, nr.prototype.clear = function() {
                        if (this.__ownerID) return this._map && this._map.clear(), this;
                        var t = this.constructor;
                        return t._empty || (t._empty = or(this, Zt()))
                    }, nr.prototype.set = function(t, e) {
                        if (!this.has(t)) throw new Error('Cannot set unknown key "' + t + '" on ' + ur(this));
                        var r = this._map && this._map.set(t, e);
                        return this.__ownerID || r === this._map ? this : or(this, r)
                    }, nr.prototype.remove = function(t) {
                        if (!this.has(t)) return this;
                        var e = this._map && this._map.remove(t);
                        return this.__ownerID || e === this._map ? this : or(this, e)
                    }, nr.prototype.wasAltered = function() {
                        return this._map.wasAltered()
                    }, nr.prototype.__iterator = function(t, e) {
                        var r = this;
                        return n(this._defaultValues).map(function(t, e) {
                            return r.get(e)
                        }).__iterator(t, e)
                    }, nr.prototype.__iterate = function(t, e) {
                        var r = this;
                        return n(this._defaultValues).map(function(t, e) {
                            return r.get(e)
                        }).__iterate(t, e)
                    }, nr.prototype.__ensureOwner = function(t) {
                        if (t === this.__ownerID) return this;
                        var e = this._map && this._map.__ensureOwner(t);
                        return t ? or(this, e, t) : (this.__ownerID = t, this._map = e, this)
                    };
                    var ir = nr.prototype;
                    ir.delete = ir.remove, ir.deleteIn = ir.removeIn = Jt.removeIn, ir.merge = Jt.merge, ir.mergeWith = Jt.mergeWith, ir.mergeIn = Jt.mergeIn, ir.mergeDeep = Jt.mergeDeep, ir.mergeDeepWith = Jt.mergeDeepWith, ir.mergeDeepIn = Jt.mergeDeepIn, ir.setIn = Jt.setIn, ir.update = Jt.update, ir.updateIn = Jt.updateIn, ir.withMutations = Jt.withMutations, ir.asMutable = Jt.asMutable, ir.asImmutable = Jt.asImmutable, e(sr, zt), sr.of = function() {
                        return this(arguments)
                    }, sr.fromKeys = function(t) {
                        return this(n(t).keySeq())
                    }, sr.prototype.toString = function() {
                        return this.__toString("Set {", "}")
                    }, sr.prototype.has = function(t) {
                        return this._map.has(t)
                    }, sr.prototype.add = function(t) {
                        return _r(this, this._map.set(t, !0))
                    }, sr.prototype.remove = function(t) {
                        return _r(this, this._map.remove(t))
                    }, sr.prototype.clear = function() {
                        return _r(this, this._map.clear())
                    }, sr.prototype.union = function() {
                        var e = t.call(arguments, 0);
                        return 0 === (e = e.filter(function(t) {
                            return 0 !== t.size
                        })).length ? this : 0 !== this.size || this.__ownerID || 1 !== e.length ? this.withMutations(function(t) {
                            for (var r = 0; r < e.length; r++) o(e[r]).forEach(function(e) {
                                return t.add(e)
                            })
                        }) : this.constructor(e[0])
                    }, sr.prototype.intersect = function() {
                        var e = t.call(arguments, 0);
                        if (0 === e.length) return this;
                        e = e.map(function(t) {
                            return o(t)
                        });
                        var r = this;
                        return this.withMutations(function(t) {
                            r.forEach(function(r) {
                                e.every(function(t) {
                                    return t.includes(r)
                                }) || t.remove(r)
                            })
                        })
                    }, sr.prototype.subtract = function() {
                        var e = t.call(arguments, 0);
                        if (0 === e.length) return this;
                        e = e.map(function(t) {
                            return o(t)
                        });
                        var r = this;
                        return this.withMutations(function(t) {
                            r.forEach(function(r) {
                                e.some(function(t) {
                                    return t.includes(r)
                                }) && t.remove(r)
                            })
                        })
                    }, sr.prototype.merge = function() {
                        return this.union.apply(this, arguments)
                    }, sr.prototype.mergeWith = function(e) {
                        var r = t.call(arguments, 1);
                        return this.union.apply(this, r)
                    }, sr.prototype.sort = function(t) {
                        return vr(He(this, t))
                    }, sr.prototype.sortBy = function(t, e) {
                        return vr(He(this, e, t))
                    }, sr.prototype.wasAltered = function() {
                        return this._map.wasAltered()
                    }, sr.prototype.__iterate = function(t, e) {
                        var r = this;
                        return this._map.__iterate(function(e, n) {
                            return t(n, n, r)
                        }, e)
                    }, sr.prototype.__iterator = function(t, e) {
                        return this._map.map(function(t, e) {
                            return e
                        }).__iterator(t, e)
                    }, sr.prototype.__ensureOwner = function(t) {
                        if (t === this.__ownerID) return this;
                        var e = this._map.__ensureOwner(t);
                        return t ? this.__make(e, t) : (this.__ownerID = t, this._map = e, this)
                    }, sr.isSet = ar;
                    var hr, fr = "@@__IMMUTABLE_SET__@@",
                        cr = sr.prototype;
                    cr[fr] = !0, cr.delete = cr.remove, cr.mergeDeep = cr.merge, cr.mergeDeepWith = cr.mergeWith, cr.withMutations = Jt.withMutations, cr.asMutable = Jt.asMutable, cr.asImmutable = Jt.asImmutable, cr.__empty = lr, cr.__make = pr, e(vr, sr), vr.of = function() {
                        return this(arguments)
                    }, vr.fromKeys = function(t) {
                        return this(n(t).keySeq())
                    }, vr.prototype.toString = function() {
                        return this.__toString("OrderedSet {", "}")
                    }, vr.isOrderedSet = yr;
                    var dr, mr = vr.prototype;
                    mr[l] = !0, mr.__empty = wr, mr.__make = gr, e(Sr, St), Sr.of = function() {
                        return this(arguments)
                    }, Sr.prototype.toString = function() {
                        return this.__toString("Stack [", "]")
                    }, Sr.prototype.get = function(t, e) {
                        var r = this._head;
                        for (t = D(this, t); r && t--;) r = r.next;
                        return r ? r.value : e
                    }, Sr.prototype.peek = function() {
                        return this._head && this._head.value
                    }, Sr.prototype.push = function() {
                        if (0 === arguments.length) return this;
                        for (var t = this.size + arguments.length, e = this._head, r = arguments.length - 1; r >= 0; r--) e = {
                            value: arguments[r],
                            next: e
                        };
                        return this.__ownerID ? (this.size = t, this._head = e, this.__hash = void 0, this.__altered = !0, this) : Dr(t, e)
                    }, Sr.prototype.pushAll = function(t) {
                        if (0 === (t = i(t)).size) return this;
                        Lt(t.size);
                        var e = this.size,
                            r = this._head;
                        return t.reverse().forEach(function(t) {
                            e++, r = {
                                value: t,
                                next: r
                            }
                        }), this.__ownerID ? (this.size = e, this._head = r, this.__hash = void 0, this.__altered = !0, this) : Dr(e, r)
                    }, Sr.prototype.pop = function() {
                        return this.slice(1)
                    }, Sr.prototype.unshift = function() {
                        return this.push.apply(this, arguments)
                    }, Sr.prototype.unshiftAll = function(t) {
                        return this.pushAll(t)
                    }, Sr.prototype.shift = function() {
                        return this.pop.apply(this, arguments)
                    }, Sr.prototype.clear = function() {
                        return 0 === this.size ? this : this.__ownerID ? (this.size = 0, this._head = void 0, this.__hash = void 0, this.__altered = !0, this) : Mr()
                    }, Sr.prototype.slice = function(t, e) {
                        if (E(t, e, this.size)) return this;
                        var r = O(t, this.size);
                        if (x(e, this.size) !== this.size) return St.prototype.slice.call(this, t, e);
                        for (var n = this.size - r, i = this._head; r--;) i = i.next;
                        return this.__ownerID ? (this.size = n, this._head = i, this.__hash = void 0, this.__altered = !0, this) : Dr(n, i)
                    }, Sr.prototype.__ensureOwner = function(t) {
                        return t === this.__ownerID ? this : t ? Dr(this.size, this._head, t, this.__hash) : (this.__ownerID = t, this.__altered = !1, this)
                    }, Sr.prototype.__iterate = function(t, e) {
                        if (e) return this.reverse().__iterate(t);
                        for (var r = 0, n = this._head; n && !1 !== t(n.value, r++, this);) n = n.next;
                        return r
                    }, Sr.prototype.__iterator = function(t, e) {
                        if (e) return this.reverse().__iterator(t);
                        var r = 0,
                            n = this._head;
                        return new T(function() {
                            if (n) {
                                var e = n.value;
                                return n = n.next, W(t, r++, e)
                            }
                            return {
                                value: void 0,
                                done: !0
                            }
                        })
                    }, Sr.isStack = zr;
                    var Ir, br = "@@__IMMUTABLE_STACK__@@",
                        qr = Sr.prototype;
                    qr[br] = !0, qr.withMutations = Jt.withMutations, qr.asMutable = Jt.asMutable, qr.asImmutable = Jt.asImmutable, qr.wasAltered = Jt.wasAltered, r.Iterator = T, Er(r, {
                        toArray: function() {
                            Lt(this.size);
                            var t = new Array(this.size || 0);
                            return this.valueSeq().__iterate(function(e, r) {
                                t[r] = e
                            }), t
                        },
                        toIndexedSeq: function() {
                            return new Re(this)
                        },
                        toJS: function() {
                            return this.toSeq().map(function(t) {
                                return t && "function" == typeof t.toJS ? t.toJS() : t
                            }).__toJS()
                        },
                        toJSON: function() {
                            return this.toSeq().map(function(t) {
                                return t && "function" == typeof t.toJSON ? t.toJSON() : t
                            }).__toJS()
                        },
                        toKeyedSeq: function() {
                            return new Ke(this, (!0))
                        },
                        toMap: function() {
                            return Tt(this.toKeyedSeq())
                        },
                        toObject: function() {
                            Lt(this.size);
                            var t = {};
                            return this.__iterate(function(e, r) {
                                t[r] = e
                            }), t
                        },
                        toOrderedMap: function() {
                            return Oe(this.toKeyedSeq())
                        },
                        toOrderedSet: function() {
                            return vr(s(this) ? this.valueSeq() : this)
                        },
                        toSet: function() {
                            return sr(s(this) ? this.valueSeq() : this)
                        },
                        toSetSeq: function() {
                            return new Ue(this)
                        },
                        toSeq: function() {
                            return a(this) ? this.toIndexedSeq() : s(this) ? this.toKeyedSeq() : this.toSetSeq()
                        },
                        toStack: function() {
                            return Sr(s(this) ? this.valueSeq() : this)
                        },
                        toList: function() {
                            return _e(s(this) ? this.valueSeq() : this)
                        },
                        toString: function() {
                            return "[Iterable]"
                        },
                        __toString: function(t, e) {
                            return 0 === this.size ? t + e : t + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + e
                        },
                        concat: function() {
                            return Xe(this, function(t, e) {
                                var r = s(t),
                                    i = [t].concat(e).map(function(t) {
                                        return u(t) ? r && (t = n(t)) : t = r ? ut(t) : st(Array.isArray(t) ? t : [t]), t
                                    }).filter(function(t) {
                                        return 0 !== t.size
                                    });
                                if (0 === i.length) return t;
                                if (1 === i.length) {
                                    var o = i[0];
                                    if (o === t || r && s(o) || a(t) && a(o)) return o
                                }
                                var h = new tt(i);
                                return r ? h = h.toKeyedSeq() : a(t) || (h = h.toSetSeq()), (h = h.flatten(!0)).size = i.reduce(function(t, e) {
                                    if (void 0 !== t) {
                                        var r = e.size;
                                        if (void 0 !== r) return t + r
                                    }
                                }, 0), h
                            }(this, t.call(arguments, 0)))
                        },
                        includes: function(t) {
                            return this.some(function(e) {
                                return lt(e, t)
                            })
                        },
                        entries: function() {
                            return this.__iterator(K)
                        },
                        every: function(t, e) {
                            Lt(this.size);
                            var r = !0;
                            return this.__iterate(function(n, i, o) {
                                if (!t.call(e, n, i, o)) return r = !1, !1
                            }), r
                        },
                        filter: function(t, e) {
                            return Xe(this, Ce(this, t, e, !0))
                        },
                        find: function(t, e, r) {
                            var n = this.findEntry(t, e);
                            return n ? n[1] : r
                        },
                        findEntry: function(t, e) {
                            var r;
                            return this.__iterate(function(n, i, o) {
                                if (t.call(e, n, i, o)) return r = [i, n], !1
                            }), r
                        },
                        findLastEntry: function(t, e) {
                            return this.toSeq().reverse().findEntry(t, e)
                        },
                        forEach: function(t, e) {
                            return Lt(this.size), this.__iterate(e ? t.bind(e) : t)
                        },
                        join: function(t) {
                            Lt(this.size), t = void 0 !== t ? "" + t : ",";
                            var e = "",
                                r = !0;
                            return this.__iterate(function(n) {
                                r ? r = !1 : e += t, e += null != n ? n.toString() : ""
                            }), e
                        },
                        keys: function() {
                            return this.__iterator(A)
                        },
                        map: function(t, e) {
                            return Xe(this, We(this, t, e))
                        },
                        reduce: function(t, e, r) {
                            var n, i;
                            return Lt(this.size), arguments.length < 2 ? i = !0 : n = e, this.__iterate(function(e, o, u) {
                                i ? (i = !1, n = e) : n = t.call(r, n, e, o, u)
                            }), n
                        },
                        reduceRight: function(t, e, r) {
                            var n = this.toKeyedSeq().reverse();
                            return n.reduce.apply(n, arguments)
                        },
                        reverse: function() {
                            return Xe(this, Be(this, !0))
                        },
                        slice: function(t, e) {
                            return Xe(this, Je(this, t, e, !0))
                        },
                        some: function(t, e) {
                            return !this.every(jr(t), e)
                        },
                        sort: function(t) {
                            return Xe(this, He(this, t))
                        },
                        values: function() {
                            return this.__iterator(j)
                        },
                        butLast: function() {
                            return this.slice(0, -1)
                        },
                        isEmpty: function() {
                            return void 0 !== this.size ? 0 === this.size : !this.some(function() {
                                return !0
                            })
                        },
                        count: function(t, e) {
                            return q(t ? this.toSeq().filter(t, e) : this)
                        },
                        countBy: function(t, e) {
                            return function(t, e, r) {
                                var n = Tt().asMutable();
                                return t.__iterate(function(i, o) {
                                    n.update(e.call(r, i, o, t), 0, function(t) {
                                        return t + 1
                                    })
                                }), n.asImmutable()
                            }(this, t, e)
                        },
                        equals: function(t) {
                            return vt(this, t)
                        },
                        entrySeq: function() {
                            var t = this;
                            if (t._cache) return new tt(t._cache);
                            var e = t.toSeq().map(Ar).toIndexedSeq();
                            return e.fromEntrySeq = function() {
                                return t.toSeq()
                            }, e
                        },
                        filterNot: function(t, e) {
                            return this.filter(jr(t), e)
                        },
                        findLast: function(t, e, r) {
                            return this.toKeyedSeq().reverse().find(t, e, r)
                        },
                        first: function() {
                            return this.find(M)
                        },
                        flatMap: function(t, e) {
                            return Xe(this, function(t, e, r) {
                                var n = Ze(t);
                                return t.toSeq().map(function(i, o) {
                                    return n(e.call(r, i, o, t))
                                }).flatten(!0)
                            }(this, t, e))
                        },
                        flatten: function(t) {
                            return Xe(this, Pe(this, t, !0))
                        },
                        fromEntrySeq: function() {
                            return new Le(this)
                        },
                        get: function(t, e) {
                            return this.find(function(e, r) {
                                return lt(r, t)
                            }, void 0, e)
                        },
                        getIn: function(t, e) {
                            for (var r, n = this, i = rr(t); !(r = i.next()).done;) {
                                var o = r.value;
                                if ((n = n && n.get ? n.get(o, m) : m) === m) return e
                            }
                            return n
                        },
                        groupBy: function(t, e) {
                            return function(t, e, r) {
                                var n = s(t),
                                    i = (f(t) ? Oe() : Tt()).asMutable();
                                t.__iterate(function(o, u) {
                                    i.update(e.call(r, o, u, t), function(t) {
                                        return (t = t || []).push(n ? [u, o] : o), t
                                    })
                                });
                                var o = Ze(t);
                                return i.map(function(e) {
                                    return Xe(t, o(e))
                                })
                            }(this, t, e)
                        },
                        has: function(t) {
                            return this.get(t, m) !== m
                        },
                        hasIn: function(t) {
                            return this.getIn(t, m) !== m
                        },
                        isSubset: function(t) {
                            return t = "function" == typeof t.includes ? t : r(t), this.every(function(e) {
                                return t.includes(e)
                            })
                        },
                        isSuperset: function(t) {
                            return (t = "function" == typeof t.isSubset ? t : r(t)).isSubset(this)
                        },
                        keySeq: function() {
                            return this.toSeq().map(kr).toIndexedSeq()
                        },
                        last: function() {
                            return this.toSeq().reverse().first()
                        },
                        max: function(t) {
                            return Ve(this, t)
                        },
                        maxBy: function(t, e) {
                            return Ve(this, e, t)
                        },
                        min: function(t) {
                            return Ve(this, t ? Kr(t) : Lr)
                        },
                        minBy: function(t, e) {
                            return Ve(this, e ? Kr(e) : Lr, t)
                        },
                        rest: function() {
                            return this.slice(1)
                        },
                        skip: function(t) {
                            return this.slice(Math.max(0, t))
                        },
                        skipLast: function(t) {
                            return Xe(this, this.toSeq().reverse().skip(t).reverse())
                        },
                        skipWhile: function(t, e) {
                            return Xe(this, Ne(this, t, e, !0))
                        },
                        skipUntil: function(t, e) {
                            return this.skipWhile(jr(t), e)
                        },
                        sortBy: function(t, e) {
                            return Xe(this, He(this, e, t))
                        },
                        take: function(t) {
                            return this.slice(0, Math.max(0, t))
                        },
                        takeLast: function(t) {
                            return Xe(this, this.toSeq().reverse().take(t).reverse())
                        },
                        takeWhile: function(t, e) {
                            return Xe(this, function(t, e, r) {
                                var n = $e(t);
                                return n.__iterateUncached = function(n, i) {
                                    var o = this;
                                    if (i) return this.cacheResult().__iterate(n, i);
                                    var u = 0;
                                    return t.__iterate(function(t, i, s) {
                                        return e.call(r, t, i, s) && ++u && n(t, i, o)
                                    }), u
                                }, n.__iteratorUncached = function(n, i) {
                                    var o = this;
                                    if (i) return this.cacheResult().__iterator(n, i);
                                    var u = t.__iterator(K, i),
                                        s = !0;
                                    return new T(function() {
                                        if (!s) return {
                                            value: void 0,
                                            done: !0
                                        };
                                        var t = u.next();
                                        if (t.done) return t;
                                        var i = t.value,
                                            a = i[0],
                                            h = i[1];
                                        return e.call(r, h, a, o) ? n === K ? t : W(n, a, h, t) : (s = !1, {
                                            value: void 0,
                                            done: !0
                                        })
                                    })
                                }, n
                            }(this, t, e))
                        },
                        takeUntil: function(t, e) {
                            return this.takeWhile(jr(t), e)
                        },
                        valueSeq: function() {
                            return this.toIndexedSeq()
                        },
                        hashCode: function() {
                            return this.__hash || (this.__hash = function(t) {
                                if (t.size === 1 / 0) return 0;
                                var e = f(t),
                                    r = s(t),
                                    n = e ? 1 : 0;
                                return function(t, e) {
                                    return e = It(e, 3432918353), e = It(e << 15 | e >>> -15, 461845907), e = It(e << 13 | e >>> -13, 5), e = It((e = (e + 3864292196 | 0) ^ t) ^ e >>> 16, 2246822507), e = bt((e = It(e ^ e >>> 13, 3266489909)) ^ e >>> 16)
                                }(t.__iterate(r ? e ? function(t, e) {
                                    n = 31 * n + Tr(qt(t), qt(e)) | 0
                                } : function(t, e) {
                                    n = n + Tr(qt(t), qt(e)) | 0
                                } : e ? function(t) {
                                    n = 31 * n + qt(t) | 0
                                } : function(t) {
                                    n = n + qt(t) | 0
                                }), n)
                            }(this))
                        }
                    });
                    var Or = r.prototype;
                    Or[c] = !0, Or[L] = Or.values, Or.__toJS = Or.toArray, Or.__toStringMapper = Rr, Or.inspect = Or.toSource = function() {
                            return this.toString()
                        }, Or.chain = Or.flatMap, Or.contains = Or.includes,
                        function() {
                            try {
                                Object.defineProperty(Or, "length", {
                                    get: function() {
                                        if (!r.noLengthWarning) {
                                            var t;
                                            try {
                                                throw new Error
                                            } catch (e) {
                                                t = e.stack
                                            }
                                            if (-1 === t.indexOf("_wrapObject")) return console && console.warn && console.warn("iterable.length has been deprecated, use iterable.size or iterable.count(). This warning will become a silent error in a future version. " + t), this.size
                                        }
                                    }
                                })
                            } catch (t) {}
                        }(), Er(n, {
                            flip: function() {
                                return Xe(this, Te(this))
                            },
                            findKey: function(t, e) {
                                var r = this.findEntry(t, e);
                                return r && r[0]
                            },
                            findLastKey: function(t, e) {
                                return this.toSeq().reverse().findKey(t, e)
                            },
                            keyOf: function(t) {
                                return this.findKey(function(e) {
                                    return lt(e, t)
                                })
                            },
                            lastKeyOf: function(t) {
                                return this.findLastKey(function(e) {
                                    return lt(e, t)
                                })
                            },
                            mapEntries: function(t, e) {
                                var r = this,
                                    n = 0;
                                return Xe(this, this.toSeq().map(function(i, o) {
                                    return t.call(e, [o, i], n++, r)
                                }).fromEntrySeq())
                            },
                            mapKeys: function(t, e) {
                                var r = this;
                                return Xe(this, this.toSeq().flip().map(function(n, i) {
                                    return t.call(e, n, i, r)
                                }).flip())
                            }
                        });
                    var xr = n.prototype;
                    return xr[_] = !0, xr[L] = Or.entries, xr.__toJS = Or.toObject, xr.__toStringMapper = function(t, e) {
                        return JSON.stringify(e) + ": " + Rr(t)
                    }, Er(i, {
                        toKeyedSeq: function() {
                            return new Ke(this, (!1))
                        },
                        filter: function(t, e) {
                            return Xe(this, Ce(this, t, e, !1))
                        },
                        findIndex: function(t, e) {
                            var r = this.findEntry(t, e);
                            return r ? r[0] : -1
                        },
                        indexOf: function(t) {
                            var e = this.toKeyedSeq().keyOf(t);
                            return void 0 === e ? -1 : e
                        },
                        lastIndexOf: function(t) {
                            var e = this.toKeyedSeq().reverse().keyOf(t);
                            return void 0 === e ? -1 : e
                        },
                        reverse: function() {
                            return Xe(this, Be(this, !1))
                        },
                        slice: function(t, e) {
                            return Xe(this, Je(this, t, e, !1))
                        },
                        splice: function(t, e) {
                            var r = arguments.length;
                            if (e = Math.max(0 | e, 0), 0 === r || 2 === r && !e) return this;
                            t = O(t, t < 0 ? this.count() : this.size);
                            var n = this.slice(0, t);
                            return Xe(this, 1 === r ? n : n.concat(b(arguments, 2), this.slice(t + e)))
                        },
                        findLastIndex: function(t, e) {
                            var r = this.toKeyedSeq().findLastKey(t, e);
                            return void 0 === r ? -1 : r
                        },
                        first: function() {
                            return this.get(0)
                        },
                        flatten: function(t) {
                            return Xe(this, Pe(this, t, !1))
                        },
                        get: function(t, e) {
                            return (t = D(this, t)) < 0 || this.size === 1 / 0 || void 0 !== this.size && t > this.size ? e : this.find(function(e, r) {
                                return r === t
                            }, void 0, e)
                        },
                        has: function(t) {
                            return (t = D(this, t)) >= 0 && (void 0 !== this.size ? this.size === 1 / 0 || t < this.size : -1 !== this.indexOf(t))
                        },
                        interpose: function(t) {
                            return Xe(this, function(t, e) {
                                var r = $e(t);
                                return r.size = t.size && 2 * t.size - 1, r.__iterateUncached = function(r, n) {
                                    var i = this,
                                        o = 0;
                                    return t.__iterate(function(t, n) {
                                        return (!o || !1 !== r(e, o++, i)) && !1 !== r(t, o++, i)
                                    }, n), o
                                }, r.__iteratorUncached = function(r, n) {
                                    var i, o = t.__iterator(j, n),
                                        u = 0;
                                    return new T(function() {
                                        return (!i || u % 2) && (i = o.next()).done ? i : u % 2 ? W(r, u++, e) : W(r, u++, i.value, i)
                                    })
                                }, r
                            }(this, t))
                        },
                        interleave: function() {
                            var t = [this].concat(b(arguments)),
                                e = Qe(this.toSeq(), Q.of, t),
                                r = e.flatten(!0);
                            return e.size && (r.size = e.size * t.length), Xe(this, r)
                        },
                        last: function() {
                            return this.get(-1)
                        },
                        skipWhile: function(t, e) {
                            return Xe(this, Ne(this, t, e, !1))
                        },
                        zip: function() {
                            return Xe(this, Qe(this, Ur, [this].concat(b(arguments))))
                        },
                        zipWith: function(t) {
                            var e = b(arguments);
                            return e[0] = this, Xe(this, Qe(this, t, e))
                        }
                    }), i.prototype[p] = !0, i.prototype[l] = !0, Er(o, {
                        get: function(t, e) {
                            return this.has(t) ? t : e
                        },
                        includes: function(t) {
                            return this.has(t)
                        },
                        keySeq: function() {
                            return this.valueSeq()
                        }
                    }), o.prototype.has = Or.includes, Er(Y, n.prototype), Er(Q, i.prototype), Er(X, o.prototype), Er(wt, n.prototype), Er(St, i.prototype), Er(zt, o.prototype), {
                        Iterable: r,
                        Seq: V,
                        Collection: gt,
                        Map: Tt,
                        OrderedMap: Oe,
                        List: _e,
                        Stack: Sr,
                        Set: sr,
                        OrderedSet: vr,
                        Record: nr,
                        Range: mt,
                        Repeat: yt,
                        is: lt,
                        fromJS: ct
                    }
                })
            }, {}],
            157: [function(require, module, exports) {
                "use strict";

                function _classCallCheck(t, e) {
                    if (!(t instanceof e)) throw new TypeError("Cannot call a class as a function")
                }

                function getFileFromDataTransfer(t) {
                    if ("file" == t.kind) return t.getAsFile()
                }
                var PhotosMimeType = require("./PhotosMimeType"),
                    createArrayFromMixed = require("./createArrayFromMixed"),
                    emptyFunction = require("./emptyFunction"),
                    CR_LF_REGEX = new RegExp("\r\n", "g"),
                    LF_ONLY = "\n",
                    RICH_TEXT_TYPES = {
                        "text/rtf": 1,
                        "text/html": 1
                    },
                    DataTransfer = function() {
                        function t(e) {
                            _classCallCheck(this, t), this.data = e, this.types = e.types ? createArrayFromMixed(e.types) : []
                        }
                        return t.prototype.isRichText = function() {
                            return !(!this.getHTML() || !this.getText()) || !this.isImage() && this.types.some(function(t) {
                                return RICH_TEXT_TYPES[t]
                            })
                        }, t.prototype.getText = function() {
                            var t;
                            return this.data.getData && (this.types.length ? -1 != this.types.indexOf("text/plain") && (t = this.data.getData("text/plain")) : t = this.data.getData("Text")), t ? t.replace(CR_LF_REGEX, LF_ONLY) : null
                        }, t.prototype.getHTML = function() {
                            if (this.data.getData) {
                                if (!this.types.length) return this.data.getData("Text");
                                if (-1 != this.types.indexOf("text/html")) return this.data.getData("text/html")
                            }
                        }, t.prototype.isLink = function() {
                            return this.types.some(function(t) {
                                return -1 != t.indexOf("Url") || -1 != t.indexOf("text/uri-list") || t.indexOf("text/x-moz-url")
                            })
                        }, t.prototype.getLink = function() {
                            return this.data.getData ? -1 != this.types.indexOf("text/x-moz-url") ? this.data.getData("text/x-moz-url").split("\n")[0] : -1 != this.types.indexOf("text/uri-list") ? this.data.getData("text/uri-list") : this.data.getData("url") : null
                        }, t.prototype.isImage = function() {
                            var t = this.types.some(function(t) {
                                return -1 != t.indexOf("application/x-moz-file")
                            });
                            if (t) return !0;
                            for (var e = this.getFiles(), i = 0; i < e.length; i++) {
                                var a = e[i].type;
                                if (!PhotosMimeType.isImage(a)) return !1
                            }
                            return !0
                        }, t.prototype.getCount = function() {
                            return this.data.hasOwnProperty("items") ? this.data.items.length : this.data.hasOwnProperty("mozItemCount") ? this.data.mozItemCount : this.data.files ? this.data.files.length : null
                        }, t.prototype.getFiles = function() {
                            return this.data.items ? Array.prototype.slice.call(this.data.items).map(getFileFromDataTransfer).filter(emptyFunction.thatReturnsArgument) : this.data.files ? Array.prototype.slice.call(this.data.files) : []
                        }, t.prototype.hasFiles = function() {
                            return this.getFiles().length > 0
                        }, t
                    }();
                module.exports = DataTransfer
            }, {
                "./PhotosMimeType": 159,
                "./createArrayFromMixed": 173,
                "./emptyFunction": 175
            }],
            158: [function(require, module, exports) {
                "use strict";
                module.exports = {
                    BACKSPACE: 8,
                    TAB: 9,
                    RETURN: 13,
                    ALT: 18,
                    ESC: 27,
                    SPACE: 32,
                    PAGE_UP: 33,
                    PAGE_DOWN: 34,
                    END: 35,
                    HOME: 36,
                    LEFT: 37,
                    UP: 38,
                    RIGHT: 39,
                    DOWN: 40,
                    DELETE: 46,
                    COMMA: 188,
                    PERIOD: 190,
                    A: 65,
                    Z: 90,
                    ZERO: 48,
                    NUMPAD_0: 96,
                    NUMPAD_9: 105
                }
            }, {}],
            159: [function(require, module, exports) {
                "use strict";

                function getParts(e) {
                    return e.split("/")
                }
                var PhotosMimeType = {
                    isImage: function(e) {
                        return "image" === getParts(e)[0]
                    },
                    isJpeg: function(e) {
                        var t = getParts(e);
                        return PhotosMimeType.isImage(e) && ("jpeg" === t[1] || "pjpeg" === t[1])
                    }
                };
                module.exports = PhotosMimeType
            }, {}],
            160: [function(require, module, exports) {
                "use strict";

                function _isViewportScrollElement(o, e) {
                    return !!e && (o === e.documentElement || o === e.body)
                }
                var Scroll = {
                    getTop: function(o) {
                        var e = o.ownerDocument;
                        return _isViewportScrollElement(o, e) ? e.body.scrollTop || e.documentElement.scrollTop : o.scrollTop
                    },
                    setTop: function(o, e) {
                        var l = o.ownerDocument;
                        _isViewportScrollElement(o, l) ? l.body.scrollTop = l.documentElement.scrollTop = e : o.scrollTop = e
                    },
                    getLeft: function(o) {
                        var e = o.ownerDocument;
                        return _isViewportScrollElement(o, e) ? e.body.scrollLeft || e.documentElement.scrollLeft : o.scrollLeft
                    },
                    setLeft: function(o, e) {
                        var l = o.ownerDocument;
                        _isViewportScrollElement(o, l) ? l.body.scrollLeft = l.documentElement.scrollLeft = e : o.scrollLeft = e
                    }
                };
                module.exports = Scroll
            }, {}],
            161: [function(require, module, exports) {
                "use strict";

                function _isNodeScrollable(e, r) {
                    var o = Style.get(e, r);
                    return "auto" === o || "scroll" === o
                }
                var getStyleProperty = require("./getStyleProperty"),
                    Style = {
                        get: getStyleProperty,
                        getScrollParent: function(e) {
                            if (!e) return null;
                            for (var r = e.ownerDocument; e && e !== r.body;) {
                                if (_isNodeScrollable(e, "overflow") || _isNodeScrollable(e, "overflowY") || _isNodeScrollable(e, "overflowX")) return e;
                                e = e.parentNode
                            }
                            return r.defaultView || r.parentWindow
                        }
                    };
                module.exports = Style
            }, {
                "./getStyleProperty": 181
            }],
            162: [function(require, module, exports) {
                "use strict";
                var PUNCTUATION = "[.,+*?$|#{}()'\\^\\-\\[\\]\\\\\\/!@%\"~=<>_:;-----------]";
                module.exports = {
                    getPunctuation: function() {
                        return PUNCTUATION
                    }
                }
            }, {}],
            163: [function(require, module, exports) {
                "use strict";

                function _classCallCheck(t, n) {
                    if (!(t instanceof n)) throw new TypeError("Cannot call a class as a function")
                }
                var URI = function() {
                    function t(n) {
                        _classCallCheck(this, t), this._uri = n
                    }
                    return t.prototype.toString = function() {
                        return this._uri
                    }, t
                }();
                module.exports = URI
            }, {}],
            164: [function(require, module, exports) {
                "use strict";

                function firstStrongChar(i) {
                    var r = REGEX_STRONG.exec(i);
                    return null == r ? null : r[0]
                }

                function firstStrongCharDir(i) {
                    var r = firstStrongChar(i);
                    return null == r ? UnicodeBidiDirection.NEUTRAL : REGEX_RTL.exec(r) ? UnicodeBidiDirection.RTL : UnicodeBidiDirection.LTR
                }

                function resolveBlockDir(i, r) {
                    if (r = r || UnicodeBidiDirection.NEUTRAL, !i.length) return r;
                    var n = firstStrongCharDir(i);
                    return n === UnicodeBidiDirection.NEUTRAL ? r : n
                }

                function getDirection(i, r) {
                    return r || (r = UnicodeBidiDirection.getGlobalDir()), UnicodeBidiDirection.isStrong(r) || invariant(!1), resolveBlockDir(i, r)
                }

                function isDirectionLTR(i, r) {
                    return getDirection(i, r) === UnicodeBidiDirection.LTR
                }

                function isDirectionRTL(i, r) {
                    return getDirection(i, r) === UnicodeBidiDirection.RTL
                }
                var UnicodeBidiDirection = require("./UnicodeBidiDirection"),
                    invariant = require("./invariant"),
                    RANGE_BY_BIDI_TYPE = {
                        L: "A-Za-z-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------",
                        R: "----------------------",
                        AL: "------------------------------"
                    },
                    REGEX_STRONG = new RegExp("[" + RANGE_BY_BIDI_TYPE.L + RANGE_BY_BIDI_TYPE.R + RANGE_BY_BIDI_TYPE.AL + "]"),
                    REGEX_RTL = new RegExp("[" + RANGE_BY_BIDI_TYPE.R + RANGE_BY_BIDI_TYPE.AL + "]"),
                    UnicodeBidi = {
                        firstStrongChar: firstStrongChar,
                        firstStrongCharDir: firstStrongCharDir,
                        resolveBlockDir: resolveBlockDir,
                        getDirection: getDirection,
                        isDirectionLTR: isDirectionLTR,
                        isDirectionRTL: isDirectionRTL
                    };
                module.exports = UnicodeBidi
            }, {
                "./UnicodeBidiDirection": 165,
                "./invariant": 185
            }],
            165: [function(require, module, exports) {
                "use strict";

                function isStrong(i) {
                    return i === LTR || i === RTL
                }

                function getHTMLDir(i) {
                    return isStrong(i) || invariant(!1), i === LTR ? "ltr" : "rtl"
                }

                function getHTMLDirIfDifferent(i, r) {
                    return isStrong(i) || invariant(!1), isStrong(r) || invariant(!1), i === r ? null : getHTMLDir(i)
                }

                function setGlobalDir(i) {
                    globalDir = i
                }

                function initGlobalDir() {
                    setGlobalDir(LTR)
                }

                function getGlobalDir() {
                    return globalDir || this.initGlobalDir(), globalDir || invariant(!1), globalDir
                }
                var invariant = require("./invariant"),
                    NEUTRAL = "NEUTRAL",
                    LTR = "LTR",
                    RTL = "RTL",
                    globalDir = null,
                    UnicodeBidiDirection = {
                        NEUTRAL: NEUTRAL,
                        LTR: LTR,
                        RTL: RTL,
                        isStrong: isStrong,
                        getHTMLDir: getHTMLDir,
                        getHTMLDirIfDifferent: getHTMLDirIfDifferent,
                        setGlobalDir: setGlobalDir,
                        initGlobalDir: initGlobalDir,
                        getGlobalDir: getGlobalDir
                    };
                module.exports = UnicodeBidiDirection
            }, {
                "./invariant": 185
            }],
            166: [function(require, module, exports) {
                "use strict";

                function _classCallCheck(i, t) {
                    if (!(i instanceof t)) throw new TypeError("Cannot call a class as a function")
                }
                var UnicodeBidi = require("./UnicodeBidi"),
                    UnicodeBidiDirection = require("./UnicodeBidiDirection"),
                    invariant = require("./invariant"),
                    UnicodeBidiService = function() {
                        function i(t) {
                            _classCallCheck(this, i), t ? UnicodeBidiDirection.isStrong(t) || invariant(!1) : t = UnicodeBidiDirection.getGlobalDir(), this._defaultDir = t, this.reset()
                        }
                        return i.prototype.reset = function() {
                            this._lastDir = this._defaultDir
                        }, i.prototype.getDirection = function(i) {
                            return this._lastDir = UnicodeBidi.getDirection(i, this._lastDir), this._lastDir
                        }, i
                    }();
                module.exports = UnicodeBidiService
            }, {
                "./UnicodeBidi": 164,
                "./UnicodeBidiDirection": 165,
                "./invariant": 185
            }],
            167: [function(require, module, exports) {
                "use strict";

                function isCodeUnitInSurrogateRange(t) {
                    return SURROGATE_HIGH_START <= t && t <= SURROGATE_LOW_END
                }

                function isSurrogatePair(t, r) {
                    if (0 <= r && r < t.length || invariant(!1), r + 1 === t.length) return !1;
                    var n = t.charCodeAt(r),
                        e = t.charCodeAt(r + 1);
                    return SURROGATE_HIGH_START <= n && n <= SURROGATE_HIGH_END && SURROGATE_LOW_START <= e && e <= SURROGATE_LOW_END
                }

                function hasSurrogateUnit(t) {
                    return SURROGATE_UNITS_REGEX.test(t)
                }

                function getUTF16Length(t, r) {
                    return 1 + isCodeUnitInSurrogateRange(t.charCodeAt(r))
                }

                function strlen(t) {
                    if (!hasSurrogateUnit(t)) return t.length;
                    for (var r = 0, n = 0; n < t.length; n += getUTF16Length(t, n)) r++;
                    return r
                }

                function substr(t, r, n) {
                    if (r = r || 0, n = void 0 === n ? 1 / 0 : n || 0, !hasSurrogateUnit(t)) return t.substr(r, n);
                    var e = t.length;
                    if (e <= 0 || r > e || n <= 0) return "";
                    var i = 0;
                    if (r > 0) {
                        for (; r > 0 && i < e; r--) i += getUTF16Length(t, i);
                        if (i >= e) return ""
                    } else if (r < 0) {
                        for (i = e; r < 0 && 0 < i; r++) i -= getUTF16Length(t, i - 1);
                        i < 0 && (i = 0)
                    }
                    var u = e;
                    if (n < e)
                        for (u = i; n > 0 && u < e; n--) u += getUTF16Length(t, u);
                    return t.substring(i, u)
                }

                function substring(t, r, n) {
                    (r = r || 0) < 0 && (r = 0), (n = void 0 === n ? 1 / 0 : n || 0) < 0 && (n = 0);
                    var e = Math.abs(n - r);
                    return substr(t, r = r < n ? r : n, e)
                }

                function getCodePoints(t) {
                    for (var r = [], n = 0; n < t.length; n += getUTF16Length(t, n)) r.push(t.codePointAt(n));
                    return r
                }
                var invariant = require("./invariant"),
                    SURROGATE_HIGH_START = 55296,
                    SURROGATE_HIGH_END = 56319,
                    SURROGATE_LOW_START = 56320,
                    SURROGATE_LOW_END = 57343,
                    SURROGATE_UNITS_REGEX = /[\uD800-\uDFFF]/,
                    UnicodeUtils = {
                        getCodePoints: getCodePoints,
                        getUTF16Length: getUTF16Length,
                        hasSurrogateUnit: hasSurrogateUnit,
                        isCodeUnitInSurrogateRange: isCodeUnitInSurrogateRange,
                        isSurrogatePair: isSurrogatePair,
                        strlen: strlen,
                        substring: substring,
                        substr: substr
                    };
                module.exports = UnicodeUtils
            }, {
                "./invariant": 185
            }],
            168: [function(require, module, exports) {
                "use strict";

                function compare(e, r, t, n) {
                    if (e === t) return !0;
                    if (!t.startsWith(e)) return !1;
                    var a = t.slice(e.length);
                    return !!r && (a = n ? n(a) : a, VersionRange.contains(a, r))
                }

                function normalizePlatformVersion(e) {
                    return "Windows" === UserAgentData.platformName ? e.replace(/^\s*NT/, "") : e
                }
                var UserAgentData = require("./UserAgentData"),
                    VersionRange = require("./VersionRange"),
                    mapObject = require("./mapObject"),
                    memoizeStringOnly = require("./memoizeStringOnly"),
                    UserAgent = {
                        isBrowser: function(e) {
                            return compare(UserAgentData.browserName, UserAgentData.browserFullVersion, e)
                        },
                        isBrowserArchitecture: function(e) {
                            return compare(UserAgentData.browserArchitecture, null, e)
                        },
                        isDevice: function(e) {
                            return compare(UserAgentData.deviceName, null, e)
                        },
                        isEngine: function(e) {
                            return compare(UserAgentData.engineName, UserAgentData.engineVersion, e)
                        },
                        isPlatform: function(e) {
                            return compare(UserAgentData.platformName, UserAgentData.platformFullVersion, e, normalizePlatformVersion)
                        },
                        isPlatformArchitecture: function(e) {
                            return compare(UserAgentData.platformArchitecture, null, e)
                        }
                    };
                module.exports = mapObject(UserAgent, memoizeStringOnly)
            }, {
                "./UserAgentData": 169,
                "./VersionRange": 170,
                "./mapObject": 189,
                "./memoizeStringOnly": 190
            }],
            169: [function(require, module, exports) {
                "use strict";

                function convertPlatformName(r) {
                    return PLATFORM_MAP[r] || r
                }

                function getBrowserVersion(r) {
                    if (!r) return {
                        major: "",
                        minor: ""
                    };
                    var e = r.split(".");
                    return {
                        major: e[0],
                        minor: e[1]
                    }
                }
                var UAParser = require("ua-parser-js"),
                    UNKNOWN = "Unknown",
                    PLATFORM_MAP = {
                        "Mac OS": "Mac OS X"
                    },
                    parser = new UAParser,
                    results = parser.getResult(),
                    browserVersionData = getBrowserVersion(results.browser.version),
                    uaData = {
                        browserArchitecture: results.cpu.architecture || UNKNOWN,
                        browserFullVersion: results.browser.version || UNKNOWN,
                        browserMinorVersion: browserVersionData.minor || UNKNOWN,
                        browserName: results.browser.name || UNKNOWN,
                        browserVersion: results.browser.major || UNKNOWN,
                        deviceName: results.device.model || UNKNOWN,
                        engineName: results.engine.name || UNKNOWN,
                        engineVersion: results.engine.version || UNKNOWN,
                        platformArchitecture: results.cpu.architecture || UNKNOWN,
                        platformName: convertPlatformName(results.os.name) || UNKNOWN,
                        platformVersion: results.os.version || UNKNOWN,
                        platformFullVersion: results.os.version || UNKNOWN
                    };
                module.exports = uaData
            }, {
                "ua-parser-js": 460
            }],
            170: [function(require, module, exports) {
                "use strict";

                function checkOrExpression(e, n) {
                    var r = e.split(orRegex);
                    return r.length > 1 ? r.some(function(e) {
                        return VersionRange.contains(e, n)
                    }) : checkRangeExpression(e = r[0].trim(), n)
                }

                function checkRangeExpression(e, n) {
                    var r = e.split(rangeRegex);
                    if (r.length > 0 && r.length <= 2 || invariant(!1), 1 === r.length) return checkSimpleExpression(r[0], n);
                    var i = r[0],
                        t = r[1];
                    return isSimpleVersion(i) && isSimpleVersion(t) || invariant(!1), checkSimpleExpression(">=" + i, n) && checkSimpleExpression("<=" + t, n)
                }

                function checkSimpleExpression(e, n) {
                    if ("" === (e = e.trim())) return !0;
                    var r = n.split(componentRegex),
                        i = getModifierAndComponents(e),
                        t = i.modifier,
                        o = i.rangeComponents;
                    switch (t) {
                        case "<":
                            return checkLessThan(r, o);
                        case "<=":
                            return checkLessThanOrEqual(r, o);
                        case ">=":
                            return checkGreaterThanOrEqual(r, o);
                        case ">":
                            return checkGreaterThan(r, o);
                        case "~":
                        case "~>":
                            return checkApproximateVersion(r, o);
                        default:
                            return checkEqual(r, o)
                    }
                }

                function checkLessThan(e, n) {
                    return -1 === compareComponents(e, n)
                }

                function checkLessThanOrEqual(e, n) {
                    var r = compareComponents(e, n);
                    return -1 === r || 0 === r
                }

                function checkEqual(e, n) {
                    return 0 === compareComponents(e, n)
                }

                function checkGreaterThanOrEqual(e, n) {
                    var r = compareComponents(e, n);
                    return 1 === r || 0 === r
                }

                function checkGreaterThan(e, n) {
                    return 1 === compareComponents(e, n)
                }

                function checkApproximateVersion(e, n) {
                    var r = n.slice(),
                        i = n.slice();
                    i.length > 1 && i.pop();
                    var t = i.length - 1,
                        o = parseInt(i[t], 10);
                    return isNumber(o) && (i[t] = o + 1 + ""), checkGreaterThanOrEqual(e, r) && checkLessThan(e, i)
                }

                function getModifierAndComponents(e) {
                    var n = e.split(componentRegex),
                        r = n[0].match(modifierRegex);
                    return r || invariant(!1), {
                        modifier: r[1],
                        rangeComponents: [r[2]].concat(n.slice(1))
                    }
                }

                function isNumber(e) {
                    return !isNaN(e) && isFinite(e)
                }

                function isSimpleVersion(e) {
                    return !getModifierAndComponents(e).modifier
                }

                function zeroPad(e, n) {
                    for (var r = e.length; r < n; r++) e[r] = "0"
                }

                function normalizeVersions(e, n) {
                    zeroPad(e = e.slice(), (n = n.slice()).length);
                    for (var r = 0; r < n.length; r++) {
                        var i = n[r].match(/^[x*]$/i);
                        if (i && (n[r] = e[r] = "0", "*" === i[0] && r === n.length - 1))
                            for (var t = r; t < e.length; t++) e[t] = "0"
                    }
                    return zeroPad(n, e.length), [e, n]
                }

                function compareNumeric(e, n) {
                    var r = e.match(numericRegex)[1],
                        i = n.match(numericRegex)[1],
                        t = parseInt(r, 10),
                        o = parseInt(i, 10);
                    return isNumber(t) && isNumber(o) && t !== o ? compare(t, o) : compare(e, n)
                }

                function compare(e, n) {
                    return _typeof2(e) != _typeof2(n) && invariant(!1), e > n ? 1 : e < n ? -1 : 0
                }

                function compareComponents(e, n) {
                    for (var r = normalizeVersions(e, n), i = r[0], t = r[1], o = 0; o < t.length; o++) {
                        var c = compareNumeric(i[o], t[o]);
                        if (c) return c
                    }
                    return 0
                }
                var invariant = require("./invariant"),
                    componentRegex = /\./,
                    orRegex = /\|\|/,
                    rangeRegex = /\s+\-\s+/,
                    modifierRegex = /^(<=|<|=|>=|~>|~|>|)?\s*(.+)/,
                    numericRegex = /^(\d*)(.*)/,
                    VersionRange = {
                        contains: function(e, n) {
                            return checkOrExpression(e.trim(), n.trim())
                        }
                    };
                module.exports = VersionRange
            }, {
                "./invariant": 185
            }],
            171: [function(require, module, exports) {
                "use strict";

                function camelize(e) {
                    return e.replace(_hyphenPattern, function(e, t) {
                        return t.toUpperCase()
                    })
                }
                var _hyphenPattern = /-(.)/g;
                module.exports = camelize
            }, {}],
            172: [function(require, module, exports) {
                "use strict";

                function containsNode(o, e) {
                    return !(!o || !e) && (o === e || !isTextNode(o) && (isTextNode(e) ? containsNode(o, e.parentNode) : "contains" in o ? o.contains(e) : !!o.compareDocumentPosition && !!(16 & o.compareDocumentPosition(e))))
                }
                var isTextNode = require("./isTextNode");
                module.exports = containsNode
            }, {
                "./isTextNode": 187
            }],
            173: [function(require, module, exports) {
                "use strict";

                function toArray(r) {
                    var t = r.length;
                    if ((Array.isArray(r) || "object" != _typeof2(r) && "function" != typeof r) && invariant(!1), "number" != typeof t && invariant(!1), 0 === t || t - 1 in r || invariant(!1), "function" == typeof r.callee && invariant(!1), r.hasOwnProperty) try {
                        return Array.prototype.slice.call(r)
                    } catch (r) {}
                    for (var e = Array(t), a = 0; a < t; a++) e[a] = r[a];
                    return e
                }

                function hasArrayNature(r) {
                    return !!r && ("object" == _typeof2(r) || "function" == typeof r) && "length" in r && !("setInterval" in r) && "number" != typeof r.nodeType && (Array.isArray(r) || "callee" in r || "item" in r)
                }

                function createArrayFromMixed(r) {
                    return hasArrayNature(r) ? Array.isArray(r) ? r.slice() : toArray(r) : [r]
                }
                var invariant = require("./invariant");
                module.exports = createArrayFromMixed
            }, {
                "./invariant": 185
            }],
            174: [function(require, module, exports) {
                "use strict";

                function cx(e) {
                    return "object" == _typeof2(e) ? Object.keys(e).filter(function(r) {
                        return e[r]
                    }).map(replace).join(" ") : Array.prototype.map.call(arguments, replace).join(" ")
                }

                function replace(e) {
                    return e.replace(/\//g, "-")
                }
                module.exports = cx
            }, {}],
            175: [function(require, module, exports) {
                "use strict";

                function makeEmptyFunction(t) {
                    return function() {
                        return t
                    }
                }
                var emptyFunction = function() {};
                emptyFunction.thatReturns = makeEmptyFunction, emptyFunction.thatReturnsFalse = makeEmptyFunction(!1), emptyFunction.thatReturnsTrue = makeEmptyFunction(!0), emptyFunction.thatReturnsNull = makeEmptyFunction(null), emptyFunction.thatReturnsThis = function() {
                    return this
                }, emptyFunction.thatReturnsArgument = function(t) {
                    return t
                }, module.exports = emptyFunction
            }, {}],
            176: [function(require, module, exports) {
                "use strict";

                function getActiveElement(e) {
                    if (void 0 === (e = e || ("undefined" != typeof document ? document : void 0))) return null;
                    try {
                        return e.activeElement || e.body
                    } catch (t) {
                        return e.body
                    }
                }
                module.exports = getActiveElement
            }, {}],
            177: [function(require, module, exports) {
                "use strict";

                function getDocumentScrollElement(e) {
                    return (e = e || document).scrollingElement ? e.scrollingElement : isWebkit || "CSS1Compat" !== e.compatMode ? e.body : e.documentElement
                }
                var isWebkit = "undefined" != typeof navigator && navigator.userAgent.indexOf("AppleWebKit") > -1;
                module.exports = getDocumentScrollElement
            }, {}],
            178: [function(require, module, exports) {
                "use strict";

                function getElementPosition(t) {
                    var e = getElementRect(t);
                    return {
                        x: e.left,
                        y: e.top,
                        width: e.right - e.left,
                        height: e.bottom - e.top
                    }
                }
                var getElementRect = require("./getElementRect");
                module.exports = getElementPosition
            }, {
                "./getElementRect": 179
            }],
            179: [function(require, module, exports) {
                "use strict";

                function getElementRect(t) {
                    var e = t.ownerDocument.documentElement;
                    if (!("getBoundingClientRect" in t && containsNode(e, t))) return {
                        left: 0,
                        right: 0,
                        top: 0,
                        bottom: 0
                    };
                    var n = t.getBoundingClientRect();
                    return {
                        left: Math.round(n.left) - e.clientLeft,
                        right: Math.round(n.right) - e.clientLeft,
                        top: Math.round(n.top) - e.clientTop,
                        bottom: Math.round(n.bottom) - e.clientTop
                    }
                }
                var containsNode = require("./containsNode");
                module.exports = getElementRect
            }, {
                "./containsNode": 172
            }],
            180: [function(require, module, exports) {
                "use strict";

                function getScrollPosition(e) {
                    var t = getDocumentScrollElement(e.ownerDocument || e.document);
                    e.Window && e instanceof e.Window && (e = t);
                    var o = getUnboundedScrollPosition(e),
                        n = e === t ? e.ownerDocument.documentElement : e,
                        l = e.scrollWidth - n.clientWidth,
                        i = e.scrollHeight - n.clientHeight;
                    return o.x = Math.max(0, Math.min(o.x, l)), o.y = Math.max(0, Math.min(o.y, i)), o
                }
                var getDocumentScrollElement = require("./getDocumentScrollElement"),
                    getUnboundedScrollPosition = require("./getUnboundedScrollPosition");
                module.exports = getScrollPosition
            }, {
                "./getDocumentScrollElement": 177,
                "./getUnboundedScrollPosition": 182
            }],
            181: [function(require, module, exports) {
                "use strict";

                function asString(e) {
                    return null == e ? e : String(e)
                }

                function getStyleProperty(e, t) {
                    var r = void 0;
                    if (window.getComputedStyle && (r = window.getComputedStyle(e, null))) return asString(r.getPropertyValue(hyphenate(t)));
                    if (document.defaultView && document.defaultView.getComputedStyle) {
                        if (r = document.defaultView.getComputedStyle(e, null)) return asString(r.getPropertyValue(hyphenate(t)));
                        if ("display" === t) return "none"
                    }
                    return asString(e.currentStyle ? "float" === t ? e.currentStyle.cssFloat || e.currentStyle.styleFloat : e.currentStyle[camelize(t)] : e.style && e.style[camelize(t)])
                }
                var camelize = require("./camelize"),
                    hyphenate = require("./hyphenate");
                module.exports = getStyleProperty
            }, {
                "./camelize": 171,
                "./hyphenate": 184
            }],
            182: [function(require, module, exports) {
                "use strict";

                function getUnboundedScrollPosition(o) {
                    return o.Window && o instanceof o.Window ? {
                        x: o.pageXOffset || o.document.documentElement.scrollLeft,
                        y: o.pageYOffset || o.document.documentElement.scrollTop
                    } : {
                        x: o.scrollLeft,
                        y: o.scrollTop
                    }
                }
                module.exports = getUnboundedScrollPosition
            }, {}],
            183: [function(require, module, exports) {
                "use strict";

                function getViewportWidth() {
                    var t = void 0;
                    return document.documentElement && (t = document.documentElement.clientWidth), !t && document.body && (t = document.body.clientWidth), t || 0
                }

                function getViewportHeight() {
                    var t = void 0;
                    return document.documentElement && (t = document.documentElement.clientHeight), !t && document.body && (t = document.body.clientHeight), t || 0
                }

                function getViewportDimensions() {
                    return {
                        width: window.innerWidth || getViewportWidth(),
                        height: window.innerHeight || getViewportHeight()
                    }
                }
                getViewportDimensions.withoutScrollbars = function() {
                    return {
                        width: getViewportWidth(),
                        height: getViewportHeight()
                    }
                }, module.exports = getViewportDimensions
            }, {}],
            184: [function(require, module, exports) {
                "use strict";

                function hyphenate(e) {
                    return e.replace(_uppercasePattern, "-$1").toLowerCase()
                }
                var _uppercasePattern = /([A-Z])/g;
                module.exports = hyphenate
            }, {}],
            185: [function(require, module, exports) {
                "use strict";

                function invariant(e, n, r, i, a, o, t, d) {
                    if (validateFormat(n), !e) {
                        var f;
                        if (void 0 === n) f = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
                        else {
                            var l = [r, i, a, o, t, d],
                                v = 0;
                            (f = new Error(n.replace(/%s/g, function() {
                                return l[v++]
                            }))).name = "Invariant Violation"
                        }
                        throw f.framesToPop = 1, f
                    }
                }
                var validateFormat = function(e) {};
                module.exports = invariant
            }, {}],
            186: [function(require, module, exports) {
                "use strict";

                function isNode(e) {
                    var o = (e ? e.ownerDocument || e : document).defaultView || window;
                    return !(!e || !("function" == typeof o.Node ? e instanceof o.Node : "object" == _typeof2(e) && "number" == typeof e.nodeType && "string" == typeof e.nodeName))
                }
                module.exports = isNode
            }, {}],
            187: [function(require, module, exports) {
                "use strict";

                function isTextNode(e) {
                    return isNode(e) && 3 == e.nodeType
                }
                var isNode = require("./isNode");
                module.exports = isTextNode
            }, {
                "./isNode": 186
            }],
            188: [function(require, module, exports) {
                "use strict";

                function joinClasses(s) {
                    s || (s = "");
                    var e = void 0,
                        o = arguments.length;
                    if (o > 1)
                        for (var r = 1; r < o; r++)(e = arguments[r]) && (s = (s ? s + " " : "") + e);
                    return s
                }
                module.exports = joinClasses
            }, {}],
            189: [function(require, module, exports) {
                "use strict";

                function mapObject(r, t, e) {
                    if (!r) return null;
                    var a = {};
                    for (var n in r) hasOwnProperty.call(r, n) && (a[n] = t.call(e, r[n], n, r));
                    return a
                }
                var hasOwnProperty = Object.prototype.hasOwnProperty;
                module.exports = mapObject
            }, {}],
            190: [function(require, module, exports) {
                "use strict";

                function memoizeStringOnly(n) {
                    var r = {};
                    return function(t) {
                        return r.hasOwnProperty(t) || (r[t] = n.call(this, t)), r[t]
                    }
                }
                module.exports = memoizeStringOnly
            }, {}],
            191: [function(require, module, exports) {
                "use strict";
                var nullthrows = function(r) {
                    if (null != r) return r;
                    throw new Error("Got unexpected null or undefined")
                };
                module.exports = nullthrows
            }, {}],
            192: [function(require, module, exports) {
                (function(global) {
                    "use strict";
                    require("setimmediate"), module.exports = global.setImmediate
                }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
            }, {
                setimmediate: 459
            }],
            193: [function(require, module, exports) {
                ! function(t, e) {
                    "object" == _typeof2(exports) && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : t.Immutable = e()
                }(this, function() {
                    "use strict";

                    function e(t, e) {
                        e && (t.prototype = Object.create(e.prototype)), t.prototype.constructor = t
                    }

                    function r(t) {
                        return u(t) ? t : V(t)
                    }

                    function n(t) {
                        return s(t) ? t : Y(t)
                    }

                    function i(t) {
                        return a(t) ? t : Q(t)
                    }

                    function o(t) {
                        return u(t) && !h(t) ? t : X(t)
                    }

                    function u(t) {
                        return !(!t || !t[c])
                    }

                    function s(t) {
                        return !(!t || !t[_])
                    }

                    function a(t) {
                        return !(!t || !t[p])
                    }

                    function h(t) {
                        return s(t) || a(t)
                    }

                    function f(t) {
                        return !(!t || !t[l])
                    }

                    function S(t) {
                        return t.value = !1, t
                    }

                    function z(t) {
                        t && (t.value = !0)
                    }

                    function I() {}

                    function b(t, e) {
                        e = e || 0;
                        for (var r = Math.max(0, t.length - e), n = new Array(r), i = 0; i < r; i++) n[i] = t[i + e];
                        return n
                    }

                    function q(t) {
                        return void 0 === t.size && (t.size = t.__iterate(M)), t.size
                    }

                    function D(t, e) {
                        if ("number" != typeof e) {
                            var r = e >>> 0;
                            if ("" + r !== e || 4294967295 === r) return NaN;
                            e = r
                        }
                        return e < 0 ? q(t) + e : e
                    }

                    function M() {
                        return !0
                    }

                    function E(t, e, r) {
                        return (0 === t || void 0 !== r && t <= -r) && (void 0 === e || void 0 !== r && e >= r)
                    }

                    function O(t, e) {
                        return k(t, e, 0)
                    }

                    function x(t, e) {
                        return k(t, e, e)
                    }

                    function k(t, e, r) {
                        return void 0 === t ? r : t < 0 ? Math.max(0, e + t) : void 0 === e ? t : Math.min(e, t)
                    }

                    function T(t) {
                        this.next = t
                    }

                    function B(t, e, r, n) {
                        var i = 0 === t ? e : 1 === t ? r : [e, r];
                        return n ? n.value = i : n = {
                            value: i,
                            done: !1
                        }, n
                    }

                    function W() {
                        return {
                            value: void 0,
                            done: !0
                        }
                    }

                    function C(t) {
                        return !!P(t)
                    }

                    function J(t) {
                        return t && "function" == typeof t.next
                    }

                    function N(t) {
                        var e = P(t);
                        return e && e.call(t)
                    }

                    function P(t) {
                        var e = t && (U && t[U] || t[K]);
                        if ("function" == typeof e) return e
                    }

                    function H(t) {
                        return t && "number" == typeof t.length
                    }

                    function V(t) {
                        return null == t ? ot() : u(t) ? t.toSeq() : function(t) {
                            var e = at(t) || "object" == _typeof2(t) && new et(t);
                            if (!e) throw new TypeError("Expected Array or iterable object of values, or keyed object: " + t);
                            return e
                        }(t)
                    }

                    function Y(t) {
                        return null == t ? ot().toKeyedSeq() : u(t) ? s(t) ? t.toSeq() : t.fromEntrySeq() : ut(t)
                    }

                    function Q(t) {
                        return null == t ? ot() : u(t) ? s(t) ? t.entrySeq() : t.toIndexedSeq() : st(t)
                    }

                    function X(t) {
                        return (null == t ? ot() : u(t) ? s(t) ? t.entrySeq() : t : st(t)).toSetSeq()
                    }

                    function tt(t) {
                        this._array = t, this.size = t.length
                    }

                    function et(t) {
                        var e = Object.keys(t);
                        this._object = t, this._keys = e, this.size = e.length
                    }

                    function rt(t) {
                        this._iterable = t, this.size = t.length || t.size
                    }

                    function nt(t) {
                        this._iterator = t, this._iteratorCache = []
                    }

                    function it(t) {
                        return !(!t || !t[$])
                    }

                    function ot() {
                        return F || (F = new tt([]))
                    }

                    function ut(t) {
                        var e = Array.isArray(t) ? new tt(t).fromEntrySeq() : J(t) ? new nt(t).fromEntrySeq() : C(t) ? new rt(t).fromEntrySeq() : "object" == _typeof2(t) ? new et(t) : void 0;
                        if (!e) throw new TypeError("Expected Array or iterable object of [k, v] entries, or keyed object: " + t);
                        return e
                    }

                    function st(t) {
                        var e = at(t);
                        if (!e) throw new TypeError("Expected Array or iterable object of values: " + t);
                        return e
                    }

                    function at(t) {
                        return H(t) ? new tt(t) : J(t) ? new nt(t) : C(t) ? new rt(t) : void 0
                    }

                    function ht(t, e, r, n) {
                        var i = t._cache;
                        if (i) {
                            for (var o = i.length - 1, u = 0; u <= o; u++) {
                                var s = i[r ? o - u : u];
                                if (!1 === e(s[1], n ? s[0] : u, t)) return u + 1
                            }
                            return u
                        }
                        return t.__iterateUncached(e, r)
                    }

                    function ft(t, e, r, n) {
                        var i = t._cache;
                        if (i) {
                            var o = i.length - 1,
                                u = 0;
                            return new T(function() {
                                var t = i[r ? o - u : u];
                                return u++ > o ? {
                                    value: void 0,
                                    done: !0
                                } : B(e, n ? t[0] : u - 1, t[1])
                            })
                        }
                        return t.__iteratorUncached(e, r)
                    }

                    function ct(t, e) {
                        return e ? function t(e, r, n, i) {
                            return Array.isArray(r) ? e.call(i, n, Q(r).map(function(n, i) {
                                return t(e, n, i, r)
                            })) : pt(r) ? e.call(i, n, Y(r).map(function(n, i) {
                                return t(e, n, i, r)
                            })) : r
                        }(e, t, "", {
                            "": t
                        }) : _t(t)
                    }

                    function _t(t) {
                        return Array.isArray(t) ? Q(t).map(_t).toList() : pt(t) ? Y(t).map(_t).toMap() : t
                    }

                    function pt(t) {
                        return t && (t.constructor === Object || void 0 === t.constructor)
                    }

                    function lt(t, e) {
                        if (t === e || t != t && e != e) return !0;
                        if (!t || !e) return !1;
                        if ("function" == typeof t.valueOf && "function" == typeof e.valueOf) {
                            if ((t = t.valueOf()) === (e = e.valueOf()) || t != t && e != e) return !0;
                            if (!t || !e) return !1
                        }
                        return !("function" != typeof t.equals || "function" != typeof e.equals || !t.equals(e))
                    }

                    function vt(t, e) {
                        if (t === e) return !0;
                        if (!u(e) || void 0 !== t.size && void 0 !== e.size && t.size !== e.size || void 0 !== t.__hash && void 0 !== e.__hash && t.__hash !== e.__hash || s(t) !== s(e) || a(t) !== a(e) || f(t) !== f(e)) return !1;
                        if (0 === t.size && 0 === e.size) return !0;
                        var r = !h(t);
                        if (f(t)) {
                            var n = t.entries();
                            return e.every(function(t, e) {
                                var i = n.next().value;
                                return i && lt(i[1], t) && (r || lt(i[0], e))
                            }) && n.next().done
                        }
                        var i = !1;
                        if (void 0 === t.size)
                            if (void 0 === e.size) "function" == typeof t.cacheResult && t.cacheResult();
                            else {
                                i = !0;
                                var o = t;
                                t = e, e = o
                            } var c = !0,
                            _ = e.__iterate(function(e, n) {
                                if (r ? !t.has(e) : i ? !lt(e, t.get(n, m)) : !lt(t.get(n, m), e)) return c = !1, !1
                            });
                        return c && t.size === _
                    }

                    function yt(t, e) {
                        if (!(this instanceof yt)) return new yt(t, e);
                        if (this._value = t, this.size = void 0 === e ? 1 / 0 : Math.max(0, e), 0 === this.size) {
                            if (G) return G;
                            G = this
                        }
                    }

                    function dt(t, e) {
                        if (!t) throw new Error(e)
                    }

                    function mt(t, e, r) {
                        if (!(this instanceof mt)) return new mt(t, e, r);
                        if (dt(0 !== r, "Cannot step a Range by 0"), t = t || 0, void 0 === e && (e = 1 / 0), r = void 0 === r ? 1 : Math.abs(r), e < t && (r = -r), this._start = t, this._end = e, this._step = r, this.size = Math.max(0, Math.ceil((e - t) / r - 1) + 1), 0 === this.size) {
                            if (Z) return Z;
                            Z = this
                        }
                    }

                    function gt() {
                        throw TypeError("Abstract")
                    }

                    function wt() {}

                    function St() {}

                    function zt() {}

                    function bt(t) {
                        return t >>> 1 & 1073741824 | 3221225471 & t
                    }

                    function qt(t) {
                        if (!1 === t || null == t) return 0;
                        if ("function" == typeof t.valueOf && (!1 === (t = t.valueOf()) || null == t)) return 0;
                        if (!0 === t) return 1;
                        var e = _typeof2(t);
                        if ("number" === e) {
                            if (t != t || t === 1 / 0) return 0;
                            var r = 0 | t;
                            for (r !== t && (r ^= 4294967295 * t); t > 4294967295;) r ^= t /= 4294967295;
                            return bt(r)
                        }
                        if ("string" === e) return t.length > jt ? function(t) {
                            var e = Kt[t];
                            return void 0 === e && (e = Dt(t), Ut === Rt && (Ut = 0, Kt = {}), Ut++, Kt[t] = e), e
                        }(t) : Dt(t);
                        if ("function" == typeof t.hashCode) return t.hashCode();
                        if ("object" === e) return function(t) {
                            var e;
                            if (xt && void 0 !== (e = Ot.get(t))) return e;
                            if (void 0 !== (e = t[At])) return e;
                            if (!Et) {
                                if (void 0 !== (e = t.propertyIsEnumerable && t.propertyIsEnumerable[At])) return e;
                                if (void 0 !== (e = function(t) {
                                        if (t && t.nodeType > 0) switch (t.nodeType) {
                                            case 1:
                                                return t.uniqueID;
                                            case 9:
                                                return t.documentElement && t.documentElement.uniqueID
                                        }
                                    }(t))) return e
                            }
                            if (e = ++kt, 1073741824 & kt && (kt = 0), xt) Ot.set(t, e);
                            else {
                                if (void 0 !== Mt && !1 === Mt(t)) throw new Error("Non-extensible objects are not allowed as keys.");
                                if (Et) Object.defineProperty(t, At, {
                                    enumerable: !1,
                                    configurable: !1,
                                    writable: !1,
                                    value: e
                                });
                                else if (void 0 !== t.propertyIsEnumerable && t.propertyIsEnumerable === t.constructor.prototype.propertyIsEnumerable) t.propertyIsEnumerable = function() {
                                    return this.constructor.prototype.propertyIsEnumerable.apply(this, arguments)
                                }, t.propertyIsEnumerable[At] = e;
                                else {
                                    if (void 0 === t.nodeType) throw new Error("Unable to set a non-enumerable property on object.");
                                    t[At] = e
                                }
                            }
                            return e
                        }(t);
                        if ("function" == typeof t.toString) return Dt(t.toString());
                        throw new Error("Value type " + e + " cannot be hashed.")
                    }

                    function Dt(t) {
                        for (var e = 0, r = 0; r < t.length; r++) e = 31 * e + t.charCodeAt(r) | 0;
                        return bt(e)
                    }

                    function Lt(t) {
                        dt(t !== 1 / 0, "Cannot perform this action with an infinite size.")
                    }

                    function Tt(t) {
                        return null == t ? Zt() : Bt(t) && !f(t) ? t : Zt().withMutations(function(e) {
                            var r = n(t);
                            Lt(r.size), r.forEach(function(t, r) {
                                return e.set(r, t)
                            })
                        })
                    }

                    function Bt(t) {
                        return !(!t || !t[Ct])
                    }

                    function Nt(t, e) {
                        this.ownerID = t, this.entries = e
                    }

                    function Pt(t, e, r) {
                        this.ownerID = t, this.bitmap = e, this.nodes = r
                    }

                    function Ht(t, e, r) {
                        this.ownerID = t, this.count = e, this.nodes = r
                    }

                    function Vt(t, e, r) {
                        this.ownerID = t, this.keyHash = e, this.entries = r
                    }

                    function Yt(t, e, r) {
                        this.ownerID = t, this.keyHash = e, this.entry = r
                    }

                    function Qt(t, e, r) {
                        this._type = e, this._reverse = r, this._stack = t._root && Ft(t._root)
                    }

                    function Xt(t, e) {
                        return B(t, e[0], e[1])
                    }

                    function Ft(t, e) {
                        return {
                            node: t,
                            index: 0,
                            __prev: e
                        }
                    }

                    function Gt(t, e, r, n) {
                        var i = Object.create(Jt);
                        return i.size = t, i._root = e, i.__ownerID = r, i.__hash = n, i.__altered = !1, i
                    }

                    function Zt() {
                        return Wt || (Wt = Gt(0))
                    }

                    function $t(t, e, r) {
                        var n, i;
                        if (t._root) {
                            var o = S(g),
                                u = S(w);
                            if (n = te(t._root, t.__ownerID, 0, void 0, e, r, o, u), !u.value) return t;
                            i = t.size + (o.value ? r === m ? -1 : 1 : 0)
                        } else {
                            if (r === m) return t;
                            i = 1, n = new Nt(t.__ownerID, [
                                [e, r]
                            ])
                        }
                        return t.__ownerID ? (t.size = i, t._root = n, t.__hash = void 0, t.__altered = !0, t) : n ? Gt(i, n) : Zt()
                    }

                    function te(t, e, r, n, i, o, u, s) {
                        return t ? t.update(e, r, n, i, o, u, s) : o === m ? t : (z(s), z(u), new Yt(e, n, [i, o]))
                    }

                    function ee(t) {
                        return t.constructor === Yt || t.constructor === Vt
                    }

                    function re(t, e, r, n, i) {
                        if (t.keyHash === n) return new Vt(e, n, [t.entry, i]);
                        var o, u = (0 === r ? t.keyHash : t.keyHash >>> r) & d,
                            s = (0 === r ? n : n >>> r) & d;
                        return new Pt(e, 1 << u | 1 << s, u === s ? [re(t, e, r + v, n, i)] : (o = new Yt(e, n, i), u < s ? [t, o] : [o, t]))
                    }

                    function ne(t, e, r) {
                        for (var i = [], o = 0; o < r.length; o++) {
                            var s = r[o],
                                a = n(s);
                            u(s) || (a = a.map(function(t) {
                                return ct(t)
                            })), i.push(a)
                        }
                        return ue(t, e, i)
                    }

                    function ie(t, e, r) {
                        return t && t.mergeDeep && u(e) ? t.mergeDeep(e) : lt(t, e) ? t : e
                    }

                    function oe(t) {
                        return function(e, r, n) {
                            if (e && e.mergeDeepWith && u(r)) return e.mergeDeepWith(t, r);
                            var i = t(e, r, n);
                            return lt(e, i) ? e : i
                        }
                    }

                    function ue(t, e, r) {
                        return 0 === (r = r.filter(function(t) {
                            return 0 !== t.size
                        })).length ? t : 0 !== t.size || t.__ownerID || 1 !== r.length ? t.withMutations(function(t) {
                            for (var n = e ? function(r, n) {
                                    t.update(n, m, function(t) {
                                        return t === m ? r : e(t, r, n)
                                    })
                                } : function(e, r) {
                                    t.set(r, e)
                                }, i = 0; i < r.length; i++) r[i].forEach(n)
                        }) : t.constructor(r[0])
                    }

                    function se(t) {
                        return t = (t = (858993459 & (t -= t >> 1 & 1431655765)) + (t >> 2 & 858993459)) + (t >> 4) & 252645135, t += t >> 8, 127 & (t += t >> 16)
                    }

                    function ae(t, e, r, n) {
                        var i = n ? t : b(t);
                        return i[e] = r, i
                    }

                    function _e(t) {
                        var e = ze();
                        if (null == t) return e;
                        if (pe(t)) return t;
                        var r = i(t),
                            n = r.size;
                        return 0 === n ? e : (Lt(n), n > 0 && n < y ? Se(0, n, v, null, new ye(r.toArray())) : e.withMutations(function(t) {
                            t.setSize(n), r.forEach(function(e, r) {
                                return t.set(r, e)
                            })
                        }))
                    }

                    function pe(t) {
                        return !(!t || !t[le])
                    }

                    function ye(t, e) {
                        this.array = t, this.ownerID = e
                    }

                    function we(t, e) {
                        function u(t, s, a) {
                            return 0 === s ? function(t, u) {
                                var s = u === i ? o && o.array : t && t.array,
                                    a = u > r ? 0 : r - u,
                                    h = n - u;
                                return h > y && (h = y),
                                    function() {
                                        if (a === h) return ge;
                                        var t = e ? --h : a++;
                                        return s && s[t]
                                    }
                            }(t, a) : function(t, i, o) {
                                var s, a = t && t.array,
                                    h = o > r ? 0 : r - o >> i,
                                    f = 1 + (n - o >> i);
                                return f > y && (f = y),
                                    function() {
                                        for (;;) {
                                            if (s) {
                                                var t = s();
                                                if (t !== ge) return t;
                                                s = null
                                            }
                                            if (h === f) return ge;
                                            var r = e ? --f : h++;
                                            s = u(a && a[r], i - v, o + (r << i))
                                        }
                                    }
                            }(t, s, a)
                        }
                        var r = t._origin,
                            n = t._capacity,
                            i = Ee(n),
                            o = t._tail;
                        return u(t._root, t._level, 0)
                    }

                    function Se(t, e, r, n, i, o, u) {
                        var s = Object.create(ve);
                        return s.size = e - t, s._origin = t, s._capacity = e, s._level = r, s._root = n, s._tail = i, s.__ownerID = o, s.__hash = u, s.__altered = !1, s
                    }

                    function ze() {
                        return de || (de = Se(0, 0, v))
                    }

                    function Ie(t, e, r, n, i, o) {
                        var u, s = n >>> r & d,
                            a = t && s < t.array.length;
                        if (!a && void 0 === i) return t;
                        if (r > 0) {
                            var h = t && t.array[s],
                                f = Ie(h, e, r - v, n, i, o);
                            return f === h ? t : ((u = be(t, e)).array[s] = f, u)
                        }
                        return a && t.array[s] === i ? t : (z(o), u = be(t, e), void 0 === i && s === u.array.length - 1 ? u.array.pop() : u.array[s] = i, u)
                    }

                    function be(t, e) {
                        return e && t && e === t.ownerID ? t : new ye(t ? t.array.slice() : [], e)
                    }

                    function qe(t, e) {
                        if (e >= Ee(t._capacity)) return t._tail;
                        if (e < 1 << t._level + v) {
                            for (var r = t._root, n = t._level; r && n > 0;) r = r.array[e >>> n & d], n -= v;
                            return r
                        }
                    }

                    function De(t, e, r) {
                        void 0 !== e && (e |= 0), void 0 !== r && (r |= 0);
                        var n = t.__ownerID || new I,
                            i = t._origin,
                            o = t._capacity,
                            u = i + e,
                            s = void 0 === r ? o : r < 0 ? o + r : i + r;
                        if (u === i && s === o) return t;
                        if (u >= s) return t.clear();
                        for (var a = t._level, h = t._root, f = 0; u + f < 0;) h = new ye(h && h.array.length ? [void 0, h] : [], n), f += 1 << (a += v);
                        f && (u += f, i += f, s += f, o += f);
                        for (var c = Ee(o), _ = Ee(s); _ >= 1 << a + v;) h = new ye(h && h.array.length ? [h] : [], n), a += v;
                        var p = t._tail,
                            l = _ < c ? qe(t, s - 1) : _ > c ? new ye([], n) : p;
                        if (p && _ > c && u < o && p.array.length) {
                            for (var y = h = be(h, n), m = a; m > v; m -= v) {
                                var g = c >>> m & d;
                                y = y.array[g] = be(y.array[g], n)
                            }
                            y.array[c >>> v & d] = p
                        }
                        if (s < o && (l = l && l.removeAfter(n, 0, s)), u >= _) u -= _, s -= _, a = v, h = null, l = l && l.removeBefore(n, 0, u);
                        else if (u > i || _ < c) {
                            for (f = 0; h;) {
                                var w = u >>> a & d;
                                if (w !== _ >>> a & d) break;
                                w && (f += (1 << a) * w), a -= v, h = h.array[w]
                            }
                            h && u > i && (h = h.removeBefore(n, a, u - f)), h && _ < c && (h = h.removeAfter(n, a, _ - f)), f && (u -= f, s -= f)
                        }
                        return t.__ownerID ? (t.size = s - u, t._origin = u, t._capacity = s, t._level = a, t._root = h, t._tail = l, t.__hash = void 0, t.__altered = !0, t) : Se(u, s, a, h, l)
                    }

                    function Me(t, e, r) {
                        for (var n = [], o = 0, s = 0; s < r.length; s++) {
                            var a = r[s],
                                h = i(a);
                            h.size > o && (o = h.size), u(a) || (h = h.map(function(t) {
                                return ct(t)
                            })), n.push(h)
                        }
                        return o > t.size && (t = t.setSize(o)), ue(t, e, n)
                    }

                    function Ee(t) {
                        return t < y ? 0 : t - 1 >>> v << v
                    }

                    function Oe(t) {
                        return null == t ? Ae() : xe(t) ? t : Ae().withMutations(function(e) {
                            var r = n(t);
                            Lt(r.size), r.forEach(function(t, r) {
                                return e.set(r, t)
                            })
                        })
                    }

                    function xe(t) {
                        return Bt(t) && f(t)
                    }

                    function ke(t, e, r, n) {
                        var i = Object.create(Oe.prototype);
                        return i.size = t ? t.size : 0, i._map = t, i._list = e, i.__ownerID = r, i.__hash = n, i
                    }

                    function Ae() {
                        return me || (me = ke(Zt(), ze()))
                    }

                    function je(t, e, r) {
                        var n, i, o = t._map,
                            u = t._list,
                            s = o.get(e),
                            a = void 0 !== s;
                        if (r === m) {
                            if (!a) return t;
                            u.size >= y && u.size >= 2 * o.size ? (n = (i = u.filter(function(t, e) {
                                return void 0 !== t && s !== e
                            })).toKeyedSeq().map(function(t) {
                                return t[0]
                            }).flip().toMap(), t.__ownerID && (n.__ownerID = i.__ownerID = t.__ownerID)) : (n = o.remove(e), i = s === u.size - 1 ? u.pop() : u.set(s, void 0))
                        } else if (a) {
                            if (r === u.get(s)[1]) return t;
                            n = o, i = u.set(s, [e, r])
                        } else n = o.set(e, u.size), i = u.set(u.size, [e, r]);
                        return t.__ownerID ? (t.size = n.size, t._map = n, t._list = i, t.__hash = void 0, t) : ke(n, i)
                    }

                    function Re(t, e) {
                        this._iter = t, this._useKeys = e, this.size = t.size
                    }

                    function Ue(t) {
                        this._iter = t, this.size = t.size
                    }

                    function Ke(t) {
                        this._iter = t, this.size = t.size
                    }

                    function Le(t) {
                        this._iter = t, this.size = t.size
                    }

                    function Te(t) {
                        var e = $e(t);
                        return e._iter = t, e.size = t.size, e.flip = function() {
                            return t
                        }, e.reverse = function() {
                            var e = t.reverse.apply(this);
                            return e.flip = function() {
                                return t.reverse()
                            }, e
                        }, e.has = function(e) {
                            return t.includes(e)
                        }, e.includes = function(e) {
                            return t.has(e)
                        }, e.cacheResult = tr, e.__iterateUncached = function(e, r) {
                            var n = this;
                            return t.__iterate(function(t, r) {
                                return !1 !== e(r, t, n)
                            }, r)
                        }, e.__iteratorUncached = function(e, r) {
                            if (e === R) {
                                var n = t.__iterator(e, r);
                                return new T(function() {
                                    var t = n.next();
                                    if (!t.done) {
                                        var e = t.value[0];
                                        t.value[0] = t.value[1], t.value[1] = e
                                    }
                                    return t
                                })
                            }
                            return t.__iterator(e === j ? A : j, r)
                        }, e
                    }

                    function Be(t, e, r) {
                        var n = $e(t);
                        return n.size = t.size, n.has = function(e) {
                            return t.has(e)
                        }, n.get = function(n, i) {
                            var o = t.get(n, m);
                            return o === m ? i : e.call(r, o, n, t)
                        }, n.__iterateUncached = function(n, i) {
                            var o = this;
                            return t.__iterate(function(t, i, u) {
                                return !1 !== n(e.call(r, t, i, u), i, o)
                            }, i)
                        }, n.__iteratorUncached = function(n, i) {
                            var o = t.__iterator(R, i);
                            return new T(function() {
                                var i = o.next();
                                if (i.done) return i;
                                var u = i.value,
                                    s = u[0];
                                return B(n, s, e.call(r, u[1], s, t), i)
                            })
                        }, n
                    }

                    function We(t, e) {
                        var r = $e(t);
                        return r._iter = t, r.size = t.size, r.reverse = function() {
                            return t
                        }, t.flip && (r.flip = function() {
                            var e = Te(t);
                            return e.reverse = function() {
                                return t.flip()
                            }, e
                        }), r.get = function(r, n) {
                            return t.get(e ? r : -1 - r, n)
                        }, r.has = function(r) {
                            return t.has(e ? r : -1 - r)
                        }, r.includes = function(e) {
                            return t.includes(e)
                        }, r.cacheResult = tr, r.__iterate = function(e, r) {
                            var n = this;
                            return t.__iterate(function(t, r) {
                                return e(t, r, n)
                            }, !r)
                        }, r.__iterator = function(e, r) {
                            return t.__iterator(e, !r)
                        }, r
                    }

                    function Ce(t, e, r, n) {
                        var i = $e(t);
                        return n && (i.has = function(n) {
                            var i = t.get(n, m);
                            return i !== m && !!e.call(r, i, n, t)
                        }, i.get = function(n, i) {
                            var o = t.get(n, m);
                            return o !== m && e.call(r, o, n, t) ? o : i
                        }), i.__iterateUncached = function(i, o) {
                            var u = this,
                                s = 0;
                            return t.__iterate(function(t, o, a) {
                                if (e.call(r, t, o, a)) return s++, i(t, n ? o : s - 1, u)
                            }, o), s
                        }, i.__iteratorUncached = function(i, o) {
                            var u = t.__iterator(R, o),
                                s = 0;
                            return new T(function() {
                                for (;;) {
                                    var o = u.next();
                                    if (o.done) return o;
                                    var a = o.value,
                                        h = a[0],
                                        f = a[1];
                                    if (e.call(r, f, h, t)) return B(i, n ? h : s++, f, o)
                                }
                            })
                        }, i
                    }

                    function Je(t, e, r, n) {
                        var i = t.size;
                        if (void 0 !== e && (e |= 0), void 0 !== r && (r === 1 / 0 ? r = i : r |= 0), E(e, r, i)) return t;
                        var o = O(e, i),
                            u = x(r, i);
                        if (o != o || u != u) return Je(t.toSeq().cacheResult(), e, r, n);
                        var s, a = u - o;
                        a == a && (s = a < 0 ? 0 : a);
                        var h = $e(t);
                        return h.size = 0 === s ? s : t.size && s || void 0, !n && it(t) && s >= 0 && (h.get = function(e, r) {
                            return (e = D(this, e)) >= 0 && e < s ? t.get(e + o, r) : r
                        }), h.__iterateUncached = function(e, r) {
                            var i = this;
                            if (0 === s) return 0;
                            if (r) return this.cacheResult().__iterate(e, r);
                            var u = 0,
                                a = !0,
                                h = 0;
                            return t.__iterate(function(t, r) {
                                if (!a || !(a = u++ < o)) return h++, !1 !== e(t, n ? r : h - 1, i) && h !== s
                            }), h
                        }, h.__iteratorUncached = function(e, r) {
                            if (0 !== s && r) return this.cacheResult().__iterator(e, r);
                            var i = 0 !== s && t.__iterator(e, r),
                                u = 0,
                                a = 0;
                            return new T(function() {
                                for (; u++ < o;) i.next();
                                if (++a > s) return {
                                    value: void 0,
                                    done: !0
                                };
                                var t = i.next();
                                return n || e === j ? t : B(e, a - 1, e === A ? void 0 : t.value[1], t)
                            })
                        }, h
                    }

                    function Ne(t, e, r, n) {
                        var i = $e(t);
                        return i.__iterateUncached = function(i, o) {
                            var u = this;
                            if (o) return this.cacheResult().__iterate(i, o);
                            var s = !0,
                                a = 0;
                            return t.__iterate(function(t, o, h) {
                                if (!s || !(s = e.call(r, t, o, h))) return a++, i(t, n ? o : a - 1, u)
                            }), a
                        }, i.__iteratorUncached = function(i, o) {
                            var u = this;
                            if (o) return this.cacheResult().__iterator(i, o);
                            var s = t.__iterator(R, o),
                                a = !0,
                                h = 0;
                            return new T(function() {
                                var t, o, f;
                                do {
                                    if ((t = s.next()).done) return n || i === j ? t : B(i, h++, i === A ? void 0 : t.value[1], t);
                                    var c = t.value;
                                    o = c[0], f = c[1], a && (a = e.call(r, f, o, u))
                                } while (a);
                                return i === R ? t : B(i, o, f, t)
                            })
                        }, i
                    }

                    function Pe(t, e, r) {
                        var n = $e(t);
                        return n.__iterateUncached = function(n, i) {
                            var o = 0,
                                s = !1;
                            return function t(a, h) {
                                var f = this;
                                a.__iterate(function(i, a) {
                                    return (!e || h < e) && u(i) ? t(i, h + 1) : !1 === n(i, r ? a : o++, f) && (s = !0), !s
                                }, i)
                            }(t, 0), o
                        }, n.__iteratorUncached = function(n, i) {
                            var o = t.__iterator(n, i),
                                s = [],
                                a = 0;
                            return new T(function() {
                                for (; o;) {
                                    var t = o.next();
                                    if (!1 === t.done) {
                                        var h = t.value;
                                        if (n === R && (h = h[1]), e && !(s.length < e) || !u(h)) return r ? t : B(n, a++, h, t);
                                        s.push(o), o = h.__iterator(n, i)
                                    } else o = s.pop()
                                }
                                return {
                                    value: void 0,
                                    done: !0
                                }
                            })
                        }, n
                    }

                    function He(t, e, r) {
                        e || (e = er);
                        var n = s(t),
                            i = 0,
                            o = t.toSeq().map(function(e, n) {
                                return [n, e, i++, r ? r(e, n, t) : e]
                            }).toArray();
                        return o.sort(function(t, r) {
                            return e(t[3], r[3]) || t[2] - r[2]
                        }).forEach(n ? function(t, e) {
                            o[e].length = 2
                        } : function(t, e) {
                            o[e] = t[1]
                        }), n ? Y(o) : a(t) ? Q(o) : X(o)
                    }

                    function Ve(t, e, r) {
                        if (e || (e = er), r) {
                            var n = t.toSeq().map(function(e, n) {
                                return [e, r(e, n, t)]
                            }).reduce(function(t, r) {
                                return Ye(e, t[1], r[1]) ? r : t
                            });
                            return n && n[0]
                        }
                        return t.reduce(function(t, r) {
                            return Ye(e, t, r) ? r : t
                        })
                    }

                    function Ye(t, e, r) {
                        var n = t(r, e);
                        return 0 === n && r !== e && (null == r || r != r) || n > 0
                    }

                    function Qe(t, e, n) {
                        var i = $e(t);
                        return i.size = new tt(n).map(function(t) {
                            return t.size
                        }).min(), i.__iterate = function(t, e) {
                            for (var r, n = this.__iterator(j, e), i = 0; !(r = n.next()).done && !1 !== t(r.value, i++, this););
                            return i
                        }, i.__iteratorUncached = function(t, i) {
                            var o = n.map(function(t) {
                                    return t = r(t), N(i ? t.reverse() : t)
                                }),
                                u = 0,
                                s = !1;
                            return new T(function() {
                                var r;
                                return s || (r = o.map(function(t) {
                                    return t.next()
                                }), s = r.some(function(t) {
                                    return t.done
                                })), s ? {
                                    value: void 0,
                                    done: !0
                                } : B(t, u++, e.apply(null, r.map(function(t) {
                                    return t.value
                                })))
                            })
                        }, i
                    }

                    function Xe(t, e) {
                        return it(t) ? e : t.constructor(e)
                    }

                    function Fe(t) {
                        if (t !== Object(t)) throw new TypeError("Expected [K, V] tuple: " + t)
                    }

                    function Ge(t) {
                        return Lt(t.size), q(t)
                    }

                    function Ze(t) {
                        return s(t) ? n : a(t) ? i : o
                    }

                    function $e(t) {
                        return Object.create((s(t) ? Y : a(t) ? Q : X).prototype)
                    }

                    function tr() {
                        return this._iter.cacheResult ? (this._iter.cacheResult(), this.size = this._iter.size, this) : V.prototype.cacheResult.call(this)
                    }

                    function er(t, e) {
                        return t > e ? 1 : t < e ? -1 : 0
                    }

                    function rr(t) {
                        var e = N(t);
                        if (!e) {
                            if (!H(t)) throw new TypeError("Expected iterable or array-like: " + t);
                            e = N(r(t))
                        }
                        return e
                    }

                    function nr(t, e) {
                        var r, n = function n(o) {
                                if (o instanceof n) return o;
                                if (!(this instanceof n)) return new n(o);
                                if (!r) {
                                    r = !0;
                                    var u = Object.keys(t);
                                    ! function(t, e) {
                                        try {
                                            e.forEach(function(t, e) {
                                                Object.defineProperty(t, e, {
                                                    get: function() {
                                                        return this.get(e)
                                                    },
                                                    set: function(t) {
                                                        dt(this.__ownerID, "Cannot set on an immutable record."), this.set(e, t)
                                                    }
                                                })
                                            }.bind(void 0, t))
                                        } catch (t) {}
                                    }(i, u), i.size = u.length, i._name = e, i._keys = u, i._defaultValues = t
                                }
                                this._map = Tt(o)
                            },
                            i = n.prototype = Object.create(ir);
                        return i.constructor = n, n
                    }

                    function or(t, e, r) {
                        var n = Object.create(Object.getPrototypeOf(t));
                        return n._map = e, n.__ownerID = r, n
                    }

                    function ur(t) {
                        return t._name || t.constructor.name || "Record"
                    }

                    function sr(t) {
                        return null == t ? lr() : ar(t) && !f(t) ? t : lr().withMutations(function(e) {
                            var r = o(t);
                            Lt(r.size), r.forEach(function(t) {
                                return e.add(t)
                            })
                        })
                    }

                    function ar(t) {
                        return !(!t || !t[fr])
                    }

                    function _r(t, e) {
                        return t.__ownerID ? (t.size = e.size, t._map = e, t) : e === t._map ? t : 0 === e.size ? t.__empty() : t.__make(e)
                    }

                    function pr(t, e) {
                        var r = Object.create(cr);
                        return r.size = t ? t.size : 0, r._map = t, r.__ownerID = e, r
                    }

                    function lr() {
                        return hr || (hr = pr(Zt()))
                    }

                    function vr(t) {
                        return null == t ? wr() : yr(t) ? t : wr().withMutations(function(e) {
                            var r = o(t);
                            Lt(r.size), r.forEach(function(t) {
                                return e.add(t)
                            })
                        })
                    }

                    function yr(t) {
                        return ar(t) && f(t)
                    }

                    function gr(t, e) {
                        var r = Object.create(mr);
                        return r.size = t ? t.size : 0, r._map = t, r.__ownerID = e, r
                    }

                    function wr() {
                        return dr || (dr = gr(Ae()))
                    }

                    function Sr(t) {
                        return null == t ? Mr() : zr(t) ? t : Mr().unshiftAll(t)
                    }

                    function zr(t) {
                        return !(!t || !t[br])
                    }

                    function Dr(t, e, r, n) {
                        var i = Object.create(qr);
                        return i.size = t, i._head = e, i.__ownerID = r, i.__hash = n, i.__altered = !1, i
                    }

                    function Mr() {
                        return Ir || (Ir = Dr(0))
                    }

                    function Er(t, e) {
                        var r = function(_r3) {
                            t.prototype[_r3] = e[_r3]
                        };
                        return Object.keys(e).forEach(r), Object.getOwnPropertySymbols && Object.getOwnPropertySymbols(e).forEach(r), t
                    }

                    function kr(t, e) {
                        return e
                    }

                    function Ar(t, e) {
                        return [e, t]
                    }

                    function jr(t) {
                        return function() {
                            return !t.apply(this, arguments)
                        }
                    }

                    function Rr(t) {
                        return function() {
                            return -t.apply(this, arguments)
                        }
                    }

                    function Ur(t) {
                        return "string" == typeof t ? JSON.stringify(t) : String(t)
                    }

                    function Kr() {
                        return b(arguments)
                    }

                    function Lr(t, e) {
                        return t < e ? 1 : t > e ? -1 : 0
                    }

                    function Tr(t, e) {
                        return t ^ e + 2654435769 + (t << 6) + (t >> 2) | 0
                    }
                    var t = Array.prototype.slice;
                    e(n, r), e(i, r), e(o, r), r.isIterable = u, r.isKeyed = s, r.isIndexed = a, r.isAssociative = h, r.isOrdered = f, r.Keyed = n, r.Indexed = i, r.Set = o;
                    var c = "@@__IMMUTABLE_ITERABLE__@@",
                        _ = "@@__IMMUTABLE_KEYED__@@",
                        p = "@@__IMMUTABLE_INDEXED__@@",
                        l = "@@__IMMUTABLE_ORDERED__@@",
                        v = 5,
                        y = 1 << v,
                        d = y - 1,
                        m = {},
                        g = {
                            value: !1
                        },
                        w = {
                            value: !1
                        },
                        A = 0,
                        j = 1,
                        R = 2,
                        U = "function" == typeof Symbol && Symbol.iterator,
                        K = "@@iterator",
                        L = U || K;
                    T.prototype.toString = function() {
                        return "[Iterator]"
                    }, T.KEYS = A, T.VALUES = j, T.ENTRIES = R, T.prototype.inspect = T.prototype.toSource = function() {
                        return this.toString()
                    }, T.prototype[L] = function() {
                        return this
                    }, e(V, r), V.of = function() {
                        return V(arguments)
                    }, V.prototype.toSeq = function() {
                        return this
                    }, V.prototype.toString = function() {
                        return this.__toString("Seq {", "}")
                    }, V.prototype.cacheResult = function() {
                        return !this._cache && this.__iterateUncached && (this._cache = this.entrySeq().toArray(), this.size = this._cache.length), this
                    }, V.prototype.__iterate = function(t, e) {
                        return ht(this, t, e, !0)
                    }, V.prototype.__iterator = function(t, e) {
                        return ft(this, t, e, !0)
                    }, e(Y, V), Y.prototype.toKeyedSeq = function() {
                        return this
                    }, e(Q, V), Q.of = function() {
                        return Q(arguments)
                    }, Q.prototype.toIndexedSeq = function() {
                        return this
                    }, Q.prototype.toString = function() {
                        return this.__toString("Seq [", "]")
                    }, Q.prototype.__iterate = function(t, e) {
                        return ht(this, t, e, !1)
                    }, Q.prototype.__iterator = function(t, e) {
                        return ft(this, t, e, !1)
                    }, e(X, V), X.of = function() {
                        return X(arguments)
                    }, X.prototype.toSetSeq = function() {
                        return this
                    }, V.isSeq = it, V.Keyed = Y, V.Set = X, V.Indexed = Q;
                    var F, G, Z, $ = "@@__IMMUTABLE_SEQ__@@";
                    V.prototype[$] = !0, e(tt, Q), tt.prototype.get = function(t, e) {
                        return this.has(t) ? this._array[D(this, t)] : e
                    }, tt.prototype.__iterate = function(t, e) {
                        for (var r = this._array, n = r.length - 1, i = 0; i <= n; i++)
                            if (!1 === t(r[e ? n - i : i], i, this)) return i + 1;
                        return i
                    }, tt.prototype.__iterator = function(t, e) {
                        var r = this._array,
                            n = r.length - 1,
                            i = 0;
                        return new T(function() {
                            return i > n ? {
                                value: void 0,
                                done: !0
                            } : B(t, i, r[e ? n - i++ : i++])
                        })
                    }, e(et, Y), et.prototype.get = function(t, e) {
                        return void 0 === e || this.has(t) ? this._object[t] : e
                    }, et.prototype.has = function(t) {
                        return this._object.hasOwnProperty(t)
                    }, et.prototype.__iterate = function(t, e) {
                        for (var r = this._object, n = this._keys, i = n.length - 1, o = 0; o <= i; o++) {
                            var u = n[e ? i - o : o];
                            if (!1 === t(r[u], u, this)) return o + 1
                        }
                        return o
                    }, et.prototype.__iterator = function(t, e) {
                        var r = this._object,
                            n = this._keys,
                            i = n.length - 1,
                            o = 0;
                        return new T(function() {
                            var u = n[e ? i - o : o];
                            return o++ > i ? {
                                value: void 0,
                                done: !0
                            } : B(t, u, r[u])
                        })
                    }, et.prototype[l] = !0, e(rt, Q), rt.prototype.__iterateUncached = function(t, e) {
                        if (e) return this.cacheResult().__iterate(t, e);
                        var r = N(this._iterable),
                            n = 0;
                        if (J(r))
                            for (var i; !(i = r.next()).done && !1 !== t(i.value, n++, this););
                        return n
                    }, rt.prototype.__iteratorUncached = function(t, e) {
                        if (e) return this.cacheResult().__iterator(t, e);
                        var r = N(this._iterable);
                        if (!J(r)) return new T(W);
                        var n = 0;
                        return new T(function() {
                            var e = r.next();
                            return e.done ? e : B(t, n++, e.value)
                        })
                    }, e(nt, Q), nt.prototype.__iterateUncached = function(t, e) {
                        if (e) return this.cacheResult().__iterate(t, e);
                        for (var r, n = this._iterator, i = this._iteratorCache, o = 0; o < i.length;)
                            if (!1 === t(i[o], o++, this)) return o;
                        for (; !(r = n.next()).done;) {
                            var u = r.value;
                            if (i[o] = u, !1 === t(u, o++, this)) break
                        }
                        return o
                    }, nt.prototype.__iteratorUncached = function(t, e) {
                        if (e) return this.cacheResult().__iterator(t, e);
                        var r = this._iterator,
                            n = this._iteratorCache,
                            i = 0;
                        return new T(function() {
                            if (i >= n.length) {
                                var e = r.next();
                                if (e.done) return e;
                                n[i] = e.value
                            }
                            return B(t, i, n[i++])
                        })
                    }, e(yt, Q), yt.prototype.toString = function() {
                        return 0 === this.size ? "Repeat []" : "Repeat [ " + this._value + " " + this.size + " times ]"
                    }, yt.prototype.get = function(t, e) {
                        return this.has(t) ? this._value : e
                    }, yt.prototype.includes = function(t) {
                        return lt(this._value, t)
                    }, yt.prototype.slice = function(t, e) {
                        var r = this.size;
                        return E(t, e, r) ? this : new yt(this._value, x(e, r) - O(t, r))
                    }, yt.prototype.reverse = function() {
                        return this
                    }, yt.prototype.indexOf = function(t) {
                        return lt(this._value, t) ? 0 : -1
                    }, yt.prototype.lastIndexOf = function(t) {
                        return lt(this._value, t) ? this.size : -1
                    }, yt.prototype.__iterate = function(t, e) {
                        for (var r = 0; r < this.size; r++)
                            if (!1 === t(this._value, r, this)) return r + 1;
                        return r
                    }, yt.prototype.__iterator = function(t, e) {
                        var r = this,
                            n = 0;
                        return new T(function() {
                            return n < r.size ? B(t, n++, r._value) : {
                                value: void 0,
                                done: !0
                            }
                        })
                    }, yt.prototype.equals = function(t) {
                        return t instanceof yt ? lt(this._value, t._value) : vt(t)
                    }, e(mt, Q), mt.prototype.toString = function() {
                        return 0 === this.size ? "Range []" : "Range [ " + this._start + "..." + this._end + (1 !== this._step ? " by " + this._step : "") + " ]"
                    }, mt.prototype.get = function(t, e) {
                        return this.has(t) ? this._start + D(this, t) * this._step : e
                    }, mt.prototype.includes = function(t) {
                        var e = (t - this._start) / this._step;
                        return e >= 0 && e < this.size && e === Math.floor(e)
                    }, mt.prototype.slice = function(t, e) {
                        return E(t, e, this.size) ? this : (t = O(t, this.size), (e = x(e, this.size)) <= t ? new mt(0, 0) : new mt(this.get(t, this._end), this.get(e, this._end), this._step))
                    }, mt.prototype.indexOf = function(t) {
                        var e = t - this._start;
                        if (e % this._step == 0) {
                            var r = e / this._step;
                            if (r >= 0 && r < this.size) return r
                        }
                        return -1
                    }, mt.prototype.lastIndexOf = function(t) {
                        return this.indexOf(t)
                    }, mt.prototype.__iterate = function(t, e) {
                        for (var r = this.size - 1, n = this._step, i = e ? this._start + r * n : this._start, o = 0; o <= r; o++) {
                            if (!1 === t(i, o, this)) return o + 1;
                            i += e ? -n : n
                        }
                        return o
                    }, mt.prototype.__iterator = function(t, e) {
                        var r = this.size - 1,
                            n = this._step,
                            i = e ? this._start + r * n : this._start,
                            o = 0;
                        return new T(function() {
                            var u = i;
                            return i += e ? -n : n, o > r ? {
                                value: void 0,
                                done: !0
                            } : B(t, o++, u)
                        })
                    }, mt.prototype.equals = function(t) {
                        return t instanceof mt ? this._start === t._start && this._end === t._end && this._step === t._step : vt(this, t)
                    }, e(gt, r), e(wt, gt), e(St, gt), e(zt, gt), gt.Keyed = wt, gt.Indexed = St, gt.Set = zt;
                    var Ot, It = "function" == typeof Math.imul && -2 === Math.imul(4294967295, 2) ? Math.imul : function(t, e) {
                            var r = 65535 & (t |= 0),
                                n = 65535 & (e |= 0);
                            return r * n + ((t >>> 16) * n + r * (e >>> 16) << 16 >>> 0) | 0
                        },
                        Mt = Object.isExtensible,
                        Et = function() {
                            try {
                                return Object.defineProperty({}, "@", {}), !0
                            } catch (t) {
                                return !1
                            }
                        }(),
                        xt = "function" == typeof WeakMap;
                    xt && (Ot = new WeakMap);
                    var kt = 0,
                        At = "__immutablehash__";
                    "function" == typeof Symbol && (At = Symbol(At));
                    var jt = 16,
                        Rt = 255,
                        Ut = 0,
                        Kt = {};
                    e(Tt, wt), Tt.of = function() {
                        var e = t.call(arguments, 0);
                        return Zt().withMutations(function(t) {
                            for (var r = 0; r < e.length; r += 2) {
                                if (r + 1 >= e.length) throw new Error("Missing value for key: " + e[r]);
                                t.set(e[r], e[r + 1])
                            }
                        })
                    }, Tt.prototype.toString = function() {
                        return this.__toString("Map {", "}")
                    }, Tt.prototype.get = function(t, e) {
                        return this._root ? this._root.get(0, void 0, t, e) : e
                    }, Tt.prototype.set = function(t, e) {
                        return $t(this, t, e)
                    }, Tt.prototype.setIn = function(t, e) {
                        return this.updateIn(t, m, function() {
                            return e
                        })
                    }, Tt.prototype.remove = function(t) {
                        return $t(this, t, m)
                    }, Tt.prototype.deleteIn = function(t) {
                        return this.updateIn(t, function() {
                            return m
                        })
                    }, Tt.prototype.update = function(t, e, r) {
                        return 1 === arguments.length ? t(this) : this.updateIn([t], e, r)
                    }, Tt.prototype.updateIn = function(t, e, r) {
                        r || (r = e, e = void 0);
                        var n = function t(e, r, n, i) {
                            var o = e === m,
                                u = r.next();
                            if (u.done) {
                                var s = o ? n : e,
                                    a = i(s);
                                return a === s ? e : a
                            }
                            dt(o || e && e.set, "invalid keyPath");
                            var h = u.value,
                                f = o ? m : e.get(h, m),
                                c = t(f, r, n, i);
                            return c === f ? e : c === m ? e.remove(h) : (o ? Zt() : e).set(h, c)
                        }(this, rr(t), e, r);
                        return n === m ? void 0 : n
                    }, Tt.prototype.clear = function() {
                        return 0 === this.size ? this : this.__ownerID ? (this.size = 0, this._root = null, this.__hash = void 0, this.__altered = !0, this) : Zt()
                    }, Tt.prototype.merge = function() {
                        return ne(this, void 0, arguments)
                    }, Tt.prototype.mergeWith = function(e) {
                        return ne(this, e, t.call(arguments, 1))
                    }, Tt.prototype.mergeIn = function(e) {
                        var r = t.call(arguments, 1);
                        return this.updateIn(e, Zt(), function(t) {
                            return "function" == typeof t.merge ? t.merge.apply(t, r) : r[r.length - 1]
                        })
                    }, Tt.prototype.mergeDeep = function() {
                        return ne(this, ie, arguments)
                    }, Tt.prototype.mergeDeepWith = function(e) {
                        var r = t.call(arguments, 1);
                        return ne(this, oe(e), r)
                    }, Tt.prototype.mergeDeepIn = function(e) {
                        var r = t.call(arguments, 1);
                        return this.updateIn(e, Zt(), function(t) {
                            return "function" == typeof t.mergeDeep ? t.mergeDeep.apply(t, r) : r[r.length - 1]
                        })
                    }, Tt.prototype.sort = function(t) {
                        return Oe(He(this, t))
                    }, Tt.prototype.sortBy = function(t, e) {
                        return Oe(He(this, e, t))
                    }, Tt.prototype.withMutations = function(t) {
                        var e = this.asMutable();
                        return t(e), e.wasAltered() ? e.__ensureOwner(this.__ownerID) : this
                    }, Tt.prototype.asMutable = function() {
                        return this.__ownerID ? this : this.__ensureOwner(new I)
                    }, Tt.prototype.asImmutable = function() {
                        return this.__ensureOwner()
                    }, Tt.prototype.wasAltered = function() {
                        return this.__altered
                    }, Tt.prototype.__iterator = function(t, e) {
                        return new Qt(this, t, e)
                    }, Tt.prototype.__iterate = function(t, e) {
                        var r = this,
                            n = 0;
                        return this._root && this._root.iterate(function(e) {
                            return n++, t(e[1], e[0], r)
                        }, e), n
                    }, Tt.prototype.__ensureOwner = function(t) {
                        return t === this.__ownerID ? this : t ? Gt(this.size, this._root, t, this.__hash) : (this.__ownerID = t, this.__altered = !1, this)
                    }, Tt.isMap = Bt;
                    var Wt, Ct = "@@__IMMUTABLE_MAP__@@",
                        Jt = Tt.prototype;
                    Jt[Ct] = !0, Jt.delete = Jt.remove, Jt.removeIn = Jt.deleteIn, Nt.prototype.get = function(t, e, r, n) {
                        for (var i = this.entries, o = 0, u = i.length; o < u; o++)
                            if (lt(r, i[o][0])) return i[o][1];
                        return n
                    }, Nt.prototype.update = function(t, e, r, n, i, o, u) {
                        for (var s = i === m, a = this.entries, h = 0, f = a.length; h < f && !lt(n, a[h][0]); h++);
                        var c = h < f;
                        if (c ? a[h][1] === i : s) return this;
                        if (z(u), (s || !c) && z(o), !s || 1 !== a.length) {
                            if (!c && !s && a.length >= he) return function(t, e, r, n) {
                                t || (t = new I);
                                for (var i = new Yt(t, qt(r), [r, n]), o = 0; o < e.length; o++) {
                                    var u = e[o];
                                    i = i.update(t, 0, void 0, u[0], u[1])
                                }
                                return i
                            }(t, a, n, i);
                            var _ = t && t === this.ownerID,
                                p = _ ? a : b(a);
                            return c ? s ? h === f - 1 ? p.pop() : p[h] = p.pop() : p[h] = [n, i] : p.push([n, i]), _ ? (this.entries = p, this) : new Nt(t, p)
                        }
                    }, Pt.prototype.get = function(t, e, r, n) {
                        void 0 === e && (e = qt(r));
                        var i = 1 << ((0 === t ? e : e >>> t) & d),
                            o = this.bitmap;
                        return 0 == (o & i) ? n : this.nodes[se(o & i - 1)].get(t + v, e, r, n)
                    }, Pt.prototype.update = function(t, e, r, n, i, o, u) {
                        void 0 === r && (r = qt(n));
                        var s = (0 === e ? r : r >>> e) & d,
                            a = 1 << s,
                            h = this.bitmap,
                            f = 0 != (h & a);
                        if (!f && i === m) return this;
                        var c = se(h & a - 1),
                            _ = this.nodes,
                            p = f ? _[c] : void 0,
                            l = te(p, t, e + v, r, n, i, o, u);
                        if (l === p) return this;
                        if (!f && l && _.length >= fe) return function(t, e, r, n, i) {
                            for (var o = 0, u = new Array(y), s = 0; 0 !== r; s++, r >>>= 1) u[s] = 1 & r ? e[o++] : void 0;
                            return u[n] = i, new Ht(t, o + 1, u)
                        }(t, _, h, s, l);
                        if (f && !l && 2 === _.length && ee(_[1 ^ c])) return _[1 ^ c];
                        if (f && l && 1 === _.length && ee(l)) return l;
                        var g = t && t === this.ownerID,
                            w = f ? l ? h : h ^ a : h | a,
                            S = f ? l ? ae(_, c, l, g) : function(t, e, r) {
                                var n = t.length - 1;
                                if (r && e === n) return t.pop(), t;
                                for (var i = new Array(n), o = 0, u = 0; u < n; u++) u === e && (o = 1), i[u] = t[u + o];
                                return i
                            }(_, c, g) : function(t, e, r, n) {
                                var i = t.length + 1;
                                if (n && e + 1 === i) return t[e] = r, t;
                                for (var o = new Array(i), u = 0, s = 0; s < i; s++) s === e ? (o[s] = r, u = -1) : o[s] = t[s + u];
                                return o
                            }(_, c, l, g);
                        return g ? (this.bitmap = w, this.nodes = S, this) : new Pt(t, w, S)
                    }, Ht.prototype.get = function(t, e, r, n) {
                        void 0 === e && (e = qt(r));
                        var i = (0 === t ? e : e >>> t) & d,
                            o = this.nodes[i];
                        return o ? o.get(t + v, e, r, n) : n
                    }, Ht.prototype.update = function(t, e, r, n, i, o, u) {
                        void 0 === r && (r = qt(n));
                        var s = (0 === e ? r : r >>> e) & d,
                            a = i === m,
                            h = this.nodes,
                            f = h[s];
                        if (a && !f) return this;
                        var c = te(f, t, e + v, r, n, i, o, u);
                        if (c === f) return this;
                        var _ = this.count;
                        if (f) {
                            if (!c && --_ < ce) return function(t, e, r, n) {
                                for (var i = 0, o = 0, u = new Array(r), s = 0, a = 1, h = e.length; s < h; s++, a <<= 1) {
                                    var f = e[s];
                                    void 0 !== f && s !== n && (i |= a, u[o++] = f)
                                }
                                return new Pt(t, i, u)
                            }(t, h, _, s)
                        } else _++;
                        var p = t && t === this.ownerID,
                            l = ae(h, s, c, p);
                        return p ? (this.count = _, this.nodes = l, this) : new Ht(t, _, l)
                    }, Vt.prototype.get = function(t, e, r, n) {
                        for (var i = this.entries, o = 0, u = i.length; o < u; o++)
                            if (lt(r, i[o][0])) return i[o][1];
                        return n
                    }, Vt.prototype.update = function(t, e, r, n, i, o, u) {
                        void 0 === r && (r = qt(n));
                        var s = i === m;
                        if (r !== this.keyHash) return s ? this : (z(u), z(o), re(this, t, e, r, [n, i]));
                        for (var a = this.entries, h = 0, f = a.length; h < f && !lt(n, a[h][0]); h++);
                        var c = h < f;
                        if (c ? a[h][1] === i : s) return this;
                        if (z(u), (s || !c) && z(o), s && 2 === f) return new Yt(t, this.keyHash, a[1 ^ h]);
                        var _ = t && t === this.ownerID,
                            p = _ ? a : b(a);
                        return c ? s ? h === f - 1 ? p.pop() : p[h] = p.pop() : p[h] = [n, i] : p.push([n, i]), _ ? (this.entries = p, this) : new Vt(t, this.keyHash, p)
                    }, Yt.prototype.get = function(t, e, r, n) {
                        return lt(r, this.entry[0]) ? this.entry[1] : n
                    }, Yt.prototype.update = function(t, e, r, n, i, o, u) {
                        var s = i === m,
                            a = lt(n, this.entry[0]);
                        return (a ? i === this.entry[1] : s) ? this : (z(u), s ? void z(o) : a ? t && t === this.ownerID ? (this.entry[1] = i, this) : new Yt(t, this.keyHash, [n, i]) : (z(o), re(this, t, e, qt(n), [n, i])))
                    }, Nt.prototype.iterate = Vt.prototype.iterate = function(t, e) {
                        for (var r = this.entries, n = 0, i = r.length - 1; n <= i; n++)
                            if (!1 === t(r[e ? i - n : n])) return !1
                    }, Pt.prototype.iterate = Ht.prototype.iterate = function(t, e) {
                        for (var r = this.nodes, n = 0, i = r.length - 1; n <= i; n++) {
                            var o = r[e ? i - n : n];
                            if (o && !1 === o.iterate(t, e)) return !1
                        }
                    }, Yt.prototype.iterate = function(t, e) {
                        return t(this.entry)
                    }, e(Qt, T), Qt.prototype.next = function() {
                        for (var t = this._type, e = this._stack; e;) {
                            var r, n = e.node,
                                i = e.index++;
                            if (n.entry) {
                                if (0 === i) return Xt(t, n.entry)
                            } else if (n.entries) {
                                if (i <= (r = n.entries.length - 1)) return Xt(t, n.entries[this._reverse ? r - i : i])
                            } else if (i <= (r = n.nodes.length - 1)) {
                                var o = n.nodes[this._reverse ? r - i : i];
                                if (o) {
                                    if (o.entry) return Xt(t, o.entry);
                                    e = this._stack = Ft(o, e)
                                }
                                continue
                            }
                            e = this._stack = this._stack.__prev
                        }
                        return {
                            value: void 0,
                            done: !0
                        }
                    };
                    var he = y / 4,
                        fe = y / 2,
                        ce = y / 4;
                    e(_e, St), _e.of = function() {
                        return this(arguments)
                    }, _e.prototype.toString = function() {
                        return this.__toString("List [", "]")
                    }, _e.prototype.get = function(t, e) {
                        if ((t = D(this, t)) >= 0 && t < this.size) {
                            var r = qe(this, t += this._origin);
                            return r && r.array[t & d]
                        }
                        return e
                    }, _e.prototype.set = function(t, e) {
                        return function(t, e, r) {
                            if ((e = D(t, e)) != e) return t;
                            if (e >= t.size || e < 0) return t.withMutations(function(t) {
                                e < 0 ? De(t, e).set(0, r) : De(t, 0, e + 1).set(e, r)
                            });
                            e += t._origin;
                            var n = t._tail,
                                i = t._root,
                                o = S(w);
                            return e >= Ee(t._capacity) ? n = Ie(n, t.__ownerID, 0, e, r, o) : i = Ie(i, t.__ownerID, t._level, e, r, o), o.value ? t.__ownerID ? (t._root = i, t._tail = n, t.__hash = void 0, t.__altered = !0, t) : Se(t._origin, t._capacity, t._level, i, n) : t
                        }(this, t, e)
                    }, _e.prototype.remove = function(t) {
                        return this.has(t) ? 0 === t ? this.shift() : t === this.size - 1 ? this.pop() : this.splice(t, 1) : this
                    }, _e.prototype.insert = function(t, e) {
                        return this.splice(t, 0, e)
                    }, _e.prototype.clear = function() {
                        return 0 === this.size ? this : this.__ownerID ? (this.size = this._origin = this._capacity = 0, this._level = v, this._root = this._tail = null, this.__hash = void 0, this.__altered = !0, this) : ze()
                    }, _e.prototype.push = function() {
                        var t = arguments,
                            e = this.size;
                        return this.withMutations(function(r) {
                            De(r, 0, e + t.length);
                            for (var n = 0; n < t.length; n++) r.set(e + n, t[n])
                        })
                    }, _e.prototype.pop = function() {
                        return De(this, 0, -1)
                    }, _e.prototype.unshift = function() {
                        var t = arguments;
                        return this.withMutations(function(e) {
                            De(e, -t.length);
                            for (var r = 0; r < t.length; r++) e.set(r, t[r])
                        })
                    }, _e.prototype.shift = function() {
                        return De(this, 1)
                    }, _e.prototype.merge = function() {
                        return Me(this, void 0, arguments)
                    }, _e.prototype.mergeWith = function(e) {
                        return Me(this, e, t.call(arguments, 1))
                    }, _e.prototype.mergeDeep = function() {
                        return Me(this, ie, arguments)
                    }, _e.prototype.mergeDeepWith = function(e) {
                        var r = t.call(arguments, 1);
                        return Me(this, oe(e), r)
                    }, _e.prototype.setSize = function(t) {
                        return De(this, 0, t)
                    }, _e.prototype.slice = function(t, e) {
                        var r = this.size;
                        return E(t, e, r) ? this : De(this, O(t, r), x(e, r))
                    }, _e.prototype.__iterator = function(t, e) {
                        var r = 0,
                            n = we(this, e);
                        return new T(function() {
                            var e = n();
                            return e === ge ? {
                                value: void 0,
                                done: !0
                            } : B(t, r++, e)
                        })
                    }, _e.prototype.__iterate = function(t, e) {
                        for (var r, n = 0, i = we(this, e);
                            (r = i()) !== ge && !1 !== t(r, n++, this););
                        return n
                    }, _e.prototype.__ensureOwner = function(t) {
                        return t === this.__ownerID ? this : t ? Se(this._origin, this._capacity, this._level, this._root, this._tail, t, this.__hash) : (this.__ownerID = t, this)
                    }, _e.isList = pe;
                    var le = "@@__IMMUTABLE_LIST__@@",
                        ve = _e.prototype;
                    ve[le] = !0, ve.delete = ve.remove, ve.setIn = Jt.setIn, ve.deleteIn = ve.removeIn = Jt.removeIn, ve.update = Jt.update, ve.updateIn = Jt.updateIn, ve.mergeIn = Jt.mergeIn, ve.mergeDeepIn = Jt.mergeDeepIn, ve.withMutations = Jt.withMutations, ve.asMutable = Jt.asMutable, ve.asImmutable = Jt.asImmutable, ve.wasAltered = Jt.wasAltered, ye.prototype.removeBefore = function(t, e, r) {
                        if (r === e ? 1 << e : 0 === this.array.length) return this;
                        var n = r >>> e & d;
                        if (n >= this.array.length) return new ye([], t);
                        var i, o = 0 === n;
                        if (e > 0) {
                            var u = this.array[n];
                            if ((i = u && u.removeBefore(t, e - v, r)) === u && o) return this
                        }
                        if (o && !i) return this;
                        var s = be(this, t);
                        if (!o)
                            for (var a = 0; a < n; a++) s.array[a] = void 0;
                        return i && (s.array[n] = i), s
                    }, ye.prototype.removeAfter = function(t, e, r) {
                        if (r === (e ? 1 << e : 0) || 0 === this.array.length) return this;
                        var n, i = r - 1 >>> e & d;
                        if (i >= this.array.length) return this;
                        if (e > 0) {
                            var o = this.array[i];
                            if ((n = o && o.removeAfter(t, e - v, r)) === o && i === this.array.length - 1) return this
                        }
                        var u = be(this, t);
                        return u.array.splice(i + 1), n && (u.array[i] = n), u
                    };
                    var de, me, ge = {};
                    e(Oe, Tt), Oe.of = function() {
                        return this(arguments)
                    }, Oe.prototype.toString = function() {
                        return this.__toString("OrderedMap {", "}")
                    }, Oe.prototype.get = function(t, e) {
                        var r = this._map.get(t);
                        return void 0 !== r ? this._list.get(r)[1] : e
                    }, Oe.prototype.clear = function() {
                        return 0 === this.size ? this : this.__ownerID ? (this.size = 0, this._map.clear(), this._list.clear(), this) : Ae()
                    }, Oe.prototype.set = function(t, e) {
                        return je(this, t, e)
                    }, Oe.prototype.remove = function(t) {
                        return je(this, t, m)
                    }, Oe.prototype.wasAltered = function() {
                        return this._map.wasAltered() || this._list.wasAltered()
                    }, Oe.prototype.__iterate = function(t, e) {
                        var r = this;
                        return this._list.__iterate(function(e) {
                            return e && t(e[1], e[0], r)
                        }, e)
                    }, Oe.prototype.__iterator = function(t, e) {
                        return this._list.fromEntrySeq().__iterator(t, e)
                    }, Oe.prototype.__ensureOwner = function(t) {
                        if (t === this.__ownerID) return this;
                        var e = this._map.__ensureOwner(t),
                            r = this._list.__ensureOwner(t);
                        return t ? ke(e, r, t, this.__hash) : (this.__ownerID = t, this._map = e, this._list = r, this)
                    }, Oe.isOrderedMap = xe, Oe.prototype[l] = !0, Oe.prototype.delete = Oe.prototype.remove, e(Re, Y), Re.prototype.get = function(t, e) {
                        return this._iter.get(t, e)
                    }, Re.prototype.has = function(t) {
                        return this._iter.has(t)
                    }, Re.prototype.valueSeq = function() {
                        return this._iter.valueSeq()
                    }, Re.prototype.reverse = function() {
                        var t = this,
                            e = We(this, !0);
                        return this._useKeys || (e.valueSeq = function() {
                            return t._iter.toSeq().reverse()
                        }), e
                    }, Re.prototype.map = function(t, e) {
                        var r = this,
                            n = Be(this, t, e);
                        return this._useKeys || (n.valueSeq = function() {
                            return r._iter.toSeq().map(t, e)
                        }), n
                    }, Re.prototype.__iterate = function(t, e) {
                        var r, n = this;
                        return this._iter.__iterate(this._useKeys ? function(e, r) {
                            return t(e, r, n)
                        } : (r = e ? Ge(this) : 0, function(i) {
                            return t(i, e ? --r : r++, n)
                        }), e)
                    }, Re.prototype.__iterator = function(t, e) {
                        if (this._useKeys) return this._iter.__iterator(t, e);
                        var r = this._iter.__iterator(j, e),
                            n = e ? Ge(this) : 0;
                        return new T(function() {
                            var i = r.next();
                            return i.done ? i : B(t, e ? --n : n++, i.value, i)
                        })
                    }, Re.prototype[l] = !0, e(Ue, Q), Ue.prototype.includes = function(t) {
                        return this._iter.includes(t)
                    }, Ue.prototype.__iterate = function(t, e) {
                        var r = this,
                            n = 0;
                        return this._iter.__iterate(function(e) {
                            return t(e, n++, r)
                        }, e)
                    }, Ue.prototype.__iterator = function(t, e) {
                        var r = this._iter.__iterator(j, e),
                            n = 0;
                        return new T(function() {
                            var e = r.next();
                            return e.done ? e : B(t, n++, e.value, e)
                        })
                    }, e(Ke, X), Ke.prototype.has = function(t) {
                        return this._iter.includes(t)
                    }, Ke.prototype.__iterate = function(t, e) {
                        var r = this;
                        return this._iter.__iterate(function(e) {
                            return t(e, e, r)
                        }, e)
                    }, Ke.prototype.__iterator = function(t, e) {
                        var r = this._iter.__iterator(j, e);
                        return new T(function() {
                            var e = r.next();
                            return e.done ? e : B(t, e.value, e.value, e)
                        })
                    }, e(Le, Y), Le.prototype.entrySeq = function() {
                        return this._iter.toSeq()
                    }, Le.prototype.__iterate = function(t, e) {
                        var r = this;
                        return this._iter.__iterate(function(e) {
                            if (e) {
                                Fe(e);
                                var n = u(e);
                                return t(n ? e.get(1) : e[1], n ? e.get(0) : e[0], r)
                            }
                        }, e)
                    }, Le.prototype.__iterator = function(t, e) {
                        var r = this._iter.__iterator(j, e);
                        return new T(function() {
                            for (;;) {
                                var e = r.next();
                                if (e.done) return e;
                                var n = e.value;
                                if (n) {
                                    Fe(n);
                                    var i = u(n);
                                    return B(t, i ? n.get(0) : n[0], i ? n.get(1) : n[1], e)
                                }
                            }
                        })
                    }, Ue.prototype.cacheResult = Re.prototype.cacheResult = Ke.prototype.cacheResult = Le.prototype.cacheResult = tr, e(nr, wt), nr.prototype.toString = function() {
                        return this.__toString(ur(this) + " {", "}")
                    }, nr.prototype.has = function(t) {
                        return this._defaultValues.hasOwnProperty(t)
                    }, nr.prototype.get = function(t, e) {
                        if (!this.has(t)) return e;
                        var r = this._defaultValues[t];
                        return this._map ? this._map.get(t, r) : r
                    }, nr.prototype.clear = function() {
                        if (this.__ownerID) return this._map && this._map.clear(), this;
                        var t = this.constructor;
                        return t._empty || (t._empty = or(this, Zt()))
                    }, nr.prototype.set = function(t, e) {
                        if (!this.has(t)) throw new Error('Cannot set unknown key "' + t + '" on ' + ur(this));
                        if (this._map && !this._map.has(t) && e === this._defaultValues[t]) return this;
                        var r = this._map && this._map.set(t, e);
                        return this.__ownerID || r === this._map ? this : or(this, r)
                    }, nr.prototype.remove = function(t) {
                        if (!this.has(t)) return this;
                        var e = this._map && this._map.remove(t);
                        return this.__ownerID || e === this._map ? this : or(this, e)
                    }, nr.prototype.wasAltered = function() {
                        return this._map.wasAltered()
                    }, nr.prototype.__iterator = function(t, e) {
                        var r = this;
                        return n(this._defaultValues).map(function(t, e) {
                            return r.get(e)
                        }).__iterator(t, e)
                    }, nr.prototype.__iterate = function(t, e) {
                        var r = this;
                        return n(this._defaultValues).map(function(t, e) {
                            return r.get(e)
                        }).__iterate(t, e)
                    }, nr.prototype.__ensureOwner = function(t) {
                        if (t === this.__ownerID) return this;
                        var e = this._map && this._map.__ensureOwner(t);
                        return t ? or(this, e, t) : (this.__ownerID = t, this._map = e, this)
                    };
                    var ir = nr.prototype;
                    ir.delete = ir.remove, ir.deleteIn = ir.removeIn = Jt.removeIn, ir.merge = Jt.merge, ir.mergeWith = Jt.mergeWith, ir.mergeIn = Jt.mergeIn, ir.mergeDeep = Jt.mergeDeep, ir.mergeDeepWith = Jt.mergeDeepWith, ir.mergeDeepIn = Jt.mergeDeepIn, ir.setIn = Jt.setIn, ir.update = Jt.update, ir.updateIn = Jt.updateIn, ir.withMutations = Jt.withMutations, ir.asMutable = Jt.asMutable, ir.asImmutable = Jt.asImmutable, e(sr, zt), sr.of = function() {
                        return this(arguments)
                    }, sr.fromKeys = function(t) {
                        return this(n(t).keySeq())
                    }, sr.prototype.toString = function() {
                        return this.__toString("Set {", "}")
                    }, sr.prototype.has = function(t) {
                        return this._map.has(t)
                    }, sr.prototype.add = function(t) {
                        return _r(this, this._map.set(t, !0))
                    }, sr.prototype.remove = function(t) {
                        return _r(this, this._map.remove(t))
                    }, sr.prototype.clear = function() {
                        return _r(this, this._map.clear())
                    }, sr.prototype.union = function() {
                        var e = t.call(arguments, 0);
                        return 0 === (e = e.filter(function(t) {
                            return 0 !== t.size
                        })).length ? this : 0 !== this.size || this.__ownerID || 1 !== e.length ? this.withMutations(function(t) {
                            for (var r = 0; r < e.length; r++) o(e[r]).forEach(function(e) {
                                return t.add(e)
                            })
                        }) : this.constructor(e[0])
                    }, sr.prototype.intersect = function() {
                        var e = t.call(arguments, 0);
                        if (0 === e.length) return this;
                        e = e.map(function(t) {
                            return o(t)
                        });
                        var r = this;
                        return this.withMutations(function(t) {
                            r.forEach(function(r) {
                                e.every(function(t) {
                                    return t.includes(r)
                                }) || t.remove(r)
                            })
                        })
                    }, sr.prototype.subtract = function() {
                        var e = t.call(arguments, 0);
                        if (0 === e.length) return this;
                        e = e.map(function(t) {
                            return o(t)
                        });
                        var r = this;
                        return this.withMutations(function(t) {
                            r.forEach(function(r) {
                                e.some(function(t) {
                                    return t.includes(r)
                                }) && t.remove(r)
                            })
                        })
                    }, sr.prototype.merge = function() {
                        return this.union.apply(this, arguments)
                    }, sr.prototype.mergeWith = function(e) {
                        var r = t.call(arguments, 1);
                        return this.union.apply(this, r)
                    }, sr.prototype.sort = function(t) {
                        return vr(He(this, t))
                    }, sr.prototype.sortBy = function(t, e) {
                        return vr(He(this, e, t))
                    }, sr.prototype.wasAltered = function() {
                        return this._map.wasAltered()
                    }, sr.prototype.__iterate = function(t, e) {
                        var r = this;
                        return this._map.__iterate(function(e, n) {
                            return t(n, n, r)
                        }, e)
                    }, sr.prototype.__iterator = function(t, e) {
                        return this._map.map(function(t, e) {
                            return e
                        }).__iterator(t, e)
                    }, sr.prototype.__ensureOwner = function(t) {
                        if (t === this.__ownerID) return this;
                        var e = this._map.__ensureOwner(t);
                        return t ? this.__make(e, t) : (this.__ownerID = t, this._map = e, this)
                    }, sr.isSet = ar;
                    var hr, fr = "@@__IMMUTABLE_SET__@@",
                        cr = sr.prototype;
                    cr[fr] = !0, cr.delete = cr.remove, cr.mergeDeep = cr.merge, cr.mergeDeepWith = cr.mergeWith, cr.withMutations = Jt.withMutations, cr.asMutable = Jt.asMutable, cr.asImmutable = Jt.asImmutable, cr.__empty = lr, cr.__make = pr, e(vr, sr), vr.of = function() {
                        return this(arguments)
                    }, vr.fromKeys = function(t) {
                        return this(n(t).keySeq())
                    }, vr.prototype.toString = function() {
                        return this.__toString("OrderedSet {", "}")
                    }, vr.isOrderedSet = yr;
                    var dr, mr = vr.prototype;
                    mr[l] = !0, mr.__empty = wr, mr.__make = gr, e(Sr, St), Sr.of = function() {
                        return this(arguments)
                    }, Sr.prototype.toString = function() {
                        return this.__toString("Stack [", "]")
                    }, Sr.prototype.get = function(t, e) {
                        var r = this._head;
                        for (t = D(this, t); r && t--;) r = r.next;
                        return r ? r.value : e
                    }, Sr.prototype.peek = function() {
                        return this._head && this._head.value
                    }, Sr.prototype.push = function() {
                        if (0 === arguments.length) return this;
                        for (var t = this.size + arguments.length, e = this._head, r = arguments.length - 1; r >= 0; r--) e = {
                            value: arguments[r],
                            next: e
                        };
                        return this.__ownerID ? (this.size = t, this._head = e, this.__hash = void 0, this.__altered = !0, this) : Dr(t, e)
                    }, Sr.prototype.pushAll = function(t) {
                        if (0 === (t = i(t)).size) return this;
                        Lt(t.size);
                        var e = this.size,
                            r = this._head;
                        return t.reverse().forEach(function(t) {
                            e++, r = {
                                value: t,
                                next: r
                            }
                        }), this.__ownerID ? (this.size = e, this._head = r, this.__hash = void 0, this.__altered = !0, this) : Dr(e, r)
                    }, Sr.prototype.pop = function() {
                        return this.slice(1)
                    }, Sr.prototype.unshift = function() {
                        return this.push.apply(this, arguments)
                    }, Sr.prototype.unshiftAll = function(t) {
                        return this.pushAll(t)
                    }, Sr.prototype.shift = function() {
                        return this.pop.apply(this, arguments)
                    }, Sr.prototype.clear = function() {
                        return 0 === this.size ? this : this.__ownerID ? (this.size = 0, this._head = void 0, this.__hash = void 0, this.__altered = !0, this) : Mr()
                    }, Sr.prototype.slice = function(t, e) {
                        if (E(t, e, this.size)) return this;
                        var r = O(t, this.size);
                        if (x(e, this.size) !== this.size) return St.prototype.slice.call(this, t, e);
                        for (var n = this.size - r, i = this._head; r--;) i = i.next;
                        return this.__ownerID ? (this.size = n, this._head = i, this.__hash = void 0, this.__altered = !0, this) : Dr(n, i)
                    }, Sr.prototype.__ensureOwner = function(t) {
                        return t === this.__ownerID ? this : t ? Dr(this.size, this._head, t, this.__hash) : (this.__ownerID = t, this.__altered = !1, this)
                    }, Sr.prototype.__iterate = function(t, e) {
                        if (e) return this.reverse().__iterate(t);
                        for (var r = 0, n = this._head; n && !1 !== t(n.value, r++, this);) n = n.next;
                        return r
                    }, Sr.prototype.__iterator = function(t, e) {
                        if (e) return this.reverse().__iterator(t);
                        var r = 0,
                            n = this._head;
                        return new T(function() {
                            if (n) {
                                var e = n.value;
                                return n = n.next, B(t, r++, e)
                            }
                            return {
                                value: void 0,
                                done: !0
                            }
                        })
                    }, Sr.isStack = zr;
                    var Ir, br = "@@__IMMUTABLE_STACK__@@",
                        qr = Sr.prototype;
                    qr[br] = !0, qr.withMutations = Jt.withMutations, qr.asMutable = Jt.asMutable, qr.asImmutable = Jt.asImmutable, qr.wasAltered = Jt.wasAltered, r.Iterator = T, Er(r, {
                        toArray: function() {
                            Lt(this.size);
                            var t = new Array(this.size || 0);
                            return this.valueSeq().__iterate(function(e, r) {
                                t[r] = e
                            }), t
                        },
                        toIndexedSeq: function() {
                            return new Ue(this)
                        },
                        toJS: function() {
                            return this.toSeq().map(function(t) {
                                return t && "function" == typeof t.toJS ? t.toJS() : t
                            }).__toJS()
                        },
                        toJSON: function() {
                            return this.toSeq().map(function(t) {
                                return t && "function" == typeof t.toJSON ? t.toJSON() : t
                            }).__toJS()
                        },
                        toKeyedSeq: function() {
                            return new Re(this, (!0))
                        },
                        toMap: function() {
                            return Tt(this.toKeyedSeq())
                        },
                        toObject: function() {
                            Lt(this.size);
                            var t = {};
                            return this.__iterate(function(e, r) {
                                t[r] = e
                            }), t
                        },
                        toOrderedMap: function() {
                            return Oe(this.toKeyedSeq())
                        },
                        toOrderedSet: function() {
                            return vr(s(this) ? this.valueSeq() : this)
                        },
                        toSet: function() {
                            return sr(s(this) ? this.valueSeq() : this)
                        },
                        toSetSeq: function() {
                            return new Ke(this)
                        },
                        toSeq: function() {
                            return a(this) ? this.toIndexedSeq() : s(this) ? this.toKeyedSeq() : this.toSetSeq()
                        },
                        toStack: function() {
                            return Sr(s(this) ? this.valueSeq() : this)
                        },
                        toList: function() {
                            return _e(s(this) ? this.valueSeq() : this)
                        },
                        toString: function() {
                            return "[Iterable]"
                        },
                        __toString: function(t, e) {
                            return 0 === this.size ? t + e : t + " " + this.toSeq().map(this.__toStringMapper).join(", ") + " " + e
                        },
                        concat: function() {
                            return Xe(this, function(t, e) {
                                var r = s(t),
                                    i = [t].concat(e).map(function(t) {
                                        return u(t) ? r && (t = n(t)) : t = r ? ut(t) : st(Array.isArray(t) ? t : [t]), t
                                    }).filter(function(t) {
                                        return 0 !== t.size
                                    });
                                if (0 === i.length) return t;
                                if (1 === i.length) {
                                    var o = i[0];
                                    if (o === t || r && s(o) || a(t) && a(o)) return o
                                }
                                var h = new tt(i);
                                return r ? h = h.toKeyedSeq() : a(t) || (h = h.toSetSeq()), (h = h.flatten(!0)).size = i.reduce(function(t, e) {
                                    if (void 0 !== t) {
                                        var r = e.size;
                                        if (void 0 !== r) return t + r
                                    }
                                }, 0), h
                            }(this, t.call(arguments, 0)))
                        },
                        includes: function(t) {
                            return this.some(function(e) {
                                return lt(e, t)
                            })
                        },
                        entries: function() {
                            return this.__iterator(R)
                        },
                        every: function(t, e) {
                            Lt(this.size);
                            var r = !0;
                            return this.__iterate(function(n, i, o) {
                                if (!t.call(e, n, i, o)) return r = !1, !1
                            }), r
                        },
                        filter: function(t, e) {
                            return Xe(this, Ce(this, t, e, !0))
                        },
                        find: function(t, e, r) {
                            var n = this.findEntry(t, e);
                            return n ? n[1] : r
                        },
                        forEach: function(t, e) {
                            return Lt(this.size), this.__iterate(e ? t.bind(e) : t)
                        },
                        join: function(t) {
                            Lt(this.size), t = void 0 !== t ? "" + t : ",";
                            var e = "",
                                r = !0;
                            return this.__iterate(function(n) {
                                r ? r = !1 : e += t, e += null != n ? n.toString() : ""
                            }), e
                        },
                        keys: function() {
                            return this.__iterator(A)
                        },
                        map: function(t, e) {
                            return Xe(this, Be(this, t, e))
                        },
                        reduce: function(t, e, r) {
                            var n, i;
                            return Lt(this.size), arguments.length < 2 ? i = !0 : n = e, this.__iterate(function(e, o, u) {
                                i ? (i = !1, n = e) : n = t.call(r, n, e, o, u)
                            }), n
                        },
                        reduceRight: function(t, e, r) {
                            var n = this.toKeyedSeq().reverse();
                            return n.reduce.apply(n, arguments)
                        },
                        reverse: function() {
                            return Xe(this, We(this, !0))
                        },
                        slice: function(t, e) {
                            return Xe(this, Je(this, t, e, !0))
                        },
                        some: function(t, e) {
                            return !this.every(jr(t), e)
                        },
                        sort: function(t) {
                            return Xe(this, He(this, t))
                        },
                        values: function() {
                            return this.__iterator(j)
                        },
                        butLast: function() {
                            return this.slice(0, -1)
                        },
                        isEmpty: function() {
                            return void 0 !== this.size ? 0 === this.size : !this.some(function() {
                                return !0
                            })
                        },
                        count: function(t, e) {
                            return q(t ? this.toSeq().filter(t, e) : this)
                        },
                        countBy: function(t, e) {
                            return function(t, e, r) {
                                var n = Tt().asMutable();
                                return t.__iterate(function(i, o) {
                                    n.update(e.call(r, i, o, t), 0, function(t) {
                                        return t + 1
                                    })
                                }), n.asImmutable()
                            }(this, t, e)
                        },
                        equals: function(t) {
                            return vt(this, t)
                        },
                        entrySeq: function() {
                            var t = this;
                            if (t._cache) return new tt(t._cache);
                            var e = t.toSeq().map(Ar).toIndexedSeq();
                            return e.fromEntrySeq = function() {
                                return t.toSeq()
                            }, e
                        },
                        filterNot: function(t, e) {
                            return this.filter(jr(t), e)
                        },
                        findEntry: function(t, e, r) {
                            var n = r;
                            return this.__iterate(function(r, i, o) {
                                if (t.call(e, r, i, o)) return n = [i, r], !1
                            }), n
                        },
                        findKey: function(t, e) {
                            var r = this.findEntry(t, e);
                            return r && r[0]
                        },
                        findLast: function(t, e, r) {
                            return this.toKeyedSeq().reverse().find(t, e, r)
                        },
                        findLastEntry: function(t, e, r) {
                            return this.toKeyedSeq().reverse().findEntry(t, e, r)
                        },
                        findLastKey: function(t, e) {
                            return this.toKeyedSeq().reverse().findKey(t, e)
                        },
                        first: function() {
                            return this.find(M)
                        },
                        flatMap: function(t, e) {
                            return Xe(this, function(t, e, r) {
                                var n = Ze(t);
                                return t.toSeq().map(function(i, o) {
                                    return n(e.call(r, i, o, t))
                                }).flatten(!0)
                            }(this, t, e))
                        },
                        flatten: function(t) {
                            return Xe(this, Pe(this, t, !0))
                        },
                        fromEntrySeq: function() {
                            return new Le(this)
                        },
                        get: function(t, e) {
                            return this.find(function(e, r) {
                                return lt(r, t)
                            }, void 0, e)
                        },
                        getIn: function(t, e) {
                            for (var r, n = this, i = rr(t); !(r = i.next()).done;) {
                                var o = r.value;
                                if ((n = n && n.get ? n.get(o, m) : m) === m) return e
                            }
                            return n
                        },
                        groupBy: function(t, e) {
                            return function(t, e, r) {
                                var n = s(t),
                                    i = (f(t) ? Oe() : Tt()).asMutable();
                                t.__iterate(function(o, u) {
                                    i.update(e.call(r, o, u, t), function(t) {
                                        return (t = t || []).push(n ? [u, o] : o), t
                                    })
                                });
                                var o = Ze(t);
                                return i.map(function(e) {
                                    return Xe(t, o(e))
                                })
                            }(this, t, e)
                        },
                        has: function(t) {
                            return this.get(t, m) !== m
                        },
                        hasIn: function(t) {
                            return this.getIn(t, m) !== m
                        },
                        isSubset: function(t) {
                            return t = "function" == typeof t.includes ? t : r(t), this.every(function(e) {
                                return t.includes(e)
                            })
                        },
                        isSuperset: function(t) {
                            return (t = "function" == typeof t.isSubset ? t : r(t)).isSubset(this)
                        },
                        keyOf: function(t) {
                            return this.findKey(function(e) {
                                return lt(e, t)
                            })
                        },
                        keySeq: function() {
                            return this.toSeq().map(kr).toIndexedSeq()
                        },
                        last: function() {
                            return this.toSeq().reverse().first()
                        },
                        lastKeyOf: function(t) {
                            return this.toKeyedSeq().reverse().keyOf(t)
                        },
                        max: function(t) {
                            return Ve(this, t)
                        },
                        maxBy: function(t, e) {
                            return Ve(this, e, t)
                        },
                        min: function(t) {
                            return Ve(this, t ? Rr(t) : Lr)
                        },
                        minBy: function(t, e) {
                            return Ve(this, e ? Rr(e) : Lr, t)
                        },
                        rest: function() {
                            return this.slice(1)
                        },
                        skip: function(t) {
                            return this.slice(Math.max(0, t))
                        },
                        skipLast: function(t) {
                            return Xe(this, this.toSeq().reverse().skip(t).reverse())
                        },
                        skipWhile: function(t, e) {
                            return Xe(this, Ne(this, t, e, !0))
                        },
                        skipUntil: function(t, e) {
                            return this.skipWhile(jr(t), e)
                        },
                        sortBy: function(t, e) {
                            return Xe(this, He(this, e, t))
                        },
                        take: function(t) {
                            return this.slice(0, Math.max(0, t))
                        },
                        takeLast: function(t) {
                            return Xe(this, this.toSeq().reverse().take(t).reverse())
                        },
                        takeWhile: function(t, e) {
                            return Xe(this, function(t, e, r) {
                                var n = $e(t);
                                return n.__iterateUncached = function(n, i) {
                                    var o = this;
                                    if (i) return this.cacheResult().__iterate(n, i);
                                    var u = 0;
                                    return t.__iterate(function(t, i, s) {
                                        return e.call(r, t, i, s) && ++u && n(t, i, o)
                                    }), u
                                }, n.__iteratorUncached = function(n, i) {
                                    var o = this;
                                    if (i) return this.cacheResult().__iterator(n, i);
                                    var u = t.__iterator(R, i),
                                        s = !0;
                                    return new T(function() {
                                        if (!s) return {
                                            value: void 0,
                                            done: !0
                                        };
                                        var t = u.next();
                                        if (t.done) return t;
                                        var i = t.value,
                                            a = i[0],
                                            h = i[1];
                                        return e.call(r, h, a, o) ? n === R ? t : B(n, a, h, t) : (s = !1, {
                                            value: void 0,
                                            done: !0
                                        })
                                    })
                                }, n
                            }(this, t, e))
                        },
                        takeUntil: function(t, e) {
                            return this.takeWhile(jr(t), e)
                        },
                        valueSeq: function() {
                            return this.toIndexedSeq()
                        },
                        hashCode: function() {
                            return this.__hash || (this.__hash = function(t) {
                                if (t.size === 1 / 0) return 0;
                                var e = f(t),
                                    r = s(t),
                                    n = e ? 1 : 0;
                                return function(t, e) {
                                    return e = It(e, 3432918353), e = It(e << 15 | e >>> -15, 461845907), e = It(e << 13 | e >>> -13, 5), e = It((e = (e + 3864292196 | 0) ^ t) ^ e >>> 16, 2246822507), e = bt((e = It(e ^ e >>> 13, 3266489909)) ^ e >>> 16)
                                }(t.__iterate(r ? e ? function(t, e) {
                                    n = 31 * n + Tr(qt(t), qt(e)) | 0
                                } : function(t, e) {
                                    n = n + Tr(qt(t), qt(e)) | 0
                                } : e ? function(t) {
                                    n = 31 * n + qt(t) | 0
                                } : function(t) {
                                    n = n + qt(t) | 0
                                }), n)
                            }(this))
                        }
                    });
                    var Or = r.prototype;
                    Or[c] = !0, Or[L] = Or.values, Or.__toJS = Or.toArray, Or.__toStringMapper = Ur, Or.inspect = Or.toSource = function() {
                        return this.toString()
                    }, Or.chain = Or.flatMap, Or.contains = Or.includes, Er(n, {
                        flip: function() {
                            return Xe(this, Te(this))
                        },
                        mapEntries: function(t, e) {
                            var r = this,
                                n = 0;
                            return Xe(this, this.toSeq().map(function(i, o) {
                                return t.call(e, [o, i], n++, r)
                            }).fromEntrySeq())
                        },
                        mapKeys: function(t, e) {
                            var r = this;
                            return Xe(this, this.toSeq().flip().map(function(n, i) {
                                return t.call(e, n, i, r)
                            }).flip())
                        }
                    });
                    var xr = n.prototype;
                    return xr[_] = !0, xr[L] = Or.entries, xr.__toJS = Or.toObject, xr.__toStringMapper = function(t, e) {
                        return JSON.stringify(e) + ": " + Ur(t)
                    }, Er(i, {
                        toKeyedSeq: function() {
                            return new Re(this, (!1))
                        },
                        filter: function(t, e) {
                            return Xe(this, Ce(this, t, e, !1))
                        },
                        findIndex: function(t, e) {
                            var r = this.findEntry(t, e);
                            return r ? r[0] : -1
                        },
                        indexOf: function(t) {
                            var e = this.keyOf(t);
                            return void 0 === e ? -1 : e
                        },
                        lastIndexOf: function(t) {
                            var e = this.lastKeyOf(t);
                            return void 0 === e ? -1 : e
                        },
                        reverse: function() {
                            return Xe(this, We(this, !1))
                        },
                        slice: function(t, e) {
                            return Xe(this, Je(this, t, e, !1))
                        },
                        splice: function(t, e) {
                            var r = arguments.length;
                            if (e = Math.max(0 | e, 0), 0 === r || 2 === r && !e) return this;
                            t = O(t, t < 0 ? this.count() : this.size);
                            var n = this.slice(0, t);
                            return Xe(this, 1 === r ? n : n.concat(b(arguments, 2), this.slice(t + e)))
                        },
                        findLastIndex: function(t, e) {
                            var r = this.findLastEntry(t, e);
                            return r ? r[0] : -1
                        },
                        first: function() {
                            return this.get(0)
                        },
                        flatten: function(t) {
                            return Xe(this, Pe(this, t, !1))
                        },
                        get: function(t, e) {
                            return (t = D(this, t)) < 0 || this.size === 1 / 0 || void 0 !== this.size && t > this.size ? e : this.find(function(e, r) {
                                return r === t
                            }, void 0, e)
                        },
                        has: function(t) {
                            return (t = D(this, t)) >= 0 && (void 0 !== this.size ? this.size === 1 / 0 || t < this.size : -1 !== this.indexOf(t))
                        },
                        interpose: function(t) {
                            return Xe(this, function(t, e) {
                                var r = $e(t);
                                return r.size = t.size && 2 * t.size - 1, r.__iterateUncached = function(r, n) {
                                    var i = this,
                                        o = 0;
                                    return t.__iterate(function(t, n) {
                                        return (!o || !1 !== r(e, o++, i)) && !1 !== r(t, o++, i)
                                    }, n), o
                                }, r.__iteratorUncached = function(r, n) {
                                    var i, o = t.__iterator(j, n),
                                        u = 0;
                                    return new T(function() {
                                        return (!i || u % 2) && (i = o.next()).done ? i : u % 2 ? B(r, u++, e) : B(r, u++, i.value, i)
                                    })
                                }, r
                            }(this, t))
                        },
                        interleave: function() {
                            var t = [this].concat(b(arguments)),
                                e = Qe(this.toSeq(), Q.of, t),
                                r = e.flatten(!0);
                            return e.size && (r.size = e.size * t.length), Xe(this, r)
                        },
                        keySeq: function() {
                            return mt(0, this.size)
                        },
                        last: function() {
                            return this.get(-1)
                        },
                        skipWhile: function(t, e) {
                            return Xe(this, Ne(this, t, e, !1))
                        },
                        zip: function() {
                            return Xe(this, Qe(this, Kr, [this].concat(b(arguments))))
                        },
                        zipWith: function(t) {
                            var e = b(arguments);
                            return e[0] = this, Xe(this, Qe(this, t, e))
                        }
                    }), i.prototype[p] = !0, i.prototype[l] = !0, Er(o, {
                        get: function(t, e) {
                            return this.has(t) ? t : e
                        },
                        includes: function(t) {
                            return this.has(t)
                        },
                        keySeq: function() {
                            return this.valueSeq()
                        }
                    }), o.prototype.has = Or.includes, o.prototype.contains = o.prototype.includes, Er(Y, n.prototype), Er(Q, i.prototype), Er(X, o.prototype), Er(wt, n.prototype), Er(St, i.prototype), Er(zt, o.prototype), {
                        Iterable: r,
                        Seq: V,
                        Collection: gt,
                        Map: Tt,
                        OrderedMap: Oe,
                        List: _e,
                        Stack: Sr,
                        Set: sr,
                        OrderedSet: vr,
                        Record: nr,
                        Range: mt,
                        Repeat: yt,
                        is: lt,
                        fromJS: ct
                    }
                })
            }, {}],
            194: [function(require, module, exports) {
                "use strict";
                var numberIsNan = require("number-is-nan");
                module.exports = Number.isFinite || function(e) {
                    return !("number" != typeof e || numberIsNan(e) || e === 1 / 0 || e === -1 / 0)
                }
            }, {
                "number-is-nan": 420
            }],
            195: [function(require, module, exports) {
                "use strict";

                function assign(t) {
                    return Array.prototype.slice.call(arguments, 1).forEach(function(e) {
                        e && Object.keys(e).forEach(function(_) {
                            t[_] = e[_]
                        })
                    }), t
                }

                function _class(t) {
                    return Object.prototype.toString.call(t)
                }

                function isString(t) {
                    return "[object String]" === _class(t)
                }

                function isObject(t) {
                    return "[object Object]" === _class(t)
                }

                function isRegExp(t) {
                    return "[object RegExp]" === _class(t)
                }

                function isFunction(t) {
                    return "[object Function]" === _class(t)
                }

                function escapeRE(t) {
                    return t.replace(/[.?*+^$[\]\\(){}|-]/g, "\\$&")
                }

                function isOptionsObj(t) {
                    return Object.keys(t || {}).reduce(function(t, e) {
                        return t || defaultOptions.hasOwnProperty(e)
                    }, !1)
                }

                function resetScanCache(t) {
                    t.__index__ = -1, t.__text_cache__ = ""
                }

                function createValidator(t) {
                    return function(e, _) {
                        var i = e.slice(_);
                        return t.test(i) ? i.match(t)[0].length : 0
                    }
                }

                function createNormalizer() {
                    return function(t, e) {
                        e.normalize(t)
                    }
                }

                function compile(t) {
                    function i(t) {
                        return t.replace("%TLDS%", e.src_tlds)
                    }

                    function n(t, e) {
                        throw new Error('(LinkifyIt) Invalid schema "' + t + '": ' + e)
                    }
                    var e = t.re = require("./lib/re")(t.__opts__),
                        _ = t.__tlds__.slice();
                    t.onCompile(), t.__tlds_replaced__ || _.push(tlds_2ch_src_re), _.push(e.src_xn), e.src_tlds = _.join("|"), e.email_fuzzy = RegExp(i(e.tpl_email_fuzzy), "i"), e.link_fuzzy = RegExp(i(e.tpl_link_fuzzy), "i"), e.link_no_ip_fuzzy = RegExp(i(e.tpl_link_no_ip_fuzzy), "i"), e.host_fuzzy_test = RegExp(i(e.tpl_host_fuzzy_test), "i");
                    var s = [];
                    t.__compiled__ = {}, Object.keys(t.__schemas__).forEach(function(e) {
                        var _ = t.__schemas__[e];
                        if (null !== _) {
                            var i = {
                                validate: null,
                                link: null
                            };
                            if (t.__compiled__[e] = i, isObject(_)) return isRegExp(_.validate) ? i.validate = createValidator(_.validate) : isFunction(_.validate) ? i.validate = _.validate : n(e, _), void(isFunction(_.normalize) ? i.normalize = _.normalize : _.normalize ? n(e, _) : i.normalize = createNormalizer());
                            isString(_) ? s.push(e) : n(e, _)
                        }
                    }), s.forEach(function(e) {
                        t.__compiled__[t.__schemas__[e]] && (t.__compiled__[e].validate = t.__compiled__[t.__schemas__[e]].validate, t.__compiled__[e].normalize = t.__compiled__[t.__schemas__[e]].normalize)
                    }), t.__compiled__[""] = {
                        validate: null,
                        normalize: createNormalizer()
                    };
                    var r = Object.keys(t.__compiled__).filter(function(e) {
                        return e.length > 0 && t.__compiled__[e]
                    }).map(escapeRE).join("|");
                    t.re.schema_test = RegExp("(^|(?!_)(?:[><]|" + e.src_ZPCc + "))(" + r + ")", "i"), t.re.schema_search = RegExp("(^|(?!_)(?:[><]|" + e.src_ZPCc + "))(" + r + ")", "ig"), t.re.pretest = RegExp("(" + t.re.schema_test.source + ")|(" + t.re.host_fuzzy_test.source + ")|@", "i"), resetScanCache(t)
                }

                function Match(t, e) {
                    var _ = t.__index__,
                        i = t.__last_index__,
                        s = t.__text_cache__.slice(_, i);
                    this.schema = t.__schema__.toLowerCase(), this.index = _ + e, this.lastIndex = i + e, this.raw = s, this.text = s, this.url = s
                }

                function createMatch(t, e) {
                    var _ = new Match(t, e);
                    return t.__compiled__[_.schema].normalize(_, t), _
                }

                function LinkifyIt(t, e) {
                    return this instanceof LinkifyIt ? (e || isOptionsObj(t) && (e = t, t = {}), this.__opts__ = assign({}, defaultOptions, e), this.__index__ = -1, this.__last_index__ = -1, this.__schema__ = "", this.__text_cache__ = "", this.__schemas__ = assign({}, defaultSchemas, t), this.__compiled__ = {}, this.__tlds__ = tlds_default, this.__tlds_replaced__ = !1, this.re = {}, compile(this), void 0) : new LinkifyIt(t, e)
                }
                var defaultOptions = {
                        fuzzyLink: !0,
                        fuzzyEmail: !0,
                        fuzzyIP: !1
                    },
                    defaultSchemas = {
                        "http:": {
                            validate: function(t, e, _) {
                                var i = t.slice(e);
                                return _.re.http || (_.re.http = new RegExp("^\\/\\/" + _.re.src_auth + _.re.src_host_port_strict + _.re.src_path, "i")), _.re.http.test(i) ? i.match(_.re.http)[0].length : 0
                            }
                        },
                        "https:": "http:",
                        "ftp:": "http:",
                        "//": {
                            validate: function(t, e, _) {
                                var i = t.slice(e);
                                return _.re.no_http || (_.re.no_http = new RegExp("^" + _.re.src_auth + "(?:localhost|(?:(?:" + _.re.src_domain + ")\\.)+" + _.re.src_domain_root + ")" + _.re.src_port + _.re.src_host_terminator + _.re.src_path, "i")), _.re.no_http.test(i) ? e >= 3 && ":" === t[e - 3] ? 0 : e >= 3 && "/" === t[e - 3] ? 0 : i.match(_.re.no_http)[0].length : 0
                            }
                        },
                        "mailto:": {
                            validate: function(t, e, _) {
                                var i = t.slice(e);
                                return _.re.mailto || (_.re.mailto = new RegExp("^" + _.re.src_email_name + "@" + _.re.src_host_strict, "i")), _.re.mailto.test(i) ? i.match(_.re.mailto)[0].length : 0
                            }
                        }
                    },
                    tlds_2ch_src_re = "a[cdefgilmnoqrstuwxz]|b[abdefghijmnorstvwyz]|c[acdfghiklmnoruvwxyz]|d[ejkmoz]|e[cegrstu]|f[ijkmor]|g[abdefghilmnpqrstuwy]|h[kmnrtu]|i[delmnoqrst]|j[emop]|k[eghimnprwyz]|l[abcikrstuvy]|m[acdeghklmnopqrstuvwxyz]|n[acefgilopruz]|om|p[aefghklmnrstwy]|qa|r[eosuw]|s[abcdeghijklmnortuvxyz]|t[cdfghjklmnortvwz]|u[agksyz]|v[aceginu]|w[fs]|y[et]|z[amw]",
                    tlds_default = "biz|com|edu|gov|net|org|pro|web|xxx|aero|asia|coop|info|museum|name|shop|".split("|");
                LinkifyIt.prototype.add = function(t, e) {
                    return this.__schemas__[t] = e, compile(this), this
                }, LinkifyIt.prototype.set = function(t) {
                    return this.__opts__ = assign(this.__opts__, t), this
                }, LinkifyIt.prototype.test = function(t) {
                    if (this.__text_cache__ = t, this.__index__ = -1, !t.length) return !1;
                    var e, _, i, s, n, r, a, c;
                    if (this.re.schema_test.test(t))
                        for ((a = this.re.schema_search).lastIndex = 0; null !== (e = a.exec(t));)
                            if (s = this.testSchemaAt(t, e[2], a.lastIndex)) {
                                this.__schema__ = e[2], this.__index__ = e.index + e[1].length, this.__last_index__ = e.index + e[0].length + s;
                                break
                            } return this.__opts__.fuzzyLink && this.__compiled__["http:"] && (c = t.search(this.re.host_fuzzy_test)) >= 0 && (this.__index__ < 0 || c < this.__index__) && null !== (_ = t.match(this.__opts__.fuzzyIP ? this.re.link_fuzzy : this.re.link_no_ip_fuzzy)) && (n = _.index + _[1].length, (this.__index__ < 0 || n < this.__index__) && (this.__schema__ = "", this.__index__ = n, this.__last_index__ = _.index + _[0].length)), this.__opts__.fuzzyEmail && this.__compiled__["mailto:"] && t.indexOf("@") >= 0 && null !== (i = t.match(this.re.email_fuzzy)) && (n = i.index + i[1].length, r = i.index + i[0].length, (this.__index__ < 0 || n < this.__index__ || n === this.__index__ && r > this.__last_index__) && (this.__schema__ = "mailto:", this.__index__ = n, this.__last_index__ = r)), this.__index__ >= 0
                }, LinkifyIt.prototype.pretest = function(t) {
                    return this.re.pretest.test(t)
                }, LinkifyIt.prototype.testSchemaAt = function(t, e, _) {
                    return this.__compiled__[e.toLowerCase()] ? this.__compiled__[e.toLowerCase()].validate(t, _, this) : 0
                }, LinkifyIt.prototype.match = function(t) {
                    var e = 0,
                        _ = [];
                    this.__index__ >= 0 && this.__text_cache__ === t && (_.push(createMatch(this, e)), e = this.__last_index__);
                    for (var i = e ? t.slice(e) : t; this.test(i);) _.push(createMatch(this, e)), i = i.slice(this.__last_index__), e += this.__last_index__;
                    return _.length ? _ : null
                }, LinkifyIt.prototype.tlds = function(t, e) {
                    return t = Array.isArray(t) ? t : [t], e ? (this.__tlds__ = this.__tlds__.concat(t).sort().filter(function(t, e, _) {
                        return t !== _[e - 1]
                    }).reverse(), compile(this), this) : (this.__tlds__ = t.slice(), this.__tlds_replaced__ = !0, compile(this), this)
                }, LinkifyIt.prototype.normalize = function(t) {
                    t.schema || (t.url = "http://" + t.url), "mailto:" !== t.schema || /^mailto:/i.test(t.url) || (t.url = "mailto:" + t.url)
                }, LinkifyIt.prototype.onCompile = function() {}, module.exports = LinkifyIt
            }, {
                "./lib/re": 196
            }],
            196: [function(require, module, exports) {
                "use strict";
                module.exports = function(_) {
                    var r = {};
                    return r.src_Any = require("uc.micro/properties/Any/regex").source, r.src_Cc = require("uc.micro/categories/Cc/regex").source, r.src_Z = require("uc.micro/categories/Z/regex").source, r.src_P = require("uc.micro/categories/P/regex").source, r.src_ZPCc = [r.src_Z, r.src_P, r.src_Cc].join("|"), r.src_ZCc = [r.src_Z, r.src_Cc].join("|"), r.src_pseudo_letter = "(?:(?![><]|" + r.src_ZPCc + ")" + r.src_Any + ")", r.src_ip4 = "(?:(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.){3}(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)", r.src_auth = "(?:(?:(?!" + r.src_ZCc + "|[@/\\[\\]()]).)+@)?", r.src_port = "(?::(?:6(?:[0-4]\\d{3}|5(?:[0-4]\\d{2}|5(?:[0-2]\\d|3[0-5])))|[1-5]?\\d{1,4}))?", r.src_host_terminator = "(?=$|[><]|" + r.src_ZPCc + ")(?!-|_|:\\d|\\.-|\\.(?!$|" + r.src_ZPCc + "))", r.src_path = "(?:[/?#](?:(?!" + r.src_ZCc + "|[><]|[()[\\]{}.,\"'?!\\-]).|\\[(?:(?!" + r.src_ZCc + "|\\]).)*\\]|\\((?:(?!" + r.src_ZCc + "|[)]).)*\\)|\\{(?:(?!" + r.src_ZCc + '|[}]).)*\\}|\\"(?:(?!' + r.src_ZCc + '|["]).)+\\"|\\\'(?:(?!' + r.src_ZCc + "|[']).)+\\'|\\'(?=" + r.src_pseudo_letter + "|[-]).|\\.{2,3}[a-zA-Z0-9%/]|\\.(?!" + r.src_ZCc + "|[.]).|" + (_ && _["---"] ? "\\-(?!--(?:[^-]|$))(?:-*)|" : "\\-+|") + "\\,(?!" + r.src_ZCc + ").|\\!(?!" + r.src_ZCc + "|[!]).|\\?(?!" + r.src_ZCc + "|[?]).)+|\\/)?", r.src_email_name = '[\\-;:&=\\+\\$,\\"\\.a-zA-Z0-9_]+', r.src_xn = "xn--[a-z0-9\\-]{1,59}", r.src_domain_root = "(?:" + r.src_xn + "|" + r.src_pseudo_letter + "{1,63})", r.src_domain = "(?:" + r.src_xn + "|(?:" + r.src_pseudo_letter + ")|(?:" + r.src_pseudo_letter + "(?:-(?!-)|" + r.src_pseudo_letter + "){0,61}" + r.src_pseudo_letter + "))", r.src_host = "(?:(?:(?:(?:" + r.src_domain + ")\\.)*" + r.src_domain + "))", r.tpl_host_fuzzy = "(?:" + r.src_ip4 + "|(?:(?:(?:" + r.src_domain + ")\\.)+(?:%TLDS%)))", r.tpl_host_no_ip_fuzzy = "(?:(?:(?:" + r.src_domain + ")\\.)+(?:%TLDS%))", r.src_host_strict = r.src_host + r.src_host_terminator, r.tpl_host_fuzzy_strict = r.tpl_host_fuzzy + r.src_host_terminator, r.src_host_port_strict = r.src_host + r.src_port + r.src_host_terminator, r.tpl_host_port_fuzzy_strict = r.tpl_host_fuzzy + r.src_port + r.src_host_terminator, r.tpl_host_port_no_ip_fuzzy_strict = r.tpl_host_no_ip_fuzzy + r.src_port + r.src_host_terminator, r.tpl_host_fuzzy_test = "localhost|www\\.|\\.\\d{1,3}\\.|(?:\\.(?:%TLDS%)(?:" + r.src_ZPCc + "|>|$))", r.tpl_email_fuzzy = "(^|[><]|\\(|" + r.src_ZCc + ")(" + r.src_email_name + "@" + r.tpl_host_fuzzy_strict + ")", r.tpl_link_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + r.src_ZPCc + "))((?![$+<=>^`|])" + r.tpl_host_port_fuzzy_strict + r.src_path + ")", r.tpl_link_no_ip_fuzzy = "(^|(?![.:/\\-_@])(?:[$+<=>^`|]|" + r.src_ZPCc + "))((?![$+<=>^`|])" + r.tpl_host_port_no_ip_fuzzy_strict + r.src_path + ")", r
                }
            }, {
                "uc.micro/categories/Cc/regex": 461,
                "uc.micro/categories/P/regex": 462,
                "uc.micro/categories/Z/regex": 463,
                "uc.micro/properties/Any/regex": 464
            }],
            197: [function(require, module, exports) {
                var getNative = require("./_getNative"),
                    root = require("./_root"),
                    DataView = getNative(root, "DataView");
                module.exports = DataView
            }, {
                "./_getNative": 300,
                "./_root": 346
            }],
            198: [function(require, module, exports) {
                function Hash(e) {
                    var h = -1,
                        a = null == e ? 0 : e.length;
                    for (this.clear(); ++h < a;) {
                        var s = e[h];
                        this.set(s[0], s[1])
                    }
                }
                var hashClear = require("./_hashClear"),
                    hashDelete = require("./_hashDelete"),
                    hashGet = require("./_hashGet"),
                    hashHas = require("./_hashHas"),
                    hashSet = require("./_hashSet");
                Hash.prototype.clear = hashClear, Hash.prototype.delete = hashDelete, Hash.prototype.get = hashGet, Hash.prototype.has = hashHas, Hash.prototype.set = hashSet, module.exports = Hash
            }, {
                "./_hashClear": 309,
                "./_hashDelete": 310,
                "./_hashGet": 311,
                "./_hashHas": 312,
                "./_hashSet": 313
            }],
            199: [function(require, module, exports) {
                function ListCache(e) {
                    var t = -1,
                        a = null == e ? 0 : e.length;
                    for (this.clear(); ++t < a;) {
                        var s = e[t];
                        this.set(s[0], s[1])
                    }
                }
                var listCacheClear = require("./_listCacheClear"),
                    listCacheDelete = require("./_listCacheDelete"),
                    listCacheGet = require("./_listCacheGet"),
                    listCacheHas = require("./_listCacheHas"),
                    listCacheSet = require("./_listCacheSet");
                ListCache.prototype.clear = listCacheClear, ListCache.prototype.delete = listCacheDelete, ListCache.prototype.get = listCacheGet, ListCache.prototype.has = listCacheHas, ListCache.prototype.set = listCacheSet, module.exports = ListCache
            }, {
                "./_listCacheClear": 325,
                "./_listCacheDelete": 326,
                "./_listCacheGet": 327,
                "./_listCacheHas": 328,
                "./_listCacheSet": 329
            }],
            200: [function(require, module, exports) {
                var getNative = require("./_getNative"),
                    root = require("./_root"),
                    Map = getNative(root, "Map");
                module.exports = Map
            }, {
                "./_getNative": 300,
                "./_root": 346
            }],
            201: [function(require, module, exports) {
                function MapCache(e) {
                    var a = -1,
                        p = null == e ? 0 : e.length;
                    for (this.clear(); ++a < p;) {
                        var t = e[a];
                        this.set(t[0], t[1])
                    }
                }
                var mapCacheClear = require("./_mapCacheClear"),
                    mapCacheDelete = require("./_mapCacheDelete"),
                    mapCacheGet = require("./_mapCacheGet"),
                    mapCacheHas = require("./_mapCacheHas"),
                    mapCacheSet = require("./_mapCacheSet");
                MapCache.prototype.clear = mapCacheClear, MapCache.prototype.delete = mapCacheDelete, MapCache.prototype.get = mapCacheGet, MapCache.prototype.has = mapCacheHas, MapCache.prototype.set = mapCacheSet, module.exports = MapCache
            }, {
                "./_mapCacheClear": 330,
                "./_mapCacheDelete": 331,
                "./_mapCacheGet": 332,
                "./_mapCacheHas": 333,
                "./_mapCacheSet": 334
            }],
            202: [function(require, module, exports) {
                var getNative = require("./_getNative"),
                    root = require("./_root"),
                    Promise = getNative(root, "Promise");
                module.exports = Promise
            }, {
                "./_getNative": 300,
                "./_root": 346
            }],
            203: [function(require, module, exports) {
                var getNative = require("./_getNative"),
                    root = require("./_root"),
                    Set = getNative(root, "Set");
                module.exports = Set
            }, {
                "./_getNative": 300,
                "./_root": 346
            }],
            204: [function(require, module, exports) {
                function SetCache(e) {
                    var a = -1,
                        t = null == e ? 0 : e.length;
                    for (this.__data__ = new MapCache; ++a < t;) this.add(e[a])
                }
                var MapCache = require("./_MapCache"),
                    setCacheAdd = require("./_setCacheAdd"),
                    setCacheHas = require("./_setCacheHas");
                SetCache.prototype.add = SetCache.prototype.push = setCacheAdd, SetCache.prototype.has = setCacheHas, module.exports = SetCache
            }, {
                "./_MapCache": 201,
                "./_setCacheAdd": 347,
                "./_setCacheHas": 348
            }],
            205: [function(require, module, exports) {
                function Stack(t) {
                    var e = this.__data__ = new ListCache(t);
                    this.size = e.size
                }
                var ListCache = require("./_ListCache"),
                    stackClear = require("./_stackClear"),
                    stackDelete = require("./_stackDelete"),
                    stackGet = require("./_stackGet"),
                    stackHas = require("./_stackHas"),
                    stackSet = require("./_stackSet");
                Stack.prototype.clear = stackClear, Stack.prototype.delete = stackDelete, Stack.prototype.get = stackGet, Stack.prototype.has = stackHas, Stack.prototype.set = stackSet, module.exports = Stack
            }, {
                "./_ListCache": 199,
                "./_stackClear": 352,
                "./_stackDelete": 353,
                "./_stackGet": 354,
                "./_stackHas": 355,
                "./_stackSet": 356
            }],
            206: [function(require, module, exports) {
                var root = require("./_root"),
                    _Symbol2 = root.Symbol;
                module.exports = _Symbol2
            }, {
                "./_root": 346
            }],
            207: [function(require, module, exports) {
                var root = require("./_root"),
                    Uint8Array = root.Uint8Array;
                module.exports = Uint8Array
            }, {
                "./_root": 346
            }],
            208: [function(require, module, exports) {
                var getNative = require("./_getNative"),
                    root = require("./_root"),
                    WeakMap = getNative(root, "WeakMap");
                module.exports = WeakMap
            }, {
                "./_getNative": 300,
                "./_root": 346
            }],
            209: [function(require, module, exports) {
                function apply(l, e, a) {
                    switch (a.length) {
                        case 0:
                            return l.call(e);
                        case 1:
                            return l.call(e, a[0]);
                        case 2:
                            return l.call(e, a[0], a[1]);
                        case 3:
                            return l.call(e, a[0], a[1], a[2])
                    }
                    return l.apply(e, a)
                }
                module.exports = apply
            }, {}],
            210: [function(require, module, exports) {
                function arrayEach(r, a) {
                    for (var n = -1, e = null == r ? 0 : r.length; ++n < e && !1 !== a(r[n], n, r););
                    return r
                }
                module.exports = arrayEach
            }, {}],
            211: [function(require, module, exports) {
                function arrayEvery(r, e) {
                    for (var n = -1, a = null == r ? 0 : r.length; ++n < a;)
                        if (!e(r[n], n, r)) return !1;
                    return !0
                }
                module.exports = arrayEvery
            }, {}],
            212: [function(require, module, exports) {
                function arrayFilter(r, a) {
                    for (var e = -1, l = null == r ? 0 : r.length, t = 0, n = []; ++e < l;) {
                        var o = r[e];
                        a(o, e, r) && (n[t++] = o)
                    }
                    return n
                }
                module.exports = arrayFilter
            }, {}],
            213: [function(require, module, exports) {
                function arrayIncludes(e, n) {
                    return !!(null == e ? 0 : e.length) && baseIndexOf(e, n, 0) > -1
                }
                var baseIndexOf = require("./_baseIndexOf");
                module.exports = arrayIncludes
            }, {
                "./_baseIndexOf": 241
            }],
            214: [function(require, module, exports) {
                function arrayIncludesWith(r, n, e) {
                    for (var t = -1, u = null == r ? 0 : r.length; ++t < u;)
                        if (e(n, r[t])) return !0;
                    return !1
                }
                module.exports = arrayIncludesWith
            }, {}],
            215: [function(require, module, exports) {
                function arrayLikeKeys(e, r) {
                    var s = isArray(e),
                        i = !s && isArguments(e),
                        t = !s && !i && isBuffer(e),
                        a = !s && !i && !t && isTypedArray(e),
                        n = s || i || t || a,
                        y = n ? baseTimes(e.length, String) : [],
                        u = y.length;
                    for (var o in e) !r && !hasOwnProperty.call(e, o) || n && ("length" == o || t && ("offset" == o || "parent" == o) || a && ("buffer" == o || "byteLength" == o || "byteOffset" == o) || isIndex(o, u)) || y.push(o);
                    return y
                }
                var baseTimes = require("./_baseTimes"),
                    isArguments = require("./isArguments"),
                    isArray = require("./isArray"),
                    isBuffer = require("./isBuffer"),
                    isIndex = require("./_isIndex"),
                    isTypedArray = require("./isTypedArray"),
                    objectProto = Object.prototype,
                    hasOwnProperty = objectProto.hasOwnProperty;
                module.exports = arrayLikeKeys
            }, {
                "./_baseTimes": 267,
                "./_isIndex": 318,
                "./isArguments": 378,
                "./isArray": 379,
                "./isBuffer": 382,
                "./isTypedArray": 394
            }],
            216: [function(require, module, exports) {
                function arrayMap(r, a) {
                    for (var n = -1, e = null == r ? 0 : r.length, l = Array(e); ++n < e;) l[n] = a(r[n], n, r);
                    return l
                }
                module.exports = arrayMap
            }, {}],
            217: [function(require, module, exports) {
                function arrayPush(r, a) {
                    for (var e = -1, n = a.length, t = r.length; ++e < n;) r[t + e] = a[e];
                    return r
                }
                module.exports = arrayPush
            }, {}],
            218: [function(require, module, exports) {
                function arrayReduce(r, e, u, a) {
                    var n = -1,
                        l = null == r ? 0 : r.length;
                    for (a && l && (u = r[++n]); ++n < l;) u = e(u, r[n], n, r);
                    return u
                }
                module.exports = arrayReduce
            }, {}],
            219: [function(require, module, exports) {
                function arraySome(r, e) {
                    for (var n = -1, o = null == r ? 0 : r.length; ++n < o;)
                        if (e(r[n], n, r)) return !0;
                    return !1
                }
                module.exports = arraySome
            }, {}],
            220: [function(require, module, exports) {
                var baseProperty = require("./_baseProperty"),
                    asciiSize = baseProperty("length");
                module.exports = asciiSize
            }, {
                "./_baseProperty": 259
            }],
            221: [function(require, module, exports) {
                function assignValue(e, s, a) {
                    var r = e[s];
                    hasOwnProperty.call(e, s) && eq(r, a) && (void 0 !== a || s in e) || baseAssignValue(e, s, a)
                }
                var baseAssignValue = require("./_baseAssignValue"),
                    eq = require("./eq"),
                    objectProto = Object.prototype,
                    hasOwnProperty = objectProto.hasOwnProperty;
                module.exports = assignValue
            }, {
                "./_baseAssignValue": 225,
                "./eq": 367
            }],
            222: [function(require, module, exports) {
                function assocIndexOf(e, r) {
                    for (var n = e.length; n--;)
                        if (eq(e[n][0], r)) return n;
                    return -1
                }
                var eq = require("./eq");
                module.exports = assocIndexOf
            }, {
                "./eq": 367
            }],
            223: [function(require, module, exports) {
                function baseAssign(e, s) {
                    return e && copyObject(s, keys(s), e)
                }
                var copyObject = require("./_copyObject"),
                    keys = require("./keys");
                module.exports = baseAssign
            }, {
                "./_copyObject": 282,
                "./keys": 396
            }],
            224: [function(require, module, exports) {
                function baseAssignIn(e, n) {
                    return e && copyObject(n, keysIn(n), e)
                }
                var copyObject = require("./_copyObject"),
                    keysIn = require("./keysIn");
                module.exports = baseAssignIn
            }, {
                "./_copyObject": 282,
                "./keysIn": 397
            }],
            225: [function(require, module, exports) {
                function baseAssignValue(e, r, i) {
                    "__proto__" == r && defineProperty ? defineProperty(e, r, {
                        configurable: !0,
                        enumerable: !0,
                        value: i,
                        writable: !0
                    }) : e[r] = i
                }
                var defineProperty = require("./_defineProperty");
                module.exports = baseAssignValue
            }, {
                "./_defineProperty": 290
            }],
            226: [function(require, module, exports) {
                function baseClamp(e, o, a) {
                    return e == e && (void 0 !== a && (e = e <= a ? e : a), void 0 !== o && (e = e >= o ? e : o)), e
                }
                module.exports = baseClamp
            }, {}],
            227: [function(require, module, exports) {
                function baseClone(e, a, r, n, g, o) {
                    var t, l = a & CLONE_DEEP_FLAG,
                        i = a & CLONE_FLAT_FLAG,
                        s = a & CLONE_SYMBOLS_FLAG;
                    if (r && (t = g ? r(e, n, g, o) : r(e)), void 0 !== t) return t;
                    if (!isObject(e)) return e;
                    var c = isArray(e);
                    if (c) {
                        if (t = initCloneArray(e), !l) return copyArray(e, t)
                    } else {
                        var T = getTag(e),
                            b = T == funcTag || T == genTag;
                        if (isBuffer(e)) return cloneBuffer(e, l);
                        if (T == objectTag || T == argsTag || b && !g) {
                            if (t = i || b ? {} : initCloneObject(e), !l) return i ? copySymbolsIn(e, baseAssignIn(t, e)) : copySymbols(e, baseAssign(t, e))
                        } else {
                            if (!cloneableTags[T]) return g ? e : {};
                            t = initCloneByTag(e, T, l)
                        }
                    }
                    o || (o = new Stack);
                    var u = o.get(e);
                    if (u) return u;
                    o.set(e, t), isSet(e) ? e.forEach(function(n) {
                        t.add(baseClone(n, a, r, n, e, o))
                    }) : isMap(e) && e.forEach(function(n, g) {
                        t.set(g, baseClone(n, a, r, g, e, o))
                    });
                    var y = s ? i ? getAllKeysIn : getAllKeys : i ? keysIn : keys,
                        A = c ? void 0 : y(e);
                    return arrayEach(A || e, function(n, g) {
                        A && (n = e[g = n]), assignValue(t, g, baseClone(n, a, r, g, e, o))
                    }), t
                }
                var Stack = require("./_Stack"),
                    arrayEach = require("./_arrayEach"),
                    assignValue = require("./_assignValue"),
                    baseAssign = require("./_baseAssign"),
                    baseAssignIn = require("./_baseAssignIn"),
                    cloneBuffer = require("./_cloneBuffer"),
                    copyArray = require("./_copyArray"),
                    copySymbols = require("./_copySymbols"),
                    copySymbolsIn = require("./_copySymbolsIn"),
                    getAllKeys = require("./_getAllKeys"),
                    getAllKeysIn = require("./_getAllKeysIn"),
                    getTag = require("./_getTag"),
                    initCloneArray = require("./_initCloneArray"),
                    initCloneByTag = require("./_initCloneByTag"),
                    initCloneObject = require("./_initCloneObject"),
                    isArray = require("./isArray"),
                    isBuffer = require("./isBuffer"),
                    isMap = require("./isMap"),
                    isObject = require("./isObject"),
                    isSet = require("./isSet"),
                    keys = require("./keys"),
                    CLONE_DEEP_FLAG = 1,
                    CLONE_FLAT_FLAG = 2,
                    CLONE_SYMBOLS_FLAG = 4,
                    argsTag = "[object Arguments]",
                    arrayTag = "[object Array]",
                    boolTag = "[object Boolean]",
                    dateTag = "[object Date]",
                    errorTag = "[object Error]",
                    funcTag = "[object Function]",
                    genTag = "[object GeneratorFunction]",
                    mapTag = "[object Map]",
                    numberTag = "[object Number]",
                    objectTag = "[object Object]",
                    regexpTag = "[object RegExp]",
                    setTag = "[object Set]",
                    stringTag = "[object String]",
                    symbolTag = "[object Symbol]",
                    weakMapTag = "[object WeakMap]",
                    arrayBufferTag = "[object ArrayBuffer]",
                    dataViewTag = "[object DataView]",
                    float32Tag = "[object Float32Array]",
                    float64Tag = "[object Float64Array]",
                    int8Tag = "[object Int8Array]",
                    int16Tag = "[object Int16Array]",
                    int32Tag = "[object Int32Array]",
                    uint8Tag = "[object Uint8Array]",
                    uint8ClampedTag = "[object Uint8ClampedArray]",
                    uint16Tag = "[object Uint16Array]",
                    uint32Tag = "[object Uint32Array]",
                    cloneableTags = {};
                cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = !0, cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = !1, module.exports = baseClone
            }, {
                "./_Stack": 205,
                "./_arrayEach": 210,
                "./_assignValue": 221,
                "./_baseAssign": 223,
                "./_baseAssignIn": 224,
                "./_cloneBuffer": 276,
                "./_copyArray": 281,
                "./_copySymbols": 283,
                "./_copySymbolsIn": 284,
                "./_getAllKeys": 296,
                "./_getAllKeysIn": 297,
                "./_getTag": 305,
                "./_initCloneArray": 314,
                "./_initCloneByTag": 315,
                "./_initCloneObject": 316,
                "./isArray": 379,
                "./isBuffer": 382,
                "./isMap": 387,
                "./isObject": 388,
                "./isSet": 391,
                "./keys": 396
            }],
            228: [function(require, module, exports) {
                var isObject = require("./isObject"),
                    objectCreate = Object.create,
                    baseCreate = function() {
                        function e() {}
                        return function(t) {
                            if (!isObject(t)) return {};
                            if (objectCreate) return objectCreate(t);
                            e.prototype = t;
                            var r = new e;
                            return e.prototype = void 0, r
                        }
                    }();
                module.exports = baseCreate
            }, {
                "./isObject": 388
            }],
            229: [function(require, module, exports) {
                function baseDifference(e, r, a, n) {
                    var u = -1,
                        c = arrayIncludes,
                        s = !0,
                        i = e.length,
                        h = [],
                        t = r.length;
                    if (!i) return h;
                    a && (r = arrayMap(r, baseUnary(a))), n ? (c = arrayIncludesWith, s = !1) : r.length >= LARGE_ARRAY_SIZE && (c = cacheHas, s = !1, r = new SetCache(r));
                    e: for (; ++u < i;) {
                        var l = e[u],
                            y = null == a ? l : a(l);
                        if (l = n || 0 !== l ? l : 0, s && y == y) {
                            for (var f = t; f--;)
                                if (r[f] === y) continue e;
                            h.push(l)
                        } else c(r, y, n) || h.push(l)
                    }
                    return h
                }
                var SetCache = require("./_SetCache"),
                    arrayIncludes = require("./_arrayIncludes"),
                    arrayIncludesWith = require("./_arrayIncludesWith"),
                    arrayMap = require("./_arrayMap"),
                    baseUnary = require("./_baseUnary"),
                    cacheHas = require("./_cacheHas"),
                    LARGE_ARRAY_SIZE = 200;
                module.exports = baseDifference
            }, {
                "./_SetCache": 204,
                "./_arrayIncludes": 213,
                "./_arrayIncludesWith": 214,
                "./_arrayMap": 216,
                "./_baseUnary": 269,
                "./_cacheHas": 272
            }],
            230: [function(require, module, exports) {
                var baseForOwn = require("./_baseForOwn"),
                    createBaseEach = require("./_createBaseEach"),
                    baseEach = createBaseEach(baseForOwn);
                module.exports = baseEach
            }, {
                "./_baseForOwn": 236,
                "./_createBaseEach": 286
            }],
            231: [function(require, module, exports) {
                function baseEvery(e, r) {
                    var a = !0;
                    return baseEach(e, function(e, n, s) {
                        return a = !!r(e, n, s)
                    }), a
                }
                var baseEach = require("./_baseEach");
                module.exports = baseEvery
            }, {
                "./_baseEach": 230
            }],
            232: [function(require, module, exports) {
                function baseFilter(e, a) {
                    var r = [];
                    return baseEach(e, function(e, s, t) {
                        a(e, s, t) && r.push(e)
                    }), r
                }
                var baseEach = require("./_baseEach");
                module.exports = baseFilter
            }, {
                "./_baseEach": 230
            }],
            233: [function(require, module, exports) {
                function baseFindIndex(e, n, r, d) {
                    for (var t = e.length, i = r + (d ? 1 : -1); d ? i-- : ++i < t;)
                        if (n(e[i], i, e)) return i;
                    return -1
                }
                module.exports = baseFindIndex
            }, {}],
            234: [function(require, module, exports) {
                function baseFlatten(a, e, r, t, l) {
                    var n = -1,
                        s = a.length;
                    for (r || (r = isFlattenable), l || (l = []); ++n < s;) {
                        var u = a[n];
                        e > 0 && r(u) ? e > 1 ? baseFlatten(u, e - 1, r, t, l) : arrayPush(l, u) : t || (l[l.length] = u)
                    }
                    return l
                }
                var arrayPush = require("./_arrayPush"),
                    isFlattenable = require("./_isFlattenable");
                module.exports = baseFlatten
            }, {
                "./_arrayPush": 217,
                "./_isFlattenable": 317
            }],
            235: [function(require, module, exports) {
                var createBaseFor = require("./_createBaseFor"),
                    baseFor = createBaseFor();
                module.exports = baseFor
            }, {
                "./_createBaseFor": 287
            }],
            236: [function(require, module, exports) {
                function baseForOwn(e, r) {
                    return e && baseFor(e, r, keys)
                }
                var baseFor = require("./_baseFor"),
                    keys = require("./keys");
                module.exports = baseForOwn
            }, {
                "./_baseFor": 235,
                "./keys": 396
            }],
            237: [function(require, module, exports) {
                function baseGet(e, t) {
                    for (var a = 0, r = (t = castPath(t, e)).length; null != e && a < r;) e = e[toKey(t[a++])];
                    return a && a == r ? e : void 0
                }
                var castPath = require("./_castPath"),
                    toKey = require("./_toKey");
                module.exports = baseGet
            }, {
                "./_castPath": 274,
                "./_toKey": 360
            }],
            238: [function(require, module, exports) {
                function baseGetAllKeys(r, a, e) {
                    var s = a(r);
                    return isArray(r) ? s : arrayPush(s, e(r))
                }
                var arrayPush = require("./_arrayPush"),
                    isArray = require("./isArray");
                module.exports = baseGetAllKeys
            }, {
                "./_arrayPush": 217,
                "./isArray": 379
            }],
            239: [function(require, module, exports) {
                function baseGetTag(e) {
                    return null == e ? void 0 === e ? undefinedTag : nullTag : symToStringTag && symToStringTag in Object(e) ? getRawTag(e) : objectToString(e)
                }
                var _Symbol3 = require("./_Symbol"),
                    getRawTag = require("./_getRawTag"),
                    objectToString = require("./_objectToString"),
                    nullTag = "[object Null]",
                    undefinedTag = "[object Undefined]",
                    symToStringTag = _Symbol3 ? _Symbol3.toStringTag : void 0;
                module.exports = baseGetTag
            }, {
                "./_Symbol": 206,
                "./_getRawTag": 302,
                "./_objectToString": 342
            }],
            240: [function(require, module, exports) {
                function baseHasIn(n, e) {
                    return null != n && e in Object(n)
                }
                module.exports = baseHasIn
            }, {}],
            241: [function(require, module, exports) {
                function baseIndexOf(e, s, n) {
                    return s == s ? strictIndexOf(e, s, n) : baseFindIndex(e, baseIsNaN, n)
                }
                var baseFindIndex = require("./_baseFindIndex"),
                    baseIsNaN = require("./_baseIsNaN"),
                    strictIndexOf = require("./_strictIndexOf");
                module.exports = baseIndexOf
            }, {
                "./_baseFindIndex": 233,
                "./_baseIsNaN": 247,
                "./_strictIndexOf": 357
            }],
            242: [function(require, module, exports) {
                function baseIsArguments(e) {
                    return isObjectLike(e) && baseGetTag(e) == argsTag
                }
                var baseGetTag = require("./_baseGetTag"),
                    isObjectLike = require("./isObjectLike"),
                    argsTag = "[object Arguments]";
                module.exports = baseIsArguments
            }, {
                "./_baseGetTag": 239,
                "./isObjectLike": 389
            }],
            243: [function(require, module, exports) {
                function baseIsEqual(e, s, a, u, i) {
                    return e === s || (null == e || null == s || !isObjectLike(e) && !isObjectLike(s) ? e != e && s != s : baseIsEqualDeep(e, s, a, u, baseIsEqual, i))
                }
                var baseIsEqualDeep = require("./_baseIsEqualDeep"),
                    isObjectLike = require("./isObjectLike");
                module.exports = baseIsEqual
            }, {
                "./_baseIsEqualDeep": 244,
                "./isObjectLike": 389
            }],
            244: [function(require, module, exports) {
                function baseIsEqualDeep(r, e, a, t, u, s) {
                    var g = isArray(r),
                        i = isArray(e),
                        y = g ? arrayTag : getTag(r),
                        c = i ? arrayTag : getTag(e),
                        o = (y = y == argsTag ? objectTag : y) == objectTag,
                        T = (c = c == argsTag ? objectTag : c) == objectTag,
                        A = y == c;
                    if (A && isBuffer(r)) {
                        if (!isBuffer(e)) return !1;
                        g = !0, o = !1
                    }
                    if (A && !o) return s || (s = new Stack), g || isTypedArray(r) ? equalArrays(r, e, a, t, u, s) : equalByTag(r, e, y, a, t, u, s);
                    if (!(a & COMPARE_PARTIAL_FLAG)) {
                        var q = o && hasOwnProperty.call(r, "__wrapped__"),
                            l = T && hasOwnProperty.call(e, "__wrapped__");
                        if (q || l) {
                            var b = q ? r.value() : r,
                                _ = l ? e.value() : e;
                            return s || (s = new Stack), u(b, _, a, t, s)
                        }
                    }
                    return !!A && (s || (s = new Stack), equalObjects(r, e, a, t, u, s))
                }
                var Stack = require("./_Stack"),
                    equalArrays = require("./_equalArrays"),
                    equalByTag = require("./_equalByTag"),
                    equalObjects = require("./_equalObjects"),
                    getTag = require("./_getTag"),
                    isArray = require("./isArray"),
                    isBuffer = require("./isBuffer"),
                    isTypedArray = require("./isTypedArray"),
                    COMPARE_PARTIAL_FLAG = 1,
                    argsTag = "[object Arguments]",
                    arrayTag = "[object Array]",
                    objectTag = "[object Object]",
                    objectProto = Object.prototype,
                    hasOwnProperty = objectProto.hasOwnProperty;
                module.exports = baseIsEqualDeep
            }, {
                "./_Stack": 205,
                "./_equalArrays": 291,
                "./_equalByTag": 292,
                "./_equalObjects": 293,
                "./_getTag": 305,
                "./isArray": 379,
                "./isBuffer": 382,
                "./isTypedArray": 394
            }],
            245: [function(require, module, exports) {
                function baseIsMap(e) {
                    return isObjectLike(e) && getTag(e) == mapTag
                }
                var getTag = require("./_getTag"),
                    isObjectLike = require("./isObjectLike"),
                    mapTag = "[object Map]";
                module.exports = baseIsMap
            }, {
                "./_getTag": 305,
                "./isObjectLike": 389
            }],
            246: [function(require, module, exports) {
                function baseIsMatch(r, e, a, t) {
                    var i = a.length,
                        u = i,
                        n = !t;
                    if (null == r) return !u;
                    for (r = Object(r); i--;) {
                        var s = a[i];
                        if (n && s[2] ? s[1] !== r[s[0]] : !(s[0] in r)) return !1
                    }
                    for (; ++i < u;) {
                        var A = (s = a[i])[0],
                            E = r[A],
                            R = s[1];
                        if (n && s[2]) {
                            if (void 0 === E && !(A in r)) return !1
                        } else {
                            var _ = new Stack;
                            if (t) var f = t(E, R, A, r, e, _);
                            if (!(void 0 === f ? baseIsEqual(R, E, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, t, _) : f)) return !1
                        }
                    }
                    return !0
                }
                var Stack = require("./_Stack"),
                    baseIsEqual = require("./_baseIsEqual"),
                    COMPARE_PARTIAL_FLAG = 1,
                    COMPARE_UNORDERED_FLAG = 2;
                module.exports = baseIsMatch
            }, {
                "./_Stack": 205,
                "./_baseIsEqual": 243
            }],
            247: [function(require, module, exports) {
                function baseIsNaN(e) {
                    return e != e
                }
                module.exports = baseIsNaN
            }, {}],
            248: [function(require, module, exports) {
                function baseIsNative(e) {
                    return !(!isObject(e) || isMasked(e)) && (isFunction(e) ? reIsNative : reIsHostCtor).test(toSource(e))
                }
                var isFunction = require("./isFunction"),
                    isMasked = require("./_isMasked"),
                    isObject = require("./isObject"),
                    toSource = require("./_toSource"),
                    reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
                    reIsHostCtor = /^\[object .+?Constructor\]$/,
                    funcProto = Function.prototype,
                    objectProto = Object.prototype,
                    funcToString = funcProto.toString,
                    hasOwnProperty = objectProto.hasOwnProperty,
                    reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
                module.exports = baseIsNative
            }, {
                "./_isMasked": 322,
                "./_toSource": 361,
                "./isFunction": 385,
                "./isObject": 388
            }],
            249: [function(require, module, exports) {
                function baseIsSet(e) {
                    return isObjectLike(e) && getTag(e) == setTag
                }
                var getTag = require("./_getTag"),
                    isObjectLike = require("./isObjectLike"),
                    setTag = "[object Set]";
                module.exports = baseIsSet
            }, {
                "./_getTag": 305,
                "./isObjectLike": 389
            }],
            250: [function(require, module, exports) {
                function baseIsTypedArray(a) {
                    return isObjectLike(a) && isLength(a.length) && !!typedArrayTags[baseGetTag(a)]
                }
                var baseGetTag = require("./_baseGetTag"),
                    isLength = require("./isLength"),
                    isObjectLike = require("./isObjectLike"),
                    argsTag = "[object Arguments]",
                    arrayTag = "[object Array]",
                    boolTag = "[object Boolean]",
                    dateTag = "[object Date]",
                    errorTag = "[object Error]",
                    funcTag = "[object Function]",
                    mapTag = "[object Map]",
                    numberTag = "[object Number]",
                    objectTag = "[object Object]",
                    regexpTag = "[object RegExp]",
                    setTag = "[object Set]",
                    stringTag = "[object String]",
                    weakMapTag = "[object WeakMap]",
                    arrayBufferTag = "[object ArrayBuffer]",
                    dataViewTag = "[object DataView]",
                    float32Tag = "[object Float32Array]",
                    float64Tag = "[object Float64Array]",
                    int8Tag = "[object Int8Array]",
                    int16Tag = "[object Int16Array]",
                    int32Tag = "[object Int32Array]",
                    uint8Tag = "[object Uint8Array]",
                    uint8ClampedTag = "[object Uint8ClampedArray]",
                    uint16Tag = "[object Uint16Array]",
                    uint32Tag = "[object Uint32Array]",
                    typedArrayTags = {};
                typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = !0, typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = !1, module.exports = baseIsTypedArray
            }, {
                "./_baseGetTag": 239,
                "./isLength": 386,
                "./isObjectLike": 389
            }],
            251: [function(require, module, exports) {
                function baseIteratee(e) {
                    return "function" == typeof e ? e : null == e ? identity : "object" == _typeof2(e) ? isArray(e) ? baseMatchesProperty(e[0], e[1]) : baseMatches(e) : property(e)
                }
                var baseMatches = require("./_baseMatches"),
                    baseMatchesProperty = require("./_baseMatchesProperty"),
                    identity = require("./identity"),
                    isArray = require("./isArray"),
                    property = require("./property");
                module.exports = baseIteratee
            }, {
                "./_baseMatches": 255,
                "./_baseMatchesProperty": 256,
                "./identity": 376,
                "./isArray": 379,
                "./property": 406
            }],
            252: [function(require, module, exports) {
                function baseKeys(e) {
                    if (!isPrototype(e)) return nativeKeys(e);
                    var r = [];
                    for (var t in Object(e)) hasOwnProperty.call(e, t) && "constructor" != t && r.push(t);
                    return r
                }
                var isPrototype = require("./_isPrototype"),
                    nativeKeys = require("./_nativeKeys"),
                    objectProto = Object.prototype,
                    hasOwnProperty = objectProto.hasOwnProperty;
                module.exports = baseKeys
            }, {
                "./_isPrototype": 323,
                "./_nativeKeys": 339
            }],
            253: [function(require, module, exports) {
                function baseKeysIn(e) {
                    if (!isObject(e)) return nativeKeysIn(e);
                    var r = isPrototype(e),
                        t = [];
                    for (var o in e)("constructor" != o || !r && hasOwnProperty.call(e, o)) && t.push(o);
                    return t
                }
                var isObject = require("./isObject"),
                    isPrototype = require("./_isPrototype"),
                    nativeKeysIn = require("./_nativeKeysIn"),
                    objectProto = Object.prototype,
                    hasOwnProperty = objectProto.hasOwnProperty;
                module.exports = baseKeysIn
            }, {
                "./_isPrototype": 323,
                "./_nativeKeysIn": 340,
                "./isObject": 388
            }],
            254: [function(require, module, exports) {
                function baseMap(r, a) {
                    var e = -1,
                        i = isArrayLike(r) ? Array(r.length) : [];
                    return baseEach(r, function(r, s, n) {
                        i[++e] = a(r, s, n)
                    }), i
                }
                var baseEach = require("./_baseEach"),
                    isArrayLike = require("./isArrayLike");
                module.exports = baseMap
            }, {
                "./_baseEach": 230,
                "./isArrayLike": 380
            }],
            255: [function(require, module, exports) {
                function baseMatches(a) {
                    var t = getMatchData(a);
                    return 1 == t.length && t[0][2] ? matchesStrictComparable(t[0][0], t[0][1]) : function(e) {
                        return e === a || baseIsMatch(e, a, t)
                    }
                }
                var baseIsMatch = require("./_baseIsMatch"),
                    getMatchData = require("./_getMatchData"),
                    matchesStrictComparable = require("./_matchesStrictComparable");
                module.exports = baseMatches
            }, {
                "./_baseIsMatch": 246,
                "./_getMatchData": 299,
                "./_matchesStrictComparable": 336
            }],
            256: [function(require, module, exports) {
                function baseMatchesProperty(e, r) {
                    return isKey(e) && isStrictComparable(r) ? matchesStrictComparable(toKey(e), r) : function(a) {
                        var t = get(a, e);
                        return void 0 === t && t === r ? hasIn(a, e) : baseIsEqual(r, t, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG)
                    }
                }
                var baseIsEqual = require("./_baseIsEqual"),
                    get = require("./get"),
                    hasIn = require("./hasIn"),
                    isKey = require("./_isKey"),
                    isStrictComparable = require("./_isStrictComparable"),
                    matchesStrictComparable = require("./_matchesStrictComparable"),
                    toKey = require("./_toKey"),
                    COMPARE_PARTIAL_FLAG = 1,
                    COMPARE_UNORDERED_FLAG = 2;
                module.exports = baseMatchesProperty
            }, {
                "./_baseIsEqual": 243,
                "./_isKey": 320,
                "./_isStrictComparable": 324,
                "./_matchesStrictComparable": 336,
                "./_toKey": 360,
                "./get": 374,
                "./hasIn": 375
            }],
            257: [function(require, module, exports) {
                function basePick(e, r) {
                    return basePickBy(e, r, function(r, a) {
                        return hasIn(e, a)
                    })
                }
                var basePickBy = require("./_basePickBy"),
                    hasIn = require("./hasIn");
                module.exports = basePick
            }, {
                "./_basePickBy": 258,
                "./hasIn": 375
            }],
            258: [function(require, module, exports) {
                function basePickBy(e, a, t) {
                    for (var r = -1, s = a.length, b = {}; ++r < s;) {
                        var c = a[r],
                            i = baseGet(e, c);
                        t(i, c) && baseSet(b, castPath(c, e), i)
                    }
                    return b
                }
                var baseGet = require("./_baseGet"),
                    baseSet = require("./_baseSet"),
                    castPath = require("./_castPath");
                module.exports = basePickBy
            }, {
                "./_baseGet": 237,
                "./_baseSet": 263,
                "./_castPath": 274
            }],
            259: [function(require, module, exports) {
                function baseProperty(r) {
                    return function(e) {
                        return null == e ? void 0 : e[r]
                    }
                }
                module.exports = baseProperty
            }, {}],
            260: [function(require, module, exports) {
                function basePropertyDeep(e) {
                    return function(r) {
                        return baseGet(r, e)
                    }
                }
                var baseGet = require("./_baseGet");
                module.exports = basePropertyDeep
            }, {
                "./_baseGet": 237
            }],
            261: [function(require, module, exports) {
                function baseReduce(e, u, n, c, o) {
                    return o(e, function(e, o, t) {
                        n = c ? (c = !1, e) : u(n, e, o, t)
                    }), n
                }
                module.exports = baseReduce
            }, {}],
            262: [function(require, module, exports) {
                function baseRest(e, t) {
                    return setToString(overRest(e, t, identity), e + "")
                }
                var identity = require("./identity"),
                    overRest = require("./_overRest"),
                    setToString = require("./_setToString");
                module.exports = baseRest
            }, {
                "./_overRest": 344,
                "./_setToString": 350,
                "./identity": 376
            }],
            263: [function(require, module, exports) {
                function baseSet(e, i, r, t) {
                    if (!isObject(e)) return e;
                    for (var s = -1, a = (i = castPath(i, e)).length, u = a - 1, n = e; null != n && ++s < a;) {
                        var o = toKey(i[s]),
                            c = r;
                        if (s != u) {
                            var l = n[o];
                            void 0 === (c = t ? t(l, o, n) : void 0) && (c = isObject(l) ? l : isIndex(i[s + 1]) ? [] : {})
                        }
                        assignValue(n, o, c), n = n[o]
                    }
                    return e
                }
                var assignValue = require("./_assignValue"),
                    castPath = require("./_castPath"),
                    isIndex = require("./_isIndex"),
                    isObject = require("./isObject"),
                    toKey = require("./_toKey");
                module.exports = baseSet
            }, {
                "./_assignValue": 221,
                "./_castPath": 274,
                "./_isIndex": 318,
                "./_toKey": 360,
                "./isObject": 388
            }],
            264: [function(require, module, exports) {
                var constant = require("./constant"),
                    defineProperty = require("./_defineProperty"),
                    identity = require("./identity"),
                    baseSetToString = defineProperty ? function(e, t) {
                        return defineProperty(e, "toString", {
                            configurable: !0,
                            enumerable: !1,
                            value: constant(t),
                            writable: !0
                        })
                    } : identity;
                module.exports = baseSetToString
            }, {
                "./_defineProperty": 290,
                "./constant": 363,
                "./identity": 376
            }],
            265: [function(require, module, exports) {
                function baseSlice(e, r, a) {
                    var l = -1,
                        n = e.length;
                    r < 0 && (r = -r > n ? 0 : n + r), (a = a > n ? n : a) < 0 && (a += n), n = r > a ? 0 : a - r >>> 0, r >>>= 0;
                    for (var o = Array(n); ++l < n;) o[l] = e[l + r];
                    return o
                }
                module.exports = baseSlice
            }, {}],
            266: [function(require, module, exports) {
                function baseSome(e, a) {
                    var r;
                    return baseEach(e, function(e, n, o) {
                        return !(r = a(e, n, o))
                    }), !!r
                }
                var baseEach = require("./_baseEach");
                module.exports = baseSome
            }, {
                "./_baseEach": 230
            }],
            267: [function(require, module, exports) {
                function baseTimes(e, r) {
                    for (var s = -1, a = Array(e); ++s < e;) a[s] = r(s);
                    return a
                }
                module.exports = baseTimes
            }, {}],
            268: [function(require, module, exports) {
                function baseToString(r) {
                    if ("string" == typeof r) return r;
                    if (isArray(r)) return arrayMap(r, baseToString) + "";
                    if (isSymbol(r)) return symbolToString ? symbolToString.call(r) : "";
                    var o = r + "";
                    return "0" == o && 1 / r == -INFINITY ? "-0" : o
                }
                var _Symbol4 = require("./_Symbol"),
                    arrayMap = require("./_arrayMap"),
                    isArray = require("./isArray"),
                    isSymbol = require("./isSymbol"),
                    INFINITY = 1 / 0,
                    symbolProto = _Symbol4 ? _Symbol4.prototype : void 0,
                    symbolToString = symbolProto ? symbolProto.toString : void 0;
                module.exports = baseToString
            }, {
                "./_Symbol": 206,
                "./_arrayMap": 216,
                "./isArray": 379,
                "./isSymbol": 393
            }],
            269: [function(require, module, exports) {
                function baseUnary(n) {
                    return function(r) {
                        return n(r)
                    }
                }
                module.exports = baseUnary
            }, {}],
            270: [function(require, module, exports) {
                function baseUnset(e, t) {
                    return t = castPath(t, e), null == (e = parent(e, t)) || delete e[toKey(last(t))]
                }
                var castPath = require("./_castPath"),
                    last = require("./last"),
                    parent = require("./_parent"),
                    toKey = require("./_toKey");
                module.exports = baseUnset
            }, {
                "./_castPath": 274,
                "./_parent": 345,
                "./_toKey": 360,
                "./last": 398
            }],
            271: [function(require, module, exports) {
                function baseValues(a, r) {
                    return arrayMap(r, function(r) {
                        return a[r]
                    })
                }
                var arrayMap = require("./_arrayMap");
                module.exports = baseValues
            }, {
                "./_arrayMap": 216
            }],
            272: [function(require, module, exports) {
                function cacheHas(a, c) {
                    return a.has(c)
                }
                module.exports = cacheHas
            }, {}],
            273: [function(require, module, exports) {
                function castFunction(t) {
                    return "function" == typeof t ? t : identity
                }
                var identity = require("./identity");
                module.exports = castFunction
            }, {
                "./identity": 376
            }],
            274: [function(require, module, exports) {
                function castPath(r, t) {
                    return isArray(r) ? r : isKey(r, t) ? [r] : stringToPath(toString(r))
                }
                var isArray = require("./isArray"),
                    isKey = require("./_isKey"),
                    stringToPath = require("./_stringToPath"),
                    toString = require("./toString");
                module.exports = castPath
            }, {
                "./_isKey": 320,
                "./_stringToPath": 359,
                "./isArray": 379,
                "./toString": 416
            }],
            275: [function(require, module, exports) {
                function cloneArrayBuffer(r) {
                    var e = new r.constructor(r.byteLength);
                    return new Uint8Array(e).set(new Uint8Array(r)), e
                }
                var Uint8Array = require("./_Uint8Array");
                module.exports = cloneArrayBuffer
            }, {
                "./_Uint8Array": 207
            }],
            276: [function(require, module, exports) {
                function cloneBuffer(e, o) {
                    if (o) return e.slice();
                    var r = e.length,
                        f = allocUnsafe ? allocUnsafe(r) : new e.constructor(r);
                    return e.copy(f), f
                }
                var root = require("./_root"),
                    freeExports = "object" == _typeof2(exports) && exports && !exports.nodeType && exports,
                    freeModule = freeExports && "object" == _typeof2(module) && module && !module.nodeType && module,
                    moduleExports = freeModule && freeModule.exports === freeExports,
                    Buffer = moduleExports ? root.Buffer : void 0,
                    allocUnsafe = Buffer ? Buffer.allocUnsafe : void 0;
                module.exports = cloneBuffer
            }, {
                "./_root": 346
            }],
            277: [function(require, module, exports) {
                function cloneDataView(e, r) {
                    var f = r ? cloneArrayBuffer(e.buffer) : e.buffer;
                    return new e.constructor(f, e.byteOffset, e.byteLength)
                }
                var cloneArrayBuffer = require("./_cloneArrayBuffer");
                module.exports = cloneDataView
            }, {
                "./_cloneArrayBuffer": 275
            }],
            278: [function(require, module, exports) {
                function cloneRegExp(e) {
                    var r = new e.constructor(e.source, reFlags.exec(e));
                    return r.lastIndex = e.lastIndex, r
                }
                var reFlags = /\w*$/;
                module.exports = cloneRegExp
            }, {}],
            279: [function(require, module, exports) {
                function cloneSymbol(o) {
                    return symbolValueOf ? Object(symbolValueOf.call(o)) : {}
                }
                var _Symbol5 = require("./_Symbol"),
                    symbolProto = _Symbol5 ? _Symbol5.prototype : void 0,
                    symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
                module.exports = cloneSymbol
            }, {
                "./_Symbol": 206
            }],
            280: [function(require, module, exports) {
                function cloneTypedArray(r, e) {
                    var f = e ? cloneArrayBuffer(r.buffer) : r.buffer;
                    return new r.constructor(f, r.byteOffset, r.length)
                }
                var cloneArrayBuffer = require("./_cloneArrayBuffer");
                module.exports = cloneTypedArray
            }, {
                "./_cloneArrayBuffer": 275
            }],
            281: [function(require, module, exports) {
                function copyArray(r, o) {
                    var y = -1,
                        a = r.length;
                    for (o || (o = Array(a)); ++y < a;) o[y] = r[y];
                    return o
                }
                module.exports = copyArray
            }, {}],
            282: [function(require, module, exports) {
                function copyObject(e, a, s, r) {
                    var i = !s;
                    s || (s = {});
                    for (var u = -1, n = a.length; ++u < n;) {
                        var l = a[u],
                            o = r ? r(s[l], e[l], l, s, e) : void 0;
                        void 0 === o && (o = e[l]), i ? baseAssignValue(s, l, o) : assignValue(s, l, o)
                    }
                    return s
                }
                var assignValue = require("./_assignValue"),
                    baseAssignValue = require("./_baseAssignValue");
                module.exports = copyObject
            }, {
                "./_assignValue": 221,
                "./_baseAssignValue": 225
            }],
            283: [function(require, module, exports) {
                function copySymbols(e, o) {
                    return copyObject(e, getSymbols(e), o)
                }
                var copyObject = require("./_copyObject"),
                    getSymbols = require("./_getSymbols");
                module.exports = copySymbols
            }, {
                "./_copyObject": 282,
                "./_getSymbols": 303
            }],
            284: [function(require, module, exports) {
                function copySymbolsIn(e, o) {
                    return copyObject(e, getSymbolsIn(e), o)
                }
                var copyObject = require("./_copyObject"),
                    getSymbolsIn = require("./_getSymbolsIn");
                module.exports = copySymbolsIn
            }, {
                "./_copyObject": 282,
                "./_getSymbolsIn": 304
            }],
            285: [function(require, module, exports) {
                var root = require("./_root"),
                    coreJsData = root["__core-js_shared__"];
                module.exports = coreJsData
            }, {
                "./_root": 346
            }],
            286: [function(require, module, exports) {
                function createBaseEach(r, e) {
                    return function(a, i) {
                        if (null == a) return a;
                        if (!isArrayLike(a)) return r(a, i);
                        for (var t = a.length, n = e ? t : -1, u = Object(a);
                            (e ? n-- : ++n < t) && !1 !== i(u[n], n, u););
                        return a
                    }
                }
                var isArrayLike = require("./isArrayLike");
                module.exports = createBaseEach
            }, {
                "./isArrayLike": 380
            }],
            287: [function(require, module, exports) {
                function createBaseFor(e) {
                    return function(r, t, a) {
                        for (var n = -1, o = Object(r), c = a(r), u = c.length; u--;) {
                            var f = c[e ? u : ++n];
                            if (!1 === t(o[f], f, o)) break
                        }
                        return r
                    }
                }
                module.exports = createBaseFor
            }, {}],
            288: [function(require, module, exports) {
                function createFind(e) {
                    return function(r, i, t) {
                        var a = Object(r);
                        if (!isArrayLike(r)) {
                            var n = baseIteratee(i, 3);
                            r = keys(r), i = function(e) {
                                return n(a[e], e, a)
                            }
                        }
                        var s = e(r, i, t);
                        return s > -1 ? a[n ? r[s] : s] : void 0
                    }
                }
                var baseIteratee = require("./_baseIteratee"),
                    isArrayLike = require("./isArrayLike"),
                    keys = require("./keys");
                module.exports = createFind
            }, {
                "./_baseIteratee": 251,
                "./isArrayLike": 380,
                "./keys": 396
            }],
            289: [function(require, module, exports) {
                function customOmitClone(i) {
                    return isPlainObject(i) ? void 0 : i
                }
                var isPlainObject = require("./isPlainObject");
                module.exports = customOmitClone
            }, {
                "./isPlainObject": 390
            }],
            290: [function(require, module, exports) {
                var getNative = require("./_getNative"),
                    defineProperty = function() {
                        try {
                            var e = getNative(Object, "defineProperty");
                            return e({}, "", {}), e
                        } catch (e) {}
                    }();
                module.exports = defineProperty
            }, {
                "./_getNative": 300
            }],
            291: [function(require, module, exports) {
                function equalArrays(e, r, a, t, i, u) {
                    var A = a & COMPARE_PARTIAL_FLAG,
                        n = e.length,
                        c = r.length;
                    if (n != c && !(A && c > n)) return !1;
                    var f = u.get(e);
                    if (f && u.get(r)) return f == r;
                    var o = -1,
                        _ = !0,
                        s = a & COMPARE_UNORDERED_FLAG ? new SetCache : void 0;
                    for (u.set(e, r), u.set(r, e); ++o < n;) {
                        var R = e[o],
                            h = r[o];
                        if (t) var l = A ? t(h, R, o, r, e, u) : t(R, h, o, e, r, u);
                        if (void 0 !== l) {
                            if (l) continue;
                            _ = !1;
                            break
                        }
                        if (s) {
                            if (!arraySome(r, function(e, r) {
                                    if (!cacheHas(s, r) && (R === e || i(R, e, a, t, u))) return s.push(r)
                                })) {
                                _ = !1;
                                break
                            }
                        } else if (R !== h && !i(R, h, a, t, u)) {
                            _ = !1;
                            break
                        }
                    }
                    return u.delete(e), u.delete(r), _
                }
                var SetCache = require("./_SetCache"),
                    arraySome = require("./_arraySome"),
                    cacheHas = require("./_cacheHas"),
                    COMPARE_PARTIAL_FLAG = 1,
                    COMPARE_UNORDERED_FLAG = 2;
                module.exports = equalArrays
            }, {
                "./_SetCache": 204,
                "./_arraySome": 219,
                "./_cacheHas": 272
            }],
            292: [function(require, module, exports) {
                function equalByTag(e, r, a, t, o, s, y) {
                    switch (a) {
                        case dataViewTag:
                            if (e.byteLength != r.byteLength || e.byteOffset != r.byteOffset) return !1;
                            e = e.buffer, r = r.buffer;
                        case arrayBufferTag:
                            return !(e.byteLength != r.byteLength || !s(new Uint8Array(e), new Uint8Array(r)));
                        case boolTag:
                        case dateTag:
                        case numberTag:
                            return eq(+e, +r);
                        case errorTag:
                            return e.name == r.name && e.message == r.message;
                        case regexpTag:
                        case stringTag:
                            return e == r + "";
                        case mapTag:
                            var b = mapToArray;
                        case setTag:
                            var g = t & COMPARE_PARTIAL_FLAG;
                            if (b || (b = setToArray), e.size != r.size && !g) return !1;
                            var u = y.get(e);
                            if (u) return u == r;
                            t |= COMPARE_UNORDERED_FLAG, y.set(e, r);
                            var l = equalArrays(b(e), b(r), t, o, s, y);
                            return y.delete(e), l;
                        case symbolTag:
                            if (symbolValueOf) return symbolValueOf.call(e) == symbolValueOf.call(r)
                    }
                    return !1
                }
                var _Symbol6 = require("./_Symbol"),
                    Uint8Array = require("./_Uint8Array"),
                    eq = require("./eq"),
                    equalArrays = require("./_equalArrays"),
                    mapToArray = require("./_mapToArray"),
                    setToArray = require("./_setToArray"),
                    COMPARE_PARTIAL_FLAG = 1,
                    COMPARE_UNORDERED_FLAG = 2,
                    boolTag = "[object Boolean]",
                    dateTag = "[object Date]",
                    errorTag = "[object Error]",
                    mapTag = "[object Map]",
                    numberTag = "[object Number]",
                    regexpTag = "[object RegExp]",
                    setTag = "[object Set]",
                    stringTag = "[object String]",
                    symbolTag = "[object Symbol]",
                    arrayBufferTag = "[object ArrayBuffer]",
                    dataViewTag = "[object DataView]",
                    symbolProto = _Symbol6 ? _Symbol6.prototype : void 0,
                    symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
                module.exports = equalByTag
            }, {
                "./_Symbol": 206,
                "./_Uint8Array": 207,
                "./_equalArrays": 291,
                "./_mapToArray": 335,
                "./_setToArray": 349,
                "./eq": 367
            }],
            293: [function(require, module, exports) {
                function equalObjects(t, e, r, o, n, c) {
                    var a = r & COMPARE_PARTIAL_FLAG,
                        s = getAllKeys(t),
                        l = s.length;
                    if (l != getAllKeys(e).length && !a) return !1;
                    for (var i = l; i--;) {
                        var u = s[i];
                        if (!(a ? u in e : hasOwnProperty.call(e, u))) return !1
                    }
                    var f = c.get(t);
                    if (f && c.get(e)) return f == e;
                    var A = !0;
                    c.set(t, e), c.set(e, t);
                    for (var v = a; ++i < l;) {
                        var y = t[u = s[i]],
                            P = e[u];
                        if (o) var g = a ? o(P, y, u, e, t, c) : o(y, P, u, t, e, c);
                        if (!(void 0 === g ? y === P || n(y, P, r, o, c) : g)) {
                            A = !1;
                            break
                        }
                        v || (v = "constructor" == u)
                    }
                    if (A && !v) {
                        var p = t.constructor,
                            O = e.constructor;
                        p != O && "constructor" in t && "constructor" in e && !("function" == typeof p && p instanceof p && "function" == typeof O && O instanceof O) && (A = !1)
                    }
                    return c.delete(t), c.delete(e), A
                }
                var getAllKeys = require("./_getAllKeys"),
                    COMPARE_PARTIAL_FLAG = 1,
                    objectProto = Object.prototype,
                    hasOwnProperty = objectProto.hasOwnProperty;
                module.exports = equalObjects
            }, {
                "./_getAllKeys": 296
            }],
            294: [function(require, module, exports) {
                function flatRest(e) {
                    return setToString(overRest(e, void 0, flatten), e + "")
                }
                var flatten = require("./flatten"),
                    overRest = require("./_overRest"),
                    setToString = require("./_setToString");
                module.exports = flatRest
            }, {
                "./_overRest": 344,
                "./_setToString": 350,
                "./flatten": 372
            }],
            295: [function(require, module, exports) {
                (function(global) {
                    var freeGlobal = "object" == _typeof2(global) && global && global.Object === Object && global;
                    module.exports = freeGlobal
                }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
            }, {}],
            296: [function(require, module, exports) {
                function getAllKeys(e) {
                    return baseGetAllKeys(e, keys, getSymbols)
                }
                var baseGetAllKeys = require("./_baseGetAllKeys"),
                    getSymbols = require("./_getSymbols"),
                    keys = require("./keys");
                module.exports = getAllKeys
            }, {
                "./_baseGetAllKeys": 238,
                "./_getSymbols": 303,
                "./keys": 396
            }],
            297: [function(require, module, exports) {
                function getAllKeysIn(e) {
                    return baseGetAllKeys(e, keysIn, getSymbolsIn)
                }
                var baseGetAllKeys = require("./_baseGetAllKeys"),
                    getSymbolsIn = require("./_getSymbolsIn"),
                    keysIn = require("./keysIn");
                module.exports = getAllKeysIn
            }, {
                "./_baseGetAllKeys": 238,
                "./_getSymbolsIn": 304,
                "./keysIn": 397
            }],
            298: [function(require, module, exports) {
                function getMapData(a, e) {
                    var t = a.__data__;
                    return isKeyable(e) ? t["string" == typeof e ? "string" : "hash"] : t.map
                }
                var isKeyable = require("./_isKeyable");
                module.exports = getMapData
            }, {
                "./_isKeyable": 321
            }],
            299: [function(require, module, exports) {
                function getMatchData(r) {
                    for (var e = keys(r), t = e.length; t--;) {
                        var a = e[t],
                            i = r[a];
                        e[t] = [a, i, isStrictComparable(i)]
                    }
                    return e
                }
                var isStrictComparable = require("./_isStrictComparable"),
                    keys = require("./keys");
                module.exports = getMatchData
            }, {
                "./_isStrictComparable": 324,
                "./keys": 396
            }],
            300: [function(require, module, exports) {
                function getNative(e, a) {
                    var t = getValue(e, a);
                    return baseIsNative(t) ? t : void 0
                }
                var baseIsNative = require("./_baseIsNative"),
                    getValue = require("./_getValue");
                module.exports = getNative
            }, {
                "./_baseIsNative": 248,
                "./_getValue": 306
            }],
            301: [function(require, module, exports) {
                var overArg = require("./_overArg"),
                    getPrototype = overArg(Object.getPrototypeOf, Object);
                module.exports = getPrototype
            }, {
                "./_overArg": 343
            }],
            302: [function(require, module, exports) {
                function getRawTag(t) {
                    var o = hasOwnProperty.call(t, symToStringTag),
                        r = t[symToStringTag];
                    try {
                        t[symToStringTag] = void 0;
                        var a = !0
                    } catch (t) {}
                    var e = nativeObjectToString.call(t);
                    return a && (o ? t[symToStringTag] = r : delete t[symToStringTag]), e
                }
                var _Symbol7 = require("./_Symbol"),
                    objectProto = Object.prototype,
                    hasOwnProperty = objectProto.hasOwnProperty,
                    nativeObjectToString = objectProto.toString,
                    symToStringTag = _Symbol7 ? _Symbol7.toStringTag : void 0;
                module.exports = getRawTag
            }, {
                "./_Symbol": 206
            }],
            303: [function(require, module, exports) {
                var arrayFilter = require("./_arrayFilter"),
                    stubArray = require("./stubArray"),
                    objectProto = Object.prototype,
                    propertyIsEnumerable = objectProto.propertyIsEnumerable,
                    nativeGetSymbols = Object.getOwnPropertySymbols,
                    getSymbols = nativeGetSymbols ? function(r) {
                        return null == r ? [] : (r = Object(r), arrayFilter(nativeGetSymbols(r), function(e) {
                            return propertyIsEnumerable.call(r, e)
                        }))
                    } : stubArray;
                module.exports = getSymbols
            }, {
                "./_arrayFilter": 212,
                "./stubArray": 411
            }],
            304: [function(require, module, exports) {
                var arrayPush = require("./_arrayPush"),
                    getPrototype = require("./_getPrototype"),
                    getSymbols = require("./_getSymbols"),
                    stubArray = require("./stubArray"),
                    nativeGetSymbols = Object.getOwnPropertySymbols,
                    getSymbolsIn = nativeGetSymbols ? function(r) {
                        for (var e = []; r;) arrayPush(e, getSymbols(r)), r = getPrototype(r);
                        return e
                    } : stubArray;
                module.exports = getSymbolsIn
            }, {
                "./_arrayPush": 217,
                "./_getPrototype": 301,
                "./_getSymbols": 303,
                "./stubArray": 411
            }],
            305: [function(require, module, exports) {
                var DataView = require("./_DataView"),
                    Map = require("./_Map"),
                    Promise = require("./_Promise"),
                    Set = require("./_Set"),
                    WeakMap = require("./_WeakMap"),
                    baseGetTag = require("./_baseGetTag"),
                    toSource = require("./_toSource"),
                    mapTag = "[object Map]",
                    objectTag = "[object Object]",
                    promiseTag = "[object Promise]",
                    setTag = "[object Set]",
                    weakMapTag = "[object WeakMap]",
                    dataViewTag = "[object DataView]",
                    dataViewCtorString = toSource(DataView),
                    mapCtorString = toSource(Map),
                    promiseCtorString = toSource(Promise),
                    setCtorString = toSource(Set),
                    weakMapCtorString = toSource(WeakMap),
                    getTag = baseGetTag;
                (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map && getTag(new Map) != mapTag || Promise && getTag(Promise.resolve()) != promiseTag || Set && getTag(new Set) != setTag || WeakMap && getTag(new WeakMap) != weakMapTag) && (getTag = function(e) {
                    var a = baseGetTag(e),
                        t = a == objectTag ? e.constructor : void 0,
                        r = t ? toSource(t) : "";
                    if (r) switch (r) {
                        case dataViewCtorString:
                            return dataViewTag;
                        case mapCtorString:
                            return mapTag;
                        case promiseCtorString:
                            return promiseTag;
                        case setCtorString:
                            return setTag;
                        case weakMapCtorString:
                            return weakMapTag
                    }
                    return a
                }), module.exports = getTag
            }, {
                "./_DataView": 197,
                "./_Map": 200,
                "./_Promise": 202,
                "./_Set": 203,
                "./_WeakMap": 208,
                "./_baseGetTag": 239,
                "./_toSource": 361
            }],
            306: [function(require, module, exports) {
                function getValue(e, u) {
                    return null == e ? void 0 : e[u]
                }
                module.exports = getValue
            }, {}],
            307: [function(require, module, exports) {
                function hasPath(e, r, t) {
                    for (var s = -1, i = (r = castPath(r, e)).length, a = !1; ++s < i;) {
                        var n = toKey(r[s]);
                        if (!(a = null != e && t(e, n))) break;
                        e = e[n]
                    }
                    return a || ++s != i ? a : !!(i = null == e ? 0 : e.length) && isLength(i) && isIndex(n, i) && (isArray(e) || isArguments(e))
                }
                var castPath = require("./_castPath"),
                    isArguments = require("./isArguments"),
                    isArray = require("./isArray"),
                    isIndex = require("./_isIndex"),
                    isLength = require("./isLength"),
                    toKey = require("./_toKey");
                module.exports = hasPath
            }, {
                "./_castPath": 274,
                "./_isIndex": 318,
                "./_toKey": 360,
                "./isArguments": 378,
                "./isArray": 379,
                "./isLength": 386
            }],
            308: [function(require, module, exports) {
                function hasUnicode(e) {
                    return reHasUnicode.test(e)
                }
                var rsAstralRange = "\\ud800-\\udfff",
                    rsComboMarksRange = "\\u0300-\\u036f",
                    reComboHalfMarksRange = "\\ufe20-\\ufe2f",
                    rsComboSymbolsRange = "\\u20d0-\\u20ff",
                    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
                    rsVarRange = "\\ufe0e\\ufe0f",
                    rsZWJ = "\\u200d",
                    reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
                module.exports = hasUnicode
            }, {}],
            309: [function(require, module, exports) {
                function hashClear() {
                    this.__data__ = nativeCreate ? nativeCreate(null) : {}, this.size = 0
                }
                var nativeCreate = require("./_nativeCreate");
                module.exports = hashClear
            }, {
                "./_nativeCreate": 338
            }],
            310: [function(require, module, exports) {
                function hashDelete(e) {
                    var t = this.has(e) && delete this.__data__[e];
                    return this.size -= t ? 1 : 0, t
                }
                module.exports = hashDelete
            }, {}],
            311: [function(require, module, exports) {
                function hashGet(e) {
                    var t = this.__data__;
                    if (nativeCreate) {
                        var r = t[e];
                        return r === HASH_UNDEFINED ? void 0 : r
                    }
                    return hasOwnProperty.call(t, e) ? t[e] : void 0
                }
                var nativeCreate = require("./_nativeCreate"),
                    HASH_UNDEFINED = "__lodash_hash_undefined__",
                    objectProto = Object.prototype,
                    hasOwnProperty = objectProto.hasOwnProperty;
                module.exports = hashGet
            }, {
                "./_nativeCreate": 338
            }],
            312: [function(require, module, exports) {
                function hashHas(e) {
                    var t = this.__data__;
                    return nativeCreate ? void 0 !== t[e] : hasOwnProperty.call(t, e)
                }
                var nativeCreate = require("./_nativeCreate"),
                    objectProto = Object.prototype,
                    hasOwnProperty = objectProto.hasOwnProperty;
                module.exports = hashHas
            }, {
                "./_nativeCreate": 338
            }],
            313: [function(require, module, exports) {
                function hashSet(e, t) {
                    var a = this.__data__;
                    return this.size += this.has(e) ? 0 : 1, a[e] = nativeCreate && void 0 === t ? HASH_UNDEFINED : t, this
                }
                var nativeCreate = require("./_nativeCreate"),
                    HASH_UNDEFINED = "__lodash_hash_undefined__";
                module.exports = hashSet
            }, {
                "./_nativeCreate": 338
            }],
            314: [function(require, module, exports) {
                function initCloneArray(t) {
                    var r = t.length,
                        n = new t.constructor(r);
                    return r && "string" == typeof t[0] && hasOwnProperty.call(t, "index") && (n.index = t.index, n.input = t.input), n
                }
                var objectProto = Object.prototype,
                    hasOwnProperty = objectProto.hasOwnProperty;
                module.exports = initCloneArray
            }, {}],
            315: [function(require, module, exports) {
                function initCloneByTag(e, a, r) {
                    var t = e.constructor;
                    switch (a) {
                        case arrayBufferTag:
                            return cloneArrayBuffer(e);
                        case boolTag:
                        case dateTag:
                            return new t((+e));
                        case dataViewTag:
                            return cloneDataView(e, r);
                        case float32Tag:
                        case float64Tag:
                        case int8Tag:
                        case int16Tag:
                        case int32Tag:
                        case uint8Tag:
                        case uint8ClampedTag:
                        case uint16Tag:
                        case uint32Tag:
                            return cloneTypedArray(e, r);
                        case mapTag:
                            return new t;
                        case numberTag:
                        case stringTag:
                            return new t(e);
                        case regexpTag:
                            return cloneRegExp(e);
                        case setTag:
                            return new t;
                        case symbolTag:
                            return cloneSymbol(e)
                    }
                }
                var cloneArrayBuffer = require("./_cloneArrayBuffer"),
                    cloneDataView = require("./_cloneDataView"),
                    cloneRegExp = require("./_cloneRegExp"),
                    cloneSymbol = require("./_cloneSymbol"),
                    cloneTypedArray = require("./_cloneTypedArray"),
                    boolTag = "[object Boolean]",
                    dateTag = "[object Date]",
                    mapTag = "[object Map]",
                    numberTag = "[object Number]",
                    regexpTag = "[object RegExp]",
                    setTag = "[object Set]",
                    stringTag = "[object String]",
                    symbolTag = "[object Symbol]",
                    arrayBufferTag = "[object ArrayBuffer]",
                    dataViewTag = "[object DataView]",
                    float32Tag = "[object Float32Array]",
                    float64Tag = "[object Float64Array]",
                    int8Tag = "[object Int8Array]",
                    int16Tag = "[object Int16Array]",
                    int32Tag = "[object Int32Array]",
                    uint8Tag = "[object Uint8Array]",
                    uint8ClampedTag = "[object Uint8ClampedArray]",
                    uint16Tag = "[object Uint16Array]",
                    uint32Tag = "[object Uint32Array]";
                module.exports = initCloneByTag
            }, {
                "./_cloneArrayBuffer": 275,
                "./_cloneDataView": 277,
                "./_cloneRegExp": 278,
                "./_cloneSymbol": 279,
                "./_cloneTypedArray": 280
            }],
            316: [function(require, module, exports) {
                function initCloneObject(e) {
                    return "function" != typeof e.constructor || isPrototype(e) ? {} : baseCreate(getPrototype(e))
                }
                var baseCreate = require("./_baseCreate"),
                    getPrototype = require("./_getPrototype"),
                    isPrototype = require("./_isPrototype");
                module.exports = initCloneObject
            }, {
                "./_baseCreate": 228,
                "./_getPrototype": 301,
                "./_isPrototype": 323
            }],
            317: [function(require, module, exports) {
                function isFlattenable(e) {
                    return isArray(e) || isArguments(e) || !!(spreadableSymbol && e && e[spreadableSymbol])
                }
                var _Symbol8 = require("./_Symbol"),
                    isArguments = require("./isArguments"),
                    isArray = require("./isArray"),
                    spreadableSymbol = _Symbol8 ? _Symbol8.isConcatSpreadable : void 0;
                module.exports = isFlattenable
            }, {
                "./_Symbol": 206,
                "./isArguments": 378,
                "./isArray": 379
            }],
            318: [function(require, module, exports) {
                function isIndex(e, n) {
                    var r = _typeof2(e);
                    return !!(n = null == n ? MAX_SAFE_INTEGER : n) && ("number" == r || "symbol" != r && reIsUint.test(e)) && e > -1 && e % 1 == 0 && e < n
                }
                var MAX_SAFE_INTEGER = 9007199254740991,
                    reIsUint = /^(?:0|[1-9]\d*)$/;
                module.exports = isIndex
            }, {}],
            319: [function(require, module, exports) {
                function isIterateeCall(e, r, i) {
                    if (!isObject(i)) return !1;
                    var t = _typeof2(r);
                    return !!("number" == t ? isArrayLike(i) && isIndex(r, i.length) : "string" == t && r in i) && eq(i[r], e)
                }
                var eq = require("./eq"),
                    isArrayLike = require("./isArrayLike"),
                    isIndex = require("./_isIndex"),
                    isObject = require("./isObject");
                module.exports = isIterateeCall
            }, {
                "./_isIndex": 318,
                "./eq": 367,
                "./isArrayLike": 380,
                "./isObject": 388
            }],
            320: [function(require, module, exports) {
                function isKey(r, e) {
                    if (isArray(r)) return !1;
                    var s = _typeof2(r);
                    return !("number" != s && "symbol" != s && "boolean" != s && null != r && !isSymbol(r)) || reIsPlainProp.test(r) || !reIsDeepProp.test(r) || null != e && r in Object(e)
                }
                var isArray = require("./isArray"),
                    isSymbol = require("./isSymbol"),
                    reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
                    reIsPlainProp = /^\w*$/;
                module.exports = isKey
            }, {
                "./isArray": 379,
                "./isSymbol": 393
            }],
            321: [function(require, module, exports) {
                function isKeyable(e) {
                    var o = _typeof2(e);
                    return "string" == o || "number" == o || "symbol" == o || "boolean" == o ? "__proto__" !== e : null === e
                }
                module.exports = isKeyable
            }, {}],
            322: [function(require, module, exports) {
                function isMasked(e) {
                    return !!maskSrcKey && maskSrcKey in e
                }
                var coreJsData = require("./_coreJsData"),
                    maskSrcKey = function() {
                        var e = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
                        return e ? "Symbol(src)_1." + e : ""
                    }();
                module.exports = isMasked
            }, {
                "./_coreJsData": 285
            }],
            323: [function(require, module, exports) {
                function isPrototype(o) {
                    var t = o && o.constructor;
                    return o === ("function" == typeof t && t.prototype || objectProto)
                }
                var objectProto = Object.prototype;
                module.exports = isPrototype
            }, {}],
            324: [function(require, module, exports) {
                function isStrictComparable(e) {
                    return e == e && !isObject(e)
                }
                var isObject = require("./isObject");
                module.exports = isStrictComparable
            }, {
                "./isObject": 388
            }],
            325: [function(require, module, exports) {
                function listCacheClear() {
                    this.__data__ = [], this.size = 0
                }
                module.exports = listCacheClear
            }, {}],
            326: [function(require, module, exports) {
                function listCacheDelete(e) {
                    var r = this.__data__,
                        a = assocIndexOf(r, e);
                    return !(a < 0 || (a == r.length - 1 ? r.pop() : splice.call(r, a, 1), --this.size, 0))
                }
                var assocIndexOf = require("./_assocIndexOf"),
                    arrayProto = Array.prototype,
                    splice = arrayProto.splice;
                module.exports = listCacheDelete
            }, {
                "./_assocIndexOf": 222
            }],
            327: [function(require, module, exports) {
                function listCacheGet(e) {
                    var s = this.__data__,
                        a = assocIndexOf(s, e);
                    return a < 0 ? void 0 : s[a][1]
                }
                var assocIndexOf = require("./_assocIndexOf");
                module.exports = listCacheGet
            }, {
                "./_assocIndexOf": 222
            }],
            328: [function(require, module, exports) {
                function listCacheHas(s) {
                    return assocIndexOf(this.__data__, s) > -1
                }
                var assocIndexOf = require("./_assocIndexOf");
                module.exports = listCacheHas
            }, {
                "./_assocIndexOf": 222
            }],
            329: [function(require, module, exports) {
                function listCacheSet(s, e) {
                    var t = this.__data__,
                        a = assocIndexOf(t, s);
                    return a < 0 ? (++this.size, t.push([s, e])) : t[a][1] = e, this
                }
                var assocIndexOf = require("./_assocIndexOf");
                module.exports = listCacheSet
            }, {
                "./_assocIndexOf": 222
            }],
            330: [function(require, module, exports) {
                function mapCacheClear() {
                    this.size = 0, this.__data__ = {
                        hash: new Hash,
                        map: new(Map || ListCache),
                        string: new Hash
                    }
                }
                var Hash = require("./_Hash"),
                    ListCache = require("./_ListCache"),
                    Map = require("./_Map");
                module.exports = mapCacheClear
            }, {
                "./_Hash": 198,
                "./_ListCache": 199,
                "./_Map": 200
            }],
            331: [function(require, module, exports) {
                function mapCacheDelete(e) {
                    var a = getMapData(this, e).delete(e);
                    return this.size -= a ? 1 : 0, a
                }
                var getMapData = require("./_getMapData");
                module.exports = mapCacheDelete
            }, {
                "./_getMapData": 298
            }],
            332: [function(require, module, exports) {
                function mapCacheGet(a) {
                    return getMapData(this, a).get(a)
                }
                var getMapData = require("./_getMapData");
                module.exports = mapCacheGet
            }, {
                "./_getMapData": 298
            }],
            333: [function(require, module, exports) {
                function mapCacheHas(a) {
                    return getMapData(this, a).has(a)
                }
                var getMapData = require("./_getMapData");
                module.exports = mapCacheHas
            }, {
                "./_getMapData": 298
            }],
            334: [function(require, module, exports) {
                function mapCacheSet(e, a) {
                    var t = getMapData(this, e),
                        i = t.size;
                    return t.set(e, a), this.size += t.size == i ? 0 : 1, this
                }
                var getMapData = require("./_getMapData");
                module.exports = mapCacheSet
            }, {
                "./_getMapData": 298
            }],
            335: [function(require, module, exports) {
                function mapToArray(r) {
                    var a = -1,
                        o = Array(r.size);
                    return r.forEach(function(r, n) {
                        o[++a] = [n, r]
                    }), o
                }
                module.exports = mapToArray;
            }, {}],
            336: [function(require, module, exports) {
                function matchesStrictComparable(t, e) {
                    return function(r) {
                        return null != r && r[t] === e && (void 0 !== e || t in Object(r))
                    }
                }
                module.exports = matchesStrictComparable
            }, {}],
            337: [function(require, module, exports) {
                function memoizeCapped(e) {
                    var m = memoize(e, function(e) {
                            return r.size === MAX_MEMOIZE_SIZE && r.clear(), e
                        }),
                        r = m.cache;
                    return m
                }
                var memoize = require("./memoize"),
                    MAX_MEMOIZE_SIZE = 500;
                module.exports = memoizeCapped
            }, {
                "./memoize": 401
            }],
            338: [function(require, module, exports) {
                var getNative = require("./_getNative"),
                    nativeCreate = getNative(Object, "create");
                module.exports = nativeCreate
            }, {
                "./_getNative": 300
            }],
            339: [function(require, module, exports) {
                var overArg = require("./_overArg"),
                    nativeKeys = overArg(Object.keys, Object);
                module.exports = nativeKeys
            }, {
                "./_overArg": 343
            }],
            340: [function(require, module, exports) {
                function nativeKeysIn(n) {
                    var e = [];
                    if (null != n)
                        for (var r in Object(n)) e.push(r);
                    return e
                }
                module.exports = nativeKeysIn
            }, {}],
            341: [function(require, module, exports) {
                var freeGlobal = require("./_freeGlobal"),
                    freeExports = "object" == _typeof2(exports) && exports && !exports.nodeType && exports,
                    freeModule = freeExports && "object" == _typeof2(module) && module && !module.nodeType && module,
                    moduleExports = freeModule && freeModule.exports === freeExports,
                    freeProcess = moduleExports && freeGlobal.process,
                    nodeUtil = function() {
                        try {
                            var e = freeModule && freeModule.require && freeModule.require("util").types;
                            return e || freeProcess && freeProcess.binding && freeProcess.binding("util")
                        } catch (e) {}
                    }();
                module.exports = nodeUtil
            }, {
                "./_freeGlobal": 295
            }],
            342: [function(require, module, exports) {
                function objectToString(t) {
                    return nativeObjectToString.call(t)
                }
                var objectProto = Object.prototype,
                    nativeObjectToString = objectProto.toString;
                module.exports = objectToString
            }, {}],
            343: [function(require, module, exports) {
                function overArg(r, e) {
                    return function(n) {
                        return r(e(n))
                    }
                }
                module.exports = overArg
            }, {}],
            344: [function(require, module, exports) {
                function overRest(r, a, e) {
                    return a = nativeMax(void 0 === a ? r.length - 1 : a, 0),
                        function() {
                            for (var t = arguments, n = -1, o = nativeMax(t.length - a, 0), v = Array(o); ++n < o;) v[n] = t[a + n];
                            n = -1;
                            for (var i = Array(a + 1); ++n < a;) i[n] = t[n];
                            return i[a] = e(v), apply(r, this, i)
                        }
                }
                var apply = require("./_apply"),
                    nativeMax = Math.max;
                module.exports = overRest
            }, {
                "./_apply": 209
            }],
            345: [function(require, module, exports) {
                function parent(e, r) {
                    return r.length < 2 ? e : baseGet(e, baseSlice(r, 0, -1))
                }
                var baseGet = require("./_baseGet"),
                    baseSlice = require("./_baseSlice");
                module.exports = parent
            }, {
                "./_baseGet": 237,
                "./_baseSlice": 265
            }],
            346: [function(require, module, exports) {
                var freeGlobal = require("./_freeGlobal"),
                    freeSelf = "object" == ("undefined" == typeof self ? "undefined" : _typeof2(self)) && self && self.Object === Object && self,
                    root = freeGlobal || freeSelf || Function("return this")();
                module.exports = root
            }, {
                "./_freeGlobal": 295
            }],
            347: [function(require, module, exports) {
                function setCacheAdd(_) {
                    return this.__data__.set(_, HASH_UNDEFINED), this
                }
                var HASH_UNDEFINED = "__lodash_hash_undefined__";
                module.exports = setCacheAdd
            }, {}],
            348: [function(require, module, exports) {
                function setCacheHas(a) {
                    return this.__data__.has(a)
                }
                module.exports = setCacheHas
            }, {}],
            349: [function(require, module, exports) {
                function setToArray(r) {
                    var o = -1,
                        e = Array(r.size);
                    return r.forEach(function(r) {
                        e[++o] = r
                    }), e
                }
                module.exports = setToArray
            }, {}],
            350: [function(require, module, exports) {
                var baseSetToString = require("./_baseSetToString"),
                    shortOut = require("./_shortOut"),
                    setToString = shortOut(baseSetToString);
                module.exports = setToString
            }, {
                "./_baseSetToString": 264,
                "./_shortOut": 351
            }],
            351: [function(require, module, exports) {
                function shortOut(t) {
                    var r = 0,
                        e = 0;
                    return function() {
                        var n = nativeNow(),
                            o = HOT_SPAN - (n - e);
                        if (e = n, o > 0) {
                            if (++r >= HOT_COUNT) return arguments[0]
                        } else r = 0;
                        return t.apply(void 0, arguments)
                    }
                }
                var HOT_COUNT = 800,
                    HOT_SPAN = 16,
                    nativeNow = Date.now;
                module.exports = shortOut
            }, {}],
            352: [function(require, module, exports) {
                function stackClear() {
                    this.__data__ = new ListCache, this.size = 0
                }
                var ListCache = require("./_ListCache");
                module.exports = stackClear
            }, {
                "./_ListCache": 199
            }],
            353: [function(require, module, exports) {
                function stackDelete(e) {
                    var t = this.__data__,
                        s = t.delete(e);
                    return this.size = t.size, s
                }
                module.exports = stackDelete
            }, {}],
            354: [function(require, module, exports) {
                function stackGet(t) {
                    return this.__data__.get(t)
                }
                module.exports = stackGet
            }, {}],
            355: [function(require, module, exports) {
                function stackHas(a) {
                    return this.__data__.has(a)
                }
                module.exports = stackHas
            }, {}],
            356: [function(require, module, exports) {
                function stackSet(e, a) {
                    var t = this.__data__;
                    if (t instanceof ListCache) {
                        var i = t.__data__;
                        if (!Map || i.length < LARGE_ARRAY_SIZE - 1) return i.push([e, a]), this.size = ++t.size, this;
                        t = this.__data__ = new MapCache(i)
                    }
                    return t.set(e, a), this.size = t.size, this
                }
                var ListCache = require("./_ListCache"),
                    Map = require("./_Map"),
                    MapCache = require("./_MapCache"),
                    LARGE_ARRAY_SIZE = 200;
                module.exports = stackSet
            }, {
                "./_ListCache": 199,
                "./_Map": 200,
                "./_MapCache": 201
            }],
            357: [function(require, module, exports) {
                function strictIndexOf(r, t, e) {
                    for (var n = e - 1, f = r.length; ++n < f;)
                        if (r[n] === t) return n;
                    return -1
                }
                module.exports = strictIndexOf
            }, {}],
            358: [function(require, module, exports) {
                function stringSize(i) {
                    return hasUnicode(i) ? unicodeSize(i) : asciiSize(i)
                }
                var asciiSize = require("./_asciiSize"),
                    hasUnicode = require("./_hasUnicode"),
                    unicodeSize = require("./_unicodeSize");
                module.exports = stringSize
            }, {
                "./_asciiSize": 220,
                "./_hasUnicode": 308,
                "./_unicodeSize": 362
            }],
            359: [function(require, module, exports) {
                var memoizeCapped = require("./_memoizeCapped"),
                    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,
                    reEscapeChar = /\\(\\)?/g,
                    stringToPath = memoizeCapped(function(e) {
                        var r = [];
                        return 46 === e.charCodeAt(0) && r.push(""), e.replace(rePropName, function(e, a, p, o) {
                            r.push(p ? o.replace(reEscapeChar, "$1") : a || e)
                        }), r
                    });
                module.exports = stringToPath
            }, {
                "./_memoizeCapped": 337
            }],
            360: [function(require, module, exports) {
                function toKey(r) {
                    if ("string" == typeof r || isSymbol(r)) return r;
                    var e = r + "";
                    return "0" == e && 1 / r == -INFINITY ? "-0" : e
                }
                var isSymbol = require("./isSymbol"),
                    INFINITY = 1 / 0;
                module.exports = toKey
            }, {
                "./isSymbol": 393
            }],
            361: [function(require, module, exports) {
                function toSource(t) {
                    if (null != t) {
                        try {
                            return funcToString.call(t)
                        } catch (t) {}
                        try {
                            return t + ""
                        } catch (t) {}
                    }
                    return ""
                }
                var funcProto = Function.prototype,
                    funcToString = funcProto.toString;
                module.exports = toSource
            }, {}],
            362: [function(require, module, exports) {
                function unicodeSize(r) {
                    for (var s = reUnicode.lastIndex = 0; reUnicode.test(r);) ++s;
                    return s
                }
                var rsAstralRange = "\\ud800-\\udfff",
                    rsComboMarksRange = "\\u0300-\\u036f",
                    reComboHalfMarksRange = "\\ufe20-\\ufe2f",
                    rsComboSymbolsRange = "\\u20d0-\\u20ff",
                    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
                    rsVarRange = "\\ufe0e\\ufe0f",
                    rsAstral = "[" + rsAstralRange + "]",
                    rsCombo = "[" + rsComboRange + "]",
                    rsFitz = "\\ud83c[\\udffb-\\udfff]",
                    rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")",
                    rsNonAstral = "[^" + rsAstralRange + "]",
                    rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}",
                    rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]",
                    rsZWJ = "\\u200d",
                    reOptMod = rsModifier + "?",
                    rsOptVar = "[" + rsVarRange + "]?",
                    rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*",
                    rsSeq = rsOptVar + reOptMod + rsOptJoin,
                    rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")",
                    reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
                module.exports = unicodeSize
            }, {}],
            363: [function(require, module, exports) {
                function constant(n) {
                    return function() {
                        return n
                    }
                }
                module.exports = constant
            }, {}],
            364: [function(require, module, exports) {
                function debounce(n, i, t) {
                    function T(i) {
                        var t = e,
                            o = r;
                        return e = r = void 0, v = i, u = n.apply(o, t)
                    }

                    function s(n) {
                        var t = n - c;
                        return void 0 === c || t >= i || t < 0 || m && n - v >= o
                    }

                    function b() {
                        var n = now();
                        return s(n) ? l(n) : void(a = setTimeout(b, function(n) {
                            var t = i - (n - c);
                            return m ? nativeMin(t, o - (n - v)) : t
                        }(n)))
                    }

                    function l(n) {
                        return a = void 0, d && e ? T(n) : (e = r = void 0, u)
                    }

                    function w() {
                        var n = now(),
                            t = s(n);
                        if (e = arguments, r = this, c = n, t) {
                            if (void 0 === a) return function(n) {
                                return v = n, a = setTimeout(b, i), f ? T(n) : u
                            }(c);
                            if (m) return clearTimeout(a), a = setTimeout(b, i), T(c)
                        }
                        return void 0 === a && (a = setTimeout(b, i)), u
                    }
                    var e, r, o, u, a, c, v = 0,
                        f = !1,
                        m = !1,
                        d = !0;
                    if ("function" != typeof n) throw new TypeError(FUNC_ERROR_TEXT);
                    return i = toNumber(i) || 0, isObject(t) && (f = !!t.leading, o = (m = "maxWait" in t) ? nativeMax(toNumber(t.maxWait) || 0, i) : o, d = "trailing" in t ? !!t.trailing : d), w.cancel = function() {
                        void 0 !== a && clearTimeout(a), v = 0, e = c = r = a = void 0
                    }, w.flush = function() {
                        return void 0 === a ? u : l(now())
                    }, w
                }
                var isObject = require("./isObject"),
                    now = require("./now"),
                    toNumber = require("./toNumber"),
                    FUNC_ERROR_TEXT = "Expected a function",
                    nativeMax = Math.max,
                    nativeMin = Math.min;
                module.exports = debounce
            }, {
                "./isObject": 388,
                "./now": 403,
                "./toNumber": 415
            }],
            365: [function(require, module, exports) {
                module.exports = require("./forEach")
            }, {
                "./forEach": 373
            }],
            366: [function(require, module, exports) {
                function endsWith(e, r, t) {
                    e = toString(e), r = baseToString(r);
                    var n = e.length,
                        i = t = void 0 === t ? n : baseClamp(toInteger(t), 0, n);
                    return (t -= r.length) >= 0 && e.slice(t, i) == r
                }
                var baseClamp = require("./_baseClamp"),
                    baseToString = require("./_baseToString"),
                    toInteger = require("./toInteger"),
                    toString = require("./toString");
                module.exports = endsWith
            }, {
                "./_baseClamp": 226,
                "./_baseToString": 268,
                "./toInteger": 414,
                "./toString": 416
            }],
            367: [function(require, module, exports) {
                function eq(e, n) {
                    return e === n || e != e && n != n
                }
                module.exports = eq
            }, {}],
            368: [function(require, module, exports) {
                function every(e, r, a) {
                    var t = isArray(e) ? arrayEvery : baseEvery;
                    return a && isIterateeCall(e, r, a) && (r = void 0), t(e, baseIteratee(r, 3))
                }
                var arrayEvery = require("./_arrayEvery"),
                    baseEvery = require("./_baseEvery"),
                    baseIteratee = require("./_baseIteratee"),
                    isArray = require("./isArray"),
                    isIterateeCall = require("./_isIterateeCall");
                module.exports = every
            }, {
                "./_arrayEvery": 211,
                "./_baseEvery": 231,
                "./_baseIteratee": 251,
                "./_isIterateeCall": 319,
                "./isArray": 379
            }],
            369: [function(require, module, exports) {
                function filter(r, e) {
                    return (isArray(r) ? arrayFilter : baseFilter)(r, baseIteratee(e, 3))
                }
                var arrayFilter = require("./_arrayFilter"),
                    baseFilter = require("./_baseFilter"),
                    baseIteratee = require("./_baseIteratee"),
                    isArray = require("./isArray");
                module.exports = filter
            }, {
                "./_arrayFilter": 212,
                "./_baseFilter": 232,
                "./_baseIteratee": 251,
                "./isArray": 379
            }],
            370: [function(require, module, exports) {
                var createFind = require("./_createFind"),
                    findIndex = require("./findIndex"),
                    find = createFind(findIndex);
                module.exports = find
            }, {
                "./_createFind": 288,
                "./findIndex": 371
            }],
            371: [function(require, module, exports) {
                function findIndex(e, n, r) {
                    var t = null == e ? 0 : e.length;
                    if (!t) return -1;
                    var a = null == r ? 0 : toInteger(r);
                    return a < 0 && (a = nativeMax(t + a, 0)), baseFindIndex(e, baseIteratee(n, 3), a)
                }
                var baseFindIndex = require("./_baseFindIndex"),
                    baseIteratee = require("./_baseIteratee"),
                    toInteger = require("./toInteger"),
                    nativeMax = Math.max;
                module.exports = findIndex
            }, {
                "./_baseFindIndex": 233,
                "./_baseIteratee": 251,
                "./toInteger": 414
            }],
            372: [function(require, module, exports) {
                function flatten(e) {
                    return (null == e ? 0 : e.length) ? baseFlatten(e, 1) : []
                }
                var baseFlatten = require("./_baseFlatten");
                module.exports = flatten
            }, {
                "./_baseFlatten": 234
            }],
            373: [function(require, module, exports) {
                function forEach(r, a) {
                    return (isArray(r) ? arrayEach : baseEach)(r, castFunction(a))
                }
                var arrayEach = require("./_arrayEach"),
                    baseEach = require("./_baseEach"),
                    castFunction = require("./_castFunction"),
                    isArray = require("./isArray");
                module.exports = forEach
            }, {
                "./_arrayEach": 210,
                "./_baseEach": 230,
                "./_castFunction": 273,
                "./isArray": 379
            }],
            374: [function(require, module, exports) {
                function get(e, t, r) {
                    var a = null == e ? void 0 : baseGet(e, t);
                    return void 0 === a ? r : a
                }
                var baseGet = require("./_baseGet");
                module.exports = get
            }, {
                "./_baseGet": 237
            }],
            375: [function(require, module, exports) {
                function hasIn(a, s) {
                    return null != a && hasPath(a, s, baseHasIn)
                }
                var baseHasIn = require("./_baseHasIn"),
                    hasPath = require("./_hasPath");
                module.exports = hasIn
            }, {
                "./_baseHasIn": 240,
                "./_hasPath": 307
            }],
            376: [function(require, module, exports) {
                function identity(t) {
                    return t
                }
                module.exports = identity
            }, {}],
            377: [function(require, module, exports) {
                function includes(e, r, i, n) {
                    e = isArrayLike(e) ? e : values(e), i = i && !n ? toInteger(i) : 0;
                    var a = e.length;
                    return i < 0 && (i = nativeMax(a + i, 0)), isString(e) ? i <= a && e.indexOf(r, i) > -1 : !!a && baseIndexOf(e, r, i) > -1
                }
                var baseIndexOf = require("./_baseIndexOf"),
                    isArrayLike = require("./isArrayLike"),
                    isString = require("./isString"),
                    toInteger = require("./toInteger"),
                    values = require("./values"),
                    nativeMax = Math.max;
                module.exports = includes
            }, {
                "./_baseIndexOf": 241,
                "./isArrayLike": 380,
                "./isString": 392,
                "./toInteger": 414,
                "./values": 418
            }],
            378: [function(require, module, exports) {
                var baseIsArguments = require("./_baseIsArguments"),
                    isObjectLike = require("./isObjectLike"),
                    objectProto = Object.prototype,
                    hasOwnProperty = objectProto.hasOwnProperty,
                    propertyIsEnumerable = objectProto.propertyIsEnumerable,
                    isArguments = baseIsArguments(function() {
                        return arguments
                    }()) ? baseIsArguments : function(e) {
                        return isObjectLike(e) && hasOwnProperty.call(e, "callee") && !propertyIsEnumerable.call(e, "callee")
                    };
                module.exports = isArguments
            }, {
                "./_baseIsArguments": 242,
                "./isObjectLike": 389
            }],
            379: [function(require, module, exports) {
                var isArray = Array.isArray;
                module.exports = isArray
            }, {}],
            380: [function(require, module, exports) {
                function isArrayLike(i) {
                    return null != i && isLength(i.length) && !isFunction(i)
                }
                var isFunction = require("./isFunction"),
                    isLength = require("./isLength");
                module.exports = isArrayLike
            }, {
                "./isFunction": 385,
                "./isLength": 386
            }],
            381: [function(require, module, exports) {
                function isArrayLikeObject(e) {
                    return isObjectLike(e) && isArrayLike(e)
                }
                var isArrayLike = require("./isArrayLike"),
                    isObjectLike = require("./isObjectLike");
                module.exports = isArrayLikeObject
            }, {
                "./isArrayLike": 380,
                "./isObjectLike": 389
            }],
            382: [function(require, module, exports) {
                var root = require("./_root"),
                    stubFalse = require("./stubFalse"),
                    freeExports = "object" == _typeof2(exports) && exports && !exports.nodeType && exports,
                    freeModule = freeExports && "object" == _typeof2(module) && module && !module.nodeType && module,
                    moduleExports = freeModule && freeModule.exports === freeExports,
                    Buffer = moduleExports ? root.Buffer : void 0,
                    nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0,
                    isBuffer = nativeIsBuffer || stubFalse;
                module.exports = isBuffer
            }, {
                "./_root": 346,
                "./stubFalse": 412
            }],
            383: [function(require, module, exports) {
                function isEmpty(r) {
                    if (null == r) return !0;
                    if (isArrayLike(r) && (isArray(r) || "string" == typeof r || "function" == typeof r.splice || isBuffer(r) || isTypedArray(r) || isArguments(r))) return !r.length;
                    var e = getTag(r);
                    if (e == mapTag || e == setTag) return !r.size;
                    if (isPrototype(r)) return !baseKeys(r).length;
                    for (var t in r)
                        if (hasOwnProperty.call(r, t)) return !1;
                    return !0
                }
                var baseKeys = require("./_baseKeys"),
                    getTag = require("./_getTag"),
                    isArguments = require("./isArguments"),
                    isArray = require("./isArray"),
                    isArrayLike = require("./isArrayLike"),
                    isBuffer = require("./isBuffer"),
                    isPrototype = require("./_isPrototype"),
                    isTypedArray = require("./isTypedArray"),
                    mapTag = "[object Map]",
                    setTag = "[object Set]",
                    objectProto = Object.prototype,
                    hasOwnProperty = objectProto.hasOwnProperty;
                module.exports = isEmpty
            }, {
                "./_baseKeys": 252,
                "./_getTag": 305,
                "./_isPrototype": 323,
                "./isArguments": 378,
                "./isArray": 379,
                "./isArrayLike": 380,
                "./isBuffer": 382,
                "./isTypedArray": 394
            }],
            384: [function(require, module, exports) {
                function isEqual(a, s) {
                    return baseIsEqual(a, s)
                }
                var baseIsEqual = require("./_baseIsEqual");
                module.exports = isEqual
            }, {
                "./_baseIsEqual": 243
            }],
            385: [function(require, module, exports) {
                function isFunction(e) {
                    if (!isObject(e)) return !1;
                    var n = baseGetTag(e);
                    return n == funcTag || n == genTag || n == asyncTag || n == proxyTag
                }
                var baseGetTag = require("./_baseGetTag"),
                    isObject = require("./isObject"),
                    asyncTag = "[object AsyncFunction]",
                    funcTag = "[object Function]",
                    genTag = "[object GeneratorFunction]",
                    proxyTag = "[object Proxy]";
                module.exports = isFunction
            }, {
                "./_baseGetTag": 239,
                "./isObject": 388
            }],
            386: [function(require, module, exports) {
                function isLength(e) {
                    return "number" == typeof e && e > -1 && e % 1 == 0 && e <= MAX_SAFE_INTEGER
                }
                var MAX_SAFE_INTEGER = 9007199254740991;
                module.exports = isLength
            }, {}],
            387: [function(require, module, exports) {
                var baseIsMap = require("./_baseIsMap"),
                    baseUnary = require("./_baseUnary"),
                    nodeUtil = require("./_nodeUtil"),
                    nodeIsMap = nodeUtil && nodeUtil.isMap,
                    isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
                module.exports = isMap
            }, {
                "./_baseIsMap": 245,
                "./_baseUnary": 269,
                "./_nodeUtil": 341
            }],
            388: [function(require, module, exports) {
                function isObject(t) {
                    var e = _typeof2(t);
                    return null != t && ("object" == e || "function" == e)
                }
                module.exports = isObject
            }, {}],
            389: [function(require, module, exports) {
                function isObjectLike(e) {
                    return null != e && "object" == _typeof2(e)
                }
                module.exports = isObjectLike
            }, {}],
            390: [function(require, module, exports) {
                function isPlainObject(t) {
                    if (!isObjectLike(t) || baseGetTag(t) != objectTag) return !1;
                    var e = getPrototype(t);
                    if (null === e) return !0;
                    var o = hasOwnProperty.call(e, "constructor") && e.constructor;
                    return "function" == typeof o && o instanceof o && funcToString.call(o) == objectCtorString
                }
                var baseGetTag = require("./_baseGetTag"),
                    getPrototype = require("./_getPrototype"),
                    isObjectLike = require("./isObjectLike"),
                    objectTag = "[object Object]",
                    funcProto = Function.prototype,
                    objectProto = Object.prototype,
                    funcToString = funcProto.toString,
                    hasOwnProperty = objectProto.hasOwnProperty,
                    objectCtorString = funcToString.call(Object);
                module.exports = isPlainObject
            }, {
                "./_baseGetTag": 239,
                "./_getPrototype": 301,
                "./isObjectLike": 389
            }],
            391: [function(require, module, exports) {
                var baseIsSet = require("./_baseIsSet"),
                    baseUnary = require("./_baseUnary"),
                    nodeUtil = require("./_nodeUtil"),
                    nodeIsSet = nodeUtil && nodeUtil.isSet,
                    isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
                module.exports = isSet
            }, {
                "./_baseIsSet": 249,
                "./_baseUnary": 269,
                "./_nodeUtil": 341
            }],
            392: [function(require, module, exports) {
                function isString(e) {
                    return "string" == typeof e || !isArray(e) && isObjectLike(e) && baseGetTag(e) == stringTag
                }
                var baseGetTag = require("./_baseGetTag"),
                    isArray = require("./isArray"),
                    isObjectLike = require("./isObjectLike"),
                    stringTag = "[object String]";
                module.exports = isString
            }, {
                "./_baseGetTag": 239,
                "./isArray": 379,
                "./isObjectLike": 389
            }],
            393: [function(require, module, exports) {
                function isSymbol(e) {
                    return "symbol" == _typeof2(e) || isObjectLike(e) && baseGetTag(e) == symbolTag
                }
                var baseGetTag = require("./_baseGetTag"),
                    isObjectLike = require("./isObjectLike"),
                    symbolTag = "[object Symbol]";
                module.exports = isSymbol
            }, {
                "./_baseGetTag": 239,
                "./isObjectLike": 389
            }],
            394: [function(require, module, exports) {
                var baseIsTypedArray = require("./_baseIsTypedArray"),
                    baseUnary = require("./_baseUnary"),
                    nodeUtil = require("./_nodeUtil"),
                    nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray,
                    isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
                module.exports = isTypedArray
            }, {
                "./_baseIsTypedArray": 250,
                "./_baseUnary": 269,
                "./_nodeUtil": 341
            }],
            395: [function(require, module, exports) {
                function isUndefined(e) {
                    return void 0 === e
                }
                module.exports = isUndefined
            }, {}],
            396: [function(require, module, exports) {
                function keys(e) {
                    return isArrayLike(e) ? arrayLikeKeys(e) : baseKeys(e)
                }
                var arrayLikeKeys = require("./_arrayLikeKeys"),
                    baseKeys = require("./_baseKeys"),
                    isArrayLike = require("./isArrayLike");
                module.exports = keys
            }, {
                "./_arrayLikeKeys": 215,
                "./_baseKeys": 252,
                "./isArrayLike": 380
            }],
            397: [function(require, module, exports) {
                function keysIn(e) {
                    return isArrayLike(e) ? arrayLikeKeys(e, !0) : baseKeysIn(e)
                }
                var arrayLikeKeys = require("./_arrayLikeKeys"),
                    baseKeysIn = require("./_baseKeysIn"),
                    isArrayLike = require("./isArrayLike");
                module.exports = keysIn
            }, {
                "./_arrayLikeKeys": 215,
                "./_baseKeysIn": 253,
                "./isArrayLike": 380
            }],
            398: [function(require, module, exports) {
                function last(l) {
                    var t = null == l ? 0 : l.length;
                    return t ? l[t - 1] : void 0
                }
                module.exports = last
            }, {}],
            399: [function(require, module, exports) {
                function map(a, r) {
                    return (isArray(a) ? arrayMap : baseMap)(a, baseIteratee(r, 3))
                }
                var arrayMap = require("./_arrayMap"),
                    baseIteratee = require("./_baseIteratee"),
                    baseMap = require("./_baseMap"),
                    isArray = require("./isArray");
                module.exports = map
            }, {
                "./_arrayMap": 216,
                "./_baseIteratee": 251,
                "./_baseMap": 254,
                "./isArray": 379
            }],
            400: [function(require, module, exports) {
                function mapValues(e, a) {
                    var s = {};
                    return a = baseIteratee(a, 3), baseForOwn(e, function(e, r, u) {
                        baseAssignValue(s, r, a(e, r, u))
                    }), s
                }
                var baseAssignValue = require("./_baseAssignValue"),
                    baseForOwn = require("./_baseForOwn"),
                    baseIteratee = require("./_baseIteratee");
                module.exports = mapValues
            }, {
                "./_baseAssignValue": 225,
                "./_baseForOwn": 236,
                "./_baseIteratee": 251
            }],
            401: [function(require, module, exports) {
                function memoize(e, a) {
                    if ("function" != typeof e || null != a && "function" != typeof a) throw new TypeError(FUNC_ERROR_TEXT);
                    var c = function c() {
                        var r = arguments,
                            t = a ? a.apply(this, r) : r[0],
                            n = c.cache;
                        if (n.has(t)) return n.get(t);
                        var o = e.apply(this, r);
                        return c.cache = n.set(t, o) || n, o
                    };
                    return c.cache = new(memoize.Cache || MapCache), c
                }
                var MapCache = require("./_MapCache"),
                    FUNC_ERROR_TEXT = "Expected a function";
                memoize.Cache = MapCache, module.exports = memoize
            }, {
                "./_MapCache": 201
            }],
            402: [function(require, module, exports) {
                function noop() {}
                module.exports = noop
            }, {}],
            403: [function(require, module, exports) {
                var root = require("./_root"),
                    now = function() {
                        return root.Date.now()
                    };
                module.exports = now
            }, {
                "./_root": 346
            }],
            404: [function(require, module, exports) {
                var arrayMap = require("./_arrayMap"),
                    baseClone = require("./_baseClone"),
                    baseUnset = require("./_baseUnset"),
                    castPath = require("./_castPath"),
                    copyObject = require("./_copyObject"),
                    customOmitClone = require("./_customOmitClone"),
                    flatRest = require("./_flatRest"),
                    getAllKeysIn = require("./_getAllKeysIn"),
                    CLONE_DEEP_FLAG = 1,
                    CLONE_FLAT_FLAG = 2,
                    CLONE_SYMBOLS_FLAG = 4,
                    omit = flatRest(function(e, t) {
                        var r = {};
                        if (null == e) return r;
                        var a = !1;
                        t = arrayMap(t, function(t) {
                            return t = castPath(t, e), a || (a = t.length > 1), t
                        }), copyObject(e, getAllKeysIn(e), r), a && (r = baseClone(r, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone));
                        for (var n = t.length; n--;) baseUnset(r, t[n]);
                        return r
                    });
                module.exports = omit
            }, {
                "./_arrayMap": 216,
                "./_baseClone": 227,
                "./_baseUnset": 270,
                "./_castPath": 274,
                "./_copyObject": 282,
                "./_customOmitClone": 289,
                "./_flatRest": 294,
                "./_getAllKeysIn": 297
            }],
            405: [function(require, module, exports) {
                var basePick = require("./_basePick"),
                    flatRest = require("./_flatRest"),
                    pick = flatRest(function(e, t) {
                        return null == e ? {} : basePick(e, t)
                    });
                module.exports = pick
            }, {
                "./_basePick": 257,
                "./_flatRest": 294
            }],
            406: [function(require, module, exports) {
                function property(e) {
                    return isKey(e) ? baseProperty(toKey(e)) : basePropertyDeep(e)
                }
                var baseProperty = require("./_baseProperty"),
                    basePropertyDeep = require("./_basePropertyDeep"),
                    isKey = require("./_isKey"),
                    toKey = require("./_toKey");
                module.exports = property
            }, {
                "./_baseProperty": 259,
                "./_basePropertyDeep": 260,
                "./_isKey": 320,
                "./_toKey": 360
            }],
            407: [function(require, module, exports) {
                function reduce(e, r, a) {
                    var u = isArray(e) ? arrayReduce : baseReduce,
                        s = arguments.length < 3;
                    return u(e, baseIteratee(r, 4), a, s, baseEach)
                }
                var arrayReduce = require("./_arrayReduce"),
                    baseEach = require("./_baseEach"),
                    baseIteratee = require("./_baseIteratee"),
                    baseReduce = require("./_baseReduce"),
                    isArray = require("./isArray");
                module.exports = reduce
            }, {
                "./_arrayReduce": 218,
                "./_baseEach": 230,
                "./_baseIteratee": 251,
                "./_baseReduce": 261,
                "./isArray": 379
            }],
            408: [function(require, module, exports) {
                function size(e) {
                    if (null == e) return 0;
                    if (isArrayLike(e)) return isString(e) ? stringSize(e) : e.length;
                    var r = getTag(e);
                    return r == mapTag || r == setTag ? e.size : baseKeys(e).length
                }
                var baseKeys = require("./_baseKeys"),
                    getTag = require("./_getTag"),
                    isArrayLike = require("./isArrayLike"),
                    isString = require("./isString"),
                    stringSize = require("./_stringSize"),
                    mapTag = "[object Map]",
                    setTag = "[object Set]";
                module.exports = size
            }, {
                "./_baseKeys": 252,
                "./_getTag": 305,
                "./_stringSize": 358,
                "./isArrayLike": 380,
                "./isString": 392
            }],
            409: [function(require, module, exports) {
                function some(e, r, a) {
                    var s = isArray(e) ? arraySome : baseSome;
                    return a && isIterateeCall(e, r, a) && (r = void 0), s(e, baseIteratee(r, 3))
                }
                var arraySome = require("./_arraySome"),
                    baseIteratee = require("./_baseIteratee"),
                    baseSome = require("./_baseSome"),
                    isArray = require("./isArray"),
                    isIterateeCall = require("./_isIterateeCall");
                module.exports = some
            }, {
                "./_arraySome": 219,
                "./_baseIteratee": 251,
                "./_baseSome": 266,
                "./_isIterateeCall": 319,
                "./isArray": 379
            }],
            410: [function(require, module, exports) {
                function startsWith(e, t, r) {
                    return e = toString(e), r = null == r ? 0 : baseClamp(toInteger(r), 0, e.length), t = baseToString(t), e.slice(r, r + t.length) == t
                }
                var baseClamp = require("./_baseClamp"),
                    baseToString = require("./_baseToString"),
                    toInteger = require("./toInteger"),
                    toString = require("./toString");
                module.exports = startsWith
            }, {
                "./_baseClamp": 226,
                "./_baseToString": 268,
                "./toInteger": 414,
                "./toString": 416
            }],
            411: [function(require, module, exports) {
                function stubArray() {
                    return []
                }
                module.exports = stubArray
            }, {}],
            412: [function(require, module, exports) {
                function stubFalse() {
                    return !1
                }
                module.exports = stubFalse
            }, {}],
            413: [function(require, module, exports) {
                function toFinite(e) {
                    return e ? (e = toNumber(e)) === INFINITY || e === -INFINITY ? (e < 0 ? -1 : 1) * MAX_INTEGER : e == e ? e : 0 : 0 === e ? e : 0
                }
                var toNumber = require("./toNumber"),
                    INFINITY = 1 / 0,
                    MAX_INTEGER = 1.7976931348623157e308;
                module.exports = toFinite
            }, {
                "./toNumber": 415
            }],
            414: [function(require, module, exports) {
                function toInteger(t) {
                    var e = toFinite(t),
                        r = e % 1;
                    return e == e ? r ? e - r : e : 0
                }
                var toFinite = require("./toFinite");
                module.exports = toInteger
            }, {
                "./toFinite": 413
            }],
            415: [function(require, module, exports) {
                function toNumber(e) {
                    if ("number" == typeof e) return e;
                    if (isSymbol(e)) return NAN;
                    if (isObject(e)) {
                        var r = "function" == typeof e.valueOf ? e.valueOf() : e;
                        e = isObject(r) ? r + "" : r
                    }
                    if ("string" != typeof e) return 0 === e ? e : +e;
                    e = e.replace(reTrim, "");
                    var t = reIsBinary.test(e);
                    return t || reIsOctal.test(e) ? freeParseInt(e.slice(2), t ? 2 : 8) : reIsBadHex.test(e) ? NAN : +e
                }
                var isObject = require("./isObject"),
                    isSymbol = require("./isSymbol"),
                    NAN = NaN,
                    reTrim = /^\s+|\s+$/g,
                    reIsBadHex = /^[-+]0x[0-9a-f]+$/i,
                    reIsBinary = /^0b[01]+$/i,
                    reIsOctal = /^0o[0-7]+$/i,
                    freeParseInt = parseInt;
                module.exports = toNumber
            }, {
                "./isObject": 388,
                "./isSymbol": 393
            }],
            416: [function(require, module, exports) {
                function toString(r) {
                    return null == r ? "" : baseToString(r)
                }
                var baseToString = require("./_baseToString");
                module.exports = toString
            }, {
                "./_baseToString": 268
            }],
            417: [function(require, module, exports) {
                function uniqueId(r) {
                    var t = ++idCounter;
                    return toString(r) + t
                }
                var toString = require("./toString"),
                    idCounter = 0;
                module.exports = uniqueId
            }, {
                "./toString": 416
            }],
            418: [function(require, module, exports) {
                function values(e) {
                    return null == e ? [] : baseValues(e, keys(e))
                }
                var baseValues = require("./_baseValues"),
                    keys = require("./keys");
                module.exports = values
            }, {
                "./_baseValues": 271,
                "./keys": 396
            }],
            419: [function(require, module, exports) {
                var baseDifference = require("./_baseDifference"),
                    baseRest = require("./_baseRest"),
                    isArrayLikeObject = require("./isArrayLikeObject"),
                    without = baseRest(function(e, r) {
                        return isArrayLikeObject(e) ? baseDifference(e, r) : []
                    });
                module.exports = without
            }, {
                "./_baseDifference": 229,
                "./_baseRest": 262,
                "./isArrayLikeObject": 381
            }],
            420: [function(require, module, exports) {
                "use strict";
                module.exports = Number.isNaN || function(e) {
                    return e != e
                }
            }, {}],
            421: [function(require, module, exports) {
                "use strict";

                function toObject(e) {
                    if (null == e) throw new TypeError("Object.assign cannot be called with null or undefined");
                    return Object(e)
                }

                function shouldUseNative() {
                    try {
                        if (!Object.assign) return !1;
                        var e = new String("abc");
                        if (e[5] = "de", "5" === Object.getOwnPropertyNames(e)[0]) return !1;
                        for (var r = {}, t = 0; t < 10; t++) r["_" + String.fromCharCode(t)] = t;
                        if ("0123456789" !== Object.getOwnPropertyNames(r).map(function(e) {
                                return r[e]
                            }).join("")) return !1;
                        var n = {};
                        return "abcdefghijklmnopqrst".split("").forEach(function(e) {
                            n[e] = e
                        }), "abcdefghijklmnopqrst" === Object.keys(Object.assign({}, n)).join("")
                    } catch (e) {
                        return !1
                    }
                }
                var getOwnPropertySymbols = Object.getOwnPropertySymbols,
                    hasOwnProperty = Object.prototype.hasOwnProperty,
                    propIsEnumerable = Object.prototype.propertyIsEnumerable;
                module.exports = shouldUseNative() ? Object.assign : function(e, r) {
                    for (var t, n, o = toObject(e), a = 1; a < arguments.length; a++) {
                        for (var s in t = Object(arguments[a])) hasOwnProperty.call(t, s) && (o[s] = t[s]);
                        if (getOwnPropertySymbols) {
                            n = getOwnPropertySymbols(t);
                            for (var c = 0; c < n.length; c++) propIsEnumerable.call(t, n[c]) && (o[n[c]] = t[n[c]])
                        }
                    }
                    return o
                }
            }, {}],
            422: [function(require, module, exports) {
                Prism.languages.css = {
                    comment: /\/\*[\w\W]*?\*\//,
                    atrule: {
                        pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i,
                        inside: {
                            rule: /@[\w-]+/
                        }
                    },
                    url: /url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
                    selector: /[^\{\}\s][^\{\};]*?(?=\s*\{)/,
                    string: {
                        pattern: /("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,
                        greedy: !0
                    },
                    property: /(\b|\B)[\w-]+(?=\s*:)/i,
                    important: /\B!important\b/i,
                    function: /[-a-z0-9]+(?=\()/i,
                    punctuation: /[(){};:]/
                }, Prism.languages.css.atrule.inside.rest = Prism.util.clone(Prism.languages.css), Prism.languages.markup && (Prism.languages.insertBefore("markup", "tag", {
                    style: {
                        pattern: /(<style[\w\W]*?>)[\w\W]*?(?=<\/style>)/i,
                        lookbehind: !0,
                        inside: Prism.languages.css,
                        alias: "language-css"
                    }
                }), Prism.languages.insertBefore("inside", "attr-value", {
                    "style-attr": {
                        pattern: /\s*style=("|').*?\1/i,
                        inside: {
                            "attr-name": {
                                pattern: /^\s*style/i,
                                inside: Prism.languages.markup.tag.inside
                            },
                            punctuation: /^\s*=\s*['"]|['"]\s*$/,
                            "attr-value": {
                                pattern: /.+/i,
                                inside: Prism.languages.css
                            }
                        },
                        alias: "language-css"
                    }
                }, Prism.languages.markup.tag))
            }, {}],
            423: [function(require, module, exports) {
                ! function(e) {
                    var a = /\{\{\{[\w\W]+?\}\}\}|\{\{[\w\W]+?\}\}/g;
                    e.languages.handlebars = e.languages.extend("markup", {
                        handlebars: {
                            pattern: a,
                            inside: {
                                delimiter: {
                                    pattern: /^\{\{\{?|\}\}\}?$/i,
                                    alias: "punctuation"
                                },
                                string: /(["'])(\\?.)*?\1/,
                                number: /\b-?(0x[\dA-Fa-f]+|\d*\.?\d+([Ee][+-]?\d+)?)\b/,
                                boolean: /\b(true|false)\b/,
                                block: {
                                    pattern: /^(\s*~?\s*)[#\/]\S+?(?=\s*~?\s*$|\s)/i,
                                    lookbehind: !0,
                                    alias: "keyword"
                                },
                                brackets: {
                                    pattern: /\[[^\]]+\]/,
                                    inside: {
                                        punctuation: /\[|\]/,
                                        variable: /[\w\W]+/
                                    }
                                },
                                punctuation: /[!"#%&'()*+,.\/;<=>@\[\\\]^`{|}~]/,
                                variable: /[^!"#%&'()*+,.\/;<=>@\[\\\]^`{|}~\s]+/
                            }
                        }
                    }), e.languages.insertBefore("handlebars", "tag", {
                        "handlebars-comment": {
                            pattern: /\{\{![\w\W]*?\}\}/,
                            alias: ["handlebars", "comment"]
                        }
                    }), e.hooks.add("before-highlight", function(e) {
                        "handlebars" === e.language && (e.tokenStack = [], e.backupCode = e.code, e.code = e.code.replace(a, function(a) {
                            return e.tokenStack.push(a), "___HANDLEBARS" + e.tokenStack.length + "___"
                        }))
                    }), e.hooks.add("before-insert", function(e) {
                        "handlebars" === e.language && (e.code = e.backupCode, delete e.backupCode)
                    }), e.hooks.add("after-highlight", function(a) {
                        if ("handlebars" === a.language) {
                            for (var n, t = 0; n = a.tokenStack[t]; t++) a.highlightedCode = a.highlightedCode.replace("___HANDLEBARS" + (t + 1) + "___", e.highlight(n, a.grammar, "handlebars").replace(/\$/g, "$$$$"));
                            a.element.innerHTML = a.highlightedCode
                        }
                    })
                }(Prism)
            }, {}],
            424: [function(require, module, exports) {
                ! function(e) {
                    e.languages.jade = {
                        comment: {
                            pattern: /(^([\t ]*))\/\/.*((?:\r?\n|\r)\2[\t ]+.+)*/m,
                            lookbehind: !0
                        },
                        "multiline-script": {
                            pattern: /(^([\t ]*)script\b.*\.[\t ]*)((?:\r?\n|\r(?!\n))(?:\2[\t ]+.+|\s*?(?=\r?\n|\r)))+/m,
                            lookbehind: !0,
                            inside: {
                                rest: e.languages.javascript
                            }
                        },
                        filter: {
                            pattern: /(^([\t ]*)):.+((?:\r?\n|\r(?!\n))(?:\2[\t ]+.+|\s*?(?=\r?\n|\r)))+/m,
                            lookbehind: !0,
                            inside: {
                                "filter-name": {
                                    pattern: /^:[\w-]+/,
                                    alias: "variable"
                                }
                            }
                        },
                        "multiline-plain-text": {
                            pattern: /(^([\t ]*)[\w\-#.]+\.[\t ]*)((?:\r?\n|\r(?!\n))(?:\2[\t ]+.+|\s*?(?=\r?\n|\r)))+/m,
                            lookbehind: !0
                        },
                        markup: {
                            pattern: /(^[\t ]*)<.+/m,
                            lookbehind: !0,
                            inside: {
                                rest: e.languages.markup
                            }
                        },
                        doctype: {
                            pattern: /((?:^|\n)[\t ]*)doctype(?: .+)?/,
                            lookbehind: !0
                        },
                        "flow-control": {
                            pattern: /(^[\t ]*)(?:if|unless|else|case|when|default|each|while)\b(?: .+)?/m,
                            lookbehind: !0,
                            inside: {
                                each: {
                                    pattern: /^each .+? in\b/,
                                    inside: {
                                        keyword: /\b(?:each|in)\b/,
                                        punctuation: /,/
                                    }
                                },
                                branch: {
                                    pattern: /^(?:if|unless|else|case|when|default|while)\b/,
                                    alias: "keyword"
                                },
                                rest: e.languages.javascript
                            }
                        },
                        keyword: {
                            pattern: /(^[\t ]*)(?:block|extends|include|append|prepend)\b.+/m,
                            lookbehind: !0
                        },
                        mixin: [{
                            pattern: /(^[\t ]*)mixin .+/m,
                            lookbehind: !0,
                            inside: {
                                keyword: /^mixin/,
                                function: /\w+(?=\s*\(|\s*$)/,
                                punctuation: /[(),.]/
                            }
                        }, {
                            pattern: /(^[\t ]*)\+.+/m,
                            lookbehind: !0,
                            inside: {
                                name: {
                                    pattern: /^\+\w+/,
                                    alias: "function"
                                },
                                rest: e.languages.javascript
                            }
                        }],
                        script: {
                            pattern: /(^[\t ]*script(?:(?:&[^(]+)?\([^)]+\))*[\t ]+).+/m,
                            lookbehind: !0,
                            inside: {
                                rest: e.languages.javascript
                            }
                        },
                        "plain-text": {
                            pattern: /(^[\t ]*(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?[\t ]+).+/m,
                            lookbehind: !0
                        },
                        tag: {
                            pattern: /(^[\t ]*)(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?:?/m,
                            lookbehind: !0,
                            inside: {
                                attributes: [{
                                    pattern: /&[^(]+\([^)]+\)/,
                                    inside: {
                                        rest: e.languages.javascript
                                    }
                                }, {
                                    pattern: /\([^)]+\)/,
                                    inside: {
                                        "attr-value": {
                                            pattern: /(=\s*)(?:\{[^}]*\}|[^,)\r\n]+)/,
                                            lookbehind: !0,
                                            inside: {
                                                rest: e.languages.javascript
                                            }
                                        },
                                        "attr-name": /[\w-]+(?=\s*!?=|\s*[,)])/,
                                        punctuation: /[!=(),]+/
                                    }
                                }],
                                punctuation: /:/
                            }
                        },
                        code: [{
                            pattern: /(^[\t ]*(?:-|!?=)).+/m,
                            lookbehind: !0,
                            inside: {
                                rest: e.languages.javascript
                            }
                        }],
                        punctuation: /[.\-!=|]+/
                    };
                    for (var t = [{
                            filter: "atpl",
                            language: "twig"
                        }, {
                            filter: "coffee",
                            language: "coffeescript"
                        }, "ejs", "handlebars", "hogan", "less", "livescript", "markdown", "mustache", "plates", {
                            filter: "sass",
                            language: "scss"
                        }, "stylus", "swig"], n = {}, a = 0, i = t.length; a < i; a++) {
                        var r = t[a];
                        r = "string" == typeof r ? {
                            filter: r,
                            language: r
                        } : r, e.languages[r.language] && (n["filter-" + r.filter] = {
                            pattern: RegExp("(^([\\t ]*)):{{filter_name}}((?:\\r?\\n|\\r(?!\\n))(?:\\2[\\t ]+.+|\\s*?(?=\\r?\\n|\\r)))+".replace("{{filter_name}}", r.filter), "m"),
                            lookbehind: !0,
                            inside: {
                                "filter-name": {
                                    pattern: /^:[\w-]+/,
                                    alias: "variable"
                                },
                                rest: e.languages[r.language]
                            }
                        })
                    }
                    e.languages.insertBefore("jade", "filter", n)
                }(Prism)
            }, {}],
            425: [function(require, module, exports) {
                Prism.languages.java = Prism.languages.extend("clike", {
                    keyword: /\b(abstract|continue|for|new|switch|assert|default|goto|package|synchronized|boolean|do|if|private|this|break|double|implements|protected|throw|byte|else|import|public|throws|case|enum|instanceof|return|transient|catch|extends|int|short|try|char|final|interface|static|void|class|finally|long|strictfp|volatile|const|float|native|super|while)\b/,
                    number: /\b0b[01]+\b|\b0x[\da-f]*\.?[\da-fp\-]+\b|\b\d*\.?\d+(?:e[+-]?\d+)?[df]?\b/i,
                    operator: {
                        pattern: /(^|[^.])(?:\+[+=]?|-[-=]?|!=?|<<?=?|>>?>?=?|==?|&[&=]?|\|[|=]?|\*=?|\/=?|%=?|\^=?|[?:~])/m,
                        lookbehind: !0
                    }
                }), Prism.languages.insertBefore("java", "function", {
                    annotation: {
                        alias: "punctuation",
                        pattern: /(^|[^.])@\w+/,
                        lookbehind: !0
                    }
                })
            }, {}],
            426: [function(require, module, exports) {
                Prism.languages.javascript = Prism.languages.extend("clike", {
                    keyword: /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
                    number: /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
                    function: /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i,
                    operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*\*?|\/|~|\^|%|\.{3}/
                }), Prism.languages.insertBefore("javascript", "keyword", {
                    regex: {
                        pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
                        lookbehind: !0,
                        greedy: !0
                    }
                }), Prism.languages.insertBefore("javascript", "string", {
                    "template-string": {
                        pattern: /`(?:\\\\|\\?[^\\])*?`/,
                        greedy: !0,
                        inside: {
                            interpolation: {
                                pattern: /\$\{[^}]+\}/,
                                inside: {
                                    "interpolation-punctuation": {
                                        pattern: /^\$\{|\}$/,
                                        alias: "punctuation"
                                    },
                                    rest: Prism.languages.javascript
                                }
                            },
                            string: /[\s\S]+/
                        }
                    }
                }), Prism.languages.markup && Prism.languages.insertBefore("markup", "tag", {
                    script: {
                        pattern: /(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,
                        lookbehind: !0,
                        inside: Prism.languages.javascript,
                        alias: "language-javascript"
                    }
                }), Prism.languages.js = Prism.languages.javascript
            }, {}],
            427: [function(require, module, exports) {
                ! function(a) {
                    var e = a.util.clone(a.languages.javascript);
                    a.languages.jsx = a.languages.extend("markup", e), a.languages.jsx.tag.pattern = /<\/?[\w\.:-]+\s*(?:\s+[\w\.:-]+(?:=(?:("|')(\\?[\w\W])*?\1|[^\s'">=]+|(\{[\w\W]*?\})))?\s*)*\/?>/i, a.languages.jsx.tag.inside["attr-value"].pattern = /=[^\{](?:('|")[\w\W]*?(\1)|[^\s>]+)/i;
                    var s = a.util.clone(a.languages.jsx);
                    delete s.punctuation, s = a.languages.insertBefore("jsx", "operator", {
                        punctuation: /=(?={)|[{}[\];(),.:]/
                    }, {
                        jsx: s
                    }), a.languages.insertBefore("inside", "attr-value", {
                        script: {
                            pattern: /=(\{(?:\{[^}]*\}|[^}])+\})/i,
                            inside: s,
                            alias: "language-javascript"
                        }
                    }, a.languages.jsx.tag)
                }(Prism)
            }, {}],
            428: [function(require, module, exports) {
                Prism.languages.php = Prism.languages.extend("clike", {
                    keyword: /\b(and|or|xor|array|as|break|case|cfunction|class|const|continue|declare|default|die|do|else|elseif|enddeclare|endfor|endforeach|endif|endswitch|endwhile|extends|for|foreach|function|include|include_once|global|if|new|return|static|switch|use|require|require_once|var|while|abstract|interface|public|implements|private|protected|parent|throw|null|echo|print|trait|namespace|final|yield|goto|instanceof|finally|try|catch)\b/i,
                    constant: /\b[A-Z0-9_]{2,}\b/,
                    comment: {
                        pattern: /(^|[^\\])(?:\/\*[\w\W]*?\*\/|\/\/.*)/,
                        lookbehind: !0,
                        greedy: !0
                    }
                }), Prism.languages.insertBefore("php", "class-name", {
                    "shell-comment": {
                        pattern: /(^|[^\\])#.*/,
                        lookbehind: !0,
                        alias: "comment"
                    }
                }), Prism.languages.insertBefore("php", "keyword", {
                    delimiter: /\?>|<\?(?:php)?/i,
                    variable: /\$\w+\b/i,
                    package: {
                        pattern: /(\\|namespace\s+|use\s+)[\w\\]+/,
                        lookbehind: !0,
                        inside: {
                            punctuation: /\\/
                        }
                    }
                }), Prism.languages.insertBefore("php", "operator", {
                    property: {
                        pattern: /(->)[\w]+/,
                        lookbehind: !0
                    }
                }), Prism.languages.markup && (Prism.hooks.add("before-highlight", function(e) {
                    "php" === e.language && (e.tokenStack = [], e.backupCode = e.code, e.code = e.code.replace(/(?:<\?php|<\?)[\w\W]*?(?:\?>)/gi, function(a) {
                        return e.tokenStack.push(a), "{{{PHP" + e.tokenStack.length + "}}}"
                    }))
                }), Prism.hooks.add("before-insert", function(e) {
                    "php" === e.language && (e.code = e.backupCode, delete e.backupCode)
                }), Prism.hooks.add("after-highlight", function(e) {
                    if ("php" === e.language) {
                        for (var a, n = 0; a = e.tokenStack[n]; n++) e.highlightedCode = e.highlightedCode.replace("{{{PHP" + (n + 1) + "}}}", Prism.highlight(a, e.grammar, "php").replace(/\$/g, "$$$$"));
                        e.element.innerHTML = e.highlightedCode
                    }
                }), Prism.hooks.add("wrap", function(e) {
                    "php" === e.language && "markup" === e.type && (e.content = e.content.replace(/(\{\{\{PHP[0-9]+\}\}\})/g, '<span class="token php">$1</span>'))
                }), Prism.languages.insertBefore("php", "comment", {
                    markup: {
                        pattern: /<[^?]\/?(.*?)>/,
                        inside: Prism.languages.markup
                    },
                    php: /\{\{\{PHP[0-9]+\}\}\}/
                }))
            }, {}],
            429: [function(require, module, exports) {
                ! function(e) {
                    e.languages.ruby = e.languages.extend("clike", {
                        comment: /#(?!\{[^\r\n]*?\}).*/,
                        keyword: /\b(alias|and|BEGIN|begin|break|case|class|def|define_method|defined|do|each|else|elsif|END|end|ensure|false|for|if|in|module|new|next|nil|not|or|raise|redo|require|rescue|retry|return|self|super|then|throw|true|undef|unless|until|when|while|yield)\b/
                    });
                    var n = {
                        pattern: /#\{[^}]+\}/,
                        inside: {
                            delimiter: {
                                pattern: /^#\{|\}$/,
                                alias: "tag"
                            },
                            rest: e.util.clone(e.languages.ruby)
                        }
                    };
                    e.languages.insertBefore("ruby", "keyword", {
                        regex: [{
                            pattern: /%r([^a-zA-Z0-9\s\{\(\[<])(?:[^\\]|\\[\s\S])*?\1[gim]{0,3}/,
                            inside: {
                                interpolation: n
                            }
                        }, {
                            pattern: /%r\((?:[^()\\]|\\[\s\S])*\)[gim]{0,3}/,
                            inside: {
                                interpolation: n
                            }
                        }, {
                            pattern: /%r\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}[gim]{0,3}/,
                            inside: {
                                interpolation: n
                            }
                        }, {
                            pattern: /%r\[(?:[^\[\]\\]|\\[\s\S])*\][gim]{0,3}/,
                            inside: {
                                interpolation: n
                            }
                        }, {
                            pattern: /%r<(?:[^<>\\]|\\[\s\S])*>[gim]{0,3}/,
                            inside: {
                                interpolation: n
                            }
                        }, {
                            pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\r\n])+\/[gim]{0,3}(?=\s*($|[\r\n,.;})]))/,
                            lookbehind: !0
                        }],
                        variable: /[@$]+[a-zA-Z_][a-zA-Z_0-9]*(?:[?!]|\b)/,
                        symbol: /:[a-zA-Z_][a-zA-Z_0-9]*(?:[?!]|\b)/
                    }), e.languages.insertBefore("ruby", "number", {
                        builtin: /\b(Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Stat|File|Fixnum|Float|Hash|Integer|IO|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|String|Struct|TMS|Symbol|ThreadGroup|Thread|Time|TrueClass)\b/,
                        constant: /\b[A-Z][a-zA-Z_0-9]*(?:[?!]|\b)/
                    }), e.languages.ruby.string = [{
                        pattern: /%[qQiIwWxs]?([^a-zA-Z0-9\s\{\(\[<])(?:[^\\]|\\[\s\S])*?\1/,
                        greedy: !0,
                        inside: {
                            interpolation: n
                        }
                    }, {
                        pattern: /%[qQiIwWxs]?\((?:[^()\\]|\\[\s\S])*\)/,
                        greedy: !0,
                        inside: {
                            interpolation: n
                        }
                    }, {
                        pattern: /%[qQiIwWxs]?\{(?:[^#{}\\]|#(?:\{[^}]+\})?|\\[\s\S])*\}/,
                        greedy: !0,
                        inside: {
                            interpolation: n
                        }
                    }, {
                        pattern: /%[qQiIwWxs]?\[(?:[^\[\]\\]|\\[\s\S])*\]/,
                        greedy: !0,
                        inside: {
                            interpolation: n
                        }
                    }, {
                        pattern: /%[qQiIwWxs]?<(?:[^<>\\]|\\[\s\S])*>/,
                        greedy: !0,
                        inside: {
                            interpolation: n
                        }
                    }, {
                        pattern: /("|')(#\{[^}]+\}|\\(?:\r?\n|\r)|\\?.)*?\1/,
                        greedy: !0,
                        inside: {
                            interpolation: n
                        }
                    }]
                }(Prism)
            }, {}],
            430: [function(require, module, exports) {
                ! function(e) {
                    var t = /\{\*[\w\W]+?\*\}|\{[\w\W]+?\}/g,
                        a = !1;
                    e.languages.smarty = e.languages.extend("markup", {
                        smarty: {
                            pattern: t,
                            inside: {
                                delimiter: {
                                    pattern: /^\{|\}$/i,
                                    alias: "punctuation"
                                },
                                string: /(["'])(?:\\?.)*?\1/,
                                number: /\b-?(?:0x[\dA-Fa-f]+|\d*\.?\d+(?:[Ee][-+]?\d+)?)\b/,
                                variable: [/\$(?!\d)\w+/, /#(?!\d)\w+#/, {
                                    pattern: /(\.|->)(?!\d)\w+/,
                                    lookbehind: !0
                                }, {
                                    pattern: /(\[)(?!\d)\w+(?=\])/,
                                    lookbehind: !0
                                }],
                                function: [{
                                    pattern: /(\|\s*)@?(?!\d)\w+/,
                                    lookbehind: !0
                                }, /^\/?(?!\d)\w+/, /(?!\d)\w+(?=\()/],
                                "attr-name": {
                                    pattern: /\w+\s*=\s*(?:(?!\d)\w+)?/,
                                    inside: {
                                        variable: {
                                            pattern: /(=\s*)(?!\d)\w+/,
                                            lookbehind: !0
                                        },
                                        operator: /=/
                                    }
                                },
                                punctuation: [/[\[\]().,:`]|\->/],
                                operator: [/[+\-*\/%]|==?=?|[!<>]=?|&&|\|\|?/, /\bis\s+(?:not\s+)?(?:div|even|odd)(?:\s+by)?\b/, /\b(?:eq|neq?|gt|lt|gt?e|lt?e|not|mod|or|and)\b/],
                                keyword: /\b(?:false|off|on|no|true|yes)\b/
                            }
                        }
                    }), e.languages.insertBefore("smarty", "tag", {
                        "smarty-comment": {
                            pattern: /\{\*[\w\W]*?\*\}/,
                            alias: ["smarty", "comment"]
                        }
                    }), e.hooks.add("before-highlight", function(e) {
                        "smarty" === e.language && (e.tokenStack = [], e.backupCode = e.code, e.code = e.code.replace(t, function(t) {
                            return "{/literal}" === t && (a = !1), a ? t : ("{literal}" === t && (a = !0), e.tokenStack.push(t), "___SMARTY" + e.tokenStack.length + "___")
                        }))
                    }), e.hooks.add("before-insert", function(e) {
                        "smarty" === e.language && (e.code = e.backupCode, delete e.backupCode)
                    }), e.hooks.add("after-highlight", function(t) {
                        if ("smarty" === t.language) {
                            for (var a, n = 0; a = t.tokenStack[n]; n++) t.highlightedCode = t.highlightedCode.replace("___SMARTY" + (n + 1) + "___", e.highlight(a, t.grammar, "smarty").replace(/\$/g, "$$$$"));
                            t.element.innerHTML = t.highlightedCode
                        }
                    })
                }(Prism)
            }, {}],
            431: [function(require, module, exports) {
                Prism.languages.yaml = {
                    scalar: {
                        pattern: /([\-:]\s*(![^\s]+)?[ \t]*[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)[^\r\n]+(?:\3[^\r\n]+)*)/,
                        lookbehind: !0,
                        alias: "string"
                    },
                    comment: /#.*/,
                    key: {
                        pattern: /(\s*(?:^|[:\-,[{\r\n?])[ \t]*(![^\s]+)?[ \t]*)[^\r\n{[\]},#\s]+?(?=\s*:\s)/,
                        lookbehind: !0,
                        alias: "atrule"
                    },
                    directive: {
                        pattern: /(^[ \t]*)%.+/m,
                        lookbehind: !0,
                        alias: "important"
                    },
                    datetime: {
                        pattern: /([:\-,[{]\s*(![^\s]+)?[ \t]*)(\d{4}-\d\d?-\d\d?([tT]|[ \t]+)\d\d?:\d{2}:\d{2}(\.\d*)?[ \t]*(Z|[-+]\d\d?(:\d{2})?)?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(:\d{2}(\.\d*)?)?)(?=[ \t]*($|,|]|}))/m,
                        lookbehind: !0,
                        alias: "number"
                    },
                    boolean: {
                        pattern: /([:\-,[{]\s*(![^\s]+)?[ \t]*)(true|false)[ \t]*(?=$|,|]|})/im,
                        lookbehind: !0,
                        alias: "important"
                    },
                    null: {
                        pattern: /([:\-,[{]\s*(![^\s]+)?[ \t]*)(null|~)[ \t]*(?=$|,|]|})/im,
                        lookbehind: !0,
                        alias: "important"
                    },
                    string: {
                        pattern: /([:\-,[{]\s*(![^\s]+)?[ \t]*)("(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')(?=[ \t]*($|,|]|}))/m,
                        lookbehind: !0
                    },
                    number: {
                        pattern: /([:\-,[{]\s*(![^\s]+)?[ \t]*)[+\-]?(0x[\da-f]+|0o[0-7]+|(\d+\.?\d*|\.?\d+)(e[\+\-]?\d+)?|\.inf|\.nan)[ \t]*(?=$|,|]|})/im,
                        lookbehind: !0
                    },
                    tag: /![^\s]+/,
                    important: /[&*][\w]+/,
                    punctuation: /---|[:[\]{}\-,|>?]|\.\.\./
                }
            }, {}],
            432: [function(require, module, exports) {
                (function(global) {
                    var _self = "undefined" != typeof window ? window : "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope ? self : {},
                        Prism = function() {
                            var e = /\blang(?:uage)?-(\w+)\b/i,
                                t = 0,
                                a = _self.Prism = {
                                    util: {
                                        encode: function(e) {
                                            return e instanceof n ? new n(e.type, a.util.encode(e.content), e.alias) : "Array" === a.util.type(e) ? e.map(a.util.encode) : e.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/\u00a0/g, " ")
                                        },
                                        type: function(e) {
                                            return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]
                                        },
                                        objId: function(e) {
                                            return e.__id || Object.defineProperty(e, "__id", {
                                                value: ++t
                                            }), e.__id
                                        },
                                        clone: function(e) {
                                            switch (a.util.type(e)) {
                                                case "Object":
                                                    var t = {};
                                                    for (var n in e) e.hasOwnProperty(n) && (t[n] = a.util.clone(e[n]));
                                                    return t;
                                                case "Array":
                                                    return e.map && e.map(function(e) {
                                                        return a.util.clone(e)
                                                    })
                                            }
                                            return e
                                        }
                                    },
                                    languages: {
                                        extend: function(e, t) {
                                            var n = a.util.clone(a.languages[e]);
                                            for (var r in t) n[r] = t[r];
                                            return n
                                        },
                                        insertBefore: function(e, t, n, r) {
                                            var i = (r = r || a.languages)[e];
                                            if (2 == arguments.length) {
                                                for (var s in n = arguments[1]) n.hasOwnProperty(s) && (i[s] = n[s]);
                                                return i
                                            }
                                            var l = {};
                                            for (var o in i)
                                                if (i.hasOwnProperty(o)) {
                                                    if (o == t)
                                                        for (var s in n) n.hasOwnProperty(s) && (l[s] = n[s]);
                                                    l[o] = i[o]
                                                } return a.languages.DFS(a.languages, function(t, a) {
                                                a === r[e] && t != e && (this[t] = l)
                                            }), r[e] = l
                                        },
                                        DFS: function(e, t, n, r) {
                                            for (var i in r = r || {}, e) e.hasOwnProperty(i) && (t.call(e, i, e[i], n || i), "Object" !== a.util.type(e[i]) || r[a.util.objId(e[i])] ? "Array" !== a.util.type(e[i]) || r[a.util.objId(e[i])] || (r[a.util.objId(e[i])] = !0, a.languages.DFS(e[i], t, i, r)) : (r[a.util.objId(e[i])] = !0, a.languages.DFS(e[i], t, null, r)))
                                        }
                                    },
                                    plugins: {},
                                    highlightAll: function(e, t) {
                                        var n = {
                                            callback: t,
                                            selector: 'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
                                        };
                                        a.hooks.run("before-highlightall", n);
                                        for (var r, i = n.elements || document.querySelectorAll(n.selector), s = 0; r = i[s++];) a.highlightElement(r, !0 === e, n.callback)
                                    },
                                    highlightElement: function(t, n, r) {
                                        for (var i, s, l = t; l && !e.test(l.className);) l = l.parentNode;
                                        l && (i = (l.className.match(e) || [, ""])[1].toLowerCase(), s = a.languages[i]), t.className = t.className.replace(e, "").replace(/\s+/g, " ") + " language-" + i, l = t.parentNode, /pre/i.test(l.nodeName) && (l.className = l.className.replace(e, "").replace(/\s+/g, " ") + " language-" + i);
                                        var o = {
                                            element: t,
                                            language: i,
                                            grammar: s,
                                            code: t.textContent
                                        };
                                        if (a.hooks.run("before-sanity-check", o), !o.code || !o.grammar) return o.code && (o.element.textContent = o.code), void a.hooks.run("complete", o);
                                        if (a.hooks.run("before-highlight", o), n && _self.Worker) {
                                            var u = new Worker(a.filename);
                                            u.onmessage = function(e) {
                                                o.highlightedCode = e.data, a.hooks.run("before-insert", o), o.element.innerHTML = o.highlightedCode, r && r.call(o.element), a.hooks.run("after-highlight", o), a.hooks.run("complete", o)
                                            }, u.postMessage(JSON.stringify({
                                                language: o.language,
                                                code: o.code,
                                                immediateClose: !0
                                            }))
                                        } else o.highlightedCode = a.highlight(o.code, o.grammar, o.language), a.hooks.run("before-insert", o), o.element.innerHTML = o.highlightedCode, r && r.call(t), a.hooks.run("after-highlight", o), a.hooks.run("complete", o)
                                    },
                                    highlight: function(e, t, r) {
                                        var i = a.tokenize(e, t);
                                        return n.stringify(a.util.encode(i), r)
                                    },
                                    tokenize: function(e, t, n) {
                                        var r = a.Token,
                                            i = [e],
                                            s = t.rest;
                                        if (s) {
                                            for (var l in s) t[l] = s[l];
                                            delete t.rest
                                        }
                                        e: for (var l in t)
                                            if (t.hasOwnProperty(l) && t[l]) {
                                                var o = t[l];
                                                o = "Array" === a.util.type(o) ? o : [o];
                                                for (var u = 0; u < o.length; ++u) {
                                                    var g = o[u],
                                                        c = g.inside,
                                                        p = !!g.lookbehind,
                                                        d = !!g.greedy,
                                                        m = 0,
                                                        h = g.alias;
                                                    if (d && !g.pattern.global) {
                                                        var f = g.pattern.toString().match(/[imuy]*$/)[0];
                                                        g.pattern = RegExp(g.pattern.source, f + "g")
                                                    }
                                                    g = g.pattern || g;
                                                    for (var y = 0, b = 0; y < i.length; b += i[y].length, ++y) {
                                                        var v = i[y];
                                                        if (i.length > e.length) break e;
                                                        if (!(v instanceof r)) {
                                                            g.lastIndex = 0;
                                                            var w = 1;
                                                            if (!(_ = g.exec(v)) && d && y != i.length - 1) {
                                                                if (g.lastIndex = b, !(_ = g.exec(e))) break;
                                                                for (var k = _.index + (p ? _[1].length : 0), P = _.index + _[0].length, x = y, A = b, j = i.length; x < j && A < P; ++x) k >= (A += i[x].length) && (++y, b = A);
                                                                if (i[y] instanceof r || i[x - 1].greedy) continue;
                                                                w = x - y, v = e.slice(b, A), _.index -= b
                                                            }
                                                            if (_) {
                                                                p && (m = _[1].length), P = (k = _.index + m) + (_ = _[0].slice(m)).length;
                                                                var _, C = v.slice(0, k),
                                                                    E = v.slice(P),
                                                                    N = [y, w];
                                                                C && N.push(C);
                                                                var S = new r(l, c ? a.tokenize(_, c) : _, h, _, d);
                                                                N.push(S), E && N.push(E), Array.prototype.splice.apply(i, N)
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        return i
                                    },
                                    hooks: {
                                        all: {},
                                        add: function(e, t) {
                                            var n = a.hooks.all;
                                            n[e] = n[e] || [], n[e].push(t)
                                        },
                                        run: function(e, t) {
                                            var n = a.hooks.all[e];
                                            if (n && n.length)
                                                for (var r, i = 0; r = n[i++];) r(t)
                                        }
                                    }
                                },
                                n = a.Token = function(e, t, a, n, r) {
                                    this.type = e, this.content = t, this.alias = a, this.length = 0 | (n || "").length, this.greedy = !!r
                                };
                            if (n.stringify = function(e, t, r) {
                                    if ("string" == typeof e) return e;
                                    if ("Array" === a.util.type(e)) return e.map(function(a) {
                                        return n.stringify(a, t, e)
                                    }).join("");
                                    var i = {
                                        type: e.type,
                                        content: n.stringify(e.content, t, r),
                                        tag: "span",
                                        classes: ["token", e.type],
                                        attributes: {},
                                        language: t,
                                        parent: r
                                    };
                                    if ("comment" == i.type && (i.attributes.spellcheck = "true"), e.alias) {
                                        var s = "Array" === a.util.type(e.alias) ? e.alias : [e.alias];
                                        Array.prototype.push.apply(i.classes, s)
                                    }
                                    a.hooks.run("wrap", i);
                                    var l = Object.keys(i.attributes).map(function(e) {
                                        return e + '="' + (i.attributes[e] || "").replace(/"/g, "&quot;") + '"'
                                    }).join(" ");
                                    return "<" + i.tag + ' class="' + i.classes.join(" ") + '"' + (l ? " " + l : "") + ">" + i.content + "</" + i.tag + ">"
                                }, !_self.document) return _self.addEventListener ? (_self.addEventListener("message", function(e) {
                                var t = JSON.parse(e.data),
                                    n = t.language,
                                    r = t.code,
                                    i = t.immediateClose;
                                _self.postMessage(a.highlight(r, a.languages[n], n)), i && _self.close()
                            }, !1), _self.Prism) : _self.Prism;
                            var r = document.currentScript || [].slice.call(document.getElementsByTagName("script")).pop();
                            return r && (a.filename = r.src, document.addEventListener && !r.hasAttribute("data-manual") && ("loading" !== document.readyState ? window.requestAnimationFrame ? window.requestAnimationFrame(a.highlightAll) : window.setTimeout(a.highlightAll, 16) : document.addEventListener("DOMContentLoaded", a.highlightAll))), _self.Prism
                        }();
                    "undefined" != typeof module && module.exports && (module.exports = Prism), "undefined" != typeof global && (global.Prism = Prism), Prism.languages.markup = {
                        comment: /<!--[\w\W]*?-->/,
                        prolog: /<\?[\w\W]+?\?>/,
                        doctype: /<!DOCTYPE[\w\W]+?>/i,
                        cdata: /<!\[CDATA\[[\w\W]*?]]>/i,
                        tag: {
                            pattern: /<\/?(?!\d)[^\s>\/=$<]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\\1|\\?(?!\1)[\w\W])*\1|[^\s'">=]+))?)*\s*\/?>/i,
                            inside: {
                                tag: {
                                    pattern: /^<\/?[^\s>\/]+/i,
                                    inside: {
                                        punctuation: /^<\/?/,
                                        namespace: /^[^\s>\/:]+:/
                                    }
                                },
                                "attr-value": {
                                    pattern: /=(?:('|")[\w\W]*?(\1)|[^\s>]+)/i,
                                    inside: {
                                        punctuation: /[=>"']/
                                    }
                                },
                                punctuation: /\/?>/,
                                "attr-name": {
                                    pattern: /[^\s>\/]+/,
                                    inside: {
                                        namespace: /^[^\s>\/:]+:/
                                    }
                                }
                            }
                        },
                        entity: /&#?[\da-z]{1,8};/i
                    }, Prism.hooks.add("wrap", function(e) {
                        "entity" === e.type && (e.attributes.title = e.content.replace(/&amp;/, "&"))
                    }), Prism.languages.xml = Prism.languages.markup, Prism.languages.html = Prism.languages.markup, Prism.languages.mathml = Prism.languages.markup, Prism.languages.svg = Prism.languages.markup, Prism.languages.css = {
                        comment: /\/\*[\w\W]*?\*\//,
                        atrule: {
                            pattern: /@[\w-]+?.*?(;|(?=\s*\{))/i,
                            inside: {
                                rule: /@[\w-]+/
                            }
                        },
                        url: /url\((?:(["'])(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1|.*?)\)/i,
                        selector: /[^\{\}\s][^\{\};]*?(?=\s*\{)/,
                        string: {
                            pattern: /("|')(\\(?:\r\n|[\w\W])|(?!\1)[^\\\r\n])*\1/,
                            greedy: !0
                        },
                        property: /(\b|\B)[\w-]+(?=\s*:)/i,
                        important: /\B!important\b/i,
                        function: /[-a-z0-9]+(?=\()/i,
                        punctuation: /[(){};:]/
                    }, Prism.languages.css.atrule.inside.rest = Prism.util.clone(Prism.languages.css), Prism.languages.markup && (Prism.languages.insertBefore("markup", "tag", {
                        style: {
                            pattern: /(<style[\w\W]*?>)[\w\W]*?(?=<\/style>)/i,
                            lookbehind: !0,
                            inside: Prism.languages.css,
                            alias: "language-css"
                        }
                    }), Prism.languages.insertBefore("inside", "attr-value", {
                        "style-attr": {
                            pattern: /\s*style=("|').*?\1/i,
                            inside: {
                                "attr-name": {
                                    pattern: /^\s*style/i,
                                    inside: Prism.languages.markup.tag.inside
                                },
                                punctuation: /^\s*=\s*['"]|['"]\s*$/,
                                "attr-value": {
                                    pattern: /.+/i,
                                    inside: Prism.languages.css
                                }
                            },
                            alias: "language-css"
                        }
                    }, Prism.languages.markup.tag)), Prism.languages.clike = {
                        comment: [{
                            pattern: /(^|[^\\])\/\*[\w\W]*?\*\//,
                            lookbehind: !0
                        }, {
                            pattern: /(^|[^\\:])\/\/.*/,
                            lookbehind: !0
                        }],
                        string: {
                            pattern: /(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
                            greedy: !0
                        },
                        "class-name": {
                            pattern: /((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,
                            lookbehind: !0,
                            inside: {
                                punctuation: /(\.|\\)/
                            }
                        },
                        keyword: /\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,
                        boolean: /\b(true|false)\b/,
                        function: /[a-z0-9_]+(?=\()/i,
                        number: /\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,
                        operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,
                        punctuation: /[{}[\];(),.:]/
                    }, Prism.languages.javascript = Prism.languages.extend("clike", {
                        keyword: /\b(as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|var|void|while|with|yield)\b/,
                        number: /\b-?(0x[\dA-Fa-f]+|0b[01]+|0o[0-7]+|\d*\.?\d+([Ee][+-]?\d+)?|NaN|Infinity)\b/,
                        function: /[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*(?=\()/i,
                        operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*\*?|\/|~|\^|%|\.{3}/
                    }), Prism.languages.insertBefore("javascript", "keyword", {
                        regex: {
                            pattern: /(^|[^/])\/(?!\/)(\[.+?]|\\.|[^/\\\r\n])+\/[gimyu]{0,5}(?=\s*($|[\r\n,.;})]))/,
                            lookbehind: !0,
                            greedy: !0
                        }
                    }), Prism.languages.insertBefore("javascript", "string", {
                        "template-string": {
                            pattern: /`(?:\\\\|\\?[^\\])*?`/,
                            greedy: !0,
                            inside: {
                                interpolation: {
                                    pattern: /\$\{[^}]+\}/,
                                    inside: {
                                        "interpolation-punctuation": {
                                            pattern: /^\$\{|\}$/,
                                            alias: "punctuation"
                                        },
                                        rest: Prism.languages.javascript
                                    }
                                },
                                string: /[\s\S]+/
                            }
                        }
                    }), Prism.languages.markup && Prism.languages.insertBefore("markup", "tag", {
                        script: {
                            pattern: /(<script[\w\W]*?>)[\w\W]*?(?=<\/script>)/i,
                            lookbehind: !0,
                            inside: Prism.languages.javascript,
                            alias: "language-javascript"
                        }
                    }), Prism.languages.js = Prism.languages.javascript, "undefined" != typeof self && self.Prism && self.document && document.querySelector && (self.Prism.fileHighlight = function() {
                        var e = {
                            js: "javascript",
                            py: "python",
                            rb: "ruby",
                            ps1: "powershell",
                            psm1: "powershell",
                            sh: "bash",
                            bat: "batch",
                            h: "c",
                            tex: "latex"
                        };
                        Array.prototype.forEach && Array.prototype.slice.call(document.querySelectorAll("pre[data-src]")).forEach(function(t) {
                            for (var a, n = t.getAttribute("data-src"), r = t, i = /\blang(?:uage)?-(?!\*)(\w+)\b/i; r && !i.test(r.className);) r = r.parentNode;
                            if (r && (a = (t.className.match(i) || [, ""])[1]), !a) {
                                var s = (n.match(/\.(\w+)$/) || [, ""])[1];
                                a = e[s] || s
                            }
                            var l = document.createElement("code");
                            l.className = "language-" + a, t.textContent = "", l.textContent = "Loading", t.appendChild(l);
                            var o = new XMLHttpRequest;
                            o.open("GET", n, !0), o.onreadystatechange = function() {
                                4 == o.readyState && (o.status < 400 && o.responseText ? (l.textContent = o.responseText, Prism.highlightElement(l)) : o.status >= 400 ? l.textContent = " Error " + o.status + " while fetching file: " + o.statusText : l.textContent = " Error: File does not exist or is empty")
                            }, o.send(null)
                        })
                    }, document.addEventListener("DOMContentLoaded", self.Prism.fileHighlight))
                }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
            }, {}],
            433: [function(require, module, exports) {
                function defaultSetTimout() {
                    throw new Error("setTimeout has not been defined")
                }

                function defaultClearTimeout() {
                    throw new Error("clearTimeout has not been defined")
                }

                function runTimeout(e) {
                    if (cachedSetTimeout === setTimeout) return setTimeout(e, 0);
                    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) return cachedSetTimeout = setTimeout, setTimeout(e, 0);
                    try {
                        return cachedSetTimeout(e, 0)
                    } catch (t) {
                        try {
                            return cachedSetTimeout.call(null, e, 0)
                        } catch (t) {
                            return cachedSetTimeout.call(this, e, 0)
                        }
                    }
                }

                function runClearTimeout(e) {
                    if (cachedClearTimeout === clearTimeout) return clearTimeout(e);
                    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) return cachedClearTimeout = clearTimeout, clearTimeout(e);
                    try {
                        return cachedClearTimeout(e)
                    } catch (t) {
                        try {
                            return cachedClearTimeout.call(null, e)
                        } catch (t) {
                            return cachedClearTimeout.call(this, e)
                        }
                    }
                }

                function cleanUpNextTick() {
                    draining && currentQueue && (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue())
                }

                function drainQueue() {
                    if (!draining) {
                        var e = runTimeout(cleanUpNextTick);
                        draining = !0;
                        for (var t = queue.length; t;) {
                            for (currentQueue = queue, queue = []; ++queueIndex < t;) currentQueue && currentQueue[queueIndex].run();
                            queueIndex = -1, t = queue.length
                        }
                        currentQueue = null, draining = !1, runClearTimeout(e)
                    }
                }

                function Item(e, t) {
                    this.fun = e, this.array = t
                }

                function noop() {}
                var cachedSetTimeout, cachedClearTimeout, process = module.exports = {};
                ! function() {
                    try {
                        cachedSetTimeout = "function" == typeof setTimeout ? setTimeout : defaultSetTimout
                    } catch (e) {
                        cachedSetTimeout = defaultSetTimout
                    }
                    try {
                        cachedClearTimeout = "function" == typeof clearTimeout ? clearTimeout : defaultClearTimeout
                    } catch (e) {
                        cachedClearTimeout = defaultClearTimeout
                    }
                }();
                var currentQueue, queue = [],
                    draining = !1,
                    queueIndex = -1;
                process.nextTick = function(e) {
                    var t = new Array(arguments.length - 1);
                    if (arguments.length > 1)
                        for (var r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
                    queue.push(new Item(e, t)), 1 !== queue.length || draining || runTimeout(drainQueue)
                }, Item.prototype.run = function() {
                    this.fun.apply(null, this.array)
                }, process.title = "browser", process.browser = !0, process.env = {}, process.argv = [], process.version = "", process.versions = {}, process.on = noop, process.addListener = noop, process.once = noop, process.off = noop, process.removeListener = noop, process.removeAllListeners = noop, process.emit = noop, process.prependListener = noop, process.prependOnceListener = noop, process.listeners = function(e) {
                    return []
                }, process.binding = function(e) {
                    throw new Error("process.binding is not supported")
                }, process.cwd = function() {
                    return "/"
                }, process.chdir = function(e) {
                    throw new Error("process.chdir is not supported")
                }, process.umask = function() {
                    return 0
                }
            }, {}],
            434: [function(require, module, exports) {
                "use strict";
                var emptyFunction = require("fbjs/lib/emptyFunction"),
                    invariant = require("fbjs/lib/invariant"),
                    ReactPropTypesSecret = require("./lib/ReactPropTypesSecret");
                module.exports = function() {
                    function e(e, r, t, n, p, o) {
                        o !== ReactPropTypesSecret && invariant(!1, "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types")
                    }

                    function r() {
                        return e
                    }
                    e.isRequired = e;
                    var t = {
                        array: e,
                        bool: e,
                        func: e,
                        number: e,
                        object: e,
                        string: e,
                        symbol: e,
                        any: e,
                        arrayOf: r,
                        element: e,
                        instanceOf: r,
                        node: e,
                        objectOf: r,
                        oneOf: r,
                        oneOfType: r,
                        shape: r,
                        exact: r
                    };
                    return t.checkPropTypes = emptyFunction, t.PropTypes = t, t
                }
            }, {
                "./lib/ReactPropTypesSecret": 436,
                "fbjs/lib/emptyFunction": 175,
                "fbjs/lib/invariant": 185
            }],
            435: [function(require, module, exports) {
                module.exports = require("./factoryWithThrowingShims")()
            }, {
                "./factoryWithThrowingShims": 434
            }],
            436: [function(require, module, exports) {
                "use strict";
                var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
                module.exports = ReactPropTypesSecret
            }, {}],
            437: [function(require, module, exports) {
                "use strict";

                function ea(e, t, n, r, a, i, l, o) {
                    if (!e) {
                        if (e = void 0, void 0 === t) e = Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
                        else {
                            var u = [n, r, a, i, l, o],
                                c = 0;
                            (e = Error(t.replace(/%s/g, function() {
                                return u[c++]
                            }))).name = "Invariant Violation"
                        }
                        throw e.framesToPop = 1, e
                    }
                }

                function r(e) {
                    for (var t = arguments.length - 1, n = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, r = 0; r < t; r++) n += "&args[]=" + encodeURIComponent(arguments[r + 1]);
                    ea(!1, "Minified React error #" + e + "; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ", n)
                }

                function fa(e, t, n, r, a, i, l, o, u) {
                    var c = Array.prototype.slice.call(arguments, 3);
                    try {
                        t.apply(n, c)
                    } catch (e) {
                        this.onError(e)
                    }
                }

                function ma(e, t, n, r, a, i, l, o, u) {
                    ha = !1, ia = null, fa.apply(la, arguments)
                }

                function na(e, t, n, a, i, l, o, u, c) {
                    if (ma.apply(this, arguments), ha) {
                        if (ha) {
                            var f = ia;
                            ha = !1, ia = null
                        } else r("198"), f = void 0;
                        ja || (ja = !0, ka = f)
                    }
                }

                function qa() {
                    if (oa)
                        for (var e in pa) {
                            var t = pa[e],
                                n = oa.indexOf(e);
                            if (-1 < n || r("96", e), !ra[n])
                                for (var a in t.extractEvents || r("97", e), ra[n] = t, n = t.eventTypes) {
                                    var i = void 0,
                                        l = n[a],
                                        o = t,
                                        u = a;
                                    sa.hasOwnProperty(u) && r("99", u), sa[u] = l;
                                    var c = l.phasedRegistrationNames;
                                    if (c) {
                                        for (i in c) c.hasOwnProperty(i) && ta(c[i], o, u);
                                        i = !0
                                    } else l.registrationName ? (ta(l.registrationName, o, u), i = !0) : i = !1;
                                    i || r("98", a, e)
                                }
                        }
                }

                function ta(e, t, n) {
                    ua[e] && r("100", e), ua[e] = t, va[e] = t.eventTypes[n].dependencies
                }

                function za(e, t, n, r) {
                    t = e.type || "unknown-event", e.currentTarget = ya(r), na(t, n, void 0, e), e.currentTarget = null
                }

                function Aa(e, t) {
                    return null == t && r("30"), null == e ? t : Array.isArray(e) ? Array.isArray(t) ? (e.push.apply(e, t), e) : (e.push(t), e) : Array.isArray(t) ? [e].concat(t) : [e, t]
                }

                function Ba(e, t, n) {
                    Array.isArray(e) ? e.forEach(t, n) : e && t.call(n, e)
                }

                function Da(e, t) {
                    if (e) {
                        var n = e._dispatchListeners,
                            r = e._dispatchInstances;
                        if (Array.isArray(n))
                            for (var a = 0; a < n.length && !e.isPropagationStopped(); a++) za(e, t, n[a], r[a]);
                        else n && za(e, t, n, r);
                        e._dispatchListeners = null, e._dispatchInstances = null, e.isPersistent() || e.constructor.release(e)
                    }
                }

                function Ea(e) {
                    return Da(e, !0)
                }

                function Fa(e) {
                    return Da(e, !1)
                }

                function Ha(e, t) {
                    var n = e.stateNode;
                    if (!n) return null;
                    var a = wa(n);
                    if (!a) return null;
                    n = a[t];
                    e: switch (t) {
                        case "onClick":
                        case "onClickCapture":
                        case "onDoubleClick":
                        case "onDoubleClickCapture":
                        case "onMouseDown":
                        case "onMouseDownCapture":
                        case "onMouseMove":
                        case "onMouseMoveCapture":
                        case "onMouseUp":
                        case "onMouseUpCapture":
                            (a = !a.disabled) || (a = !("button" === (e = e.type) || "input" === e || "select" === e || "textarea" === e)), e = !a;
                            break e;
                        default:
                            e = !1
                    }
                    return e ? null : (n && "function" != typeof n && r("231", t, _typeof2(n)), n)
                }

                function Ia(e, t) {
                    if (null !== e && (Ca = Aa(Ca, e)), e = Ca, Ca = null, e && (Ba(e, t ? Ea : Fa), Ca && r("95"), ja)) throw t = ka, ja = !1, ka = null, t
                }

                function Na(e) {
                    if (e[La]) return e[La];
                    for (; !e[La];) {
                        if (!e.parentNode) return null;
                        e = e.parentNode
                    }
                    return 5 === (e = e[La]).tag || 6 === e.tag ? e : null
                }

                function Oa(e) {
                    return !(e = e[La]) || 5 !== e.tag && 6 !== e.tag ? null : e
                }

                function Pa(e) {
                    return 5 === e.tag || 6 === e.tag ? e.stateNode : void r("33")
                }

                function Qa(e) {
                    return e[Ma] || null
                }

                function Ra(e) {
                    do e = e.return; while (e && 5 !== e.tag);
                    return e || null
                }

                function Sa(e, t, n) {
                    (t = Ha(e, n.dispatchConfig.phasedRegistrationNames[t])) && (n._dispatchListeners = Aa(n._dispatchListeners, t), n._dispatchInstances = Aa(n._dispatchInstances, e))
                }

                function Ta(e) {
                    if (e && e.dispatchConfig.phasedRegistrationNames) {
                        for (var t = e._targetInst, n = []; t;) n.push(t), t = Ra(t);
                        for (t = n.length; 0 < t--;) Sa(n[t], "captured", e);
                        for (t = 0; t < n.length; t++) Sa(n[t], "bubbled", e)
                    }
                }

                function Ua(e, t, n) {
                    e && n && n.dispatchConfig.registrationName && (t = Ha(e, n.dispatchConfig.registrationName)) && (n._dispatchListeners = Aa(n._dispatchListeners, t), n._dispatchInstances = Aa(n._dispatchInstances, e))
                }

                function Va(e) {
                    e && e.dispatchConfig.registrationName && Ua(e._targetInst, null, e)
                }

                function Wa(e) {
                    Ba(e, Ta)
                }

                function Ya(e, t) {
                    var n = {};
                    return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n
                }

                function bb(e) {
                    if ($a[e]) return $a[e];
                    if (!Za[e]) return e;
                    var t, n = Za[e];
                    for (t in n)
                        if (n.hasOwnProperty(t) && t in ab) return $a[e] = n[t];
                    return e
                }

                function pb() {
                    if (ob) return ob;
                    var e, t, n = nb,
                        r = n.length,
                        a = "value" in mb ? mb.value : mb.textContent,
                        i = a.length;
                    for (e = 0; e < r && n[e] === a[e]; e++);
                    var l = r - e;
                    for (t = 1; t <= l && n[r - t] === a[i - t]; t++);
                    return ob = a.slice(e, 1 < t ? 1 - t : void 0)
                }

                function qb() {
                    return !0
                }

                function rb() {
                    return !1
                }

                function y(e, t, n, r) {
                    for (var a in this.dispatchConfig = e, this._targetInst = t, this.nativeEvent = n, e = this.constructor.Interface) e.hasOwnProperty(a) && ((t = e[a]) ? this[a] = t(n) : "target" === a ? this.target = r : this[a] = n[a]);
                    return this.isDefaultPrevented = (null != n.defaultPrevented ? n.defaultPrevented : !1 === n.returnValue) ? qb : rb, this.isPropagationStopped = rb, this
                }

                function tb(e, t, n, r) {
                    if (this.eventPool.length) {
                        var a = this.eventPool.pop();
                        return this.call(a, e, t, n, r), a
                    }
                    return new this(e, t, n, r)
                }

                function ub(e) {
                    e instanceof this || r("279"), e.destructor(), 10 > this.eventPool.length && this.eventPool.push(e)
                }

                function sb(e) {
                    e.eventPool = [], e.getPooled = tb, e.release = ub
                }

                function Fb(e, t) {
                    switch (e) {
                        case "keyup":
                            return -1 !== xb.indexOf(t.keyCode);
                        case "keydown":
                            return 229 !== t.keyCode;
                        case "keypress":
                        case "mousedown":
                        case "blur":
                            return !0;
                        default:
                            return !1
                    }
                }

                function Gb(e) {
                    return "object" == _typeof2(e = e.detail) && "data" in e ? e.data : null
                }

                function Kb(e, t) {
                    switch (e) {
                        case "compositionend":
                            return Gb(t);
                        case "keypress":
                            return 32 !== t.which ? null : (Eb = !0, Cb);
                        case "textInput":
                            return (e = t.data) === Cb && Eb ? null : e;
                        default:
                            return null
                    }
                }

                function Lb(e, t) {
                    if (Hb) return "compositionend" === e || !yb && Fb(e, t) ? (e = pb(), ob = nb = mb = null, Hb = !1, e) : null;
                    switch (e) {
                        case "paste":
                            return null;
                        case "keypress":
                            if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) {
                                if (t.char && 1 < t.char.length) return t.char;
                                if (t.which) return String.fromCharCode(t.which)
                            }
                            return null;
                        case "compositionend":
                            return Bb && "ko" !== t.locale ? null : t.data;
                        default:
                            return null
                    }
                }

                function Vb(e) {
                    if (e = xa(e)) {
                        "function" != typeof Nb && r("280");
                        var t = wa(e.stateNode);
                        Nb(e.stateNode, e.type, t)
                    }
                }

                function Wb(e) {
                    Ob ? Pb ? Pb.push(e) : Pb = [e] : Ob = e
                }

                function Xb() {
                    if (Ob) {
                        var e = Ob,
                            t = Pb;
                        if (Pb = Ob = null, Vb(e), t)
                            for (e = 0; e < t.length; e++) Vb(t[e])
                    }
                }

                function Yb(e, t) {
                    return e(t)
                }

                function Zb(e, t, n) {
                    return e(t, n)
                }

                function $b() {}

                function bc(e, t) {
                    if (ac) return e(t);
                    ac = !0;
                    try {
                        return Yb(e, t)
                    } finally {
                        ac = !1, (null !== Ob || null !== Pb) && ($b(), Xb())
                    }
                }

                function dc(e) {
                    var t = e && e.nodeName && e.nodeName.toLowerCase();
                    return "input" === t ? !!cc[e.type] : "textarea" === t
                }

                function ec(e) {
                    return (e = e.target || e.srcElement || window).correspondingUseElement && (e = e.correspondingUseElement), 3 === e.nodeType ? e.parentNode : e
                }

                function fc(e) {
                    if (!Xa) return !1;
                    var t = (e = "on" + e) in document;
                    return t || ((t = document.createElement("div")).setAttribute(e, "return;"), t = "function" == typeof t[e]), t
                }

                function gc(e) {
                    var t = e.type;
                    return (e = e.nodeName) && "input" === e.toLowerCase() && ("checkbox" === t || "radio" === t)
                }

                function hc(e) {
                    var t = gc(e) ? "checked" : "value",
                        n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t),
                        r = "" + e[t];
                    if (!e.hasOwnProperty(t) && void 0 !== n && "function" == typeof n.get && "function" == typeof n.set) {
                        var a = n.get,
                            i = n.set;
                        return Object.defineProperty(e, t, {
                            configurable: !0,
                            get: function() {
                                return a.call(this)
                            },
                            set: function(e) {
                                r = "" + e, i.call(this, e)
                            }
                        }), Object.defineProperty(e, t, {
                            enumerable: n.enumerable
                        }), {
                            getValue: function() {
                                return r
                            },
                            setValue: function(e) {
                                r = "" + e
                            },
                            stopTracking: function() {
                                e._valueTracker = null, delete e[t]
                            }
                        }
                    }
                }

                function ic(e) {
                    e._valueTracker || (e._valueTracker = hc(e))
                }

                function jc(e) {
                    if (!e) return !1;
                    var t = e._valueTracker;
                    if (!t) return !0;
                    var n = t.getValue(),
                        r = "";
                    return e && (r = gc(e) ? e.checked ? "true" : "false" : e.value), (e = r) !== n && (t.setValue(e), !0)
                }

                function zc(e) {
                    return null === e || "object" != _typeof2(e) ? null : "function" == typeof(e = yc && e[yc] || e["@@iterator"]) ? e : null
                }

                function Ac(e) {
                    if (null == e) return null;
                    if ("function" == typeof e) return e.displayName || e.name || null;
                    if ("string" == typeof e) return e;
                    switch (e) {
                        case tc:
                            return "ConcurrentMode";
                        case oc:
                            return "Fragment";
                        case nc:
                            return "Portal";
                        case qc:
                            return "Profiler";
                        case pc:
                            return "StrictMode";
                        case vc:
                            return "Suspense"
                    }
                    if ("object" == _typeof2(e)) switch (e.$$typeof) {
                        case sc:
                            return "Context.Consumer";
                        case rc:
                            return "Context.Provider";
                        case uc:
                            var t = e.render;
                            return t = t.displayName || t.name || "", e.displayName || ("" !== t ? "ForwardRef(" + t + ")" : "ForwardRef");
                        case wc:
                            return Ac(e.type);
                        case xc:
                            if (e = 1 === e._status ? e._result : null) return Ac(e)
                    }
                    return null
                }

                function Bc(e) {
                    var t = "";
                    do {
                        e: switch (e.tag) {
                            case 2:
                            case 16:
                            case 0:
                            case 1:
                            case 5:
                            case 8:
                                var n = e._debugOwner,
                                    r = e._debugSource,
                                    a = Ac(e.type),
                                    i = null;
                                n && (i = Ac(n.type)), n = a, a = "", r ? a = " (at " + r.fileName.replace(lc, "") + ":" + r.lineNumber + ")" : i && (a = " (created by " + i + ")"), i = "\n    in " + (n || "Unknown") + a;
                                break e;
                            default:
                                i = ""
                        }
                        t += i,
                        e = e.return
                    } while (e);
                    return t
                }

                function Gc(e) {
                    return !!Dc.call(Fc, e) || !Dc.call(Ec, e) && (Cc.test(e) ? Fc[e] = !0 : (Ec[e] = !0, !1))
                }

                function Hc(e, t, n, r) {
                    if (null !== n && 0 === n.type) return !1;
                    switch (_typeof2(t)) {
                        case "function":
                        case "symbol":
                            return !0;
                        case "boolean":
                            return !r && (null !== n ? !n.acceptsBooleans : "data-" !== (e = e.toLowerCase().slice(0, 5)) && "aria-" !== e);
                        default:
                            return !1
                    }
                }

                function Ic(e, t, n, r) {
                    if (null == t || Hc(e, t, n, r)) return !0;
                    if (r) return !1;
                    if (null !== n) switch (n.type) {
                        case 3:
                            return !t;
                        case 4:
                            return !1 === t;
                        case 5:
                            return isNaN(t);
                        case 6:
                            return isNaN(t) || 1 > t
                    }
                    return !1
                }

                function F(e, t, n, r, a) {
                    this.acceptsBooleans = 2 === t || 3 === t || 4 === t, this.attributeName = r, this.attributeNamespace = a, this.mustUseProperty = n, this.propertyName = e, this.type = t
                }

                function Nc(e) {
                    return e[1].toUpperCase()
                }

                function Oc(e, t, n, r) {
                    var a = G.hasOwnProperty(t) ? G[t] : null;
                    (null !== a ? 0 === a.type : !r && 2 < t.length && ("o" === t[0] || "O" === t[0]) && ("n" === t[1] || "N" === t[1])) || (Ic(t, n, a, r) && (n = null), r || null === a ? Gc(t) && (null === n ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : a.mustUseProperty ? e[a.propertyName] = null === n ? 3 !== a.type && "" : n : (t = a.attributeName, r = a.attributeNamespace, null === n ? e.removeAttribute(t) : (n = 3 === (a = a.type) || 4 === a && !0 === n ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n))))
                }

                function Pc(e) {
                    switch (_typeof2(e)) {
                        case "boolean":
                        case "number":
                        case "object":
                        case "string":
                        case "undefined":
                            return e;
                        default:
                            return ""
                    }
                }

                function Qc(e, t) {
                    var r = t.checked;
                    return n({}, t, {
                        defaultChecked: void 0,
                        defaultValue: void 0,
                        value: void 0,
                        checked: null != r ? r : e._wrapperState.initialChecked
                    })
                }

                function Rc(e, t) {
                    var n = null == t.defaultValue ? "" : t.defaultValue,
                        r = null != t.checked ? t.checked : t.defaultChecked;
                    n = Pc(null != t.value ? t.value : n), e._wrapperState = {
                        initialChecked: r,
                        initialValue: n,
                        controlled: "checkbox" === t.type || "radio" === t.type ? null != t.checked : null != t.value
                    }
                }

                function Sc(e, t) {
                    null != (t = t.checked) && Oc(e, "checked", t, !1)
                }

                function Tc(e, t) {
                    Sc(e, t);
                    var n = Pc(t.value),
                        r = t.type;
                    if (null != n) "number" === r ? (0 === n && "" === e.value || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n);
                    else if ("submit" === r || "reset" === r) return void e.removeAttribute("value");
                    t.hasOwnProperty("value") ? Uc(e, t.type, n) : t.hasOwnProperty("defaultValue") && Uc(e, t.type, Pc(t.defaultValue)), null == t.checked && null != t.defaultChecked && (e.defaultChecked = !!t.defaultChecked)
                }

                function bd(e, t, n) {
                    if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) {
                        var r = t.type;
                        if (!("submit" !== r && "reset" !== r || void 0 !== t.value && null !== t.value)) return;
                        t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t
                    }
                    "" !== (n = e.name) && (e.name = ""), e.defaultChecked = !e.defaultChecked, e.defaultChecked = !!e._wrapperState.initialChecked, "" !== n && (e.name = n)
                }

                function Uc(e, t, n) {
                    "number" === t && e.ownerDocument.activeElement === e || (null == n ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n))
                }

                function dd(e, t, n) {
                    return (e = y.getPooled(cd.change, e, t, n)).type = "change", Wb(n), Wa(e), e
                }

                function gd(e) {
                    Ia(e, !1)
                }

                function hd(e) {
                    if (jc(Pa(e))) return e
                }

                function id(e, t) {
                    if ("change" === e) return t
                }

                function kd() {
                    ed && (ed.detachEvent("onpropertychange", ld), fd = ed = null)
                }

                function ld(e) {
                    "value" === e.propertyName && hd(fd) && bc(gd, e = dd(fd, e, ec(e)))
                }

                function md(e, t, n) {
                    "focus" === e ? (kd(), fd = n, (ed = t).attachEvent("onpropertychange", ld)) : "blur" === e && kd()
                }

                function nd(e) {
                    if ("selectionchange" === e || "keyup" === e || "keydown" === e) return hd(fd)
                }

                function od(e, t) {
                    if ("click" === e) return hd(t)
                }

                function pd(e, t) {
                    if ("input" === e || "change" === e) return hd(t)
                }

                function td(e) {
                    var t = this.nativeEvent;
                    return t.getModifierState ? t.getModifierState(e) : !!(e = sd[e]) && !!t[e]
                }

                function ud() {
                    return td
                }

                function Ed(e, t) {
                    return e === t ? 0 !== e || 0 !== t || 1 / e == 1 / t : e != e && t != t
                }

                function Fd(e, t) {
                    if (Ed(e, t)) return !0;
                    if ("object" != _typeof2(e) || null === e || "object" != _typeof2(t) || null === t) return !1;
                    var n = Object.keys(e),
                        r = Object.keys(t);
                    if (n.length !== r.length) return !1;
                    for (r = 0; r < n.length; r++)
                        if (!Dd.call(t, n[r]) || !Ed(e[n[r]], t[n[r]])) return !1;
                    return !0
                }

                function Gd(e) {
                    var t = e;
                    if (e.alternate)
                        for (; t.return;) t = t.return;
                    else {
                        if (0 != (2 & t.effectTag)) return 1;
                        for (; t.return;)
                            if (0 != (2 & (t = t.return).effectTag)) return 1
                    }
                    return 3 === t.tag ? 2 : 3
                }

                function Hd(e) {
                    2 !== Gd(e) && r("188")
                }

                function Id(e) {
                    var t = e.alternate;
                    if (!t) return 3 === (t = Gd(e)) && r("188"), 1 === t ? null : e;
                    for (var n = e, a = t;;) {
                        var i = n.return,
                            l = i ? i.alternate : null;
                        if (!i || !l) break;
                        if (i.child === l.child) {
                            for (var o = i.child; o;) {
                                if (o === n) return Hd(i), e;
                                if (o === a) return Hd(i), t;
                                o = o.sibling
                            }
                            r("188")
                        }
                        if (n.return !== a.return) n = i, a = l;
                        else {
                            o = !1;
                            for (var u = i.child; u;) {
                                if (u === n) {
                                    o = !0, n = i, a = l;
                                    break
                                }
                                if (u === a) {
                                    o = !0, a = i, n = l;
                                    break
                                }
                                u = u.sibling
                            }
                            if (!o) {
                                for (u = l.child; u;) {
                                    if (u === n) {
                                        o = !0, n = l, a = i;
                                        break
                                    }
                                    if (u === a) {
                                        o = !0, a = l, n = i;
                                        break
                                    }
                                    u = u.sibling
                                }
                                o || r("189")
                            }
                        }
                        n.alternate !== a && r("190")
                    }
                    return 3 !== n.tag && r("188"), n.stateNode.current === n ? e : t
                }

                function Jd(e) {
                    if (!(e = Id(e))) return null;
                    for (var t = e;;) {
                        if (5 === t.tag || 6 === t.tag) return t;
                        if (t.child) t.child.return = t, t = t.child;
                        else {
                            if (t === e) break;
                            for (; !t.sibling;) {
                                if (!t.return || t.return === e) return null;
                                t = t.return
                            }
                            t.sibling.return = t.return, t = t.sibling
                        }
                    }
                    return null
                }

                function Nd(e) {
                    var t = e.keyCode;
                    return "charCode" in e ? 0 === (e = e.charCode) && 13 === t && (e = 13) : e = t, 10 === e && (e = 13), 32 <= e || 13 === e ? e : 0
                }

                function Yd(e, t) {
                    var n = e[0],
                        r = "on" + ((e = e[1])[0].toUpperCase() + e.slice(1));
                    t = {
                        phasedRegistrationNames: {
                            bubbled: r,
                            captured: r + "Capture"
                        },
                        dependencies: [n],
                        isInteractive: t
                    }, Wd[e] = t, Xd[n] = t
                }

                function be(e) {
                    var t = e.targetInst,
                        n = t;
                    do {
                        if (!n) {
                            e.ancestors.push(n);
                            break
                        }
                        var r;
                        for (r = n; r.return;) r = r.return;
                        if (!(r = 3 !== r.tag ? null : r.stateNode.containerInfo)) break;
                        e.ancestors.push(n), n = Na(r)
                    } while (n);
                    for (n = 0; n < e.ancestors.length; n++) {
                        t = e.ancestors[n];
                        var a = ec(e.nativeEvent);
                        r = e.topLevelType;
                        for (var i = e.nativeEvent, l = null, o = 0; o < ra.length; o++) {
                            var u = ra[o];
                            u && (u = u.extractEvents(r, t, i, a)) && (l = Aa(l, u))
                        }
                        Ia(l, !1)
                    }
                }

                function H(e, t) {
                    if (!t) return null;
                    var n = ($d(e) ? de : ee).bind(null, e);
                    t.addEventListener(e, n, !1)
                }

                function ge(e, t) {
                    if (!t) return null;
                    var n = ($d(e) ? de : ee).bind(null, e);
                    t.addEventListener(e, n, !0)
                }

                function de(e, t) {
                    Zb(ee, e, t)
                }

                function ee(e, t) {
                    if (ce) {
                        var n = ec(t);
                        if (null === (n = Na(n)) || "number" != typeof n.tag || 2 === Gd(n) || (n = null), ae.length) {
                            var r = ae.pop();
                            r.topLevelType = e, r.nativeEvent = t, r.targetInst = n, e = r
                        } else e = {
                            topLevelType: e,
                            nativeEvent: t,
                            targetInst: n,
                            ancestors: []
                        };
                        try {
                            bc(be, e)
                        } finally {
                            e.topLevelType = null, e.nativeEvent = null, e.targetInst = null, e.ancestors.length = 0, 10 > ae.length && ae.push(e)
                        }
                    }
                }

                function ke(e) {
                    return Object.prototype.hasOwnProperty.call(e, je) || (e[je] = ie++, he[e[je]] = {}), he[e[je]]
                }

                function le(e) {
                    if (void 0 === (e = e || ("undefined" != typeof document ? document : void 0))) return null;
                    try {
                        return e.activeElement || e.body
                    } catch (t) {
                        return e.body
                    }
                }

                function me(e) {
                    for (; e && e.firstChild;) e = e.firstChild;
                    return e
                }

                function ne(e, t) {
                    var n, r = me(e);
                    for (e = 0; r;) {
                        if (3 === r.nodeType) {
                            if (n = e + r.textContent.length, e <= t && n >= t) return {
                                node: r,
                                offset: t - e
                            };
                            e = n
                        }
                        e: {
                            for (; r;) {
                                if (r.nextSibling) {
                                    r = r.nextSibling;
                                    break e
                                }
                                r = r.parentNode
                            }
                            r = void 0
                        }
                        r = me(r)
                    }
                }

                function oe(e, t) {
                    return !(!e || !t) && (e === t || (!e || 3 !== e.nodeType) && (t && 3 === t.nodeType ? oe(e, t.parentNode) : "contains" in e ? e.contains(t) : !!e.compareDocumentPosition && !!(16 & e.compareDocumentPosition(t))))
                }

                function pe() {
                    for (var e = window, t = le(); t instanceof e.HTMLIFrameElement;) {
                        try {
                            e = t.contentDocument.defaultView
                        } catch (e) {
                            break
                        }
                        t = le(e.document)
                    }
                    return t
                }

                function qe(e) {
                    var t = e && e.nodeName && e.nodeName.toLowerCase();
                    return t && ("input" === t && ("text" === e.type || "search" === e.type || "tel" === e.type || "url" === e.type || "password" === e.type) || "textarea" === t || "true" === e.contentEditable)
                }

                function Je(e, t) {
                    var n = t.window === t ? t.document : 9 === t.nodeType ? t : t.ownerDocument;
                    return Ie || null == te || te !== le(n) ? null : (n = "selectionStart" in (n = te) && qe(n) ? {
                        start: n.selectionStart,
                        end: n.selectionEnd
                    } : {
                        anchorNode: (n = (n.ownerDocument && n.ownerDocument.defaultView || window).getSelection()).anchorNode,
                        anchorOffset: n.anchorOffset,
                        focusNode: n.focusNode,
                        focusOffset: n.focusOffset
                    }, He && Fd(He, n) ? null : (He = n, (e = y.getPooled(se.select, ue, e, t)).type = "select", e.target = te, Wa(e), e))
                }

                function Le(e) {
                    var t = "";
                    return aa.Children.forEach(e, function(e) {
                        null != e && (t += e)
                    }), t
                }

                function Me(e, t) {
                    return e = n({
                        children: void 0
                    }, t), (t = Le(t.children)) && (e.children = t), e
                }

                function Ne(e, t, n, r) {
                    if (e = e.options, t) {
                        t = {};
                        for (var a = 0; a < n.length; a++) t["$" + n[a]] = !0;
                        for (n = 0; n < e.length; n++) a = t.hasOwnProperty("$" + e[n].value), e[n].selected !== a && (e[n].selected = a), a && r && (e[n].defaultSelected = !0)
                    } else {
                        for (n = "" + Pc(n), t = null, a = 0; a < e.length; a++) {
                            if (e[a].value === n) return e[a].selected = !0, void(r && (e[a].defaultSelected = !0));
                            null !== t || e[a].disabled || (t = e[a])
                        }
                        null !== t && (t.selected = !0)
                    }
                }

                function Oe(e, t) {
                    return null != t.dangerouslySetInnerHTML && r("91"), n({}, t, {
                        value: void 0,
                        defaultValue: void 0,
                        children: "" + e._wrapperState.initialValue
                    })
                }

                function Pe(e, t) {
                    var n = t.value;
                    null == n && (n = t.defaultValue, null != (t = t.children) && (null != n && r("92"), Array.isArray(t) && (1 >= t.length || r("93"), t = t[0]), n = t), null == n && (n = "")), e._wrapperState = {
                        initialValue: Pc(n)
                    }
                }

                function Qe(e, t) {
                    var n = Pc(t.value),
                        r = Pc(t.defaultValue);
                    null != n && ((n = "" + n) !== e.value && (e.value = n), null == t.defaultValue && e.defaultValue !== n && (e.defaultValue = n)), null != r && (e.defaultValue = "" + r)
                }

                function Re(e) {
                    var t = e.textContent;
                    t === e._wrapperState.initialValue && (e.value = t)
                }

                function Te(e) {
                    switch (e) {
                        case "svg":
                            return "http://www.w3.org/2000/svg";
                        case "math":
                            return "http://www.w3.org/1998/Math/MathML";
                        default:
                            return "http://www.w3.org/1999/xhtml"
                    }
                }

                function Ue(e, t) {
                    return null == e || "http://www.w3.org/1999/xhtml" === e ? Te(t) : "http://www.w3.org/2000/svg" === e && "foreignObject" === t ? "http://www.w3.org/1999/xhtml" : e
                }

                function Xe(e, t) {
                    if (t) {
                        var n = e.firstChild;
                        if (n && n === e.lastChild && 3 === n.nodeType) return void(n.nodeValue = t)
                    }
                    e.textContent = t
                }

                function $e(e, t) {
                    for (var n in e = e.style, t)
                        if (t.hasOwnProperty(n)) {
                            var r = 0 === n.indexOf("--"),
                                a = n,
                                i = t[n];
                            a = null == i || "boolean" == typeof i || "" === i ? "" : r || "number" != typeof i || 0 === i || Ye.hasOwnProperty(a) && Ye[a] ? ("" + i).trim() : i + "px", "float" === n && (n = "cssFloat"), r ? e.setProperty(n, a) : e[n] = a
                        }
                }

                function bf(e, t) {
                    t && (af[e] && (null != t.children || null != t.dangerouslySetInnerHTML) && r("137", e, ""), null != t.dangerouslySetInnerHTML && (null != t.children && r("60"), "object" == _typeof2(t.dangerouslySetInnerHTML) && "__html" in t.dangerouslySetInnerHTML || r("61")), null != t.style && "object" != _typeof2(t.style) && r("62", ""))
                }

                function cf(e, t) {
                    if (-1 === e.indexOf("-")) return "string" == typeof t.is;
                    switch (e) {
                        case "annotation-xml":
                        case "color-profile":
                        case "font-face":
                        case "font-face-src":
                        case "font-face-uri":
                        case "font-face-format":
                        case "font-face-name":
                        case "missing-glyph":
                            return !1;
                        default:
                            return !0
                    }
                }

                function df(e, t) {
                    var n = ke(e = 9 === e.nodeType || 11 === e.nodeType ? e : e.ownerDocument);
                    t = va[t];
                    for (var r = 0; r < t.length; r++) {
                        var a = t[r];
                        if (!n.hasOwnProperty(a) || !n[a]) {
                            switch (a) {
                                case "scroll":
                                    ge("scroll", e);
                                    break;
                                case "focus":
                                case "blur":
                                    ge("focus", e), ge("blur", e), n.blur = !0, n.focus = !0;
                                    break;
                                case "cancel":
                                case "close":
                                    fc(a) && ge(a, e);
                                    break;
                                case "invalid":
                                case "submit":
                                case "reset":
                                    break;
                                default:
                                    -1 === lb.indexOf(a) && H(a, e)
                            }
                            n[a] = !0
                        }
                    }
                }

                function ef() {}

                function hf(e, t) {
                    switch (e) {
                        case "button":
                        case "input":
                        case "select":
                        case "textarea":
                            return !!t.autoFocus
                    }
                    return !1
                }

                function jf(e, t) {
                    return "textarea" === e || "option" === e || "noscript" === e || "string" == typeof t.children || "number" == typeof t.children || "object" == _typeof2(t.dangerouslySetInnerHTML) && null !== t.dangerouslySetInnerHTML && null != t.dangerouslySetInnerHTML.__html
                }

                function mf(e) {
                    for (e = e.nextSibling; e && 1 !== e.nodeType && 3 !== e.nodeType;) e = e.nextSibling;
                    return e
                }

                function nf(e) {
                    for (e = e.firstChild; e && 1 !== e.nodeType && 3 !== e.nodeType;) e = e.nextSibling;
                    return e
                }

                function I(e) {
                    0 > pf || (e.current = of [pf], of [pf] = null, pf--)
                }

                function J(e, t) {
                    of [++pf] = e.current, e.current = t
                }

                function sf(e, t) {
                    var n = e.type.contextTypes;
                    if (!n) return qf;
                    var r = e.stateNode;
                    if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext;
                    var a, i = {};
                    for (a in n) i[a] = t[a];
                    return r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = i), i
                }

                function M(e) {
                    return null != (e = e.childContextTypes)
                }

                function tf(e) {
                    I(L, e), I(K, e)
                }

                function uf(e) {
                    I(L, e), I(K, e)
                }

                function vf(e, t, n) {
                    K.current !== qf && r("168"), J(K, t, e), J(L, n, e)
                }

                function wf(e, t, a) {
                    var i = e.stateNode;
                    if (e = t.childContextTypes, "function" != typeof i.getChildContext) return a;
                    for (var l in i = i.getChildContext()) l in e || r("108", Ac(t) || "Unknown", l);
                    return n({}, a, i)
                }

                function xf(e) {
                    var t = e.stateNode;
                    return t = t && t.__reactInternalMemoizedMergedChildContext || qf, rf = K.current, J(K, t, e), J(L, L.current, e), !0
                }

                function yf(e, t, n) {
                    var a = e.stateNode;
                    a || r("169"), n ? (t = wf(e, t, rf), a.__reactInternalMemoizedMergedChildContext = t, I(L, e), I(K, e), J(K, t, e)) : I(L, e), J(L, n, e)
                }

                function Bf(e) {
                    return function(t) {
                        try {
                            return e(t)
                        } catch (e) {}
                    }
                }

                function Cf(e) {
                    if ("undefined" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) return !1;
                    var t = __REACT_DEVTOOLS_GLOBAL_HOOK__;
                    if (t.isDisabled || !t.supportsFiber) return !0;
                    try {
                        var n = t.inject(e);
                        zf = Bf(function(e) {
                            return t.onCommitFiberRoot(n, e)
                        }), Af = Bf(function(e) {
                            return t.onCommitFiberUnmount(n, e)
                        })
                    } catch (e) {}
                    return !0
                }

                function Df(e, t, n, r) {
                    this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.firstContextDependency = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.effectTag = 0, this.lastEffect = this.firstEffect = this.nextEffect = null, this.childExpirationTime = this.expirationTime = 0, this.alternate = null
                }

                function N(e, t, n, r) {
                    return new Df(e, t, n, r)
                }

                function Ef(e) {
                    return !(!(e = e.prototype) || !e.isReactComponent)
                }

                function Ff(e) {
                    if ("function" == typeof e) return Ef(e) ? 1 : 0;
                    if (null != e) {
                        if ((e = e.$$typeof) === uc) return 11;
                        if (e === wc) return 14
                    }
                    return 2
                }

                function Gf(e, t) {
                    var n = e.alternate;
                    return null === n ? ((n = N(e.tag, t, e.key, e.mode)).elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.effectTag = 0, n.nextEffect = null, n.firstEffect = null, n.lastEffect = null), n.childExpirationTime = e.childExpirationTime, n.expirationTime = e.expirationTime, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, n.firstContextDependency = e.firstContextDependency, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n
                }

                function Hf(e, t, n, a, i, l) {
                    var o = 2;
                    if (a = e, "function" == typeof e) Ef(e) && (o = 1);
                    else if ("string" == typeof e) o = 5;
                    else e: switch (e) {
                        case oc:
                            return If(n.children, i, l, t);
                        case tc:
                            return Jf(n, 3 | i, l, t);
                        case pc:
                            return Jf(n, 2 | i, l, t);
                        case qc:
                            return (e = N(12, n, t, 4 | i)).elementType = qc, e.type = qc, e.expirationTime = l, e;
                        case vc:
                            return (e = N(13, n, t, i)).elementType = vc, e.type = vc, e.expirationTime = l, e;
                        default:
                            if ("object" == _typeof2(e) && null !== e) switch (e.$$typeof) {
                                case rc:
                                    o = 10;
                                    break e;
                                case sc:
                                    o = 9;
                                    break e;
                                case uc:
                                    o = 11;
                                    break e;
                                case wc:
                                    o = 14;
                                    break e;
                                case xc:
                                    o = 16, a = null;
                                    break e
                            }
                            r("130", null == e ? e : _typeof2(e), "")
                    }
                    return (t = N(o, n, t, i)).elementType = e, t.type = a, t.expirationTime = l, t
                }

                function If(e, t, n, r) {
                    return (e = N(7, e, r, t)).expirationTime = n, e
                }

                function Jf(e, t, n, r) {
                    return e = N(8, e, r, t), t = 0 == (1 & t) ? pc : tc, e.elementType = t, e.type = t, e.expirationTime = n, e
                }

                function Kf(e, t, n) {
                    return (e = N(6, e, null, t)).expirationTime = n, e
                }

                function Lf(e, t, n) {
                    return (t = N(4, null !== e.children ? e.children : [], e.key, t)).expirationTime = n, t.stateNode = {
                        containerInfo: e.containerInfo,
                        pendingChildren: null,
                        implementation: e.implementation
                    }, t
                }

                function Mf(e, t) {
                    e.didError = !1;
                    var n = e.earliestPendingTime;
                    0 === n ? e.earliestPendingTime = e.latestPendingTime = t : n > t ? e.earliestPendingTime = t : e.latestPendingTime < t && (e.latestPendingTime = t), Nf(t, e)
                }

                function Of(e, t) {
                    e.didError = !1;
                    var n = e.latestPingedTime;
                    0 !== n && n <= t && (e.latestPingedTime = 0), n = e.earliestPendingTime;
                    var r = e.latestPendingTime;
                    n === t ? e.earliestPendingTime = r === t ? e.latestPendingTime = 0 : r : r === t && (e.latestPendingTime = n), n = e.earliestSuspendedTime, r = e.latestSuspendedTime, 0 === n ? e.earliestSuspendedTime = e.latestSuspendedTime = t : n > t ? e.earliestSuspendedTime = t : r < t && (e.latestSuspendedTime = t), Nf(t, e)
                }

                function Pf(e, t) {
                    var n = e.earliestPendingTime;
                    return e = e.earliestSuspendedTime, (0 === t || 0 !== n && n < t) && (t = n), (0 === t || 0 !== e && e < t) && (t = e), t
                }

                function Nf(e, t) {
                    var n = t.earliestSuspendedTime,
                        r = t.latestSuspendedTime,
                        a = t.earliestPendingTime,
                        i = t.latestPingedTime;
                    0 === (a = 0 !== a ? a : i) && (0 === e || r > e) && (a = r), 0 !== (e = a) && 0 !== n && n < e && (e = n), t.nextExpirationTimeToWorkOn = a, t.expirationTime = e
                }

                function Rf(e) {
                    return {
                        baseState: e,
                        firstUpdate: null,
                        lastUpdate: null,
                        firstCapturedUpdate: null,
                        lastCapturedUpdate: null,
                        firstEffect: null,
                        lastEffect: null,
                        firstCapturedEffect: null,
                        lastCapturedEffect: null
                    }
                }

                function Sf(e) {
                    return {
                        baseState: e.baseState,
                        firstUpdate: e.firstUpdate,
                        lastUpdate: e.lastUpdate,
                        firstCapturedUpdate: null,
                        lastCapturedUpdate: null,
                        firstEffect: null,
                        lastEffect: null,
                        firstCapturedEffect: null,
                        lastCapturedEffect: null
                    }
                }

                function Tf(e) {
                    return {
                        expirationTime: e,
                        tag: 0,
                        payload: null,
                        callback: null,
                        next: null,
                        nextEffect: null
                    }
                }

                function Uf(e, t) {
                    null === e.lastUpdate ? e.firstUpdate = e.lastUpdate = t : (e.lastUpdate.next = t, e.lastUpdate = t)
                }

                function Vf(e, t) {
                    var n = e.alternate;
                    if (null === n) {
                        var r = e.updateQueue,
                            a = null;
                        null === r && (r = e.updateQueue = Rf(e.memoizedState))
                    } else r = e.updateQueue, a = n.updateQueue, null === r ? null === a ? (r = e.updateQueue = Rf(e.memoizedState), a = n.updateQueue = Rf(n.memoizedState)) : r = e.updateQueue = Sf(a) : null === a && (a = n.updateQueue = Sf(r));
                    null === a || r === a ? Uf(r, t) : null === r.lastUpdate || null === a.lastUpdate ? (Uf(r, t), Uf(a, t)) : (Uf(r, t), a.lastUpdate = t)
                }

                function Wf(e, t) {
                    var n = e.updateQueue;
                    null === (n = null === n ? e.updateQueue = Rf(e.memoizedState) : Xf(e, n)).lastCapturedUpdate ? n.firstCapturedUpdate = n.lastCapturedUpdate = t : (n.lastCapturedUpdate.next = t, n.lastCapturedUpdate = t)
                }

                function Xf(e, t) {
                    var n = e.alternate;
                    return null !== n && t === n.updateQueue && (t = e.updateQueue = Sf(t)), t
                }

                function Yf(e, t, r, a, i, l) {
                    switch (r.tag) {
                        case 1:
                            return "function" == typeof(e = r.payload) ? e.call(l, a, i) : e;
                        case 3:
                            e.effectTag = -1025 & e.effectTag | 64;
                        case 0:
                            if (null == (i = "function" == typeof(e = r.payload) ? e.call(l, a, i) : e)) break;
                            return n({}, a, i);
                        case 2:
                            Qf = !0
                    }
                    return a
                }

                function Zf(e, t, n, r, a) {
                    Qf = !1;
                    for (var i = (t = Xf(e, t)).baseState, l = null, o = 0, u = t.firstUpdate, c = i; null !== u;) {
                        var f = u.expirationTime;
                        f > a ? (null === l && (l = u, i = c), (0 === o || o > f) && (o = f)) : (c = Yf(e, t, u, c, n, r), null !== u.callback && (e.effectTag |= 32, u.nextEffect = null, null === t.lastEffect ? t.firstEffect = t.lastEffect = u : (t.lastEffect.nextEffect = u, t.lastEffect = u))), u = u.next
                    }
                    for (f = null, u = t.firstCapturedUpdate; null !== u;) {
                        var s = u.expirationTime;
                        s > a ? (null === f && (f = u, null === l && (i = c)), (0 === o || o > s) && (o = s)) : (c = Yf(e, t, u, c, n, r), null !== u.callback && (e.effectTag |= 32, u.nextEffect = null, null === t.lastCapturedEffect ? t.firstCapturedEffect = t.lastCapturedEffect = u : (t.lastCapturedEffect.nextEffect = u, t.lastCapturedEffect = u))), u = u.next
                    }
                    null === l && (t.lastUpdate = null), null === f ? t.lastCapturedUpdate = null : e.effectTag |= 32, null === l && null === f && (i = c), t.baseState = i, t.firstUpdate = l, t.firstCapturedUpdate = f, e.expirationTime = o, e.memoizedState = c
                }

                function $f(e, t, n) {
                    null !== t.firstCapturedUpdate && (null !== t.lastUpdate && (t.lastUpdate.next = t.firstCapturedUpdate, t.lastUpdate = t.lastCapturedUpdate), t.firstCapturedUpdate = t.lastCapturedUpdate = null), ag(t.firstEffect, n), t.firstEffect = t.lastEffect = null, ag(t.firstCapturedEffect, n), t.firstCapturedEffect = t.lastCapturedEffect = null
                }

                function ag(e, t) {
                    for (; null !== e;) {
                        var n = e.callback;
                        if (null !== n) {
                            e.callback = null;
                            var a = t;
                            "function" != typeof n && r("191", n), n.call(a)
                        }
                        e = e.nextEffect
                    }
                }

                function bg(e, t) {
                    return {
                        value: e,
                        source: t,
                        stack: Bc(t)
                    }
                }

                function gg(e, t) {
                    var n = e.type._context;
                    J(cg, n._currentValue, e), n._currentValue = t
                }

                function hg(e) {
                    var t = cg.current;
                    I(cg, e), e.type._context._currentValue = t
                }

                function ig(e) {
                    dg = e, fg = eg = null, e.firstContextDependency = null
                }

                function jg(e, t) {
                    return fg !== e && !1 !== t && 0 !== t && ("number" == typeof t && 1073741823 !== t || (fg = e, t = 1073741823), t = {
                        context: e,
                        observedBits: t,
                        next: null
                    }, null === eg ? (null === dg && r("293"), dg.firstContextDependency = eg = t) : eg = eg.next = t), e._currentValue
                }

                function ng(e) {
                    return e === kg && r("174"), e
                }

                function og(e, t) {
                    J(mg, t, e), J(lg, e, e), J(O, kg, e);
                    var n = t.nodeType;
                    switch (n) {
                        case 9:
                        case 11:
                            t = (t = t.documentElement) ? t.namespaceURI : Ue(null, "");
                            break;
                        default:
                            t = Ue(t = (n = 8 === n ? t.parentNode : t).namespaceURI || null, n = n.tagName)
                    }
                    I(O, e), J(O, t, e)
                }

                function pg(e) {
                    I(O, e), I(lg, e), I(mg, e)
                }

                function qg(e) {
                    ng(mg.current);
                    var t = ng(O.current),
                        n = Ue(t, e.type);
                    t !== n && (J(lg, e, e), J(O, n, e))
                }

                function rg(e) {
                    lg.current === e && (I(O, e), I(lg, e))
                }

                function ug(e, t, r, a) {
                    r = null == (r = r(a, t = e.memoizedState)) ? t : n({}, t, r), e.memoizedState = r, null !== (a = e.updateQueue) && 0 === e.expirationTime && (a.baseState = r)
                }

                function zg(e, t, n, r, a, i, l) {
                    return "function" == typeof(e = e.stateNode).shouldComponentUpdate ? e.shouldComponentUpdate(r, i, l) : !(t.prototype && t.prototype.isPureReactComponent && Fd(n, r) && Fd(a, i))
                }

                function Ag(e, t, n) {
                    var r = !1,
                        a = qf,
                        i = t.contextType;
                    return "object" == _typeof2(i) && null !== i ? i = sg.currentDispatcher.readContext(i) : (a = M(t) ? rf : K.current, i = (r = null != (r = t.contextTypes)) ? sf(e, a) : qf), t = new t(n, i), e.memoizedState = null !== t.state && void 0 !== t.state ? t.state : null, t.updater = yg, e.stateNode = t, t._reactInternalFiber = e, r && ((e = e.stateNode).__reactInternalMemoizedUnmaskedChildContext = a, e.__reactInternalMemoizedMaskedChildContext = i), t
                }

                function Bg(e, t, n, r) {
                    e = t.state, "function" == typeof t.componentWillReceiveProps && t.componentWillReceiveProps(n, r), "function" == typeof t.UNSAFE_componentWillReceiveProps && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && yg.enqueueReplaceState(t, t.state, null)
                }

                function Cg(e, t, n, r) {
                    var a = e.stateNode;
                    a.props = n, a.state = e.memoizedState, a.refs = tg;
                    var i = t.contextType;
                    "object" == _typeof2(i) && null !== i ? a.context = sg.currentDispatcher.readContext(i) : (i = M(t) ? rf : K.current, a.context = sf(e, i)), null !== (i = e.updateQueue) && (Zf(e, i, n, a, r), a.state = e.memoizedState), "function" == typeof(i = t.getDerivedStateFromProps) && (ug(e, t, i, n), a.state = e.memoizedState), "function" == typeof t.getDerivedStateFromProps || "function" == typeof a.getSnapshotBeforeUpdate || "function" != typeof a.UNSAFE_componentWillMount && "function" != typeof a.componentWillMount || (t = a.state, "function" == typeof a.componentWillMount && a.componentWillMount(), "function" == typeof a.UNSAFE_componentWillMount && a.UNSAFE_componentWillMount(), t !== a.state && yg.enqueueReplaceState(a, a.state, null), null !== (i = e.updateQueue) && (Zf(e, i, n, a, r), a.state = e.memoizedState)), "function" == typeof a.componentDidMount && (e.effectTag |= 4)
                }

                function Eg(e, t, n) {
                    if (null !== (e = n.ref) && "function" != typeof e && "object" != _typeof2(e)) {
                        if (n._owner) {
                            n = n._owner;
                            var a = void 0;
                            n && (1 !== n.tag && r("289"), a = n.stateNode), a || r("147", e);
                            var i = "" + e;
                            return null !== t && null !== t.ref && "function" == typeof t.ref && t.ref._stringRef === i ? t.ref : ((t = function t(e) {
                                var t = a.refs;
                                t === tg && (t = a.refs = {}), null === e ? delete t[i] : t[i] = e
                            })._stringRef = i, t)
                        }
                        "string" != typeof e && r("284"), n._owner || r("290", e)
                    }
                    return e
                }

                function Fg(e, t) {
                    "textarea" !== e.type && r("31", "[object Object]" === Object.prototype.toString.call(t) ? "object with keys {" + Object.keys(t).join(", ") + "}" : t, "")
                }

                function Gg(e) {
                    function t(t, n) {
                        if (e) {
                            var r = t.lastEffect;
                            null !== r ? (r.nextEffect = n, t.lastEffect = n) : t.firstEffect = t.lastEffect = n, n.nextEffect = null, n.effectTag = 8
                        }
                    }

                    function n(n, r) {
                        if (!e) return null;
                        for (; null !== r;) t(n, r), r = r.sibling;
                        return null
                    }

                    function a(e, t) {
                        for (e = new Map; null !== t;) null !== t.key ? e.set(t.key, t) : e.set(t.index, t), t = t.sibling;
                        return e
                    }

                    function i(e, t, n) {
                        return (e = Gf(e, t, n)).index = 0, e.sibling = null, e
                    }

                    function l(t, n, r) {
                        return t.index = r, e ? null !== (r = t.alternate) ? (r = r.index) < n ? (t.effectTag = 2, n) : r : (t.effectTag = 2, n) : n
                    }

                    function o(t) {
                        return e && null === t.alternate && (t.effectTag = 2), t
                    }

                    function u(e, t, n, r) {
                        return null === t || 6 !== t.tag ? ((t = Kf(n, e.mode, r)).return = e, t) : ((t = i(t, n, r)).return = e, t)
                    }

                    function c(e, t, n, r) {
                        return null !== t && t.elementType === n.type ? ((r = i(t, n.props, r)).ref = Eg(e, t, n), r.return = e, r) : ((r = Hf(n.type, n.key, n.props, null, e.mode, r)).ref = Eg(e, t, n), r.return = e, r)
                    }

                    function f(e, t, n, r) {
                        return null === t || 4 !== t.tag || t.stateNode.containerInfo !== n.containerInfo || t.stateNode.implementation !== n.implementation ? ((t = Lf(n, e.mode, r)).return = e, t) : ((t = i(t, n.children || [], r)).return = e, t)
                    }

                    function s(e, t, n, r, a) {
                        return null === t || 7 !== t.tag ? ((t = If(n, e.mode, r, a)).return = e, t) : ((t = i(t, n, r)).return = e, t)
                    }

                    function d(e, t, n) {
                        if ("string" == typeof t || "number" == typeof t) return (t = Kf("" + t, e.mode, n)).return = e, t;
                        if ("object" == _typeof2(t) && null !== t) {
                            switch (t.$$typeof) {
                                case mc:
                                    return (n = Hf(t.type, t.key, t.props, null, e.mode, n)).ref = Eg(e, null, t), n.return = e, n;
                                case nc:
                                    return (t = Lf(t, e.mode, n)).return = e, t
                            }
                            if (Dg(t) || zc(t)) return (t = If(t, e.mode, n, null)).return = e, t;
                            Fg(e, t)
                        }
                        return null
                    }

                    function p(e, t, n, r) {
                        var a = null !== t ? t.key : null;
                        if ("string" == typeof n || "number" == typeof n) return null !== a ? null : u(e, t, "" + n, r);
                        if ("object" == _typeof2(n) && null !== n) {
                            switch (n.$$typeof) {
                                case mc:
                                    return n.key === a ? n.type === oc ? s(e, t, n.props.children, r, a) : c(e, t, n, r) : null;
                                case nc:
                                    return n.key === a ? f(e, t, n, r) : null
                            }
                            if (Dg(n) || zc(n)) return null !== a ? null : s(e, t, n, r, null);
                            Fg(e, n)
                        }
                        return null
                    }

                    function m(e, t, n, r, a) {
                        if ("string" == typeof r || "number" == typeof r) return u(t, e = e.get(n) || null, "" + r, a);
                        if ("object" == _typeof2(r) && null !== r) {
                            switch (r.$$typeof) {
                                case mc:
                                    return e = e.get(null === r.key ? n : r.key) || null, r.type === oc ? s(t, e, r.props.children, a, r.key) : c(t, e, r, a);
                                case nc:
                                    return f(t, e = e.get(null === r.key ? n : r.key) || null, r, a)
                            }
                            if (Dg(r) || zc(r)) return s(t, e = e.get(n) || null, r, a, null);
                            Fg(t, r)
                        }
                        return null
                    }

                    function h(r, i, o, u) {
                        for (var c = null, f = null, s = i, h = i = 0, g = null; null !== s && h < o.length; h++) {
                            s.index > h ? (g = s, s = null) : g = s.sibling;
                            var v = p(r, s, o[h], u);
                            if (null === v) {
                                null === s && (s = g);
                                break
                            }
                            e && s && null === v.alternate && t(r, s), i = l(v, i, h), null === f ? c = v : f.sibling = v, f = v, s = g
                        }
                        if (h === o.length) return n(r, s), c;
                        if (null === s) {
                            for (; h < o.length; h++)(s = d(r, o[h], u)) && (i = l(s, i, h), null === f ? c = s : f.sibling = s, f = s);
                            return c
                        }
                        for (s = a(r, s); h < o.length; h++)(g = m(s, r, h, o[h], u)) && (e && null !== g.alternate && s.delete(null === g.key ? h : g.key), i = l(g, i, h), null === f ? c = g : f.sibling = g, f = g);
                        return e && s.forEach(function(e) {
                            return t(r, e)
                        }), c
                    }

                    function g(i, o, u, c) {
                        var f = zc(u);
                        "function" != typeof f && r("150"), null == (u = f.call(u)) && r("151");
                        for (var s = f = null, h = o, g = o = 0, v = null, y = u.next(); null !== h && !y.done; g++, y = u.next()) {
                            h.index > g ? (v = h, h = null) : v = h.sibling;
                            var b = p(i, h, y.value, c);
                            if (null === b) {
                                h || (h = v);
                                break
                            }
                            e && h && null === b.alternate && t(i, h), o = l(b, o, g), null === s ? f = b : s.sibling = b, s = b, h = v
                        }
                        if (y.done) return n(i, h), f;
                        if (null === h) {
                            for (; !y.done; g++, y = u.next()) null !== (y = d(i, y.value, c)) && (o = l(y, o, g), null === s ? f = y : s.sibling = y, s = y);
                            return f
                        }
                        for (h = a(i, h); !y.done; g++, y = u.next()) null !== (y = m(h, i, g, y.value, c)) && (e && null !== y.alternate && h.delete(null === y.key ? g : y.key), o = l(y, o, g), null === s ? f = y : s.sibling = y, s = y);
                        return e && h.forEach(function(e) {
                            return t(i, e)
                        }), f
                    }
                    return function(e, a, l, u) {
                        var c = "object" == _typeof2(l) && null !== l && l.type === oc && null === l.key;
                        c && (l = l.props.children);
                        var f = "object" == _typeof2(l) && null !== l;
                        if (f) switch (l.$$typeof) {
                            case mc:
                                e: {
                                    for (f = l.key, c = a; null !== c;) {
                                        if (c.key === f) {
                                            if (7 === c.tag ? l.type === oc : c.elementType === l.type) {
                                                n(e, c.sibling), (a = i(c, l.type === oc ? l.props.children : l.props, u)).ref = Eg(e, c, l), a.return = e, e = a;
                                                break e
                                            }
                                            n(e, c);
                                            break
                                        }
                                        t(e, c), c = c.sibling
                                    }
                                    l.type === oc ? ((a = If(l.props.children, e.mode, u, l.key)).return = e, e = a) : ((u = Hf(l.type, l.key, l.props, null, e.mode, u)).ref = Eg(e, a, l), u.return = e, e = u)
                                }
                                return o(e);
                            case nc:
                                e: {
                                    for (c = l.key; null !== a;) {
                                        if (a.key === c) {
                                            if (4 === a.tag && a.stateNode.containerInfo === l.containerInfo && a.stateNode.implementation === l.implementation) {
                                                n(e, a.sibling), (a = i(a, l.children || [], u)).return = e, e = a;
                                                break e
                                            }
                                            n(e, a);
                                            break
                                        }
                                        t(e, a), a = a.sibling
                                    }(a = Lf(l, e.mode, u)).return = e,
                                    e = a
                                }
                                return o(e)
                        }
                        if ("string" == typeof l || "number" == typeof l) return l = "" + l, null !== a && 6 === a.tag ? (n(e, a.sibling), (a = i(a, l, u)).return = e, e = a) : (n(e, a), (a = Kf(l, e.mode, u)).return = e, e = a), o(e);
                        if (Dg(l)) return h(e, a, l, u);
                        if (zc(l)) return g(e, a, l, u);
                        if (f && Fg(e, l), void 0 === l && !c) switch (e.tag) {
                            case 1:
                            case 0:
                                r("152", (u = e.type).displayName || u.name || "Component")
                        }
                        return n(e, a)
                    }
                }

                function Mg(e, t) {
                    var n = N(5, null, null, 0);
                    n.elementType = "DELETED", n.type = "DELETED", n.stateNode = t, n.return = e, n.effectTag = 8, null !== e.lastEffect ? (e.lastEffect.nextEffect = n, e.lastEffect = n) : e.firstEffect = e.lastEffect = n
                }

                function Ng(e, t) {
                    switch (e.tag) {
                        case 5:
                            var n = e.type;
                            return null !== (t = 1 !== t.nodeType || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t) && (e.stateNode = t, !0);
                        case 6:
                            return null !== (t = "" === e.pendingProps || 3 !== t.nodeType ? null : t) && (e.stateNode = t, !0);
                        default:
                            return !1
                    }
                }

                function Og(e) {
                    if (Lg) {
                        var t = Kg;
                        if (t) {
                            var n = t;
                            if (!Ng(e, t)) {
                                if (!(t = mf(n)) || !Ng(e, t)) return e.effectTag |= 2, Lg = !1, void(Jg = e);
                                Mg(Jg, n)
                            }
                            Jg = e, Kg = nf(t)
                        } else e.effectTag |= 2, Lg = !1, Jg = e
                    }
                }

                function Pg(e) {
                    for (e = e.return; null !== e && 5 !== e.tag && 3 !== e.tag;) e = e.return;
                    Jg = e
                }

                function Qg(e) {
                    if (e !== Jg) return !1;
                    if (!Lg) return Pg(e), Lg = !0, !1;
                    var t = e.type;
                    if (5 !== e.tag || "head" !== t && "body" !== t && !jf(t, e.memoizedProps))
                        for (t = Kg; t;) Mg(e, t), t = mf(t);
                    return Pg(e), Kg = Jg ? mf(e.stateNode) : null, !0
                }

                function Rg() {
                    Kg = Jg = null, Lg = !1
                }

                function Sg(e) {
                    var t = e._result;
                    switch (e._status) {
                        case 1:
                            return t;
                        case 2:
                        case 0:
                            throw t;
                        default:
                            throw e._status = 0, (t = (t = e._ctor)()).then(function(t) {
                                0 === e._status && (t = t.default, e._status = 1, e._result = t)
                            }, function(t) {
                                0 === e._status && (e._status = 2, e._result = t)
                            }), e._result = t, t
                    }
                }

                function P(e, t, n, r) {
                    t.child = null === e ? Ig(t, null, n, r) : Hg(t, e.child, n, r)
                }

                function Ug(e, t, n, r, a) {
                    n = n.render;
                    var i = t.ref;
                    return L.current || t.memoizedProps !== r || i !== (null !== e ? e.ref : null) ? (P(e, t, r = n(r, i), a), t.child) : Vg(e, t, a)
                }

                function Wg(e, t, n, r, a, i) {
                    if (null === e) {
                        var l = n.type;
                        return "function" != typeof l || Ef(l) || void 0 !== l.defaultProps || null !== n.compare ? ((e = Hf(n.type, null, r, null, t.mode, i)).ref = t.ref, e.return = t, t.child = e) : (t.tag = 15, t.type = l, Xg(e, t, l, r, a, i))
                    }
                    return l = e.child, (0 === a || a > i) && (a = l.memoizedProps, (n = null !== (n = n.compare) ? n : Fd)(a, r) && e.ref === t.ref) ? Vg(e, t, i) : ((e = Gf(l, r, i)).ref = t.ref, e.return = t, t.child = e)
                }

                function Xg(e, t, n, r, a, i) {
                    return null !== e && (0 === a || a > i) && Fd(e.memoizedProps, r) && e.ref === t.ref ? Vg(e, t, i) : Yg(e, t, n, r, i)
                }

                function Zg(e, t) {
                    var n = t.ref;
                    (null === e && null !== n || null !== e && e.ref !== n) && (t.effectTag |= 128)
                }

                function Yg(e, t, n, r, a) {
                    var i = M(n) ? rf : K.current;
                    return i = sf(t, i), ig(t, a), n = n(r, i), t.effectTag |= 1, P(e, t, n, a), t.child
                }

                function $g(e, t, n, r, a) {
                    if (M(n)) {
                        var i = !0;
                        xf(t)
                    } else i = !1;
                    if (ig(t, a), null === t.stateNode) null !== e && (e.alternate = null, t.alternate = null, t.effectTag |= 2), Ag(t, n, r, a), Cg(t, n, r, a), r = !0;
                    else if (null === e) {
                        var l = t.stateNode,
                            o = t.memoizedProps;
                        l.props = o;
                        var u = l.context,
                            c = n.contextType;
                        c = "object" == _typeof2(c) && null !== c ? sg.currentDispatcher.readContext(c) : sf(t, c = M(n) ? rf : K.current);
                        var f = n.getDerivedStateFromProps,
                            s = "function" == typeof f || "function" == typeof l.getSnapshotBeforeUpdate;
                        s || "function" != typeof l.UNSAFE_componentWillReceiveProps && "function" != typeof l.componentWillReceiveProps || (o !== r || u !== c) && Bg(t, l, r, c), Qf = !1;
                        var d = t.memoizedState;
                        u = l.state = d;
                        var p = t.updateQueue;
                        null !== p && (Zf(t, p, r, l, a), u = t.memoizedState), o !== r || d !== u || L.current || Qf ? ("function" == typeof f && (ug(t, n, f, r), u = t.memoizedState), (o = Qf || zg(t, n, o, r, d, u, c)) ? (s || "function" != typeof l.UNSAFE_componentWillMount && "function" != typeof l.componentWillMount || ("function" == typeof l.componentWillMount && l.componentWillMount(),
                            "function" == typeof l.UNSAFE_componentWillMount && l.UNSAFE_componentWillMount()), "function" == typeof l.componentDidMount && (t.effectTag |= 4)) : ("function" == typeof l.componentDidMount && (t.effectTag |= 4), t.memoizedProps = r, t.memoizedState = u), l.props = r, l.state = u, l.context = c, r = o) : ("function" == typeof l.componentDidMount && (t.effectTag |= 4), r = !1)
                    } else l = t.stateNode, o = t.memoizedProps, l.props = o, u = l.context, c = "object" == _typeof2(c = n.contextType) && null !== c ? sg.currentDispatcher.readContext(c) : sf(t, c = M(n) ? rf : K.current), (s = "function" == typeof(f = n.getDerivedStateFromProps) || "function" == typeof l.getSnapshotBeforeUpdate) || "function" != typeof l.UNSAFE_componentWillReceiveProps && "function" != typeof l.componentWillReceiveProps || (o !== r || u !== c) && Bg(t, l, r, c), Qf = !1, u = t.memoizedState, d = l.state = u, null !== (p = t.updateQueue) && (Zf(t, p, r, l, a), d = t.memoizedState), o !== r || u !== d || L.current || Qf ? ("function" == typeof f && (ug(t, n, f, r), d = t.memoizedState), (f = Qf || zg(t, n, o, r, u, d, c)) ? (s || "function" != typeof l.UNSAFE_componentWillUpdate && "function" != typeof l.componentWillUpdate || ("function" == typeof l.componentWillUpdate && l.componentWillUpdate(r, d, c), "function" == typeof l.UNSAFE_componentWillUpdate && l.UNSAFE_componentWillUpdate(r, d, c)), "function" == typeof l.componentDidUpdate && (t.effectTag |= 4), "function" == typeof l.getSnapshotBeforeUpdate && (t.effectTag |= 256)) : ("function" != typeof l.componentDidUpdate || o === e.memoizedProps && u === e.memoizedState || (t.effectTag |= 4), "function" != typeof l.getSnapshotBeforeUpdate || o === e.memoizedProps && u === e.memoizedState || (t.effectTag |= 256), t.memoizedProps = r, t.memoizedState = d), l.props = r, l.state = d, l.context = c, r = f) : ("function" != typeof l.componentDidUpdate || o === e.memoizedProps && u === e.memoizedState || (t.effectTag |= 4), "function" != typeof l.getSnapshotBeforeUpdate || o === e.memoizedProps && u === e.memoizedState || (t.effectTag |= 256), r = !1);
                    return ah(e, t, n, r, i, a)
                }

                function ah(e, t, n, r, a, i) {
                    Zg(e, t);
                    var l = 0 != (64 & t.effectTag);
                    if (!r && !l) return a && yf(t, n, !1), Vg(e, t, i);
                    r = t.stateNode, Tg.current = t;
                    var o = l && "function" != typeof n.getDerivedStateFromError ? null : r.render();
                    return t.effectTag |= 1, null !== e && l ? (t.child = Hg(t, e.child, null, i), t.child = Hg(t, null, o, i)) : P(e, t, o, i), t.memoizedState = r.state, a && yf(t, n, !0), t.child
                }

                function bh(e) {
                    var t = e.stateNode;
                    t.pendingContext ? vf(e, t.pendingContext, t.pendingContext !== t.context) : t.context && vf(e, t.context, !1), og(e, t.containerInfo)
                }

                function ch(e, t) {
                    if (e && e.defaultProps)
                        for (var r in t = n({}, t), e = e.defaultProps) void 0 === t[r] && (t[r] = e[r]);
                    return t
                }

                function dh(e, t, n) {
                    var r = t.mode,
                        a = t.pendingProps,
                        i = t.memoizedState;
                    null !== i && (i.alreadyCaptured ? null !== e && i === e.memoizedState ? i = {
                        alreadyCaptured: !0,
                        didTimeout: !0,
                        timedOutAt: i.timedOutAt
                    } : (i.alreadyCaptured = !0, i.didTimeout = !0) : i = null);
                    var l = null !== i && i.didTimeout;
                    if (null === e) l ? (l = a.fallback, a = If(null, r, 0, null), r = If(l, r, n, null), a.sibling = r, (n = a).return = r.return = t) : n = r = Ig(t, null, a.children, n);
                    else {
                        var o = e.memoizedState;
                        null !== o && o.didTimeout ? (e = (r = e.child).sibling, l ? (n = a.fallback, (r = Gf(r, r.pendingProps, 0)).effectTag |= 2, (a = r.sibling = Gf(e, n, e.expirationTime)).effectTag |= 2, n = r, r.childExpirationTime = 0, r = a, n.return = r.return = t) : (l = e.child, r = Hg(t, r.child, a.children, n), Hg(t, l, null, n), n = r)) : (e = e.child, l ? (l = a.fallback, (a = If(null, r, 0, null)).effectTag |= 2, a.child = e, e.return = a, (r = a.sibling = If(l, r, n, null)).effectTag |= 2, n = a, a.childExpirationTime = 0, n.return = r.return = t) : r = n = Hg(t, e, a.children, n))
                    }
                    return t.memoizedState = i, t.child = n, r
                }

                function Vg(e, t, n) {
                    null !== e && (t.firstContextDependency = e.firstContextDependency);
                    var a = t.childExpirationTime;
                    if (0 === a || a > n) return null;
                    if (null !== e && t.child !== e.child && r("153"), null !== t.child) {
                        for (n = Gf(e = t.child, e.pendingProps, e.expirationTime), t.child = n, n.return = t; null !== e.sibling;) e = e.sibling, (n = n.sibling = Gf(e, e.pendingProps, e.expirationTime)).return = t;
                        n.sibling = null
                    }
                    return t.child
                }

                function eh(e, t, n) {
                    var a = t.expirationTime;
                    if (null !== e && e.memoizedProps === t.pendingProps && !L.current && (0 === a || a > n)) {
                        switch (t.tag) {
                            case 3:
                                bh(t), Rg();
                                break;
                            case 5:
                                qg(t);
                                break;
                            case 1:
                                M(t.type) && xf(t);
                                break;
                            case 4:
                                og(t, t.stateNode.containerInfo);
                                break;
                            case 10:
                                gg(t, t.memoizedProps.value);
                                break;
                            case 13:
                                if (null !== (a = t.memoizedState) && a.didTimeout) return 0 !== (a = t.child.childExpirationTime) && a <= n ? dh(e, t, n) : null !== (t = Vg(e, t, n)) ? t.sibling : null
                        }
                        return Vg(e, t, n)
                    }
                    switch (t.expirationTime = 0, t.tag) {
                        case 2:
                            a = t.elementType, null !== e && (e.alternate = null, t.alternate = null, t.effectTag |= 2), e = t.pendingProps;
                            var i = sf(t, K.current);
                            if (ig(t, n), i = a(e, i), t.effectTag |= 1, "object" == _typeof2(i) && null !== i && "function" == typeof i.render && void 0 === i.$$typeof) {
                                if (t.tag = 1, M(a)) {
                                    var l = !0;
                                    xf(t)
                                } else l = !1;
                                t.memoizedState = null !== i.state && void 0 !== i.state ? i.state : null;
                                var o = a.getDerivedStateFromProps;
                                "function" == typeof o && ug(t, a, o, e), i.updater = yg, t.stateNode = i, i._reactInternalFiber = t, Cg(t, a, e, n), t = ah(null, t, a, !0, l, n)
                            } else t.tag = 0, P(null, t, i, n), t = t.child;
                            return t;
                        case 16:
                            switch (i = t.elementType, null !== e && (e.alternate = null, t.alternate = null, t.effectTag |= 2), l = t.pendingProps, e = Sg(i), t.type = e, i = t.tag = Ff(e), l = ch(e, l), o = void 0, i) {
                                case 0:
                                    o = Yg(null, t, e, l, n);
                                    break;
                                case 1:
                                    o = $g(null, t, e, l, n);
                                    break;
                                case 11:
                                    o = Ug(null, t, e, l, n);
                                    break;
                                case 14:
                                    o = Wg(null, t, e, ch(e.type, l), a, n);
                                    break;
                                default:
                                    r("283", e)
                            }
                            return o;
                        case 0:
                            return a = t.type, i = t.pendingProps, Yg(e, t, a, i = t.elementType === a ? i : ch(a, i), n);
                        case 1:
                            return a = t.type, i = t.pendingProps, $g(e, t, a, i = t.elementType === a ? i : ch(a, i), n);
                        case 3:
                            return bh(t), null === (a = t.updateQueue) && r("282"), i = null !== (i = t.memoizedState) ? i.element : null, Zf(t, a, t.pendingProps, null, n), (a = t.memoizedState.element) === i ? (Rg(), t = Vg(e, t, n)) : (i = t.stateNode, (i = (null === e || null === e.child) && i.hydrate) && (Kg = nf(t.stateNode.containerInfo), Jg = t, i = Lg = !0), i ? (t.effectTag |= 2, t.child = Ig(t, null, a, n)) : (P(e, t, a, n), Rg()), t = t.child), t;
                        case 5:
                            return qg(t), null === e && Og(t), a = t.type, i = t.pendingProps, l = null !== e ? e.memoizedProps : null, o = i.children, jf(a, i) ? o = null : null !== l && jf(a, l) && (t.effectTag |= 16), Zg(e, t), 1073741823 !== n && 1 & t.mode && i.hidden ? (t.expirationTime = 1073741823, t = null) : (P(e, t, o, n), t = t.child), t;
                        case 6:
                            return null === e && Og(t), null;
                        case 13:
                            return dh(e, t, n);
                        case 4:
                            return og(t, t.stateNode.containerInfo), a = t.pendingProps, null === e ? t.child = Hg(t, null, a, n) : P(e, t, a, n), t.child;
                        case 11:
                            return a = t.type, i = t.pendingProps, Ug(e, t, a, i = t.elementType === a ? i : ch(a, i), n);
                        case 7:
                            return P(e, t, t.pendingProps, n), t.child;
                        case 8:
                        case 12:
                            return P(e, t, t.pendingProps.children, n), t.child;
                        case 10:
                            e: {
                                if (a = t.type._context, i = t.pendingProps, o = t.memoizedProps, gg(t, l = i.value), null !== o) {
                                    var u = o.value;
                                    if (0 === (l = u === l && (0 !== u || 1 / u == 1 / l) || u != u && l != l ? 0 : 0 | ("function" == typeof a._calculateChangedBits ? a._calculateChangedBits(u, l) : 1073741823))) {
                                        if (o.children === i.children && !L.current) {
                                            t = Vg(e, t, n);
                                            break e
                                        }
                                    } else
                                        for (null !== (o = t.child) && (o.return = t); null !== o;) {
                                            if (null !== (u = o.firstContextDependency)) {
                                                do {
                                                    if (u.context === a && 0 != (u.observedBits & l)) {
                                                        if (1 === o.tag) {
                                                            var c = Tf(n);
                                                            c.tag = 2, Vf(o, c)
                                                        }(0 === o.expirationTime || o.expirationTime > n) && (o.expirationTime = n), null !== (c = o.alternate) && (0 === c.expirationTime || c.expirationTime > n) && (c.expirationTime = n);
                                                        for (var f = o.return; null !== f;) {
                                                            if (c = f.alternate, 0 === f.childExpirationTime || f.childExpirationTime > n) f.childExpirationTime = n, null !== c && (0 === c.childExpirationTime || c.childExpirationTime > n) && (c.childExpirationTime = n);
                                                            else {
                                                                if (null === c || !(0 === c.childExpirationTime || c.childExpirationTime > n)) break;
                                                                c.childExpirationTime = n
                                                            }
                                                            f = f.return
                                                        }
                                                    }
                                                    c = o.child, u = u.next
                                                } while (null !== u)
                                            } else c = 10 === o.tag && o.type === t.type ? null : o.child;
                                            if (null !== c) c.return = o;
                                            else
                                                for (c = o; null !== c;) {
                                                    if (c === t) {
                                                        c = null;
                                                        break
                                                    }
                                                    if (null !== (o = c.sibling)) {
                                                        o.return = c.return, c = o;
                                                        break
                                                    }
                                                    c = c.return
                                                }
                                            o = c
                                        }
                                }
                                P(e, t, i.children, n),
                                t = t.child
                            }
                            return t;
                        case 9:
                            return i = t.type, a = (l = t.pendingProps).children, ig(t, n), a = a(i = jg(i, l.unstable_observedBits)), t.effectTag |= 1, P(e, t, a, n), t.child;
                        case 14:
                            return Wg(e, t, i = t.type, l = ch(i.type, t.pendingProps), a, n);
                        case 15:
                            return Xg(e, t, t.type, t.pendingProps, a, n);
                        case 17:
                            return a = t.type, i = t.pendingProps, i = t.elementType === a ? i : ch(a, i), null !== e && (e.alternate = null, t.alternate = null, t.effectTag |= 2), t.tag = 1, M(a) ? (e = !0, xf(t)) : e = !1, ig(t, n), Ag(t, a, i, n), Cg(t, a, i, n), ah(null, t, a, !0, e, n);
                        default:
                            r("156")
                    }
                }

                function zh(e) {
                    e.effectTag |= 4
                }

                function Eh(e, t) {
                    var n = t.source,
                        r = t.stack;
                    null === r && null !== n && (r = Bc(n)), null !== n && Ac(n.type), t = t.value, null !== e && 1 === e.tag && Ac(e.type);
                    try {
                        console.error(t)
                    } catch (e) {
                        setTimeout(function() {
                            throw e
                        })
                    }
                }

                function Fh(e) {
                    var t = e.ref;
                    if (null !== t)
                        if ("function" == typeof t) try {
                            t(null)
                        } catch (t) {
                            Gh(e, t)
                        } else t.current = null
                }

                function Hh(e) {
                    switch ("function" == typeof Af && Af(e), e.tag) {
                        case 1:
                            Fh(e);
                            var t = e.stateNode;
                            if ("function" == typeof t.componentWillUnmount) try {
                                t.props = e.memoizedProps, t.state = e.memoizedState, t.componentWillUnmount()
                            } catch (t) {
                                Gh(e, t)
                            }
                            break;
                        case 5:
                            Fh(e);
                            break;
                        case 4:
                            Ih(e)
                    }
                }

                function Jh(e) {
                    return 5 === e.tag || 3 === e.tag || 4 === e.tag
                }

                function Kh(e) {
                    e: {
                        for (var t = e.return; null !== t;) {
                            if (Jh(t)) {
                                var n = t;
                                break e
                            }
                            t = t.return
                        }
                        r("160"),
                        n = void 0
                    }
                    var a = t = void 0;
                    switch (n.tag) {
                        case 5:
                            t = n.stateNode, a = !1;
                            break;
                        case 3:
                        case 4:
                            t = n.stateNode.containerInfo, a = !0;
                            break;
                        default:
                            r("161")
                    }
                    16 & n.effectTag && (Xe(t, ""), n.effectTag &= -17);e: t: for (n = e;;) {
                        for (; null === n.sibling;) {
                            if (null === n.return || Jh(n.return)) {
                                n = null;
                                break e
                            }
                            n = n.return
                        }
                        for (n.sibling.return = n.return, n = n.sibling; 5 !== n.tag && 6 !== n.tag;) {
                            if (2 & n.effectTag) continue t;
                            if (null === n.child || 4 === n.tag) continue t;
                            n.child.return = n, n = n.child
                        }
                        if (!(2 & n.effectTag)) {
                            n = n.stateNode;
                            break e
                        }
                    }
                    for (var i = e;;) {
                        if (5 === i.tag || 6 === i.tag)
                            if (n)
                                if (a) {
                                    var l = t,
                                        o = i.stateNode,
                                        u = n;
                                    8 === l.nodeType ? l.parentNode.insertBefore(o, u) : l.insertBefore(o, u)
                                } else t.insertBefore(i.stateNode, n);
                        else a ? (o = t, u = i.stateNode, 8 === o.nodeType ? (l = o.parentNode).insertBefore(u, o) : (l = o).appendChild(u), null != (o = o._reactRootContainer) || null !== l.onclick || (l.onclick = ef)) : t.appendChild(i.stateNode);
                        else if (4 !== i.tag && null !== i.child) {
                            i.child.return = i, i = i.child;
                            continue
                        }
                        if (i === e) break;
                        for (; null === i.sibling;) {
                            if (null === i.return || i.return === e) return;
                            i = i.return
                        }
                        i.sibling.return = i.return, i = i.sibling
                    }
                }

                function Ih(e) {
                    for (var t = e, n = !1, a = void 0, i = void 0;;) {
                        if (!n) {
                            n = t.return;
                            e: for (;;) {
                                switch (null === n && r("160"), n.tag) {
                                    case 5:
                                        a = n.stateNode, i = !1;
                                        break e;
                                    case 3:
                                    case 4:
                                        a = n.stateNode.containerInfo, i = !0;
                                        break e
                                }
                                n = n.return
                            }
                            n = !0
                        }
                        if (5 === t.tag || 6 === t.tag) {
                            e: for (var l = t, o = l;;)
                                if (Hh(o), null !== o.child && 4 !== o.tag) o.child.return = o, o = o.child;
                                else {
                                    if (o === l) break;
                                    for (; null === o.sibling;) {
                                        if (null === o.return || o.return === l) break e;
                                        o = o.return
                                    }
                                    o.sibling.return = o.return, o = o.sibling
                                }i ? (l = a, o = t.stateNode, 8 === l.nodeType ? l.parentNode.removeChild(o) : l.removeChild(o)) : a.removeChild(t.stateNode)
                        }
                        else if (4 === t.tag ? (a = t.stateNode.containerInfo, i = !0) : Hh(t), null !== t.child) {
                            t.child.return = t, t = t.child;
                            continue
                        }
                        if (t === e) break;
                        for (; null === t.sibling;) {
                            if (null === t.return || t.return === e) return;
                            4 === (t = t.return).tag && (n = !1)
                        }
                        t.sibling.return = t.return, t = t.sibling
                    }
                }

                function Lh(e, t) {
                    switch (t.tag) {
                        case 1:
                            break;
                        case 5:
                            var n = t.stateNode;
                            if (null != n) {
                                var a = t.memoizedProps,
                                    i = null !== e ? e.memoizedProps : a;
                                e = t.type;
                                var l = t.updateQueue;
                                if (t.updateQueue = null, null !== l) {
                                    for (n[Ma] = a, "input" === e && "radio" === a.type && null != a.name && Sc(n, a), cf(e, i), t = cf(e, a), i = 0; i < l.length; i += 2) {
                                        var o = l[i],
                                            u = l[i + 1];
                                        "style" === o ? $e(n, u) : "dangerouslySetInnerHTML" === o ? We(n, u) : "children" === o ? Xe(n, u) : Oc(n, o, u, t)
                                    }
                                    switch (e) {
                                        case "input":
                                            Tc(n, a);
                                            break;
                                        case "textarea":
                                            Qe(n, a);
                                            break;
                                        case "select":
                                            e = n._wrapperState.wasMultiple, n._wrapperState.wasMultiple = !!a.multiple, null != (l = a.value) ? Ne(n, !!a.multiple, l, !1) : e !== !!a.multiple && (null != a.defaultValue ? Ne(n, !!a.multiple, a.defaultValue, !0) : Ne(n, !!a.multiple, a.multiple ? [] : "", !1))
                                    }
                                }
                            }
                            break;
                        case 6:
                            null === t.stateNode && r("162"), t.stateNode.nodeValue = t.memoizedProps;
                            break;
                        case 3:
                        case 12:
                        case 13:
                        case 17:
                            break;
                        default:
                            r("163")
                    }
                }

                function Mh(e, t, n) {
                    (n = Tf(n)).tag = 3, n.payload = {
                        element: null
                    };
                    var r = t.value;
                    return n.callback = function() {
                        Nh(r), Eh(e, t)
                    }, n
                }

                function Oh(e, t, n) {
                    (n = Tf(n)).tag = 3;
                    var r = e.type.getDerivedStateFromError;
                    if ("function" == typeof r) {
                        var a = t.value;
                        n.payload = function() {
                            return r(a)
                        }
                    }
                    var i = e.stateNode;
                    return null !== i && "function" == typeof i.componentDidCatch && (n.callback = function() {
                        "function" != typeof r && (null === Ph ? Ph = new Set([this]) : Ph.add(this));
                        var n = t.value,
                            a = t.stack;
                        Eh(e, t), this.componentDidCatch(n, {
                            componentStack: null !== a ? a : ""
                        })
                    }), n
                }

                function Qh(e) {
                    switch (e.tag) {
                        case 1:
                            M(e.type) && tf(e);
                            var t = e.effectTag;
                            return 1024 & t ? (e.effectTag = -1025 & t | 64, e) : null;
                        case 3:
                            return pg(e), uf(e), 0 != (64 & (t = e.effectTag)) && r("285"), e.effectTag = -1025 & t | 64, e;
                        case 5:
                            return rg(e), null;
                        case 13:
                            if (1024 & (t = e.effectTag)) {
                                e.effectTag = -1025 & t | 64, t = null !== (t = e.alternate) ? t.memoizedState : null;
                                var n = e.memoizedState;
                                return null === n ? n = {
                                    alreadyCaptured: !0,
                                    didTimeout: !1,
                                    timedOutAt: 0
                                } : t === n ? n = {
                                    alreadyCaptured: !0,
                                    didTimeout: n.didTimeout,
                                    timedOutAt: n.timedOutAt
                                } : n.alreadyCaptured = !0, e.memoizedState = n, e
                            }
                            return null;
                        case 4:
                            return pg(e), null;
                        case 10:
                            return hg(e), null;
                        default:
                            return null
                    }
                }

                function Zh() {
                    if (null !== Q)
                        for (var e = Q.return; null !== e;) {
                            var t = e;
                            switch (t.tag) {
                                case 1:
                                    var n = t.type.childContextTypes;
                                    null != n && tf(t);
                                    break;
                                case 3:
                                    pg(t), uf(t);
                                    break;
                                case 5:
                                    rg(t);
                                    break;
                                case 4:
                                    pg(t);
                                    break;
                                case 10:
                                    hg(t)
                            }
                            e = e.return
                        }
                    R = null, S = 0, Wh = -1, Xh = !1, Q = null
                }

                function $h(e) {
                    for (;;) {
                        var t = e.alternate,
                            a = e.return,
                            i = e.sibling;
                        if (0 == (512 & e.effectTag)) {
                            var l = t,
                                o = (t = e).pendingProps;
                            switch (t.tag) {
                                case 2:
                                case 16:
                                    break;
                                case 15:
                                case 0:
                                    break;
                                case 1:
                                    M(t.type) && tf(t);
                                    break;
                                case 3:
                                    pg(t), uf(t), (o = t.stateNode).pendingContext && (o.context = o.pendingContext, o.pendingContext = null), null !== l && null !== l.child || (Qg(t), t.effectTag &= -3), Bh(t);
                                    break;
                                case 5:
                                    rg(t);
                                    var u = ng(mg.current),
                                        c = t.type;
                                    if (null !== l && null != t.stateNode) Ch(l, t, c, o, u), l.ref !== t.ref && (t.effectTag |= 128);
                                    else if (o) {
                                        var f = ng(O.current);
                                        if (Qg(t)) {
                                            l = (o = t).stateNode;
                                            var s = o.type,
                                                d = o.memoizedProps,
                                                p = u;
                                            switch (l[La] = o, l[Ma] = d, c = void 0, u = s) {
                                                case "iframe":
                                                case "object":
                                                    H("load", l);
                                                    break;
                                                case "video":
                                                case "audio":
                                                    for (s = 0; s < lb.length; s++) H(lb[s], l);
                                                    break;
                                                case "source":
                                                    H("error", l);
                                                    break;
                                                case "img":
                                                case "image":
                                                case "link":
                                                    H("error", l), H("load", l);
                                                    break;
                                                case "form":
                                                    H("reset", l), H("submit", l);
                                                    break;
                                                case "details":
                                                    H("toggle", l);
                                                    break;
                                                case "input":
                                                    Rc(l, d), H("invalid", l), df(p, "onChange");
                                                    break;
                                                case "select":
                                                    l._wrapperState = {
                                                        wasMultiple: !!d.multiple
                                                    }, H("invalid", l), df(p, "onChange");
                                                    break;
                                                case "textarea":
                                                    Pe(l, d), H("invalid", l), df(p, "onChange")
                                            }
                                            for (c in bf(u, d), s = null, d) d.hasOwnProperty(c) && (f = d[c], "children" === c ? "string" == typeof f ? l.textContent !== f && (s = ["children", f]) : "number" == typeof f && l.textContent !== "" + f && (s = ["children", "" + f]) : ua.hasOwnProperty(c) && null != f && df(p, c));
                                            switch (u) {
                                                case "input":
                                                    ic(l), bd(l, d, !0);
                                                    break;
                                                case "textarea":
                                                    ic(l), Re(l, d);
                                                    break;
                                                case "select":
                                                case "option":
                                                    break;
                                                default:
                                                    "function" == typeof d.onClick && (l.onclick = ef)
                                            }
                                            c = s, o.updateQueue = c, (o = null !== c) && zh(t)
                                        } else {
                                            d = t, l = c, p = o, s = 9 === u.nodeType ? u : u.ownerDocument, f === Se.html && (f = Te(l)), f === Se.html ? "script" === l ? ((l = s.createElement("div")).innerHTML = "<script></script>", s = l.removeChild(l.firstChild)) : "string" == typeof p.is ? s = s.createElement(l, {
                                                is: p.is
                                            }) : (s = s.createElement(l), "select" === l && p.multiple && (s.multiple = !0)) : s = s.createElementNS(f, l), (l = s)[La] = d, l[Ma] = o, Ah(l, t, !1, !1), p = l;
                                            var m = u,
                                                h = cf(s = c, d = o);
                                            switch (s) {
                                                case "iframe":
                                                case "object":
                                                    H("load", p), u = d;
                                                    break;
                                                case "video":
                                                case "audio":
                                                    for (u = 0; u < lb.length; u++) H(lb[u], p);
                                                    u = d;
                                                    break;
                                                case "source":
                                                    H("error", p), u = d;
                                                    break;
                                                case "img":
                                                case "image":
                                                case "link":
                                                    H("error", p), H("load", p), u = d;
                                                    break;
                                                case "form":
                                                    H("reset", p), H("submit", p), u = d;
                                                    break;
                                                case "details":
                                                    H("toggle", p), u = d;
                                                    break;
                                                case "input":
                                                    Rc(p, d), u = Qc(p, d), H("invalid", p), df(m, "onChange");
                                                    break;
                                                case "option":
                                                    u = Me(p, d);
                                                    break;
                                                case "select":
                                                    p._wrapperState = {
                                                        wasMultiple: !!d.multiple
                                                    }, u = n({}, d, {
                                                        value: void 0
                                                    }), H("invalid", p), df(m, "onChange");
                                                    break;
                                                case "textarea":
                                                    Pe(p, d), u = Oe(p, d), H("invalid", p), df(m, "onChange");
                                                    break;
                                                default:
                                                    u = d
                                            }
                                            bf(s, u), f = void 0;
                                            var g = s,
                                                v = p,
                                                y = u;
                                            for (f in y)
                                                if (y.hasOwnProperty(f)) {
                                                    var b = y[f];
                                                    "style" === f ? $e(v, b) : "dangerouslySetInnerHTML" === f ? null != (b = b ? b.__html : void 0) && We(v, b) : "children" === f ? "string" == typeof b ? ("textarea" !== g || "" !== b) && Xe(v, b) : "number" == typeof b && Xe(v, "" + b) : "suppressContentEditableWarning" !== f && "suppressHydrationWarning" !== f && "autoFocus" !== f && (ua.hasOwnProperty(f) ? null != b && df(m, f) : null != b && Oc(v, f, b, h))
                                                } switch (s) {
                                                case "input":
                                                    ic(p), bd(p, d, !1);
                                                    break;
                                                case "textarea":
                                                    ic(p), Re(p, d);
                                                    break;
                                                case "option":
                                                    null != d.value && p.setAttribute("value", "" + Pc(d.value));
                                                    break;
                                                case "select":
                                                    (u = p).multiple = !!d.multiple, null != (p = d.value) ? Ne(u, !!d.multiple, p, !1) : null != d.defaultValue && Ne(u, !!d.multiple, d.defaultValue, !0);
                                                    break;
                                                default:
                                                    "function" == typeof u.onClick && (p.onclick = ef)
                                            }(o = hf(c, o)) && zh(t), t.stateNode = l
                                        }
                                        null !== t.ref && (t.effectTag |= 128)
                                    } else null === t.stateNode && r("166");
                                    break;
                                case 6:
                                    l && null != t.stateNode ? Dh(l, t, l.memoizedProps, o) : ("string" != typeof o && null === t.stateNode && r("166"), l = ng(mg.current), ng(O.current), Qg(t) ? (c = (o = t).stateNode, l = o.memoizedProps, c[La] = o, (o = c.nodeValue !== l) && zh(t)) : (c = t, (o = (9 === l.nodeType ? l : l.ownerDocument).createTextNode(o))[La] = t, c.stateNode = o));
                                    break;
                                case 11:
                                    break;
                                case 13:
                                    o = t.memoizedState, c = null !== l ? l.memoizedState : null, (null !== o && o.didTimeout) !== (null !== c && c.didTimeout) && (t.effectTag |= 4);
                                    break;
                                case 7:
                                case 8:
                                case 12:
                                    break;
                                case 4:
                                    pg(t), Bh(t);
                                    break;
                                case 10:
                                    hg(t);
                                    break;
                                case 9:
                                case 14:
                                    break;
                                case 17:
                                    M(t.type) && tf(t);
                                    break;
                                default:
                                    r("156")
                            }
                            if (Q = null, t = e, 1073741823 === S || 1073741823 !== t.childExpirationTime) {
                                for (o = 0, c = t.child; null !== c;) l = c.expirationTime, u = c.childExpirationTime, (0 === o || 0 !== l && l < o) && (o = l), (0 === o || 0 !== u && u < o) && (o = u), c = c.sibling;
                                t.childExpirationTime = o
                            }
                            null !== a && 0 == (512 & a.effectTag) && (null === a.firstEffect && (a.firstEffect = e.firstEffect), null !== e.lastEffect && (null !== a.lastEffect && (a.lastEffect.nextEffect = e.firstEffect), a.lastEffect = e.lastEffect), 1 < e.effectTag && (null !== a.lastEffect ? a.lastEffect.nextEffect = e : a.firstEffect = e, a.lastEffect = e))
                        } else {
                            if (null !== (e = Qh(e, S))) return e.effectTag &= 511, e;
                            null !== a && (a.firstEffect = a.lastEffect = null, a.effectTag |= 512)
                        }
                        if (null !== i) return i;
                        if (null === a) break;
                        e = a
                    }
                    return null
                }

                function ai(e) {
                    var t = eh(e.alternate, e, S);
                    return e.memoizedProps = e.pendingProps, null === t && (t = $h(e)), Sh.current = null, t
                }

                function bi(e, t, n) {
                    Vh && r("243"), Vh = !0, Sh.currentDispatcher = Rh;
                    var a = e.nextExpirationTimeToWorkOn;
                    a === S && e === R && null !== Q || (Zh(), S = a, Q = Gf((R = e).current, null, S), e.pendingCommitExpirationTime = 0);
                    for (var i = !1;;) {
                        try {
                            if (t)
                                for (; null !== Q && !ci();) Q = ai(Q);
                            else
                                for (; null !== Q;) Q = ai(Q)
                        } catch (t) {
                            if (null === Q) i = !0, Nh(t);
                            else {
                                null === Q && r("271");
                                var l = Q,
                                    o = l.return;
                                if (null !== o) {
                                    e: {
                                        var u = e,
                                            c = o,
                                            f = l,
                                            s = t;
                                        if (o = S, f.effectTag |= 512, f.firstEffect = f.lastEffect = null, null !== s && "object" == _typeof2(s) && "function" == typeof s.then) {
                                            var d = s;
                                            s = c;
                                            var p = -1,
                                                m = -1;
                                            do {
                                                if (13 === s.tag) {
                                                    var h = s.alternate;
                                                    if (null !== h && null !== (h = h.memoizedState) && h.didTimeout) {
                                                        m = 10 * (h.timedOutAt - 2);
                                                        break
                                                    }
                                                    "number" == typeof(h = s.pendingProps.maxDuration) && (0 >= h ? p = 0 : (-1 === p || h < p) && (p = h))
                                                }
                                                s = s.return
                                            } while (null !== s);
                                            s = c;
                                            do {
                                                if ((h = 13 === s.tag) && (h = void 0 !== s.memoizedProps.fallback && (null === (h = s.memoizedState) || !h.didTimeout)), h) {
                                                    if (c = di.bind(null, u, s, f, 0 == (1 & s.mode) ? 1 : o), d.then(c, c), 0 == (1 & s.mode)) {
                                                        s.effectTag |= 32, P(f.alternate, f, null, o), f.effectTag &= -513, 1 === f.tag && (f.effectTag &= -421, null === f.alternate && (f.tag = 17));
                                                        break e
                                                    } - 1 === p ? u = 1073741823 : (-1 === m && (m = 10 * (Pf(u, o) - 2) - 5e3), u = m + p), 0 <= u && Wh < u && (Wh = u), s.effectTag |= 1024, s.expirationTime = o;
                                                    break e
                                                }
                                                s = s.return
                                            } while (null !== s);
                                            s = Error("An update was suspended, but no placeholder UI was provided.")
                                        }
                                        Xh = !0,
                                        s = bg(s, f),
                                        u = c;do {
                                            switch (u.tag) {
                                                case 3:
                                                    f = s, u.effectTag |= 1024, u.expirationTime = o, Wf(u, o = Mh(u, f, o));
                                                    break e;
                                                case 1:
                                                    if (f = s, c = u.type, d = u.stateNode, 0 == (64 & u.effectTag) && ("function" == typeof c.getDerivedStateFromError || null !== d && "function" == typeof d.componentDidCatch && (null === Ph || !Ph.has(d)))) {
                                                        u.effectTag |= 1024, u.expirationTime = o, Wf(u, o = Oh(u, f, o));
                                                        break e
                                                    }
                                            }
                                            u = u.return
                                        } while (null !== u)
                                    }
                                    Q = $h(l);
                                    continue
                                }
                                i = !0, Nh(t)
                            }
                        }
                        break
                    }
                    if (Vh = !1, fg = eg = dg = Sh.currentDispatcher = null, i) R = null, e.finishedWork = null;
                    else if (null !== Q) e.finishedWork = null;
                    else {
                        if (null === (t = e.current.alternate) && r("281"), R = null, Xh) {
                            if (i = e.latestPendingTime, l = e.latestSuspendedTime, o = e.latestPingedTime, 0 !== i && i > a || 0 !== l && l > a || 0 !== o && o > a) return Of(e, a), void ei(e, t, a, e.expirationTime, -1);
                            if (!e.didError && !n) return e.didError = !0, a = e.nextExpirationTimeToWorkOn = a, n = e.expirationTime = 1, void ei(e, t, a, n, -1)
                        }
                        n || -1 === Wh ? (e.pendingCommitExpirationTime = a, e.finishedWork = t) : (Of(e, a), (n = 10 * (Pf(e, a) - 2)) < Wh && (Wh = n), n = 10 * (vg() - 2), n = Wh - n, ei(e, t, a, e.expirationTime, 0 > n ? 0 : n))
                    }
                }

                function Gh(e, t) {
                    var n;
                    e: {
                        for (Vh && !Yh && r("263"), n = e.return; null !== n;) {
                            switch (n.tag) {
                                case 1:
                                    var a = n.stateNode;
                                    if ("function" == typeof n.type.getDerivedStateFromError || "function" == typeof a.componentDidCatch && (null === Ph || !Ph.has(a))) {
                                        Vf(n, e = Oh(n, e = bg(t, e), 1)), xg(n, 1), n = void 0;
                                        break e
                                    }
                                    break;
                                case 3:
                                    Vf(n, e = Mh(n, e = bg(t, e), 1)), xg(n, 1), n = void 0;
                                    break e
                            }
                            n = n.return
                        }
                        3 === e.tag && (Vf(e, n = Mh(e, n = bg(t, e), 1)), xg(e, 1)),
                        n = void 0
                    }
                    return n
                }

                function wg(e, t) {
                    return 0 !== Uh ? e = Uh : Vh ? e = Yh ? 1 : S : 1 & t.mode ? (e = fi ? 2 + 10 * (1 + ((e - 2 + 15) / 10 | 0)) : 2 + 25 * (1 + ((e - 2 + 500) / 25 | 0)), null !== R && e === S && (e += 1)) : e = 1, fi && e > gi && (gi = e), e
                }

                function di(e, t, n, r) {
                    var a = e.earliestSuspendedTime,
                        i = e.latestSuspendedTime;
                    if (0 !== a && r >= a && r <= i) {
                        i = a = r, e.didError = !1;
                        var l = e.latestPingedTime;
                        (0 === l || l < i) && (e.latestPingedTime = i), Nf(i, e)
                    } else Mf(e, a = wg(a = vg(), t));
                    0 != (1 & t.mode) && e === R && S === r && (R = null), hi(t, a), 0 == (1 & t.mode) && (hi(n, a), 1 === n.tag && null !== n.stateNode && ((t = Tf(a)).tag = 2, Vf(n, t))), 0 !== (n = e.expirationTime) && ii(e, n)
                }

                function hi(e, t) {
                    (0 === e.expirationTime || e.expirationTime > t) && (e.expirationTime = t);
                    var n = e.alternate;
                    null !== n && (0 === n.expirationTime || n.expirationTime > t) && (n.expirationTime = t);
                    var r = e.return,
                        a = null;
                    if (null === r && 3 === e.tag) a = e.stateNode;
                    else
                        for (; null !== r;) {
                            if (n = r.alternate, (0 === r.childExpirationTime || r.childExpirationTime > t) && (r.childExpirationTime = t), null !== n && (0 === n.childExpirationTime || n.childExpirationTime > t) && (n.childExpirationTime = t), null === r.return && 3 === r.tag) {
                                a = r.stateNode;
                                break
                            }
                            r = r.return
                        }
                    return null === a ? null : a
                }

                function xg(e, t) {
                    null !== (e = hi(e, t)) && (!Vh && 0 !== S && t < S && Zh(), Mf(e, t), Vh && !Yh && R === e || ii(e, e.expirationTime), ji > ki && (ji = 0, r("185")))
                }

                function li(e, t, n, r, a) {
                    var i = Uh;
                    Uh = 1;
                    try {
                        return e(t, n, r, a)
                    } finally {
                        Uh = i
                    }
                }

                function zi() {
                    vi = 2 + ((da.unstable_now() - ui) / 10 | 0)
                }

                function Ai(e, t) {
                    if (0 !== mi) {
                        if (t > mi) return;
                        null !== ni && da.unstable_cancelCallback(ni)
                    }
                    mi = t, e = da.unstable_now() - ui, ni = da.unstable_scheduleCallback(Bi, {
                        timeout: 10 * (t - 2) - e
                    })
                }

                function ei(e, t, n, r, a) {
                    e.expirationTime = r, 0 !== a || ci() ? 0 < a && (e.timeoutHandle = kf(Ci.bind(null, e, t, n), a)) : (e.pendingCommitExpirationTime = n, e.finishedWork = t)
                }

                function Ci(e, t, n) {
                    e.pendingCommitExpirationTime = n, e.finishedWork = t, zi(), wi = vi, Di(e, n)
                }

                function vg() {
                    return W ? wi : (Ei(), 0 !== Y && 1073741823 !== Y || (zi(), wi = vi), wi)
                }

                function ii(e, t) {
                    if (null === e.nextScheduledRoot) e.expirationTime = t, null === V ? (U = V = e, e.nextScheduledRoot = e) : (V = V.nextScheduledRoot = e).nextScheduledRoot = U;
                    else {
                        var n = e.expirationTime;
                        (0 === n || t < n) && (e.expirationTime = t)
                    }
                    W || (Z ? si && (X = e, Y = 1, Fi(e, 1, !0)) : 1 === t ? Gi(1, null) : Ai(e, t))
                }

                function Ei() {
                    var e = 0,
                        t = null;
                    if (null !== V)
                        for (var n = V, a = U; null !== a;) {
                            var i = a.expirationTime;
                            if (0 === i) {
                                if ((null === n || null === V) && r("244"), a === a.nextScheduledRoot) {
                                    U = V = a.nextScheduledRoot = null;
                                    break
                                }
                                if (a === U) U = i = a.nextScheduledRoot, V.nextScheduledRoot = i, a.nextScheduledRoot = null;
                                else {
                                    if (a === V) {
                                        (V = n).nextScheduledRoot = U, a.nextScheduledRoot = null;
                                        break
                                    }
                                    n.nextScheduledRoot = a.nextScheduledRoot, a.nextScheduledRoot = null
                                }
                                a = n.nextScheduledRoot
                            } else {
                                if ((0 === e || i < e) && (e = i, t = a), a === V) break;
                                if (1 === e) break;
                                n = a, a = a.nextScheduledRoot
                            }
                        }
                    X = t, Y = e
                }

                function Bi(e) {
                    if (e.didTimeout && null !== U) {
                        zi();
                        var t = U;
                        do {
                            var n = t.expirationTime;
                            0 !== n && vi >= n && (t.nextExpirationTimeToWorkOn = vi), t = t.nextScheduledRoot
                        } while (t !== U)
                    }
                    Gi(0, e)
                }

                function Gi(e, t) {
                    if (ri = t, Ei(), null !== ri)
                        for (zi(), wi = vi; null !== X && 0 !== Y && (0 === e || e >= Y) && (!oi || vi >= Y);) Fi(X, Y, vi >= Y), Ei(), zi(), wi = vi;
                    else
                        for (; null !== X && 0 !== Y && (0 === e || e >= Y);) Fi(X, Y, !0), Ei();
                    if (null !== ri && (mi = 0, ni = null), 0 !== Y && Ai(X, Y), ri = null, oi = !1, ji = 0, xi = null, null !== ti)
                        for (e = ti, ti = null, t = 0; t < e.length; t++) {
                            var n = e[t];
                            try {
                                n._onComplete()
                            } catch (e) {
                                pi || (pi = !0, qi = e)
                            }
                        }
                    if (pi) throw e = qi, qi = null, pi = !1, e
                }

                function Di(e, t) {
                    W && r("253"), X = e, Y = t, Fi(e, t, !0), Gi(1, null)
                }

                function Fi(e, t, n) {
                    if (W && r("245"), W = !0, null === ri || n) {
                        var a = e.finishedWork;
                        null !== a ? Hi(e, a, t) : (e.finishedWork = null, -1 !== (a = e.timeoutHandle) && (e.timeoutHandle = -1, lf(a)), bi(e, !1, n), null !== (a = e.finishedWork) && Hi(e, a, t))
                    } else null !== (a = e.finishedWork) ? Hi(e, a, t) : (e.finishedWork = null, -1 !== (a = e.timeoutHandle) && (e.timeoutHandle = -1, lf(a)), bi(e, !0, n), null !== (a = e.finishedWork) && (ci() ? e.finishedWork = a : Hi(e, a, t)));
                    W = !1
                }

                function Hi(e, t, n) {
                    var a = e.firstBatch;
                    if (null !== a && a._expirationTime <= n && (null === ti ? ti = [a] : ti.push(a), a._defer)) return e.finishedWork = t, void(e.expirationTime = 0);
                    e.finishedWork = null, e === xi ? ji++ : (xi = e, ji = 0), Yh = Vh = !0, e.current === t && r("177");
                    var i = e.pendingCommitExpirationTime;
                    0 === i && r("261"), e.pendingCommitExpirationTime = 0;
                    var l = t.expirationTime,
                        o = t.childExpirationTime,
                        u = 0 === l || 0 !== o && o < l ? o : l;
                    if (e.didError = !1, 0 === u) e.earliestPendingTime = 0, e.latestPendingTime = 0, e.earliestSuspendedTime = 0, e.latestSuspendedTime = 0, e.latestPingedTime = 0;
                    else {
                        var c = e.latestPendingTime;
                        0 !== c && (c < u ? e.earliestPendingTime = e.latestPendingTime = 0 : e.earliestPendingTime < u && (e.earliestPendingTime = e.latestPendingTime));
                        var f = e.earliestSuspendedTime;
                        0 === f ? Mf(e, u) : u > e.latestSuspendedTime ? (e.earliestSuspendedTime = 0, e.latestSuspendedTime = 0, e.latestPingedTime = 0, Mf(e, u)) : u < f && Mf(e, u)
                    }
                    if (Nf(0, e), Sh.current = null, 1 < t.effectTag)
                        if (null !== t.lastEffect) {
                            t.lastEffect.nextEffect = t;
                            var s = t.firstEffect
                        } else s = t;
                    else s = t.firstEffect;
                    ff = ce;
                    var d = pe();
                    if (qe(d)) {
                        if ("selectionStart" in d) var p = {
                            start: d.selectionStart,
                            end: d.selectionEnd
                        };
                        else e: {
                            var m = d.ownerDocument,
                                h = m && m.defaultView || window,
                                g = h.getSelection && h.getSelection();
                            if (g && 0 !== g.rangeCount) {
                                var v = g.anchorNode,
                                    y = g.anchorOffset,
                                    b = g.focusNode,
                                    k = g.focusOffset;
                                try {
                                    v.nodeType, b.nodeType
                                } catch (e) {
                                    p = null;
                                    break e
                                }
                                var x = 0,
                                    w = -1,
                                    C = -1,
                                    E = 0,
                                    S = 0,
                                    P = d,
                                    _ = null;
                                t: for (;;) {
                                    for (var N; P !== v || 0 !== y && 3 !== P.nodeType || (w = x + y), P !== b || 0 !== k && 3 !== P.nodeType || (C = x + k), 3 === P.nodeType && (x += P.nodeValue.length), null !== (N = P.firstChild);) _ = P, P = N;
                                    for (;;) {
                                        if (P === d) break t;
                                        if (_ === v && ++E === y && (w = x), _ === b && ++S === k && (C = x), null !== (N = P.nextSibling)) break;
                                        _ = (P = _).parentNode
                                    }
                                    P = N
                                }
                                p = -1 === w || -1 === C ? null : {
                                    start: w,
                                    end: C
                                }
                            } else p = null
                        }
                        var I = p || {
                            start: 0,
                            end: 0
                        }
                    } else I = null;
                    for (gf = {
                            focusedElem: d,
                            selectionRange: I
                        }, ce = !1, T = s; null !== T;) {
                        var M = !1,
                            D = void 0;
                        try {
                            for (; null !== T;) {
                                if (256 & T.effectTag) {
                                    var U = T.alternate;
                                    e: {
                                        var O = T;
                                        switch (O.tag) {
                                            case 1:
                                                if (256 & O.effectTag && null !== U) {
                                                    var z = U.memoizedProps,
                                                        F = U.memoizedState,
                                                        R = O.stateNode;
                                                    R.props = O.memoizedProps, R.state = O.memoizedState;
                                                    var L = R.getSnapshotBeforeUpdate(z, F);
                                                    R.__reactInternalSnapshotBeforeUpdate = L
                                                }
                                                break e;
                                            case 3:
                                            case 5:
                                            case 6:
                                            case 4:
                                            case 17:
                                                break e;
                                            default:
                                                r("163")
                                        }
                                    }
                                }
                                T = T.nextEffect
                            }
                        } catch (e) {
                            M = !0, D = e
                        }
                        M && (null === T && r("178"), Gh(T, D), null !== T && (T = T.nextEffect))
                    }
                    for (T = s; null !== T;) {
                        var A = !1,
                            W = void 0;
                        try {
                            for (; null !== T;) {
                                var V = T.effectTag;
                                if (16 & V && Xe(T.stateNode, ""), 128 & V) {
                                    var H = T.alternate;
                                    if (null !== H) {
                                        var j = H.ref;
                                        null !== j && ("function" == typeof j ? j(null) : j.current = null)
                                    }
                                }
                                switch (14 & V) {
                                    case 2:
                                        Kh(T), T.effectTag &= -3;
                                        break;
                                    case 6:
                                        Kh(T), T.effectTag &= -3, Lh(T.alternate, T);
                                        break;
                                    case 4:
                                        Lh(T.alternate, T);
                                        break;
                                    case 8:
                                        var B = T;
                                        Ih(B);
                                        var Q = B;
                                        Q.return = null, Q.child = null, Q.alternate && (Q.alternate.child = null, Q.alternate.return = null)
                                }
                                T = T.nextEffect
                            }
                        } catch (e) {
                            A = !0, W = e
                        }
                        A && (null === T && r("178"), Gh(T, W), null !== T && (T = T.nextEffect))
                    }
                    var K = gf,
                        Y = pe(),
                        G = K.focusedElem,
                        X = K.selectionRange;
                    if (Y !== G && G && G.ownerDocument && oe(G.ownerDocument.documentElement, G)) {
                        if (null !== X && qe(G)) {
                            var q = X.start,
                                Z = X.end;
                            if (void 0 === Z && (Z = q), "selectionStart" in G) G.selectionStart = q, G.selectionEnd = Math.min(Z, G.value.length);
                            else {
                                var $ = G.ownerDocument || document,
                                    J = ($ && $.defaultView || window).getSelection(),
                                    ee = G.textContent.length,
                                    te = Math.min(X.start, ee),
                                    re = void 0 === X.end ? te : Math.min(X.end, ee);
                                if (!J.extend && te > re) {
                                    var ae = re;
                                    re = te, te = ae
                                }
                                var ie = ne(G, te),
                                    le = ne(G, re);
                                if (ie && le && (1 !== J.rangeCount || J.anchorNode !== ie.node || J.anchorOffset !== ie.offset || J.focusNode !== le.node || J.focusOffset !== le.offset)) {
                                    var ue = $.createRange();
                                    ue.setStart(ie.node, ie.offset), J.removeAllRanges(), te > re ? (J.addRange(ue), J.extend(le.node, le.offset)) : (ue.setEnd(le.node, le.offset), J.addRange(ue))
                                }
                            }
                        }
                        for (var fe = [], se = G; se = se.parentNode;) 1 === se.nodeType && fe.push({
                            element: se,
                            left: se.scrollLeft,
                            top: se.scrollTop
                        });
                        "function" == typeof G.focus && G.focus();
                        for (var de = 0; de < fe.length; de++) {
                            var me = fe[de];
                            me.element.scrollLeft = me.left, me.element.scrollTop = me.top
                        }
                    }
                    for (gf = null, ce = !!ff, ff = null, e.current = t, T = s; null !== T;) {
                        var he = !1,
                            ge = void 0;
                        try {
                            for (var ve = i; null !== T;) {
                                var ye = T.effectTag;
                                if (36 & ye) {
                                    var be = void 0,
                                        Te = T.alternate,
                                        ke = T,
                                        xe = ve;
                                    switch (ke.tag) {
                                        case 1:
                                            var we = ke.stateNode;
                                            if (4 & ke.effectTag)
                                                if (null === Te) we.props = ke.memoizedProps, we.state = ke.memoizedState, we.componentDidMount();
                                                else {
                                                    var Ce = Te.memoizedProps,
                                                        Ee = Te.memoizedState;
                                                    we.props = ke.memoizedProps, we.state = ke.memoizedState, we.componentDidUpdate(Ce, Ee, we.__reactInternalSnapshotBeforeUpdate)
                                                } var Se = ke.updateQueue;
                                            null !== Se && (we.props = ke.memoizedProps, we.state = ke.memoizedState, $f(ke, Se, we, xe));
                                            break;
                                        case 3:
                                            var Pe = ke.updateQueue;
                                            if (null !== Pe) {
                                                var _e = null;
                                                if (null !== ke.child) switch (ke.child.tag) {
                                                    case 5:
                                                        _e = ke.child.stateNode;
                                                        break;
                                                    case 1:
                                                        _e = ke.child.stateNode
                                                }
                                                $f(ke, Pe, _e, xe)
                                            }
                                            break;
                                        case 5:
                                            var Ne = ke.stateNode;
                                            null === Te && 4 & ke.effectTag && hf(ke.type, ke.memoizedProps) && Ne.focus();
                                            break;
                                        case 6:
                                        case 4:
                                        case 12:
                                            break;
                                        case 13:
                                            if (32 & ke.effectTag) {
                                                ke.memoizedState = {
                                                    alreadyCaptured: !0,
                                                    didTimeout: !1,
                                                    timedOutAt: 0
                                                }, xg(ke, 1);
                                                break
                                            }
                                            var Ie = null !== Te ? Te.memoizedState : null,
                                                Me = ke.memoizedState,
                                                De = null !== Ie && Ie.didTimeout,
                                                Ue = ke;
                                            if (null === Me ? be = !1 : (be = Me.didTimeout) && (Ue = ke.child, Me.alreadyCaptured = !1, 0 === Me.timedOutAt && (Me.timedOutAt = vg())), be !== De && null !== Ue) e: for (var Oe = Ue, ze = be, Fe = Oe;;) {
                                                if (5 === Fe.tag) {
                                                    var Re = Fe.stateNode;
                                                    if (ze) Re.style.display = "none";
                                                    else {
                                                        var Le = Fe.stateNode,
                                                            Ae = Fe.memoizedProps.style,
                                                            We = null != Ae && Ae.hasOwnProperty("display") ? Ae.display : null;
                                                        Le.style.display = We
                                                    }
                                                } else if (6 === Fe.tag) Fe.stateNode.nodeValue = ze ? "" : Fe.memoizedProps;
                                                else if (null !== Fe.child) {
                                                    Fe.child.return = Fe, Fe = Fe.child;
                                                    continue
                                                }
                                                if (Fe === Oe) break e;
                                                for (; null === Fe.sibling;) {
                                                    if (null === Fe.return || Fe.return === Oe) break e;
                                                    Fe = Fe.return
                                                }
                                                Fe.sibling.return = Fe.return, Fe = Fe.sibling
                                            }
                                            break;
                                        case 17:
                                            break;
                                        default:
                                            r("163")
                                    }
                                }
                                if (128 & ye) {
                                    var Ve = T.ref;
                                    if (null !== Ve) {
                                        var He = T.stateNode;
                                        switch (T.tag) {
                                            case 5:
                                                var je = He;
                                                break;
                                            default:
                                                je = He
                                        }
                                        "function" == typeof Ve ? Ve(je) : Ve.current = je
                                    }
                                }
                                var Be = T.nextEffect;
                                T.nextEffect = null, T = Be
                            }
                        } catch (e) {
                            he = !0, ge = e
                        }
                        he && (null === T && r("178"), Gh(T, ge), null !== T && (T = T.nextEffect))
                    }
                    Vh = Yh = !1, "function" == typeof zf && zf(t.stateNode);
                    var Qe = t.expirationTime,
                        Ke = t.childExpirationTime,
                        Ye = 0 === Qe || 0 !== Ke && Ke < Qe ? Ke : Qe;
                    0 === Ye && (Ph = null), e.expirationTime = Ye, e.finishedWork = null
                }

                function ci() {
                    return !!oi || !(null === ri || ri.timeRemaining() > yi) && (oi = !0)
                }

                function Nh(e) {
                    null === X && r("246"), X.expirationTime = 0, pi || (pi = !0, qi = e)
                }

                function Ii(e, t) {
                    var n = Z;
                    Z = !0;
                    try {
                        return e(t)
                    } finally {
                        (Z = n) || W || Gi(1, null)
                    }
                }

                function Ji(e, t) {
                    if (Z && !si) {
                        si = !0;
                        try {
                            return e(t)
                        } finally {
                            si = !1
                        }
                    }
                    return e(t)
                }

                function Ki(e, t, n) {
                    if (fi) return e(t, n);
                    Z || W || 0 === gi || (Gi(gi, null), gi = 0);
                    var r = fi,
                        a = Z;
                    Z = fi = !0;
                    try {
                        return e(t, n)
                    } finally {
                        fi = r, (Z = a) || W || Gi(1, null)
                    }
                }

                function Li(e, t, n, a, i) {
                    var l = t.current;
                    e: if (n) {
                        t: {
                            2 === Gd(n = n._reactInternalFiber) && 1 === n.tag || r("170");
                            var o = n;do {
                                switch (o.tag) {
                                    case 3:
                                        o = o.stateNode.context;
                                        break t;
                                    case 1:
                                        if (M(o.type)) {
                                            o = o.stateNode.__reactInternalMemoizedMergedChildContext;
                                            break t
                                        }
                                }
                                o = o.return
                            } while (null !== o);r("171"),
                            o = void 0
                        }
                        if (1 === n.tag) {
                            var u = n.type;
                            if (M(u)) {
                                n = wf(n, u, o);
                                break e
                            }
                        }
                        n = o
                    }
                    else n = qf;
                    return null === t.context ? t.context = n : t.pendingContext = n, t = i, (i = Tf(a)).payload = {
                        element: e
                    }, null !== (t = void 0 === t ? null : t) && (i.callback = t), Vf(l, i), xg(l, a), a
                }

                function Mi(e, t, n, r) {
                    var a = t.current;
                    return Li(e, t, n, a = wg(vg(), a), r)
                }

                function Pi(e) {
                    if (!(e = e.current).child) return null;
                    switch (e.child.tag) {
                        case 5:
                        default:
                            return e.child.stateNode
                    }
                }

                function Qi(e, t, n) {
                    var r = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
                    return {
                        $$typeof: nc,
                        key: null == r ? null : "" + r,
                        children: e,
                        containerInfo: t,
                        implementation: n
                    }
                }

                function Ri(e) {
                    var t = 2 + 25 * (1 + ((vg() - 2 + 500) / 25 | 0));
                    t <= Th && (t = Th + 1), this._expirationTime = Th = t, this._root = e, this._callbacks = this._next = null, this._hasChildren = this._didComplete = !1, this._children = null, this._defer = !0
                }

                function Si() {
                    this._callbacks = null, this._didCommit = !1, this._onCommit = this._onCommit.bind(this)
                }

                function Ti(e, t, n) {
                    e = {
                        current: t = N(3, null, null, t ? 3 : 0),
                        containerInfo: e,
                        pendingChildren: null,
                        earliestPendingTime: 0,
                        latestPendingTime: 0,
                        earliestSuspendedTime: 0,
                        latestSuspendedTime: 0,
                        latestPingedTime: 0,
                        didError: !1,
                        pendingCommitExpirationTime: 0,
                        finishedWork: null,
                        timeoutHandle: -1,
                        context: null,
                        pendingContext: null,
                        hydrate: n,
                        nextExpirationTimeToWorkOn: 0,
                        expirationTime: 0,
                        firstBatch: null,
                        nextScheduledRoot: null
                    }, this._internalRoot = t.stateNode = e
                }

                function Ui(e) {
                    return !(!e || 1 !== e.nodeType && 9 !== e.nodeType && 11 !== e.nodeType && (8 !== e.nodeType || " react-mount-point-unstable " !== e.nodeValue))
                }

                function Vi(e, t) {
                    if (t || (t = !(!(t = e ? 9 === e.nodeType ? e.documentElement : e.firstChild : null) || 1 !== t.nodeType || !t.hasAttribute("data-reactroot"))), !t)
                        for (var n; n = e.lastChild;) e.removeChild(n);
                    return new Ti(e, (!1), t)
                }

                function Wi(e, t, n, a, i) {
                    Ui(n) || r("200");
                    var l = n._reactRootContainer;
                    if (l) {
                        if ("function" == typeof i) {
                            var o = i;
                            i = function() {
                                var e = Pi(l._internalRoot);
                                o.call(e)
                            }
                        }
                        null != e ? l.legacy_renderSubtreeIntoContainer(e, t, i) : l.render(t, i)
                    } else {
                        if (l = n._reactRootContainer = Vi(n, a), "function" == typeof i) {
                            var u = i;
                            i = function() {
                                var e = Pi(l._internalRoot);
                                u.call(e)
                            }
                        }
                        Ji(function() {
                            null != e ? l.legacy_renderSubtreeIntoContainer(e, t, i) : l.render(t, i)
                        })
                    }
                    return Pi(l._internalRoot)
                }

                function Xi(e, t) {
                    var n = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
                    return Ui(t) || r("200"), Qi(e, t, null, n)
                }
                var aa = require("react"),
                    n = require("object-assign"),
                    da = require("scheduler");
                aa || r("227");
                var ha = !1,
                    ia = null,
                    ja = !1,
                    ka = null,
                    la = {
                        onError: function(e) {
                            ha = !0, ia = e
                        }
                    },
                    oa = null,
                    pa = {},
                    ra = [],
                    sa = {},
                    ua = {},
                    va = {},
                    wa = null,
                    xa = null,
                    ya = null,
                    Ca = null,
                    Ga = {
                        injectEventPluginOrder: function(e) {
                            oa && r("101"), oa = Array.prototype.slice.call(e), qa()
                        },
                        injectEventPluginsByName: function(e) {
                            var t, n = !1;
                            for (t in e)
                                if (e.hasOwnProperty(t)) {
                                    var a = e[t];
                                    pa.hasOwnProperty(t) && pa[t] === a || (pa[t] && r("102", t), pa[t] = a, n = !0)
                                } n && qa()
                        }
                    },
                    Ka = Math.random().toString(36).slice(2),
                    La = "__reactInternalInstance$" + Ka,
                    Ma = "__reactEventHandlers$" + Ka,
                    Xa = !("undefined" == typeof window || !window.document || !window.document.createElement),
                    Za = {
                        animationend: Ya("Animation", "AnimationEnd"),
                        animationiteration: Ya("Animation", "AnimationIteration"),
                        animationstart: Ya("Animation", "AnimationStart"),
                        transitionend: Ya("Transition", "TransitionEnd")
                    },
                    $a = {},
                    ab = {};
                Xa && (ab = document.createElement("div").style, "AnimationEvent" in window || (delete Za.animationend.animation, delete Za.animationiteration.animation, delete Za.animationstart.animation), "TransitionEvent" in window || delete Za.transitionend.transition);
                var cb = bb("animationend"),
                    ib = bb("animationiteration"),
                    jb = bb("animationstart"),
                    kb = bb("transitionend"),
                    lb = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),
                    mb = null,
                    nb = null,
                    ob = null;
                n(y.prototype, {
                    preventDefault: function() {
                        this.defaultPrevented = !0;
                        var e = this.nativeEvent;
                        e && (e.preventDefault ? e.preventDefault() : "unknown" != typeof e.returnValue && (e.returnValue = !1), this.isDefaultPrevented = qb)
                    },
                    stopPropagation: function() {
                        var e = this.nativeEvent;
                        e && (e.stopPropagation ? e.stopPropagation() : "unknown" != typeof e.cancelBubble && (e.cancelBubble = !0), this.isPropagationStopped = qb)
                    },
                    persist: function() {
                        this.isPersistent = qb
                    },
                    isPersistent: rb,
                    destructor: function() {
                        var e, t = this.constructor.Interface;
                        for (e in t) this[e] = null;
                        this.nativeEvent = this._targetInst = this.dispatchConfig = null, this.isPropagationStopped = this.isDefaultPrevented = rb, this._dispatchInstances = this._dispatchListeners = null
                    }
                }), y.Interface = {
                    type: null,
                    target: null,
                    currentTarget: function() {
                        return null
                    },
                    eventPhase: null,
                    bubbles: null,
                    cancelable: null,
                    timeStamp: function(e) {
                        return e.timeStamp || Date.now()
                    },
                    defaultPrevented: null,
                    isTrusted: null
                }, y.extend = function(e) {
                    function t() {}

                    function r() {
                        return a.apply(this, arguments)
                    }
                    var a = this;
                    t.prototype = a.prototype;
                    var i = new t;
                    return n(i, r.prototype), r.prototype = i, r.prototype.constructor = r, r.Interface = n({}, a.Interface, e), r.extend = a.extend, sb(r), r
                }, sb(y);
                var vb = y.extend({
                        data: null
                    }),
                    wb = y.extend({
                        data: null
                    }),
                    xb = [9, 13, 27, 32],
                    yb = Xa && "CompositionEvent" in window,
                    zb = null;
                Xa && "documentMode" in document && (zb = document.documentMode);
                var Ab = Xa && "TextEvent" in window && !zb,
                    Bb = Xa && (!yb || zb && 8 < zb && 11 >= zb),
                    Cb = String.fromCharCode(32),
                    Db = {
                        beforeInput: {
                            phasedRegistrationNames: {
                                bubbled: "onBeforeInput",
                                captured: "onBeforeInputCapture"
                            },
                            dependencies: ["compositionend", "keypress", "textInput", "paste"]
                        },
                        compositionEnd: {
                            phasedRegistrationNames: {
                                bubbled: "onCompositionEnd",
                                captured: "onCompositionEndCapture"
                            },
                            dependencies: "blur compositionend keydown keypress keyup mousedown".split(" ")
                        },
                        compositionStart: {
                            phasedRegistrationNames: {
                                bubbled: "onCompositionStart",
                                captured: "onCompositionStartCapture"
                            },
                            dependencies: "blur compositionstart keydown keypress keyup mousedown".split(" ")
                        },
                        compositionUpdate: {
                            phasedRegistrationNames: {
                                bubbled: "onCompositionUpdate",
                                captured: "onCompositionUpdateCapture"
                            },
                            dependencies: "blur compositionupdate keydown keypress keyup mousedown".split(" ")
                        }
                    },
                    Eb = !1,
                    Hb = !1,
                    Mb = {
                        eventTypes: Db,
                        extractEvents: function(e, t, n, r) {
                            var a = void 0,
                                i = void 0;
                            if (yb) e: {
                                switch (e) {
                                    case "compositionstart":
                                        a = Db.compositionStart;
                                        break e;
                                    case "compositionend":
                                        a = Db.compositionEnd;
                                        break e;
                                    case "compositionupdate":
                                        a = Db.compositionUpdate;
                                        break e
                                }
                                a = void 0
                            }
                            else Hb ? Fb(e, n) && (a = Db.compositionEnd) : "keydown" === e && 229 === n.keyCode && (a = Db.compositionStart);
                            return a ? (Bb && "ko" !== n.locale && (Hb || a !== Db.compositionStart ? a === Db.compositionEnd && Hb && (i = pb()) : (nb = "value" in (mb = r) ? mb.value : mb.textContent, Hb = !0)), a = vb.getPooled(a, t, n, r), i ? a.data = i : null !== (i = Gb(n)) && (a.data = i), Wa(a), i = a) : i = null, (e = Ab ? Kb(e, n) : Lb(e, n)) ? ((t = wb.getPooled(Db.beforeInput, t, n, r)).data = e, Wa(t)) : t = null, null === i ? t : null === t ? i : [i, t]
                        }
                    },
                    Nb = null,
                    Ob = null,
                    Pb = null,
                    ac = !1,
                    cc = {
                        color: !0,
                        date: !0,
                        datetime: !0,
                        "datetime-local": !0,
                        email: !0,
                        month: !0,
                        number: !0,
                        password: !0,
                        range: !0,
                        search: !0,
                        tel: !0,
                        text: !0,
                        time: !0,
                        url: !0,
                        week: !0
                    },
                    kc = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
                    lc = /^(.*)[\\\/]/,
                    D = "function" == typeof Symbol && Symbol.for,
                    mc = D ? Symbol.for("react.element") : 60103,
                    nc = D ? Symbol.for("react.portal") : 60106,
                    oc = D ? Symbol.for("react.fragment") : 60107,
                    pc = D ? Symbol.for("react.strict_mode") : 60108,
                    qc = D ? Symbol.for("react.profiler") : 60114,
                    rc = D ? Symbol.for("react.provider") : 60109,
                    sc = D ? Symbol.for("react.context") : 60110,
                    tc = D ? Symbol.for("react.concurrent_mode") : 60111,
                    uc = D ? Symbol.for("react.forward_ref") : 60112,
                    vc = D ? Symbol.for("react.suspense") : 60113,
                    wc = D ? Symbol.for("react.memo") : 60115,
                    xc = D ? Symbol.for("react.lazy") : 60116,
                    yc = "function" == typeof Symbol && Symbol.iterator,
                    Cc = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,
                    Dc = Object.prototype.hasOwnProperty,
                    Ec = {},
                    Fc = {},
                    G = {};
                "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e) {
                    G[e] = new F(e, 0, (!1), e, null)
                }), [
                    ["acceptCharset", "accept-charset"],
                    ["className", "class"],
                    ["htmlFor", "for"],
                    ["httpEquiv", "http-equiv"]
                ].forEach(function(e) {
                    var t = e[0];
                    G[t] = new F(t, 1, (!1), e[1], null)
                }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(e) {
                    G[e] = new F(e, 2, (!1), e.toLowerCase(), null)
                }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(e) {
                    G[e] = new F(e, 2, (!1), e, null)
                }), "allowFullScreen async autoFocus autoPlay controls default defer disabled formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e) {
                    G[e] = new F(e, 3, (!1), e.toLowerCase(), null)
                }), ["checked", "multiple", "muted", "selected"].forEach(function(e) {
                    G[e] = new F(e, 3, (!0), e, null)
                }), ["capture", "download"].forEach(function(e) {
                    G[e] = new F(e, 4, (!1), e, null)
                }), ["cols", "rows", "size", "span"].forEach(function(e) {
                    G[e] = new F(e, 6, (!1), e, null)
                }), ["rowSpan", "start"].forEach(function(e) {
                    G[e] = new F(e, 5, (!1), e.toLowerCase(), null)
                });
                var Mc = /[\-:]([a-z])/g;
                "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e) {
                    var t = e.replace(Mc, Nc);
                    G[t] = new F(t, 1, (!1), e, null)
                }), "xlink:actuate xlink:arcrole xlink:href xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e) {
                    var t = e.replace(Mc, Nc);
                    G[t] = new F(t, 1, (!1), e, "http://www.w3.org/1999/xlink")
                }), ["xml:base", "xml:lang", "xml:space"].forEach(function(e) {
                    var t = e.replace(Mc, Nc);
                    G[t] = new F(t, 1, (!1), e, "http://www.w3.org/XML/1998/namespace")
                }), G.tabIndex = new F("tabIndex", 1, (!1), "tabindex", null);
                var cd = {
                        change: {
                            phasedRegistrationNames: {
                                bubbled: "onChange",
                                captured: "onChangeCapture"
                            },
                            dependencies: "blur change click focus input keydown keyup selectionchange".split(" ")
                        }
                    },
                    ed = null,
                    fd = null,
                    jd = !1;
                Xa && (jd = fc("input") && (!document.documentMode || 9 < document.documentMode));
                var qd = {
                        eventTypes: cd,
                        _isInputEventSupported: jd,
                        extractEvents: function(e, t, n, r) {
                            var a = t ? Pa(t) : window,
                                i = void 0,
                                l = void 0,
                                o = a.nodeName && a.nodeName.toLowerCase();
                            return "select" === o || "input" === o && "file" === a.type ? i = id : dc(a) ? jd ? i = pd : (i = nd, l = md) : (o = a.nodeName) && "input" === o.toLowerCase() && ("checkbox" === a.type || "radio" === a.type) && (i = od), i && (i = i(e, t)) ? dd(i, n, r) : (l && l(e, a, t), void("blur" === e && (e = a._wrapperState) && e.controlled && "number" === a.type && Uc(a, "number", a.value)))
                        }
                    },
                    rd = y.extend({
                        view: null,
                        detail: null
                    }),
                    sd = {
                        Alt: "altKey",
                        Control: "ctrlKey",
                        Meta: "metaKey",
                        Shift: "shiftKey"
                    },
                    vd = 0,
                    wd = 0,
                    xd = !1,
                    yd = !1,
                    zd = rd.extend({
                        screenX: null,
                        screenY: null,
                        clientX: null,
                        clientY: null,
                        pageX: null,
                        pageY: null,
                        ctrlKey: null,
                        shiftKey: null,
                        altKey: null,
                        metaKey: null,
                        getModifierState: ud,
                        button: null,
                        buttons: null,
                        relatedTarget: function(e) {
                            return e.relatedTarget || (e.fromElement === e.srcElement ? e.toElement : e.fromElement)
                        },
                        movementX: function(e) {
                            if ("movementX" in e) return e.movementX;
                            var t = vd;
                            return vd = e.screenX, xd ? "mousemove" === e.type ? e.screenX - t : 0 : (xd = !0, 0)
                        },
                        movementY: function(e) {
                            if ("movementY" in e) return e.movementY;
                            var t = wd;
                            return wd = e.screenY, yd ? "mousemove" === e.type ? e.screenY - t : 0 : (yd = !0, 0)
                        }
                    }),
                    Ad = zd.extend({
                        pointerId: null,
                        width: null,
                        height: null,
                        pressure: null,
                        tangentialPressure: null,
                        tiltX: null,
                        tiltY: null,
                        twist: null,
                        pointerType: null,
                        isPrimary: null
                    }),
                    Bd = {
                        mouseEnter: {
                            registrationName: "onMouseEnter",
                            dependencies: ["mouseout", "mouseover"]
                        },
                        mouseLeave: {
                            registrationName: "onMouseLeave",
                            dependencies: ["mouseout", "mouseover"]
                        },
                        pointerEnter: {
                            registrationName: "onPointerEnter",
                            dependencies: ["pointerout", "pointerover"]
                        },
                        pointerLeave: {
                            registrationName: "onPointerLeave",
                            dependencies: ["pointerout", "pointerover"]
                        }
                    },
                    Cd = {
                        eventTypes: Bd,
                        extractEvents: function(e, t, n, r) {
                            var a = "mouseover" === e || "pointerover" === e,
                                i = "mouseout" === e || "pointerout" === e;
                            if (a && (n.relatedTarget || n.fromElement) || !i && !a) return null;
                            if (a = r.window === r ? r : (a = r.ownerDocument) ? a.defaultView || a.parentWindow : window, i ? (i = t, t = (t = n.relatedTarget || n.toElement) ? Na(t) : null) : i = null, i === t) return null;
                            var l = void 0,
                                o = void 0,
                                u = void 0,
                                c = void 0;
                            "mouseout" === e || "mouseover" === e ? (l = zd, o = Bd.mouseLeave, u = Bd.mouseEnter, c = "mouse") : "pointerout" !== e && "pointerover" !== e || (l = Ad, o = Bd.pointerLeave, u = Bd.pointerEnter, c = "pointer");
                            var f = null == i ? a : Pa(i);
                            if (a = null == t ? a : Pa(t), (e = l.getPooled(o, i, n, r)).type = c + "leave", e.target = f, e.relatedTarget = a, (n = l.getPooled(u, t, n, r)).type = c + "enter", n.target = a, n.relatedTarget = f, r = t, i && r) e: {
                                for (a = r, c = 0, l = t = i; l; l = Ra(l)) c++;
                                for (l = 0, u = a; u; u = Ra(u)) l++;
                                for (; 0 < c - l;) t = Ra(t),
                                c--;
                                for (; 0 < l - c;) a = Ra(a),
                                l--;
                                for (; c--;) {
                                    if (t === a || t === a.alternate) break e;
                                    t = Ra(t), a = Ra(a)
                                }
                                t = null
                            }
                            else t = null;
                            for (a = t, t = []; i && i !== a && (null === (c = i.alternate) || c !== a);) t.push(i), i = Ra(i);
                            for (i = []; r && r !== a && (null === (c = r.alternate) || c !== a);) i.push(r), r = Ra(r);
                            for (r = 0; r < t.length; r++) Ua(t[r], "bubbled", e);
                            for (r = i.length; 0 < r--;) Ua(i[r], "captured", n);
                            return [e, n]
                        }
                    },
                    Dd = Object.prototype.hasOwnProperty,
                    Kd = y.extend({
                        animationName: null,
                        elapsedTime: null,
                        pseudoElement: null
                    }),
                    Ld = y.extend({
                        clipboardData: function(e) {
                            return "clipboardData" in e ? e.clipboardData : window.clipboardData
                        }
                    }),
                    Md = rd.extend({
                        relatedTarget: null
                    }),
                    Od = {
                        Esc: "Escape",
                        Spacebar: " ",
                        Left: "ArrowLeft",
                        Up: "ArrowUp",
                        Right: "ArrowRight",
                        Down: "ArrowDown",
                        Del: "Delete",
                        Win: "OS",
                        Menu: "ContextMenu",
                        Apps: "ContextMenu",
                        Scroll: "ScrollLock",
                        MozPrintableKey: "Unidentified"
                    },
                    Pd = {
                        8: "Backspace",
                        9: "Tab",
                        12: "Clear",
                        13: "Enter",
                        16: "Shift",
                        17: "Control",
                        18: "Alt",
                        19: "Pause",
                        20: "CapsLock",
                        27: "Escape",
                        32: " ",
                        33: "PageUp",
                        34: "PageDown",
                        35: "End",
                        36: "Home",
                        37: "ArrowLeft",
                        38: "ArrowUp",
                        39: "ArrowRight",
                        40: "ArrowDown",
                        45: "Insert",
                        46: "Delete",
                        112: "F1",
                        113: "F2",
                        114: "F3",
                        115: "F4",
                        116: "F5",
                        117: "F6",
                        118: "F7",
                        119: "F8",
                        120: "F9",
                        121: "F10",
                        122: "F11",
                        123: "F12",
                        144: "NumLock",
                        145: "ScrollLock",
                        224: "Meta"
                    },
                    Qd = rd.extend({
                        key: function(e) {
                            if (e.key) {
                                var t = Od[e.key] || e.key;
                                if ("Unidentified" !== t) return t
                            }
                            return "keypress" === e.type ? 13 === (e = Nd(e)) ? "Enter" : String.fromCharCode(e) : "keydown" === e.type || "keyup" === e.type ? Pd[e.keyCode] || "Unidentified" : ""
                        },
                        location: null,
                        ctrlKey: null,
                        shiftKey: null,
                        altKey: null,
                        metaKey: null,
                        repeat: null,
                        locale: null,
                        getModifierState: ud,
                        charCode: function(e) {
                            return "keypress" === e.type ? Nd(e) : 0
                        },
                        keyCode: function(e) {
                            return "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
                        },
                        which: function(e) {
                            return "keypress" === e.type ? Nd(e) : "keydown" === e.type || "keyup" === e.type ? e.keyCode : 0
                        }
                    }),
                    Rd = zd.extend({
                        dataTransfer: null
                    }),
                    Sd = rd.extend({
                        touches: null,
                        targetTouches: null,
                        changedTouches: null,
                        altKey: null,
                        metaKey: null,
                        ctrlKey: null,
                        shiftKey: null,
                        getModifierState: ud
                    }),
                    Td = y.extend({
                        propertyName: null,
                        elapsedTime: null,
                        pseudoElement: null
                    }),
                    Ud = zd.extend({
                        deltaX: function(e) {
                            return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0
                        },
                        deltaY: function(e) {
                            return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0
                        },
                        deltaZ: null,
                        deltaMode: null
                    }),
                    Vd = [
                        ["abort", "abort"],
                        [cb, "animationEnd"],
                        [ib, "animationIteration"],
                        [jb, "animationStart"],
                        ["canplay", "canPlay"],
                        ["canplaythrough", "canPlayThrough"],
                        ["drag", "drag"],
                        ["dragenter", "dragEnter"],
                        ["dragexit", "dragExit"],
                        ["dragleave", "dragLeave"],
                        ["dragover", "dragOver"],
                        ["durationchange", "durationChange"],
                        ["emptied", "emptied"],
                        ["encrypted", "encrypted"],
                        ["ended", "ended"],
                        ["error", "error"],
                        ["gotpointercapture", "gotPointerCapture"],
                        ["load", "load"],
                        ["loadeddata", "loadedData"],
                        ["loadedmetadata", "loadedMetadata"],
                        ["loadstart", "loadStart"],
                        ["lostpointercapture", "lostPointerCapture"],
                        ["mousemove", "mouseMove"],
                        ["mouseout", "mouseOut"],
                        ["mouseover", "mouseOver"],
                        ["playing", "playing"],
                        ["pointermove", "pointerMove"],
                        ["pointerout", "pointerOut"],
                        ["pointerover", "pointerOver"],
                        ["progress", "progress"],
                        ["scroll", "scroll"],
                        ["seeking", "seeking"],
                        ["stalled", "stalled"],
                        ["suspend", "suspend"],
                        ["timeupdate", "timeUpdate"],
                        ["toggle", "toggle"],
                        ["touchmove", "touchMove"],
                        [kb, "transitionEnd"],
                        ["waiting", "waiting"],
                        ["wheel", "wheel"]
                    ],
                    Wd = {},
                    Xd = {};
                [
                    ["blur", "blur"],
                    ["cancel", "cancel"],
                    ["click", "click"],
                    ["close", "close"],
                    ["contextmenu", "contextMenu"],
                    ["copy", "copy"],
                    ["cut", "cut"],
                    ["auxclick", "auxClick"],
                    ["dblclick", "doubleClick"],
                    ["dragend", "dragEnd"],
                    ["dragstart", "dragStart"],
                    ["drop", "drop"],
                    ["focus", "focus"],
                    ["input", "input"],
                    ["invalid", "invalid"],
                    ["keydown", "keyDown"],
                    ["keypress", "keyPress"],
                    ["keyup", "keyUp"],
                    ["mousedown", "mouseDown"],
                    ["mouseup", "mouseUp"],
                    ["paste", "paste"],
                    ["pause", "pause"],
                    ["play", "play"],
                    ["pointercancel", "pointerCancel"],
                    ["pointerdown", "pointerDown"],
                    ["pointerup", "pointerUp"],
                    ["ratechange", "rateChange"],
                    ["reset", "reset"],
                    ["seeked", "seeked"],
                    ["submit", "submit"],
                    ["touchcancel", "touchCancel"],
                    ["touchend", "touchEnd"],
                    ["touchstart", "touchStart"],
                    ["volumechange", "volumeChange"]
                ].forEach(function(e) {
                    Yd(e, !0)
                }), Vd.forEach(function(e) {
                    Yd(e, !1)
                });
                var Zd = {
                        eventTypes: Wd,
                        isInteractiveTopLevelEventType: function(e) {
                            return void 0 !== (e = Xd[e]) && !0 === e.isInteractive
                        },
                        extractEvents: function(e, t, n, r) {
                            var a = Xd[e];
                            if (!a) return null;
                            switch (e) {
                                case "keypress":
                                    if (0 === Nd(n)) return null;
                                case "keydown":
                                case "keyup":
                                    e = Qd;
                                    break;
                                case "blur":
                                case "focus":
                                    e = Md;
                                    break;
                                case "click":
                                    if (2 === n.button) return null;
                                case "auxclick":
                                case "dblclick":
                                case "mousedown":
                                case "mousemove":
                                case "mouseup":
                                case "mouseout":
                                case "mouseover":
                                case "contextmenu":
                                    e = zd;
                                    break;
                                case "drag":
                                case "dragend":
                                case "dragenter":
                                case "dragexit":
                                case "dragleave":
                                case "dragover":
                                case "dragstart":
                                case "drop":
                                    e = Rd;
                                    break;
                                case "touchcancel":
                                case "touchend":
                                case "touchmove":
                                case "touchstart":
                                    e = Sd;
                                    break;
                                case cb:
                                case ib:
                                case jb:
                                    e = Kd;
                                    break;
                                case kb:
                                    e = Td;
                                    break;
                                case "scroll":
                                    e = rd;
                                    break;
                                case "wheel":
                                    e = Ud;
                                    break;
                                case "copy":
                                case "cut":
                                case "paste":
                                    e = Ld;
                                    break;
                                case "gotpointercapture":
                                case "lostpointercapture":
                                case "pointercancel":
                                case "pointerdown":
                                case "pointermove":
                                case "pointerout":
                                case "pointerover":
                                case "pointerup":
                                    e = Ad;
                                    break;
                                default:
                                    e = y
                            }
                            return Wa(t = e.getPooled(a, t, n, r)), t
                        }
                    },
                    $d = Zd.isInteractiveTopLevelEventType,
                    ae = [],
                    ce = !0,
                    he = {},
                    ie = 0,
                    je = "_reactListenersID" + ("" + Math.random()).slice(2),
                    re = Xa && "documentMode" in document && 11 >= document.documentMode,
                    se = {
                        select: {
                            phasedRegistrationNames: {
                                bubbled: "onSelect",
                                captured: "onSelectCapture"
                            },
                            dependencies: "blur contextmenu dragend focus keydown keyup mousedown mouseup selectionchange".split(" ")
                        }
                    },
                    te = null,
                    ue = null,
                    He = null,
                    Ie = !1,
                    Ke = {
                        eventTypes: se,
                        extractEvents: function(e, t, n, r) {
                            var a, i = r.window === r ? r.document : 9 === r.nodeType ? r : r.ownerDocument;
                            if (!(a = !i)) {
                                e: {
                                    i = ke(i),
                                    a = va.onSelect;
                                    for (var l = 0; l < a.length; l++) {
                                        var o = a[l];
                                        if (!i.hasOwnProperty(o) || !i[o]) {
                                            i = !1;
                                            break e
                                        }
                                    }
                                    i = !0
                                }
                                a = !i
                            }
                            if (a) return null;
                            switch (i = t ? Pa(t) : window, e) {
                                case "focus":
                                    (dc(i) || "true" === i.contentEditable) && (te = i, ue = t, He = null);
                                    break;
                                case "blur":
                                    He = ue = te = null;
                                    break;
                                case "mousedown":
                                    Ie = !0;
                                    break;
                                case "contextmenu":
                                case "mouseup":
                                case "dragend":
                                    return Ie = !1, Je(n, r);
                                case "selectionchange":
                                    if (re) break;
                                case "keydown":
                                case "keyup":
                                    return Je(n, r)
                            }
                            return null
                        }
                    };
                Ga.injectEventPluginOrder("ResponderEventPlugin SimpleEventPlugin EnterLeaveEventPlugin ChangeEventPlugin SelectEventPlugin BeforeInputEventPlugin".split(" ")), wa = Qa, xa = Oa, ya = Pa, Ga.injectEventPluginsByName({
                    SimpleEventPlugin: Zd,
                    EnterLeaveEventPlugin: Cd,
                    ChangeEventPlugin: qd,
                    SelectEventPlugin: Ke,
                    BeforeInputEventPlugin: Mb
                });
                var Se = {
                        html: "http://www.w3.org/1999/xhtml",
                        mathml: "http://www.w3.org/1998/Math/MathML",
                        svg: "http://www.w3.org/2000/svg"
                    },
                    Ve = void 0,
                    We = function(e) {
                        return "undefined" != typeof MSApp && MSApp.execUnsafeLocalFunction ? function(t, n, r, a) {
                            MSApp.execUnsafeLocalFunction(function() {
                                return e(t, n)
                            })
                        } : e
                    }(function(e, t) {
                        if (e.namespaceURI !== Se.svg || "innerHTML" in e) e.innerHTML = t;
                        else {
                            for ((Ve = Ve || document.createElement("div")).innerHTML = "<svg>" + t + "</svg>", t = Ve.firstChild; e.firstChild;) e.removeChild(e.firstChild);
                            for (; t.firstChild;) e.appendChild(t.firstChild)
                        }
                    }),
                    Ye = {
                        animationIterationCount: !0,
                        borderImageOutset: !0,
                        borderImageSlice: !0,
                        borderImageWidth: !0,
                        boxFlex: !0,
                        boxFlexGroup: !0,
                        boxOrdinalGroup: !0,
                        columnCount: !0,
                        columns: !0,
                        flex: !0,
                        flexGrow: !0,
                        flexPositive: !0,
                        flexShrink: !0,
                        flexNegative: !0,
                        flexOrder: !0,
                        gridArea: !0,
                        gridRow: !0,
                        gridRowEnd: !0,
                        gridRowSpan: !0,
                        gridRowStart: !0,
                        gridColumn: !0,
                        gridColumnEnd: !0,
                        gridColumnSpan: !0,
                        gridColumnStart: !0,
                        fontWeight: !0,
                        lineClamp: !0,
                        lineHeight: !0,
                        opacity: !0,
                        order: !0,
                        orphans: !0,
                        tabSize: !0,
                        widows: !0,
                        zIndex: !0,
                        zoom: !0,
                        fillOpacity: !0,
                        floodOpacity: !0,
                        stopOpacity: !0,
                        strokeDasharray: !0,
                        strokeDashoffset: !0,
                        strokeMiterlimit: !0,
                        strokeOpacity: !0,
                        strokeWidth: !0
                    },
                    Ze = ["Webkit", "ms", "Moz", "O"];
                Object.keys(Ye).forEach(function(e) {
                    Ze.forEach(function(t) {
                        t = t + e.charAt(0).toUpperCase() + e.substring(1), Ye[t] = Ye[e]
                    })
                });
                var af = n({
                        menuitem: !0
                    }, {
                        area: !0,
                        base: !0,
                        br: !0,
                        col: !0,
                        embed: !0,
                        hr: !0,
                        img: !0,
                        input: !0,
                        keygen: !0,
                        link: !0,
                        meta: !0,
                        param: !0,
                        source: !0,
                        track: !0,
                        wbr: !0
                    }),
                    ff = null,
                    gf = null,
                    kf = setTimeout,
                    lf = clearTimeout;
                new Set;
                var of = [], pf = -1, qf = {}, K = {
                    current: qf
                }, L = {
                    current: !1
                }, rf = qf, zf = null, Af = null, Qf = !1, cg = {
                    current: null
                }, dg = null, eg = null, fg = null, kg = {}, O = {
                    current: kg
                }, lg = {
                    current: kg
                }, mg = {
                    current: kg
                }, sg = kc.ReactCurrentOwner, tg = (new aa.Component).refs, yg = {
                    isMounted: function(e) {
                        return !!(e = e._reactInternalFiber) && 2 === Gd(e)
                    },
                    enqueueSetState: function(e, t, n) {
                        e = e._reactInternalFiber;
                        var r = vg(),
                            a = Tf(r = wg(r, e));
                        a.payload = t, null != n && (a.callback = n), Vf(e, a), xg(e, r)
                    },
                    enqueueReplaceState: function(e, t, n) {
                        e = e._reactInternalFiber;
                        var r = vg(),
                            a = Tf(r = wg(r, e));
                        a.tag = 1, a.payload = t, null != n && (a.callback = n), Vf(e, a), xg(e, r)
                    },
                    enqueueForceUpdate: function(e, t) {
                        e = e._reactInternalFiber;
                        var n = vg(),
                            r = Tf(n = wg(n, e));
                        r.tag = 2, null != t && (r.callback = t), Vf(e, r), xg(e, n)
                    }
                }, Dg = Array.isArray, Hg = Gg(!0), Ig = Gg(!1), Jg = null, Kg = null, Lg = !1, Tg = kc.ReactCurrentOwner, Ah = void 0, Bh = void 0, Ch = void 0, Dh = void 0;
                Ah = function(e, t) {
                    for (var n = t.child; null !== n;) {
                        if (5 === n.tag || 6 === n.tag) e.appendChild(n.stateNode);
                        else if (4 !== n.tag && null !== n.child) {
                            n.child.return = n, n = n.child;
                            continue
                        }
                        if (n === t) break;
                        for (; null === n.sibling;) {
                            if (null === n.return || n.return === t) return;
                            n = n.return
                        }
                        n.sibling.return = n.return, n = n.sibling
                    }
                }, Bh = function() {}, Ch = function(e, t, r, a, i) {
                    var l = e.memoizedProps;
                    if (l !== a) {
                        var o = t.stateNode;
                        switch (ng(O.current), e = null, r) {
                            case "input":
                                l = Qc(o, l), a = Qc(o, a), e = [];
                                break;
                            case "option":
                                l = Me(o, l), a = Me(o, a), e = [];
                                break;
                            case "select":
                                l = n({}, l, {
                                    value: void 0
                                }), a = n({}, a, {
                                    value: void 0
                                }), e = [];
                                break;
                            case "textarea":
                                l = Oe(o, l), a = Oe(o, a), e = [];
                                break;
                            default:
                                "function" != typeof l.onClick && "function" == typeof a.onClick && (o.onclick = ef)
                        }
                        bf(r, a), o = r = void 0;
                        var u = null;
                        for (r in l)
                            if (!a.hasOwnProperty(r) && l.hasOwnProperty(r) && null != l[r])
                                if ("style" === r) {
                                    var c = l[r];
                                    for (o in c) c.hasOwnProperty(o) && (u || (u = {}), u[o] = "")
                                } else "dangerouslySetInnerHTML" !== r && "children" !== r && "suppressContentEditableWarning" !== r && "suppressHydrationWarning" !== r && "autoFocus" !== r && (ua.hasOwnProperty(r) ? e || (e = []) : (e = e || []).push(r, null));
                        for (r in a) {
                            var f = a[r];
                            if (c = null != l ? l[r] : void 0, a.hasOwnProperty(r) && f !== c && (null != f || null != c))
                                if ("style" === r)
                                    if (c) {
                                        for (o in c) !c.hasOwnProperty(o) || f && f.hasOwnProperty(o) || (u || (u = {}), u[o] = "");
                                        for (o in f) f.hasOwnProperty(o) && c[o] !== f[o] && (u || (u = {}), u[o] = f[o])
                                    } else u || (e || (e = []), e.push(r, u)), u = f;
                            else "dangerouslySetInnerHTML" === r ? (f = f ? f.__html : void 0, c = c ? c.__html : void 0, null != f && c !== f && (e = e || []).push(r, "" + f)) : "children" === r ? c === f || "string" != typeof f && "number" != typeof f || (e = e || []).push(r, "" + f) : "suppressContentEditableWarning" !== r && "suppressHydrationWarning" !== r && (ua.hasOwnProperty(r) ? (null != f && df(i, r), e || c === f || (e = [])) : (e = e || []).push(r, f))
                        }
                        u && (e = e || []).push("style", u), i = e, (t.updateQueue = i) && zh(t)
                    }
                }, Dh = function(e, t, n, r) {
                    n !== r && zh(t)
                };
                var Rh = {
                        readContext: jg
                    },
                    Sh = kc.ReactCurrentOwner,
                    Th = 0,
                    Uh = 0,
                    Vh = !1,
                    Q = null,
                    R = null,
                    S = 0,
                    Wh = -1,
                    Xh = !1,
                    T = null,
                    Yh = !1,
                    Ph = null,
                    U = null,
                    V = null,
                    mi = 0,
                    ni = void 0,
                    W = !1,
                    X = null,
                    Y = 0,
                    gi = 0,
                    oi = !1,
                    pi = !1,
                    qi = null,
                    ri = null,
                    Z = !1,
                    si = !1,
                    fi = !1,
                    ti = null,
                    ui = da.unstable_now(),
                    vi = 2 + (ui / 10 | 0),
                    wi = vi,
                    ki = 50,
                    ji = 0,
                    xi = null,
                    yi = 1;
                Nb = function(e, t, n) {
                    switch (t) {
                        case "input":
                            if (Tc(e, n), t = n.name, "radio" === n.type && null != t) {
                                for (n = e; n.parentNode;) n = n.parentNode;
                                for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) {
                                    var a = n[t];
                                    if (a !== e && a.form === e.form) {
                                        var i = Qa(a);
                                        i || r("90"), jc(a), Tc(a, i)
                                    }
                                }
                            }
                            break;
                        case "textarea":
                            Qe(e, n);
                            break;
                        case "select":
                            null != (t = n.value) && Ne(e, !!n.multiple, t, !1)
                    }
                }, Ri.prototype.render = function(e) {
                    this._defer || r("250"), this._hasChildren = !0, this._children = e;
                    var t = this._root._internalRoot,
                        n = this._expirationTime,
                        a = new Si;
                    return Li(e, t, null, n, a._onCommit), a
                }, Ri.prototype.then = function(e) {
                    if (this._didComplete) e();
                    else {
                        var t = this._callbacks;
                        null === t && (t = this._callbacks = []), t.push(e)
                    }
                }, Ri.prototype.commit = function() {
                    var e = this._root._internalRoot,
                        t = e.firstBatch;
                    if (this._defer && null !== t || r("251"), this._hasChildren) {
                        var n = this._expirationTime;
                        if (t !== this) {
                            this._hasChildren && (n = this._expirationTime = t._expirationTime, this.render(this._children));
                            for (var a = null, i = t; i !== this;) a = i, i = i._next;
                            null === a && r("251"), a._next = i._next, this._next = t, e.firstBatch = this
                        }
                        this._defer = !1, Di(e, n), t = this._next, this._next = null, null !== (t = e.firstBatch = t) && t._hasChildren && t.render(t._children)
                    } else this._next = null, this._defer = !1
                }, Ri.prototype._onComplete = function() {
                    if (!this._didComplete) {
                        this._didComplete = !0;
                        var e = this._callbacks;
                        if (null !== e)
                            for (var t = 0; t < e.length; t++)(0, e[t])()
                    }
                }, Si.prototype.then = function(e) {
                    if (this._didCommit) e();
                    else {
                        var t = this._callbacks;
                        null === t && (t = this._callbacks = []), t.push(e)
                    }
                }, Si.prototype._onCommit = function() {
                    if (!this._didCommit) {
                        this._didCommit = !0;
                        var e = this._callbacks;
                        if (null !== e)
                            for (var t = 0; t < e.length; t++) {
                                var n = e[t];
                                "function" != typeof n && r("191", n), n()
                            }
                    }
                }, Ti.prototype.render = function(e, t) {
                    var n = this._internalRoot,
                        r = new Si;
                    return null !== (t = void 0 === t ? null : t) && r.then(t), Mi(e, n, null, r._onCommit), r
                }, Ti.prototype.unmount = function(e) {
                    var t = this._internalRoot,
                        n = new Si;
                    return null !== (e = void 0 === e ? null : e) && n.then(e), Mi(null, t, null, n._onCommit), n
                }, Ti.prototype.legacy_renderSubtreeIntoContainer = function(e, t, n) {
                    var r = this._internalRoot,
                        a = new Si;
                    return null !== (n = void 0 === n ? null : n) && a.then(n), Mi(t, r, e, a._onCommit), a
                }, Ti.prototype.createBatch = function() {
                    var e = new Ri(this),
                        t = e._expirationTime,
                        n = this._internalRoot,
                        r = n.firstBatch;
                    if (null === r) n.firstBatch = e, e._next = null;
                    else {
                        for (n = null; null !== r && r._expirationTime <= t;) n = r, r = r._next;
                        e._next = r, null !== n && (n._next = e)
                    }
                    return e
                }, Yb = Ii, Zb = Ki, $b = function() {
                    W || 0 === gi || (Gi(gi, null), gi = 0)
                };
                var Yi = {
                    createPortal: Xi,
                    findDOMNode: function(e) {
                        if (null == e) return null;
                        if (1 === e.nodeType) return e;
                        var t = e._reactInternalFiber;
                        return void 0 === t && ("function" == typeof e.render ? r("188") : r("268", Object.keys(e))), e = null === (e = Jd(t)) ? null : e.stateNode
                    },
                    hydrate: function(e, t, n) {
                        return Wi(null, e, t, !0, n)
                    },
                    render: function(e, t, n) {
                        return Wi(null, e, t, !1, n)
                    },
                    unstable_renderSubtreeIntoContainer: function(e, t, n, a) {
                        return (null == e || void 0 === e._reactInternalFiber) && r("38"), Wi(e, t, n, !1, a)
                    },
                    unmountComponentAtNode: function(e) {
                        return Ui(e) || r("40"), !!e._reactRootContainer && (Ji(function() {
                            Wi(null, null, e, !1, function() {
                                e._reactRootContainer = null
                            })
                        }), !0)
                    },
                    unstable_createPortal: function() {
                        return Xi.apply(void 0, arguments)
                    },
                    unstable_batchedUpdates: Ii,
                    unstable_interactiveUpdates: Ki,
                    flushSync: function(e, t) {
                        W && r("187");
                        var n = Z;
                        Z = !0;
                        try {
                            return li(e, t)
                        } finally {
                            Z = n, Gi(1, null)
                        }
                    },
                    unstable_flushControlled: function(e) {
                        var t = Z;
                        Z = !0;
                        try {
                            li(e)
                        } finally {
                            (Z = t) || W || Gi(1, null)
                        }
                    },
                    __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
                        Events: [Oa, Pa, Qa, Ga.injectEventPluginsByName, sa, Wa, function(e) {
                            Ba(e, Va)
                        }, Wb, Xb, ee, Ia]
                    },
                    unstable_createRoot: function(e, t) {
                        return Ui(e) || r("278"), new Ti(e, (!0), null != t && !0 === t.hydrate)
                    }
                };
                ! function(e) {
                    var t = e.findFiberByHostInstance;
                    Cf(n({}, e, {
                        findHostInstanceByFiber: function(e) {
                            return null === (e = Jd(e)) ? null : e.stateNode
                        },
                        findFiberByHostInstance: function(e) {
                            return t ? t(e) : null
                        }
                    }))
                }({
                    findFiberByHostInstance: Na,
                    bundleType: 0,
                    version: "16.6.0",
                    rendererPackageName: "react-dom"
                });
                var mj = {
                        default: Yi
                    },
                    nj = mj && Yi || mj;
                module.exports = nj.default || nj
            }, {
                "object-assign": 421,
                react: 455,
                scheduler: 458
            }],
            438: [function(require, module, exports) {
                "use strict";

                function checkDCE() {
                    if ("undefined" != typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" == typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE) try {
                        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE)
                    } catch (_) {
                        console.error(_)
                    }
                }
                checkDCE(), module.exports = require("./cjs/react-dom.production.min.js")
            }, {
                "./cjs/react-dom.production.min.js": 437
            }],
            439: [function(require, module, exports) {
                "use strict";

                function componentWillMount() {
                    var e = this.constructor.getDerivedStateFromProps(this.props, this.state);
                    null != e && this.setState(e)
                }

                function componentWillReceiveProps(e) {
                    this.setState(function(t) {
                        var o = this.constructor.getDerivedStateFromProps(e, t);
                        return null != o ? o : null
                    }.bind(this))
                }

                function componentWillUpdate(e, t) {
                    try {
                        var o = this.props,
                            n = this.state;
                        this.props = e, this.state = t, this.__reactInternalSnapshotFlag = !0, this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(o, n)
                    } finally {
                        this.props = o, this.state = n
                    }
                }

                function polyfill(e) {
                    var t = e.prototype;
                    if (!t || !t.isReactComponent) throw new Error("Can only polyfill class components");
                    if ("function" != typeof e.getDerivedStateFromProps && "function" != typeof t.getSnapshotBeforeUpdate) return e;
                    var o = null,
                        n = null,
                        l = null;
                    if ("function" == typeof t.componentWillMount ? o = "componentWillMount" : "function" == typeof t.UNSAFE_componentWillMount && (o = "UNSAFE_componentWillMount"), "function" == typeof t.componentWillReceiveProps ? n = "componentWillReceiveProps" : "function" == typeof t.UNSAFE_componentWillReceiveProps && (n = "UNSAFE_componentWillReceiveProps"), "function" == typeof t.componentWillUpdate ? l = "componentWillUpdate" : "function" == typeof t.UNSAFE_componentWillUpdate && (l = "UNSAFE_componentWillUpdate"), null !== o || null !== n || null !== l) {
                        var p = e.displayName || e.name,
                            i = "function" == typeof e.getDerivedStateFromProps ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
                        throw Error("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" + p + " uses " + i + " but also contains the following legacy lifecycles:" + (null !== o ? "\n  " + o : "") + (null !== n ? "\n  " + n : "") + (null !== l ? "\n  " + l : "") + "\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://fb.me/react-async-component-lifecycle-hooks")
                    }
                    if ("function" == typeof e.getDerivedStateFromProps && (t.componentWillMount = componentWillMount, t.componentWillReceiveProps = componentWillReceiveProps), "function" == typeof t.getSnapshotBeforeUpdate) {
                        if ("function" != typeof t.componentDidUpdate) throw new Error("Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype");
                        t.componentWillUpdate = componentWillUpdate;
                        var r = t.componentDidUpdate;
                        t.componentDidUpdate = function(e, t, o) {
                            var n = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : o;
                            r.call(this, e, t, n)
                        }
                    }
                    return e
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                }), componentWillMount.__suppressDeprecationWarning = !0, componentWillReceiveProps.__suppressDeprecationWarning = !0, componentWillUpdate.__suppressDeprecationWarning = !0, exports.polyfill = polyfill
            }, {}],
            440: [function(require, module, exports) {
                "use strict";

                function _interopDefault(e) {
                    return e && "object" == _typeof2(e) && "default" in e ? e.default : e
                }

                function isValidDelay(e) {
                    return "number" == typeof e && !isNaN(e) && e > 0
                }

                function objectValues(e) {
                    return Object.keys(e).map(function(t) {
                        return e[t]
                    })
                }

                function withRequired(e) {
                    return e.isRequired = function(t, o, s) {
                        return void 0 === t[o] ? new Error("The prop " + o + " is marked as required in \n      " + s + ", but its value is undefined.") : void e(t, o, s)
                    }, e
                }

                function ProgressBar(e) {
                    var t, o = e.delay,
                        s = e.isRunning,
                        n = e.closeToast,
                        r = e.type,
                        a = e.hide,
                        i = e.className,
                        p = e.style,
                        l = e.controlledProgress,
                        u = e.progress,
                        c = e.isProgressDone,
                        d = e.rtl,
                        T = _extends({}, p, {
                            animationDuration: o + "ms",
                            animationPlayState: s ? "running" : "paused",
                            opacity: a ? 0 : 1,
                            transform: l ? "scaleX(" + u + ")" : null
                        }),
                        f = cx("Toastify__progress-bar", l ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated", "Toastify__progress-bar--" + r, {
                            "Toastify__progress-bar--rtl": d
                        }, i),
                        y = ((t = {})[l && c ? "onTransitionEnd" : "onAnimationEnd"] = l && !c ? null : n, t);
                    return React__default.createElement("div", _extends({
                        className: f,
                        style: T
                    }, y))
                }

                function getX(e) {
                    return e.targetTouches && e.targetTouches.length >= 1 ? e.targetTouches[0].clientX : e.clientX
                }

                function getY(e) {
                    return e.targetTouches && e.targetTouches.length >= 1 ? e.targetTouches[0].clientY : e.clientY
                }

                function CloseButton(e) {
                    var t = e.closeToast,
                        o = e.type,
                        s = e.ariaLabel;
                    return React__default.createElement("button", {
                        className: "Toastify__close-button Toastify__close-button--" + o,
                        type: "button",
                        onClick: t,
                        "aria-label": s
                    }, "")
                }

                function cssTransition(e) {
                    var t = e.enter,
                        o = e.exit,
                        s = e.duration,
                        n = void 0 === s ? 750 : s,
                        r = e.appendPosition,
                        a = void 0 !== r && r;
                    return function(e) {
                        var s, r, i = e.children,
                            p = e.position,
                            l = e.preventExitTransition,
                            u = _objectWithoutPropertiesLoose(e, ["children", "position", "preventExitTransition"]),
                            c = a ? t + "--" + p : t,
                            d = a ? o + "--" + p : o;
                        return Array.isArray(n) && 2 === n.length ? (s = n[0], r = n[1]) : s = r = n, React__default.createElement(Transition, _extends({}, u, {
                            timeout: l ? 0 : {
                                enter: s,
                                exit: r
                            },
                            onEnter: function(e) {
                                e.classList.add(c), e.style.animationFillMode = "forwards", e.style.animationDuration = .001 * s + "s"
                            },
                            onEntered: function(e) {
                                e.classList.remove(c), e.style.cssText = ""
                            },
                            onExit: l ? NOOP : function(e) {
                                e.classList.add(d), e.style.animationFillMode = "forwards", e.style.animationDuration = .001 * r + "s"
                            }
                        }), i)
                    }
                }

                function mergeOptions(e, t) {
                    return _extends({}, e, {
                        type: t,
                        toastId: getToastId(e)
                    })
                }

                function generateToastId() {
                    return (Math.random().toString(36) + Date.now().toString(36)).substr(2, 10)
                }

                function getToastId(e) {
                    return e && ("string" == typeof e.toastId || "number" == typeof e.toastId && !isNaN(e.toastId)) ? e.toastId : generateToastId()
                }

                function dispatchToast(e, t) {
                    return container ? eventManager.emit(ACTION.SHOW, e, t) : (queue.push({
                        action: ACTION.SHOW,
                        content: e,
                        options: t
                    }), lazy && canUseDom && (containerDomNode = document.createElement("div"), document.body.appendChild(containerDomNode), reactDom.render(React__default.createElement(ToastContainer, containerConfig), containerDomNode))), t.toastId
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
                var _extends = _interopDefault(require("@babel/runtime/helpers/extends")),
                    _objectWithoutPropertiesLoose = _interopDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose")),
                    _inheritsLoose = _interopDefault(require("@babel/runtime/helpers/inheritsLoose")),
                    React = require("react"),
                    React__default = _interopDefault(React),
                    PropTypes = _interopDefault(require("prop-types")),
                    cx = _interopDefault(require("classnames")),
                    TransitionGroup = _interopDefault(require("react-transition-group/TransitionGroup")),
                    Transition = _interopDefault(require("react-transition-group/Transition")),
                    reactDom = require("react-dom"),
                    POSITION = {
                        TOP_LEFT: "top-left",
                        TOP_RIGHT: "top-right",
                        TOP_CENTER: "top-center",
                        BOTTOM_LEFT: "bottom-left",
                        BOTTOM_RIGHT: "bottom-right",
                        BOTTOM_CENTER: "bottom-center"
                    },
                    TYPE = {
                        INFO: "info",
                        SUCCESS: "success",
                        WARNING: "warning",
                        ERROR: "error",
                        DEFAULT: "default"
                    },
                    ACTION = {
                        SHOW: 0,
                        CLEAR: 1,
                        DID_MOUNT: 2,
                        WILL_UNMOUNT: 3,
                        ON_CHANGE: 4
                    },
                    NOOP = function() {},
                    canUseDom = !("undefined" == typeof window || !window.document || !window.document.createElement),
                    falseOrDelay = withRequired(function(e, t, o) {
                        var s = e[t];
                        return !1 === s || isValidDelay(s) ? null : new Error(o + " expect " + t + " \n      to be a valid Number > 0 or equal to false. " + s + " given.")
                    });
                ProgressBar.propTypes = {
                    delay: falseOrDelay.isRequired,
                    isRunning: PropTypes.bool.isRequired,
                    closeToast: PropTypes.func.isRequired,
                    rtl: PropTypes.bool.isRequired,
                    type: PropTypes.string,
                    hide: PropTypes.bool,
                    className: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
                    progress: PropTypes.number,
                    controlledProgress: PropTypes.bool,
                    isProgressDone: PropTypes.bool
                }, ProgressBar.defaultProps = {
                    type: TYPE.DEFAULT,
                    hide: !1
                };
                var iLoveInternetExplorer = canUseDom && /(msie|trident)/i.test(navigator.userAgent),
                    Toast = function(e) {
                        function t() {
                            for (var t, o = arguments.length, s = new Array(o), n = 0; n < o; n++) s[n] = arguments[n];
                            return (t = e.call.apply(e, [this].concat(s)) || this).state = {
                                isRunning: !0,
                                preventExitTransition: !1
                            }, t.flag = {
                                canCloseOnClick: !0,
                                canDrag: !1
                            }, t.drag = {
                                start: 0,
                                x: 0,
                                y: 0,
                                deltaX: 0,
                                removalDistance: 0
                            }, t.boundingRect = null, t.ref = null, t.pauseToast = function() {
                                t.props.autoClose && t.setState({
                                    isRunning: !1
                                })
                            }, t.playToast = function() {
                                t.props.autoClose && t.setState({
                                    isRunning: !0
                                })
                            }, t.onDragStart = function(e) {
                                t.flag.canCloseOnClick = !0, t.flag.canDrag = !0, t.boundingRect = t.ref.getBoundingClientRect(), t.ref.style.transition = "", t.drag.start = t.drag.x = getX(e.nativeEvent), t.drag.removalDistance = t.ref.offsetWidth * (t.props.draggablePercent / 100)
                            }, t.onDragMove = function(e) {
                                t.flag.canDrag && (t.state.isRunning && t.pauseToast(), t.drag.x = getX(e), t.drag.deltaX = t.drag.x - t.drag.start, t.drag.y = getY(e), t.drag.start !== t.drag.x && (t.flag.canCloseOnClick = !1), t.ref.style.transform = "translateX(" + t.drag.deltaX + "px)", t.ref.style.opacity = 1 - Math.abs(t.drag.deltaX / t.drag.removalDistance))
                            }, t.onDragEnd = function(e) {
                                if (t.flag.canDrag) {
                                    if (t.flag.canDrag = !1, Math.abs(t.drag.deltaX) > t.drag.removalDistance) return void t.setState({
                                        preventExitTransition: !0
                                    }, t.props.closeToast);
                                    t.ref.style.transition = "transform 0.2s, opacity 0.2s", t.ref.style.transform = "translateX(0)", t.ref.style.opacity = 1
                                }
                            }, t.onDragTransitionEnd = function() {
                                if (t.boundingRect) {
                                    var e = t.boundingRect,
                                        o = e.top,
                                        s = e.bottom,
                                        n = e.left,
                                        r = e.right;
                                    t.props.pauseOnHover && t.drag.x >= n && t.drag.x <= r && t.drag.y >= o && t.drag.y <= s ? t.pauseToast() : t.playToast()
                                }
                            }, t.onExitTransitionEnd = function() {
                                if (iLoveInternetExplorer) t.props.onExited();
                                else {
                                    var e = t.ref.scrollHeight,
                                        o = t.ref.style;
                                    requestAnimationFrame(function() {
                                        o.minHeight = "initial", o.height = e + "px", o.transition = "all 0.4s ", requestAnimationFrame(function() {
                                            o.height = 0, o.padding = 0, o.margin = 0
                                        }), setTimeout(function() {
                                            return t.props.onExited()
                                        }, 400)
                                    })
                                }
                            }, t
                        }
                        _inheritsLoose(t, e);
                        var o = t.prototype;
                        return o.componentDidMount = function() {
                            this.props.onOpen(this.props.children.props), this.props.draggable && this.bindDragEvents(), this.props.pauseOnFocusLoss && this.bindFocusEvents()
                        }, o.componentDidUpdate = function(e) {
                            e.draggable !== this.props.draggable && (this.props.draggable ? this.bindDragEvents() : this.unbindDragEvents()), e.pauseOnFocusLoss !== this.props.pauseOnFocusLoss && (this.props.pauseOnFocusLoss ? this.bindFocusEvents() : this.unbindFocusEvents())
                        }, o.componentWillUnmount = function() {
                            this.props.onClose(this.props.children.props), this.props.draggable && this.unbindDragEvents(), this.props.pauseOnFocusLoss && this.unbindFocusEvents()
                        }, o.bindFocusEvents = function() {
                            window.addEventListener("focus", this.playToast), window.addEventListener("blur", this.pauseToast)
                        }, o.unbindFocusEvents = function() {
                            window.removeEventListener("focus", this.playToast), window.removeEventListener("blur", this.pauseToast)
                        }, o.bindDragEvents = function() {
                            document.addEventListener("mousemove", this.onDragMove), document.addEventListener("mouseup", this.onDragEnd), document.addEventListener("touchmove", this.onDragMove), document.addEventListener("touchend", this.onDragEnd)
                        }, o.unbindDragEvents = function() {
                            document.removeEventListener("mousemove", this.onDragMove), document.removeEventListener("mouseup", this.onDragEnd), document.removeEventListener("touchmove", this.onDragMove), document.removeEventListener("touchend", this.onDragEnd)
                        }, o.render = function() {
                            var e = this,
                                t = this.props,
                                o = t.closeButton,
                                s = t.children,
                                n = t.autoClose,
                                r = t.pauseOnHover,
                                a = t.closeOnClick,
                                i = t.type,
                                p = t.hideProgressBar,
                                l = t.closeToast,
                                u = t.transition,
                                c = t.position,
                                d = t.className,
                                T = t.bodyClassName,
                                f = t.progressClassName,
                                y = t.progressStyle,
                                g = t.updateId,
                                h = t.role,
                                m = t.progress,
                                P = t.isProgressDone,
                                b = t.rtl,
                                v = {
                                    className: cx("Toastify__toast", "Toastify__toast--" + i, {
                                        "Toastify__toast--rtl": b
                                    }, d)
                                };
                            n && r && (v.onMouseEnter = this.pauseToast, v.onMouseLeave = this.playToast), a && (v.onClick = function() {
                                return e.flag.canCloseOnClick && l()
                            });
                            var O = parseFloat(m) === m;
                            return React__default.createElement(u, {
                                in: this.props.in,
                                appear: !0,
                                onExited: this.onExitTransitionEnd,
                                position: c,
                                preventExitTransition: this.state.preventExitTransition
                            }, React__default.createElement("div", _extends({}, v, {
                                ref: function(t) {
                                    return e.ref = t
                                },
                                onMouseDown: this.onDragStart,
                                onTouchStart: this.onDragStart,
                                onMouseUp: this.onDragTransitionEnd,
                                onTouchEnd: this.onDragTransitionEnd
                            }), React__default.createElement("div", _extends({}, this.props.in && {
                                role: h
                            }, {
                                className: cx("Toastify__toast-body", T)
                            }), s), o && o, (n || O) && React__default.createElement(ProgressBar, _extends({}, g && !O ? {
                                key: "pb-" + g
                            } : {}, {
                                rtl: b,
                                delay: n,
                                isRunning: this.state.isRunning,
                                closeToast: l,
                                hide: p,
                                type: i,
                                style: y,
                                className: f,
                                controlledProgress: O,
                                isProgressDone: P,
                                progress: m
                            }))))
                        }, t
                    }(React.Component);
                Toast.propTypes = {
                    closeButton: PropTypes.oneOfType([PropTypes.node, PropTypes.bool]).isRequired,
                    autoClose: falseOrDelay.isRequired,
                    children: PropTypes.node.isRequired,
                    closeToast: PropTypes.func.isRequired,
                    position: PropTypes.oneOf(objectValues(POSITION)).isRequired,
                    pauseOnHover: PropTypes.bool.isRequired,
                    pauseOnFocusLoss: PropTypes.bool.isRequired,
                    closeOnClick: PropTypes.bool.isRequired,
                    transition: PropTypes.func.isRequired,
                    rtl: PropTypes.bool.isRequired,
                    hideProgressBar: PropTypes.bool.isRequired,
                    draggable: PropTypes.bool.isRequired,
                    draggablePercent: PropTypes.number.isRequired,
                    in: PropTypes.bool,
                    onExited: PropTypes.func,
                    onOpen: PropTypes.func,
                    onClose: PropTypes.func,
                    type: PropTypes.oneOf(objectValues(TYPE)),
                    className: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
                    bodyClassName: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
                    progressClassName: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
                    progressStyle: PropTypes.object,
                    progress: PropTypes.number,
                    isProgressDone: PropTypes.bool,
                    updateId: PropTypes.oneOfType([PropTypes.string, PropTypes.number]),
                    ariaLabel: PropTypes.string,
                    containerId: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
                }, Toast.defaultProps = {
                    type: TYPE.DEFAULT,
                    in: !0,
                    onOpen: NOOP,
                    onClose: NOOP,
                    className: null,
                    bodyClassName: null,
                    progressClassName: null,
                    updateId: null,
                    role: "alert"
                }, CloseButton.propTypes = {
                    closeToast: PropTypes.func,
                    arialLabel: PropTypes.string
                }, CloseButton.defaultProps = {
                    ariaLabel: "close"
                };
                var Bounce = cssTransition({
                        enter: "Toastify__bounce-enter",
                        exit: "Toastify__bounce-exit",
                        appendPosition: !0
                    }),
                    Slide = cssTransition({
                        enter: "Toastify__slide-enter",
                        exit: "Toastify__slide-exit",
                        duration: [450, 750],
                        appendPosition: !0
                    }),
                    Zoom = cssTransition({
                        enter: "Toastify__zoom-enter",
                        exit: "Toastify__zoom-exit"
                    }),
                    Flip = cssTransition({
                        enter: "Toastify__flip-enter",
                        exit: "Toastify__flip-exit"
                    }),
                    eventManager = {
                        list: new Map,
                        on: function(e, t) {
                            return this.list.has(e) || this.list.set(e, []), this.list.get(e).push(t), this
                        },
                        off: function(e) {
                            return this.list.delete(e), this
                        },
                        emit: function(e) {
                            for (var t = arguments.length, o = new Array(t > 1 ? t - 1 : 0), s = 1; s < t; s++) o[s - 1] = arguments[s];
                            this.list.has(e) && this.list.get(e).forEach(function(e) {
                                return setTimeout(function() {
                                    e.apply(void 0, o)
                                }, 0)
                            })
                        }
                    },
                    ToastContainer = function(e) {
                        function t() {
                            for (var t, o = arguments.length, s = new Array(o), n = 0; n < o; n++) s[n] = arguments[n];
                            return (t = e.call.apply(e, [this].concat(s)) || this).state = {
                                toast: []
                            }, t.toastKey = 1, t.collection = {}, t.isToastActive = function(e) {
                                return -1 !== t.state.toast.indexOf(e)
                            }, t
                        }
                        _inheritsLoose(t, e);
                        var o = t.prototype;
                        return o.componentDidMount = function() {
                            var e = this;
                            eventManager.on(ACTION.SHOW, function(t, o) {
                                return e.buildToast(t, o)
                            }).on(ACTION.CLEAR, function(t) {
                                return null == t ? e.clear() : e.removeToast(t)
                            }).emit(ACTION.DID_MOUNT, this)
                        }, o.componentWillUnmount = function() {
                            eventManager.off(ACTION.SHOW).off(ACTION.CLEAR).emit(ACTION.WILL_UNMOUNT)
                        }, o.removeToast = function(e) {
                            this.setState({
                                toast: this.state.toast.filter(function(t) {
                                    return t !== e
                                })
                            }, this.dispatchChange)
                        }, o.dispatchChange = function() {
                            eventManager.emit(ACTION.ON_CHANGE, this.state.toast.length)
                        }, o.makeCloseButton = function(e, t, o) {
                            var s = this,
                                n = this.props.closeButton;
                            return React.isValidElement(e) || !1 === e ? n = e : !0 === e && (n = React__default.createElement(CloseButton, null)), !1 !== n && React.cloneElement(n, {
                                closeToast: function() {
                                    return s.removeToast(t)
                                },
                                type: o
                            })
                        }, o.getAutoCloseDelay = function(e) {
                            return !1 === e || isValidDelay(e) ? e : this.props.autoClose
                        }, o.canBeRendered = function(e) {
                            return React.isValidElement(e) || "string" == typeof e || "number" == typeof e || "function" == typeof e
                        }, o.parseClassName = function(e) {
                            return "string" == typeof e ? e : null !== e && "object" == _typeof2(e) && "toString" in e ? e.toString() : null
                        }, o.belongToContainer = function(e) {
                            return e.containerId === this.props.containerId
                        }, o.buildToast = function(e, t) {
                            var o = this,
                                s = t.delay,
                                n = _objectWithoutPropertiesLoose(t, ["delay"]);
                            if (!this.canBeRendered(e)) throw new Error("The element you provided cannot be rendered. You provided an element of type " + _typeof2(e));
                            if (this.props.enableMultiContainer && !this.belongToContainer(n)) return null;
                            var r = n.toastId,
                                a = function() {
                                    return o.removeToast(r)
                                },
                                i = {
                                    id: r,
                                    key: n.key || this.toastKey++,
                                    type: n.type,
                                    closeToast: a,
                                    updateId: n.updateId,
                                    rtl: this.props.rtl,
                                    position: n.position || this.props.position,
                                    transition: n.transition || this.props.transition,
                                    className: this.parseClassName(n.className || this.props.toastClassName),
                                    bodyClassName: this.parseClassName(n.bodyClassName || this.props.bodyClassName),
                                    closeButton: this.makeCloseButton(n.closeButton, r, n.type),
                                    pauseOnHover: "boolean" == typeof n.pauseOnHover ? n.pauseOnHover : this.props.pauseOnHover,
                                    pauseOnFocusLoss: "boolean" == typeof n.pauseOnFocusLoss ? n.pauseOnFocusLoss : this.props.pauseOnFocusLoss,
                                    draggable: "boolean" == typeof n.draggable ? n.draggable : this.props.draggable,
                                    draggablePercent: "number" != typeof n.draggablePercent || isNaN(n.draggablePercent) ? this.props.draggablePercent : n.draggablePercent,
                                    closeOnClick: "boolean" == typeof n.closeOnClick ? n.closeOnClick : this.props.closeOnClick,
                                    progressClassName: this.parseClassName(n.progressClassName || this.props.progressClassName),
                                    progressStyle: this.props.progressStyle,
                                    autoClose: this.getAutoCloseDelay(n.autoClose),
                                    hideProgressBar: "boolean" == typeof n.hideProgressBar ? n.hideProgressBar : this.props.hideProgressBar,
                                    progress: parseFloat(n.progress),
                                    isProgressDone: n.isProgressDone
                                };
                            "function" == typeof n.onOpen && (i.onOpen = n.onOpen), "function" == typeof n.onClose && (i.onClose = n.onClose), React.isValidElement(e) && "string" != typeof e.type && "number" != typeof e.type ? e = React.cloneElement(e, {
                                closeToast: a
                            }) : "function" == typeof e && (e = e({
                                closeToast: a
                            })), isValidDelay(s) ? setTimeout(function() {
                                o.appendToast(i, e, n.staleToastId)
                            }, s) : this.appendToast(i, e, n.staleToastId)
                        }, o.appendToast = function(e, t, o) {
                            var s, n = e.id,
                                r = e.updateId;
                            this.collection = _extends({}, this.collection, ((s = {})[n] = {
                                options: e,
                                content: t,
                                position: e.position
                            }, s)), this.setState({
                                toast: (r ? [].concat(this.state.toast) : [].concat(this.state.toast, [n])).filter(function(e) {
                                    return e !== o
                                })
                            }, this.dispatchChange)
                        }, o.clear = function() {
                            this.setState({
                                toast: []
                            })
                        }, o.renderToast = function() {
                            var e = this,
                                t = {},
                                o = this.props,
                                s = o.className,
                                n = o.style;
                            return (o.newestOnTop ? Object.keys(this.collection).reverse() : Object.keys(this.collection)).forEach(function(o) {
                                var s = e.collection[o],
                                    n = s.position,
                                    r = s.options,
                                    a = s.content;
                                t[n] || (t[n] = []), -1 !== e.state.toast.indexOf(r.id) ? t[n].push(React__default.createElement(Toast, _extends({}, r, {
                                    isDocumentHidden: e.state.isDocumentHidden,
                                    key: "toast-" + r.key
                                }), a)) : (t[n].push(null), delete e.collection[o])
                            }), Object.keys(t).map(function(o) {
                                var r = 1 === t[o].length && null === t[o][0],
                                    a = {
                                        className: cx("Toastify__toast-container", "Toastify__toast-container--" + o, {
                                            "Toastify__toast-container--rtl": e.props.rtl
                                        }, e.parseClassName(s)),
                                        style: r ? _extends({}, n, {
                                            pointerEvents: "none"
                                        }) : _extends({}, n)
                                    };
                                return React__default.createElement(TransitionGroup, _extends({}, a, {
                                    key: "container-" + o
                                }), t[o])
                            })
                        }, o.render = function() {
                            return React__default.createElement("div", {
                                className: "Toastify"
                            }, this.renderToast())
                        }, t
                    }(React.Component);
                ToastContainer.propTypes = {
                    position: PropTypes.oneOf(objectValues(POSITION)),
                    autoClose: falseOrDelay,
                    closeButton: PropTypes.oneOfType([PropTypes.node, PropTypes.bool]),
                    hideProgressBar: PropTypes.bool,
                    pauseOnHover: PropTypes.bool,
                    closeOnClick: PropTypes.bool,
                    newestOnTop: PropTypes.bool,
                    className: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
                    style: PropTypes.object,
                    toastClassName: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
                    bodyClassName: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
                    progressClassName: PropTypes.oneOfType([PropTypes.string, PropTypes.object]),
                    progressStyle: PropTypes.object,
                    transition: PropTypes.func,
                    rtl: PropTypes.bool,
                    draggable: PropTypes.bool,
                    draggablePercent: PropTypes.number,
                    pauseOnFocusLoss: PropTypes.bool,
                    enableMultiContainer: PropTypes.bool,
                    containerId: PropTypes.oneOfType([PropTypes.string, PropTypes.number])
                }, ToastContainer.defaultProps = {
                    position: POSITION.TOP_RIGHT,
                    transition: Bounce,
                    rtl: !1,
                    autoClose: 5e3,
                    hideProgressBar: !1,
                    closeButton: React__default.createElement(CloseButton, null),
                    pauseOnHover: !0,
                    pauseOnFocusLoss: !0,
                    closeOnClick: !0,
                    newestOnTop: !1,
                    draggable: !0,
                    draggablePercent: 80,
                    className: null,
                    style: null,
                    toastClassName: null,
                    bodyClassName: null,
                    progressClassName: null,
                    progressStyle: null
                };
                var container = null,
                    containerDomNode = null,
                    containerConfig = {},
                    queue = [],
                    lazy = !1,
                    toast = function(e, t) {
                        return dispatchToast(e, mergeOptions(t, t && t.type || TYPE.DEFAULT))
                    },
                    _loop = function(e) {
                        TYPE[e] !== TYPE.DEFAULT && (toast[TYPE[e].toLowerCase()] = function(t, o) {
                            return dispatchToast(t, mergeOptions(o, o && o.type || TYPE[e]))
                        })
                    };
                for (var pos in TYPE) _loop(pos);
                toast.warn = toast.warning, toast.dismiss = function(e) {
                    return void 0 === e && (e = null), container && eventManager.emit(ACTION.CLEAR, e)
                }, toast.isActive = NOOP, toast.update = function(e, t) {
                    setTimeout(function() {
                        if (container && void 0 !== container.collection[e]) {
                            var o = container.collection[e],
                                s = o.options,
                                n = o.content,
                                r = _extends({}, s, t, {
                                    toastId: t.toastId || e
                                });
                            t.toastId && t.toastId !== e ? r.staleToastId = e : r.updateId = generateToastId();
                            var a = void 0 !== r.render ? r.render : n;
                            delete r.render, dispatchToast(a, r)
                        }
                    }, 0)
                }, toast.done = function(e, t) {
                    void 0 === t && (t = 1), toast.update(e, {
                        progress: t,
                        isProgressDone: !0
                    })
                }, toast.onChange = function(e) {
                    "function" == typeof e && eventManager.on(ACTION.ON_CHANGE, e)
                }, toast.configure = function(e) {
                    lazy = !0, containerConfig = e
                }, toast.POSITION = POSITION, toast.TYPE = TYPE, eventManager.on(ACTION.DID_MOUNT, function(e) {
                    container = e, toast.isActive = function(e) {
                        return container.isToastActive(e)
                    }, queue.forEach(function(e) {
                        eventManager.emit(e.action, e.content, e.options)
                    }), queue = []
                }).on(ACTION.WILL_UNMOUNT, function() {
                    container = null, toast.isActive = NOOP, canUseDom && containerDomNode && document.body.removeChild(containerDomNode)
                }), exports.Bounce = Bounce, exports.Flip = Flip, exports.Slide = Slide, exports.ToastContainer = ToastContainer, exports.ToastPosition = POSITION, exports.ToastType = TYPE, exports.Zoom = Zoom, exports.cssTransition = cssTransition, exports.toast = toast
            }, {
                "@babel/runtime/helpers/extends": 40,
                "@babel/runtime/helpers/inheritsLoose": 41,
                "@babel/runtime/helpers/objectWithoutPropertiesLoose": 42,
                classnames: 443,
                "prop-types": 445,
                react: 455,
                "react-dom": 438,
                "react-transition-group/Transition": 447,
                "react-transition-group/TransitionGroup": 448
            }],
            441: [function(require, module, exports) {
                "use strict";

                function _interopDefault(t) {
                    return t && "object" == _typeof2(t) && "default" in t ? t.default : t
                }

                function isValidDelay(t) {
                    return "number" == typeof t && !isNaN(t) && 0 < t
                }

                function withRequired(t) {
                    return t.isRequired = function(e, n, o) {
                        return void 0 === e[n] ? new Error("The prop " + n + " is marked as required in \n      " + o + ", but its value is undefined.") : void t(e, n, o)
                    }, t
                }

                function ProgressBar(t) {
                    var e, n = t.delay,
                        o = t.isRunning,
                        s = t.closeToast,
                        a = t.type,
                        r = t.hide,
                        i = t.className,
                        l = t.style,
                        u = t.controlledProgress,
                        c = t.progress,
                        p = t.isProgressDone,
                        d = t.rtl,
                        f = _extends({}, l, {
                            animationDuration: n + "ms",
                            animationPlayState: o ? "running" : "paused",
                            opacity: r ? 0 : 1,
                            transform: u ? "scaleX(" + c + ")" : null
                        }),
                        g = cx("Toastify__progress-bar", u ? "Toastify__progress-bar--controlled" : "Toastify__progress-bar--animated", "Toastify__progress-bar--" + a, {
                            "Toastify__progress-bar--rtl": d
                        }, i),
                        h = ((e = {})[u && p ? "onTransitionEnd" : "onAnimationEnd"] = u && !p ? null : s, e);
                    return React__default.createElement("div", _extends({
                        className: g,
                        style: f
                    }, h))
                }

                function getX(t) {
                    return t.targetTouches && 1 <= t.targetTouches.length ? t.targetTouches[0].clientX : t.clientX
                }

                function getY(t) {
                    return t.targetTouches && 1 <= t.targetTouches.length ? t.targetTouches[0].clientY : t.clientY
                }

                function CloseButton(t) {
                    var e = t.closeToast,
                        n = t.type,
                        o = t.ariaLabel;
                    return React__default.createElement("button", {
                        className: "Toastify__close-button Toastify__close-button--" + n,
                        type: "button",
                        onClick: e,
                        "aria-label": o
                    }, "")
                }

                function cssTransition(t) {
                    var e = t.enter,
                        n = t.exit,
                        o = t.duration,
                        s = void 0 === o ? 750 : o,
                        a = t.appendPosition,
                        r = void 0 !== a && a;
                    return function(t) {
                        var o, a, i = t.children,
                            l = t.position,
                            u = t.preventExitTransition,
                            c = _objectWithoutPropertiesLoose(t, ["children", "position", "preventExitTransition"]),
                            p = r ? e + "--" + l : e,
                            d = r ? n + "--" + l : n;
                        return Array.isArray(s) && 2 === s.length ? (o = s[0], a = s[1]) : o = a = s, React__default.createElement(Transition, _extends({}, c, {
                            timeout: u ? 0 : {
                                enter: o,
                                exit: a
                            },
                            onEnter: function(t) {
                                t.classList.add(p), t.style.animationFillMode = "forwards", t.style.animationDuration = .001 * o + "s"
                            },
                            onEntered: function(t) {
                                t.classList.remove(p), t.style.cssText = ""
                            },
                            onExit: u ? NOOP : function(t) {
                                t.classList.add(d), t.style.animationFillMode = "forwards", t.style.animationDuration = .001 * a + "s"
                            }
                        }), i)
                    }
                }

                function mergeOptions(t, e) {
                    return _extends({}, t, {
                        type: e,
                        toastId: getToastId(t)
                    })
                }

                function generateToastId() {
                    return (Math.random().toString(36) + Date.now().toString(36)).substr(2, 10)
                }

                function getToastId(t) {
                    return t && ("string" == typeof t.toastId || "number" == typeof t.toastId && !isNaN(t.toastId)) ? t.toastId : generateToastId()
                }

                function dispatchToast(t, e) {
                    return container ? eventManager.emit(ACTION.SHOW, t, e) : (queue.push({
                        action: ACTION.SHOW,
                        content: t,
                        options: e
                    }), lazy && canUseDom && (containerDomNode = document.createElement("div"), document.body.appendChild(containerDomNode), reactDom.render(React__default.createElement(ToastContainer, containerConfig), containerDomNode))), e.toastId
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
                var _extends = _interopDefault(require("@babel/runtime/helpers/extends")),
                    _objectWithoutPropertiesLoose = _interopDefault(require("@babel/runtime/helpers/objectWithoutPropertiesLoose")),
                    _inheritsLoose = _interopDefault(require("@babel/runtime/helpers/inheritsLoose")),
                    React = require("react"),
                    React__default = _interopDefault(React),
                    cx = _interopDefault(require("classnames")),
                    TransitionGroup = _interopDefault(require("react-transition-group/TransitionGroup")),
                    Transition = _interopDefault(require("react-transition-group/Transition")),
                    reactDom = require("react-dom"),
                    POSITION = {
                        TOP_LEFT: "top-left",
                        TOP_RIGHT: "top-right",
                        TOP_CENTER: "top-center",
                        BOTTOM_LEFT: "bottom-left",
                        BOTTOM_RIGHT: "bottom-right",
                        BOTTOM_CENTER: "bottom-center"
                    },
                    TYPE = {
                        INFO: "info",
                        SUCCESS: "success",
                        WARNING: "warning",
                        ERROR: "error",
                        DEFAULT: "default"
                    },
                    ACTION = {
                        SHOW: 0,
                        CLEAR: 1,
                        DID_MOUNT: 2,
                        WILL_UNMOUNT: 3,
                        ON_CHANGE: 4
                    },
                    NOOP = function() {},
                    canUseDom = !("undefined" == typeof window || !window.document || !window.document.createElement);
                withRequired(function(t, e, n) {
                    var o = t[e];
                    return !1 === o || isValidDelay(o) ? null : new Error(n + " expect " + e + " \n      to be a valid Number > 0 or equal to false. " + o + " given.")
                });
                ProgressBar.defaultProps = {
                    type: TYPE.DEFAULT,
                    hide: !1
                };
                var iLoveInternetExplorer = canUseDom && /(msie|trident)/i.test(navigator.userAgent),
                    Toast = function(t) {
                        function e() {
                            for (var e, n = arguments.length, o = new Array(n), s = 0; s < n; s++) o[s] = arguments[s];
                            return (e = t.call.apply(t, [this].concat(o)) || this).state = {
                                isRunning: !0,
                                preventExitTransition: !1
                            }, e.flag = {
                                canCloseOnClick: !0,
                                canDrag: !1
                            }, e.drag = {
                                start: 0,
                                x: 0,
                                y: 0,
                                deltaX: 0,
                                removalDistance: 0
                            }, e.boundingRect = null, e.ref = null, e.pauseToast = function() {
                                e.props.autoClose && e.setState({
                                    isRunning: !1
                                })
                            }, e.playToast = function() {
                                e.props.autoClose && e.setState({
                                    isRunning: !0
                                })
                            }, e.onDragStart = function(t) {
                                e.flag.canCloseOnClick = !0, e.flag.canDrag = !0, e.boundingRect = e.ref.getBoundingClientRect(), e.ref.style.transition = "", e.drag.start = e.drag.x = getX(t.nativeEvent), e.drag.removalDistance = e.ref.offsetWidth * (e.props.draggablePercent / 100)
                            }, e.onDragMove = function(t) {
                                e.flag.canDrag && (e.state.isRunning && e.pauseToast(), e.drag.x = getX(t), e.drag.deltaX = e.drag.x - e.drag.start, e.drag.y = getY(t), e.drag.start !== e.drag.x && (e.flag.canCloseOnClick = !1), e.ref.style.transform = "translateX(" + e.drag.deltaX + "px)", e.ref.style.opacity = 1 - Math.abs(e.drag.deltaX / e.drag.removalDistance))
                            }, e.onDragEnd = function(t) {
                                if (e.flag.canDrag) {
                                    if (e.flag.canDrag = !1, Math.abs(e.drag.deltaX) > e.drag.removalDistance) return void e.setState({
                                        preventExitTransition: !0
                                    }, e.props.closeToast);
                                    e.ref.style.transition = "transform 0.2s, opacity 0.2s", e.ref.style.transform = "translateX(0)", e.ref.style.opacity = 1
                                }
                            }, e.onDragTransitionEnd = function() {
                                if (e.boundingRect) {
                                    var t = e.boundingRect,
                                        n = t.top,
                                        o = t.bottom,
                                        s = t.left,
                                        a = t.right;
                                    e.props.pauseOnHover && e.drag.x >= s && e.drag.x <= a && e.drag.y >= n && e.drag.y <= o ? e.pauseToast() : e.playToast()
                                }
                            }, e.onExitTransitionEnd = function() {
                                if (iLoveInternetExplorer) e.props.onExited();
                                else {
                                    var t = e.ref.scrollHeight,
                                        n = e.ref.style;
                                    requestAnimationFrame(function() {
                                        n.minHeight = "initial", n.height = t + "px", n.transition = "all 0.4s ", requestAnimationFrame(function() {
                                            n.height = 0, n.padding = 0, n.margin = 0
                                        }), setTimeout(function() {
                                            return e.props.onExited()
                                        }, 400)
                                    })
                                }
                            }, e
                        }
                        _inheritsLoose(e, t);
                        var n = e.prototype;
                        return n.componentDidMount = function() {
                            this.props.onOpen(this.props.children.props), this.props.draggable && this.bindDragEvents(), this.props.pauseOnFocusLoss && this.bindFocusEvents()
                        }, n.componentDidUpdate = function(t) {
                            t.draggable !== this.props.draggable && (this.props.draggable ? this.bindDragEvents() : this.unbindDragEvents()), t.pauseOnFocusLoss !== this.props.pauseOnFocusLoss && (this.props.pauseOnFocusLoss ? this.bindFocusEvents() : this.unbindFocusEvents())
                        }, n.componentWillUnmount = function() {
                            this.props.onClose(this.props.children.props), this.props.draggable && this.unbindDragEvents(), this.props.pauseOnFocusLoss && this.unbindFocusEvents()
                        }, n.bindFocusEvents = function() {
                            window.addEventListener("focus", this.playToast), window.addEventListener("blur", this.pauseToast)
                        }, n.unbindFocusEvents = function() {
                            window.removeEventListener("focus", this.playToast), window.removeEventListener("blur", this.pauseToast)
                        }, n.bindDragEvents = function() {
                            document.addEventListener("mousemove", this.onDragMove), document.addEventListener("mouseup", this.onDragEnd), document.addEventListener("touchmove", this.onDragMove), document.addEventListener("touchend", this.onDragEnd)
                        }, n.unbindDragEvents = function() {
                            document.removeEventListener("mousemove", this.onDragMove), document.removeEventListener("mouseup", this.onDragEnd), document.removeEventListener("touchmove", this.onDragMove), document.removeEventListener("touchend", this.onDragEnd)
                        }, n.render = function() {
                            var t = this,
                                e = this.props,
                                n = e.closeButton,
                                o = e.children,
                                s = e.autoClose,
                                a = e.pauseOnHover,
                                r = e.closeOnClick,
                                i = e.type,
                                l = e.hideProgressBar,
                                u = e.closeToast,
                                c = e.transition,
                                p = e.position,
                                d = e.className,
                                f = e.bodyClassName,
                                g = e.progressClassName,
                                h = e.progressStyle,
                                T = e.updateId,
                                m = e.role,
                                y = e.progress,
                                v = e.isProgressDone,
                                _ = e.rtl,
                                E = {
                                    className: cx("Toastify__toast", "Toastify__toast--" + i, {
                                        "Toastify__toast--rtl": _
                                    }, d)
                                };
                            s && a && (E.onMouseEnter = this.pauseToast, E.onMouseLeave = this.playToast), r && (E.onClick = function() {
                                return t.flag.canCloseOnClick && u()
                            });
                            var O = parseFloat(y) === y;
                            return React__default.createElement(c, {
                                in: this.props.in,
                                appear: !0,
                                onExited: this.onExitTransitionEnd,
                                position: p,
                                preventExitTransition: this.state.preventExitTransition
                            }, React__default.createElement("div", _extends({}, E, {
                                ref: function(e) {
                                    return t.ref = e
                                },
                                onMouseDown: this.onDragStart,
                                onTouchStart: this.onDragStart,
                                onMouseUp: this.onDragTransitionEnd,
                                onTouchEnd: this.onDragTransitionEnd
                            }), React__default.createElement("div", _extends({}, this.props.in && {
                                role: m
                            }, {
                                className: cx("Toastify__toast-body", f)
                            }), o), n && n, (s || O) && React__default.createElement(ProgressBar, _extends({}, T && !O ? {
                                key: "pb-" + T
                            } : {}, {
                                rtl: _,
                                delay: s,
                                isRunning: this.state.isRunning,
                                closeToast: u,
                                hide: l,
                                type: i,
                                style: h,
                                className: g,
                                controlledProgress: O,
                                isProgressDone: v,
                                progress: y
                            }))))
                        }, e
                    }(React.Component);
                Toast.defaultProps = {
                    type: TYPE.DEFAULT,
                    in: !0,
                    onOpen: NOOP,
                    onClose: NOOP,
                    className: null,
                    bodyClassName: null,
                    progressClassName: null,
                    updateId: null,
                    role: "alert"
                }, CloseButton.defaultProps = {
                    ariaLabel: "close"
                };
                var Bounce = cssTransition({
                        enter: "Toastify__bounce-enter",
                        exit: "Toastify__bounce-exit",
                        appendPosition: !0
                    }),
                    Slide = cssTransition({
                        enter: "Toastify__slide-enter",
                        exit: "Toastify__slide-exit",
                        duration: [450, 750],
                        appendPosition: !0
                    }),
                    Zoom = cssTransition({
                        enter: "Toastify__zoom-enter",
                        exit: "Toastify__zoom-exit"
                    }),
                    Flip = cssTransition({
                        enter: "Toastify__flip-enter",
                        exit: "Toastify__flip-exit"
                    }),
                    eventManager = {
                        list: new Map,
                        on: function(t, e) {
                            return this.list.has(t) || this.list.set(t, []), this.list.get(t).push(e), this
                        },
                        off: function(t) {
                            return this.list.delete(t), this
                        },
                        emit: function(t) {
                            for (var e = arguments.length, n = new Array(1 < e ? e - 1 : 0), o = 1; o < e; o++) n[o - 1] = arguments[o];
                            this.list.has(t) && this.list.get(t).forEach(function(t) {
                                return setTimeout(function() {
                                    t.apply(void 0, n)
                                }, 0)
                            })
                        }
                    },
                    ToastContainer = function(t) {
                        function e() {
                            for (var e, n = arguments.length, o = new Array(n), s = 0; s < n; s++) o[s] = arguments[s];
                            return (e = t.call.apply(t, [this].concat(o)) || this).state = {
                                toast: []
                            }, e.toastKey = 1, e.collection = {}, e.isToastActive = function(t) {
                                return -1 !== e.state.toast.indexOf(t)
                            }, e
                        }
                        _inheritsLoose(e, t);
                        var n = e.prototype;
                        return n.componentDidMount = function() {
                            var t = this;
                            eventManager.on(ACTION.SHOW, function(e, n) {
                                return t.buildToast(e, n)
                            }).on(ACTION.CLEAR, function(e) {
                                return null == e ? t.clear() : t.removeToast(e)
                            }).emit(ACTION.DID_MOUNT, this)
                        }, n.componentWillUnmount = function() {
                            eventManager.off(ACTION.SHOW).off(ACTION.CLEAR).emit(ACTION.WILL_UNMOUNT)
                        }, n.removeToast = function(t) {
                            this.setState({
                                toast: this.state.toast.filter(function(e) {
                                    return e !== t
                                })
                            }, this.dispatchChange)
                        }, n.dispatchChange = function() {
                            eventManager.emit(ACTION.ON_CHANGE, this.state.toast.length)
                        }, n.makeCloseButton = function(t, e, n) {
                            var o = this,
                                s = this.props.closeButton;
                            return React.isValidElement(t) || !1 === t ? s = t : !0 === t && (s = React__default.createElement(CloseButton, null)), !1 !== s && React.cloneElement(s, {
                                closeToast: function() {
                                    return o.removeToast(e)
                                },
                                type: n
                            })
                        }, n.getAutoCloseDelay = function(t) {
                            return !1 === t || isValidDelay(t) ? t : this.props.autoClose
                        }, n.canBeRendered = function(t) {
                            return React.isValidElement(t) || "string" == typeof t || "number" == typeof t || "function" == typeof t
                        }, n.parseClassName = function(t) {
                            return "string" == typeof t ? t : null !== t && "object" == _typeof2(t) && "toString" in t ? t.toString() : null
                        }, n.belongToContainer = function(t) {
                            return t.containerId === this.props.containerId
                        }, n.buildToast = function(t, e) {
                            var n = this,
                                o = e.delay,
                                s = _objectWithoutPropertiesLoose(e, ["delay"]);
                            if (!this.canBeRendered(t)) throw new Error("The element you provided cannot be rendered. You provided an element of type " + _typeof2(t));
                            if (this.props.enableMultiContainer && !this.belongToContainer(s)) return null;
                            var a = s.toastId,
                                r = function() {
                                    return n.removeToast(a)
                                },
                                i = {
                                    id: a,
                                    key: s.key || this.toastKey++,
                                    type: s.type,
                                    closeToast: r,
                                    updateId: s.updateId,
                                    rtl: this.props.rtl,
                                    position: s.position || this.props.position,
                                    transition: s.transition || this.props.transition,
                                    className: this.parseClassName(s.className || this.props.toastClassName),
                                    bodyClassName: this.parseClassName(s.bodyClassName || this.props.bodyClassName),
                                    closeButton: this.makeCloseButton(s.closeButton, a, s.type),
                                    pauseOnHover: "boolean" == typeof s.pauseOnHover ? s.pauseOnHover : this.props.pauseOnHover,
                                    pauseOnFocusLoss: "boolean" == typeof s.pauseOnFocusLoss ? s.pauseOnFocusLoss : this.props.pauseOnFocusLoss,
                                    draggable: "boolean" == typeof s.draggable ? s.draggable : this.props.draggable,
                                    draggablePercent: "number" != typeof s.draggablePercent || isNaN(s.draggablePercent) ? this.props.draggablePercent : s.draggablePercent,
                                    closeOnClick: "boolean" == typeof s.closeOnClick ? s.closeOnClick : this.props.closeOnClick,
                                    progressClassName: this.parseClassName(s.progressClassName || this.props.progressClassName),
                                    progressStyle: this.props.progressStyle,
                                    autoClose: this.getAutoCloseDelay(s.autoClose),
                                    hideProgressBar: "boolean" == typeof s.hideProgressBar ? s.hideProgressBar : this.props.hideProgressBar,
                                    progress: parseFloat(s.progress),
                                    isProgressDone: s.isProgressDone
                                };
                            "function" == typeof s.onOpen && (i.onOpen = s.onOpen), "function" == typeof s.onClose && (i.onClose = s.onClose), React.isValidElement(t) && "string" != typeof t.type && "number" != typeof t.type ? t = React.cloneElement(t, {
                                closeToast: r
                            }) : "function" == typeof t && (t = t({
                                closeToast: r
                            })), isValidDelay(o) ? setTimeout(function() {
                                n.appendToast(i, t, s.staleToastId)
                            }, o) : this.appendToast(i, t, s.staleToastId)
                        }, n.appendToast = function(t, e, n) {
                            var o, s = t.id,
                                a = t.updateId;
                            this.collection = _extends({}, this.collection, ((o = {})[s] = {
                                options: t,
                                content: e,
                                position: t.position
                            }, o)), this.setState({
                                toast: (a ? [].concat(this.state.toast) : [].concat(this.state.toast, [s])).filter(function(t) {
                                    return t !== n
                                })
                            }, this.dispatchChange)
                        }, n.clear = function() {
                            this.setState({
                                toast: []
                            })
                        }, n.renderToast = function() {
                            var t = this,
                                e = {},
                                n = this.props,
                                o = n.className,
                                s = n.style;
                            return (n.newestOnTop ? Object.keys(this.collection).reverse() : Object.keys(this.collection)).forEach(function(n) {
                                var o = t.collection[n],
                                    s = o.position,
                                    a = o.options,
                                    r = o.content;
                                e[s] || (e[s] = []), -1 !== t.state.toast.indexOf(a.id) ? e[s].push(React__default.createElement(Toast, _extends({}, a, {
                                    isDocumentHidden: t.state.isDocumentHidden,
                                    key: "toast-" + a.key
                                }), r)) : (e[s].push(null), delete t.collection[n])
                            }), Object.keys(e).map(function(n) {
                                var a = 1 === e[n].length && null === e[n][0],
                                    r = {
                                        className: cx("Toastify__toast-container", "Toastify__toast-container--" + n, {
                                            "Toastify__toast-container--rtl": t.props.rtl
                                        }, t.parseClassName(o)),
                                        style: a ? _extends({}, s, {
                                            pointerEvents: "none"
                                        }) : _extends({}, s)
                                    };
                                return React__default.createElement(TransitionGroup, _extends({}, r, {
                                    key: "container-" + n
                                }), e[n])
                            })
                        }, n.render = function() {
                            return React__default.createElement("div", {
                                className: "Toastify"
                            }, this.renderToast())
                        }, e
                    }(React.Component);
                ToastContainer.defaultProps = {
                    position: POSITION.TOP_RIGHT,
                    transition: Bounce,
                    rtl: !1,
                    autoClose: 5e3,
                    hideProgressBar: !1,
                    closeButton: React__default.createElement(CloseButton, null),
                    pauseOnHover: !0,
                    pauseOnFocusLoss: !0,
                    closeOnClick: !0,
                    newestOnTop: !1,
                    draggable: !0,
                    draggablePercent: 80,
                    className: null,
                    style: null,
                    toastClassName: null,
                    bodyClassName: null,
                    progressClassName: null,
                    progressStyle: null
                };
                var container = null,
                    containerDomNode = null,
                    containerConfig = {},
                    queue = [],
                    lazy = !1,
                    toast = function(t, e) {
                        return dispatchToast(t, mergeOptions(e, e && e.type || TYPE.DEFAULT))
                    },
                    _loop = function(t) {
                        TYPE[t] !== TYPE.DEFAULT && (toast[TYPE[t].toLowerCase()] = function(e, n) {
                            return dispatchToast(e, mergeOptions(n, n && n.type || TYPE[t]))
                        })
                    };
                for (var pos in TYPE) _loop(pos);
                toast.warn = toast.warning, toast.dismiss = function(t) {
                    return void 0 === t && (t = null), container && eventManager.emit(ACTION.CLEAR, t)
                }, toast.isActive = NOOP, toast.update = function(t, e) {
                    setTimeout(function() {
                        if (container && void 0 !== container.collection[t]) {
                            var n = container.collection[t],
                                o = n.options,
                                s = n.content,
                                a = _extends({}, o, e, {
                                    toastId: e.toastId || t
                                });
                            e.toastId && e.toastId !== t ? a.staleToastId = t : a.updateId = generateToastId();
                            var r = void 0 !== a.render ? a.render : s;
                            delete a.render, dispatchToast(r, a)
                        }
                    }, 0)
                }, toast.done = function(t, e) {
                    void 0 === e && (e = 1), toast.update(t, {
                        progress: e,
                        isProgressDone: !0
                    })
                }, toast.onChange = function(t) {
                    "function" == typeof t && eventManager.on(ACTION.ON_CHANGE, t)
                }, toast.configure = function(t) {
                    lazy = !0, containerConfig = t
                }, toast.POSITION = POSITION, toast.TYPE = TYPE, eventManager.on(ACTION.DID_MOUNT, function(t) {
                    container = t, toast.isActive = function(t) {
                        return container.isToastActive(t)
                    }, queue.forEach(function(t) {
                        eventManager.emit(t.action, t.content, t.options)
                    }), queue = []
                }).on(ACTION.WILL_UNMOUNT, function() {
                    container = null, toast.isActive = NOOP, canUseDom && containerDomNode && document.body.removeChild(containerDomNode)
                }), exports.Bounce = Bounce, exports.Flip = Flip, exports.Slide = Slide, exports.ToastContainer = ToastContainer, exports.ToastPosition = POSITION, exports.ToastType = TYPE, exports.Zoom = Zoom, exports.cssTransition = cssTransition, exports.toast = toast
            }, {
                "@babel/runtime/helpers/extends": 40,
                "@babel/runtime/helpers/inheritsLoose": 41,
                "@babel/runtime/helpers/objectWithoutPropertiesLoose": 42,
                classnames: 443,
                react: 455,
                "react-dom": 438,
                "react-transition-group/Transition": 447,
                "react-transition-group/TransitionGroup": 448
            }],
            442: [function(require, module, exports) {
                (function(process) {
                    "use strict";
                    "production" === process.env.NODE_ENV ? module.exports = require("./cjs/react-toastify.min.js") : module.exports = require("./cjs/react-toastify.js")
                }).call(this, require("_process"))
            }, {
                "./cjs/react-toastify.js": 440,
                "./cjs/react-toastify.min.js": 441,
                _process: 433
            }],
            443: [function(require, module, exports) {
                ! function() {
                    "use strict";

                    function n() {
                        for (var r = [], t = 0; t < arguments.length; t++) {
                            var f = arguments[t];
                            if (f) {
                                var o = _typeof2(f);
                                if ("string" === o || "number" === o) r.push(f);
                                else if (Array.isArray(f) && f.length) {
                                    var i = n.apply(null, f);
                                    i && r.push(i)
                                } else if ("object" === o)
                                    for (var a in f) e.call(f, a) && f[a] && r.push(a)
                            }
                        }
                        return r.join(" ")
                    }
                    var e = {}.hasOwnProperty;
                    "undefined" != typeof module && module.exports ? (n.default = n, module.exports = n) : "function" == typeof define && "object" == _typeof2(define.amd) && define.amd ? define("classnames", [], function() {
                        return n
                    }) : window.classNames = n
                }()
            }, {}],
            444: [function(require, module, exports) {
                "use strict";

                function emptyFunction() {}

                function emptyFunctionWithReset() {}
                var ReactPropTypesSecret = require("./lib/ReactPropTypesSecret");
                emptyFunctionWithReset.resetWarningCache = emptyFunction, module.exports = function() {
                    function e(e, t, n, r, o, p) {
                        if (p !== ReactPropTypesSecret) {
                            var c = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                            throw c.name = "Invariant Violation", c
                        }
                    }

                    function t() {
                        return e
                    }
                    e.isRequired = e;
                    var n = {
                        array: e,
                        bool: e,
                        func: e,
                        number: e,
                        object: e,
                        string: e,
                        symbol: e,
                        any: e,
                        arrayOf: t,
                        element: e,
                        elementType: e,
                        instanceOf: t,
                        node: e,
                        objectOf: t,
                        oneOf: t,
                        oneOfType: t,
                        shape: t,
                        exact: t,
                        checkPropTypes: emptyFunctionWithReset,
                        resetWarningCache: emptyFunction
                    };
                    return n.PropTypes = n, n
                }
            }, {
                "./lib/ReactPropTypesSecret": 446
            }],
            445: [function(require, module, exports) {
                module.exports = require("./factoryWithThrowingShims")()
            }, {
                "./factoryWithThrowingShims": 444
            }],
            446: [function(require, module, exports) {
                "use strict";
                var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
                module.exports = ReactPropTypesSecret
            }, {}],
            447: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(t) {
                    return t && t.__esModule ? t : {
                        default: t
                    }
                }

                function _interopRequireWildcard(t) {
                    if (t && t.__esModule) return t;
                    var e = {};
                    if (null != t)
                        for (var n in t)
                            if (Object.prototype.hasOwnProperty.call(t, n)) {
                                var r = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(t, n) : {};
                                r.get || r.set ? Object.defineProperty(e, n, r) : e[n] = t[n]
                            } return e.default = t, e
                }

                function _objectWithoutPropertiesLoose(t, e) {
                    if (null == t) return {};
                    var n, r, o = {},
                        i = Object.keys(t);
                    for (r = 0; r < i.length; r++) n = i[r], e.indexOf(n) >= 0 || (o[n] = t[n]);
                    return o
                }

                function _inheritsLoose(t, e) {
                    t.prototype = Object.create(e.prototype), t.prototype.constructor = t, t.__proto__ = e
                }

                function noop() {}
                exports.__esModule = !0, exports.default = exports.EXITING = exports.ENTERED = exports.ENTERING = exports.EXITED = exports.UNMOUNTED = void 0;
                var PropTypes = _interopRequireWildcard(require("prop-types")),
                    _react = _interopRequireDefault(require("react")),
                    _reactDom = _interopRequireDefault(require("react-dom")),
                    _reactLifecyclesCompat = require("react-lifecycles-compat"),
                    UNMOUNTED = (require("./utils/PropTypes"), "unmounted");
                exports.UNMOUNTED = UNMOUNTED;
                var EXITED = "exited";
                exports.EXITED = EXITED;
                var ENTERING = "entering";
                exports.ENTERING = ENTERING;
                var ENTERED = "entered";
                exports.ENTERED = ENTERED;
                var EXITING = "exiting";
                exports.EXITING = EXITING;
                var Transition = function(t) {
                    function e(e, n) {
                        var r;
                        r = t.call(this, e, n) || this;
                        var o, i = n.transitionGroup,
                            s = i && !i.isMounting ? e.enter : e.appear;
                        return r.appearStatus = null, e.in ? s ? (o = EXITED, r.appearStatus = ENTERING) : o = ENTERED : o = e.unmountOnExit || e.mountOnEnter ? UNMOUNTED : EXITED, r.state = {
                            status: o
                        }, r.nextCallback = null, r
                    }
                    _inheritsLoose(e, t);
                    var n = e.prototype;
                    return n.getChildContext = function() {
                        return {
                            transitionGroup: null
                        }
                    }, e.getDerivedStateFromProps = function(t, e) {
                        return t.in && e.status === UNMOUNTED ? {
                            status: EXITED
                        } : null
                    }, n.componentDidMount = function() {
                        this.updateStatus(!0, this.appearStatus)
                    }, n.componentDidUpdate = function(t) {
                        var e = null;
                        if (t !== this.props) {
                            var n = this.state.status;
                            this.props.in ? n !== ENTERING && n !== ENTERED && (e = ENTERING) : n !== ENTERING && n !== ENTERED || (e = EXITING)
                        }
                        this.updateStatus(!1, e)
                    }, n.componentWillUnmount = function() {
                        this.cancelNextCallback()
                    }, n.getTimeouts = function() {
                        var t, e, n, r = this.props.timeout;
                        return t = e = n = r, null != r && "number" != typeof r && (t = r.exit, e = r.enter, n = void 0 !== r.appear ? r.appear : e), {
                            exit: t,
                            enter: e,
                            appear: n
                        }
                    }, n.updateStatus = function(t, e) {
                        if (void 0 === t && (t = !1), null !== e) {
                            this.cancelNextCallback();
                            var n = _reactDom.default.findDOMNode(this);
                            e === ENTERING ? this.performEnter(n, t) : this.performExit(n)
                        } else this.props.unmountOnExit && this.state.status === EXITED && this.setState({
                            status: UNMOUNTED
                        })
                    }, n.performEnter = function(t, e) {
                        var n = this,
                            r = this.props.enter,
                            o = this.context.transitionGroup ? this.context.transitionGroup.isMounting : e,
                            i = this.getTimeouts(),
                            s = o ? i.appear : i.enter;
                        e || r ? (this.props.onEnter(t, o), this.safeSetState({
                            status: ENTERING
                        }, function() {
                            n.props.onEntering(t, o), n.onTransitionEnd(t, s, function() {
                                n.safeSetState({
                                    status: ENTERED
                                }, function() {
                                    n.props.onEntered(t, o)
                                })
                            })
                        })) : this.safeSetState({
                            status: ENTERED
                        }, function() {
                            n.props.onEntered(t)
                        })
                    }, n.performExit = function(t) {
                        var e = this,
                            n = this.props.exit,
                            r = this.getTimeouts();
                        n ? (this.props.onExit(t), this.safeSetState({
                            status: EXITING
                        }, function() {
                            e.props.onExiting(t), e.onTransitionEnd(t, r.exit, function() {
                                e.safeSetState({
                                    status: EXITED
                                }, function() {
                                    e.props.onExited(t)
                                })
                            })
                        })) : this.safeSetState({
                            status: EXITED
                        }, function() {
                            e.props.onExited(t)
                        })
                    }, n.cancelNextCallback = function() {
                        null !== this.nextCallback && (this.nextCallback.cancel(), this.nextCallback = null)
                    }, n.safeSetState = function(t, e) {
                        e = this.setNextCallback(e), this.setState(t, e)
                    }, n.setNextCallback = function(t) {
                        var e = this,
                            n = !0;
                        return this.nextCallback = function(r) {
                            n && (n = !1, e.nextCallback = null, t(r))
                        }, this.nextCallback.cancel = function() {
                            n = !1
                        }, this.nextCallback
                    }, n.onTransitionEnd = function(t, e, n) {
                        this.setNextCallback(n);
                        var r = null == e && !this.props.addEndListener;
                        t && !r ? (this.props.addEndListener && this.props.addEndListener(t, this.nextCallback), null != e && setTimeout(this.nextCallback, e)) : setTimeout(this.nextCallback, 0)
                    }, n.render = function() {
                        var t = this.state.status;
                        if (t === UNMOUNTED) return null;
                        var e = this.props,
                            n = e.children,
                            r = _objectWithoutPropertiesLoose(e, ["children"]);
                        if (delete r.in, delete r.mountOnEnter, delete r.unmountOnExit, delete r.appear, delete r.enter, delete r.exit, delete r.timeout, delete r.addEndListener, delete r.onEnter, delete r.onEntering, delete r.onEntered, delete r.onExit, delete r.onExiting, delete r.onExited, "function" == typeof n) return n(t, r);
                        var o = _react.default.Children.only(n);
                        return _react.default.cloneElement(o, r)
                    }, e
                }(_react.default.Component);
                Transition.contextTypes = {
                    transitionGroup: PropTypes.object
                }, Transition.childContextTypes = {
                    transitionGroup: function() {}
                }, Transition.propTypes = {}, Transition.defaultProps = {
                    in: !1,
                    mountOnEnter: !1,
                    unmountOnExit: !1,
                    appear: !1,
                    enter: !0,
                    exit: !0,
                    onEnter: noop,
                    onEntering: noop,
                    onEntered: noop,
                    onExit: noop,
                    onExiting: noop,
                    onExited: noop
                }, Transition.UNMOUNTED = 0, Transition.EXITED = 1, Transition.ENTERING = 2, Transition.ENTERED = 3, Transition.EXITING = 4;
                var _default = (0, _reactLifecyclesCompat.polyfill)(Transition);
                exports.default = _default
            }, {
                "./utils/PropTypes": 453,
                "prop-types": 450,
                react: 455,
                "react-dom": 438,
                "react-lifecycles-compat": 439
            }],
            448: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }

                function _objectWithoutPropertiesLoose(e, t) {
                    if (null == e) return {};
                    var r, n, i = {},
                        o = Object.keys(e);
                    for (n = 0; n < o.length; n++) r = o[n], t.indexOf(r) >= 0 || (i[r] = e[r]);
                    return i
                }

                function _extends() {
                    return (_extends = Object.assign || function(e) {
                        for (var t = 1; t < arguments.length; t++) {
                            var r = arguments[t];
                            for (var n in r) Object.prototype.hasOwnProperty.call(r, n) && (e[n] = r[n])
                        }
                        return e
                    }).apply(this, arguments)
                }

                function _inheritsLoose(e, t) {
                    e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t
                }

                function _assertThisInitialized(e) {
                    if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
                    return e
                }
                exports.__esModule = !0, exports.default = void 0;
                var _propTypes = _interopRequireDefault(require("prop-types")),
                    _react = _interopRequireDefault(require("react")),
                    _reactLifecyclesCompat = require("react-lifecycles-compat"),
                    _ChildMapping = require("./utils/ChildMapping"),
                    values = Object.values || function(e) {
                        return Object.keys(e).map(function(t) {
                            return e[t]
                        })
                    },
                    defaultProps = {
                        component: "div",
                        childFactory: function(e) {
                            return e
                        }
                    },
                    TransitionGroup = function(e) {
                        function t(t, r) {
                            var n, i = (n = e.call(this, t, r) || this).handleExited.bind(_assertThisInitialized(_assertThisInitialized(n)));
                            return n.state = {
                                handleExited: i,
                                firstRender: !0
                            }, n
                        }
                        _inheritsLoose(t, e);
                        var r = t.prototype;
                        return r.getChildContext = function() {
                            return {
                                transitionGroup: {
                                    isMounting: !this.appeared
                                }
                            }
                        }, r.componentDidMount = function() {
                            this.appeared = !0, this.mounted = !0
                        }, r.componentWillUnmount = function() {
                            this.mounted = !1
                        }, t.getDerivedStateFromProps = function(e, t) {
                            var r = t.children,
                                n = t.handleExited;
                            return {
                                children: t.firstRender ? (0, _ChildMapping.getInitialChildMapping)(e, n) : (0, _ChildMapping.getNextChildMapping)(e, r, n),
                                firstRender: !1
                            }
                        }, r.handleExited = function(e, t) {
                            var r = (0, _ChildMapping.getChildMapping)(this.props.children);
                            e.key in r || (e.props.onExited && e.props.onExited(t), this.mounted && this.setState(function(t) {
                                var r = _extends({}, t.children);
                                return delete r[e.key], {
                                    children: r
                                }
                            }))
                        }, r.render = function() {
                            var e = this.props,
                                t = e.component,
                                r = e.childFactory,
                                n = _objectWithoutPropertiesLoose(e, ["component", "childFactory"]),
                                i = values(this.state.children).map(r);
                            return delete n.appear, delete n.enter, delete n.exit, null === t ? i : _react.default.createElement(t, n, i)
                        }, t
                    }(_react.default.Component);
                TransitionGroup.childContextTypes = {
                    transitionGroup: _propTypes.default.object.isRequired
                }, TransitionGroup.propTypes = {}, TransitionGroup.defaultProps = defaultProps;
                var _default = (0, _reactLifecyclesCompat.polyfill)(TransitionGroup);
                exports.default = _default, module.exports = exports.default
            }, {
                "./utils/ChildMapping": 452,
                "prop-types": 450,
                react: 455,
                "react-lifecycles-compat": 439
            }],
            449: [function(require, module, exports) {
                "use strict";

                function emptyFunction() {}
                var ReactPropTypesSecret = require("./lib/ReactPropTypesSecret");
                module.exports = function() {
                    function e(e, r, t, o, n, p) {
                        if (p !== ReactPropTypesSecret) {
                            var c = new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");
                            throw c.name = "Invariant Violation", c
                        }
                    }

                    function r() {
                        return e
                    }
                    e.isRequired = e;
                    var t = {
                        array: e,
                        bool: e,
                        func: e,
                        number: e,
                        object: e,
                        string: e,
                        symbol: e,
                        any: e,
                        arrayOf: r,
                        element: e,
                        instanceOf: r,
                        node: e,
                        objectOf: r,
                        oneOf: r,
                        oneOfType: r,
                        shape: r,
                        exact: r
                    };
                    return t.checkPropTypes = emptyFunction, t.PropTypes = t, t
                }
            }, {
                "./lib/ReactPropTypesSecret": 451
            }],
            450: [function(require, module, exports) {
                module.exports = require("./factoryWithThrowingShims")()
            }, {
                "./factoryWithThrowingShims": 449
            }],
            451: [function(require, module, exports) {
                "use strict";
                var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
                module.exports = ReactPropTypesSecret
            }, {}],
            452: [function(require, module, exports) {
                "use strict";

                function getChildMapping(e, n) {
                    var t = Object.create(null);
                    return e && _react.Children.map(e, function(e) {
                        return e
                    }).forEach(function(e) {
                        t[e.key] = function(e) {
                            return n && (0, _react.isValidElement)(e) ? n(e) : e
                        }(e)
                    }), t
                }

                function mergeChildMappings(e, n) {
                    function t(t) {
                        return t in n ? n[t] : e[t]
                    }
                    e = e || {}, n = n || {};
                    var i, r = Object.create(null),
                        p = [];
                    for (var l in e) l in n ? p.length && (r[l] = p, p = []) : p.push(l);
                    var a = {};
                    for (var g in n) {
                        if (r[g])
                            for (i = 0; i < r[g].length; i++) {
                                var o = r[g][i];
                                a[r[g][i]] = t(o)
                            }
                        a[g] = t(g)
                    }
                    for (i = 0; i < p.length; i++) a[p[i]] = t(p[i]);
                    return a
                }

                function getProp(e, n, t) {
                    return null != t[n] ? t[n] : e.props[n]
                }

                function getInitialChildMapping(e, n) {
                    return getChildMapping(e.children, function(t) {
                        return (0, _react.cloneElement)(t, {
                            onExited: n.bind(null, t),
                            in: !0,
                            appear: getProp(t, "appear", e),
                            enter: getProp(t, "enter", e),
                            exit: getProp(t, "exit", e)
                        })
                    })
                }

                function getNextChildMapping(e, n, t) {
                    var i = getChildMapping(e.children),
                        r = mergeChildMappings(n, i);
                    return Object.keys(r).forEach(function(p) {
                        var l = r[p];
                        if ((0, _react.isValidElement)(l)) {
                            var a = p in n,
                                g = p in i,
                                o = n[p],
                                c = (0, _react.isValidElement)(o) && !o.props.in;
                            !g || a && !c ? g || !a || c ? g && a && (0, _react.isValidElement)(o) && (r[p] = (0, _react.cloneElement)(l, {
                                onExited: t.bind(null, l),
                                in: o.props.in,
                                exit: getProp(l, "exit", e),
                                enter: getProp(l, "enter", e)
                            })) : r[p] = (0, _react.cloneElement)(l, {
                                in: !1
                            }) : r[p] = (0, _react.cloneElement)(l, {
                                onExited: t.bind(null, l),
                                in: !0,
                                exit: getProp(l, "exit", e),
                                enter: getProp(l, "enter", e)
                            })
                        }
                    }), r
                }
                exports.__esModule = !0, exports.getChildMapping = getChildMapping, exports.mergeChildMappings = mergeChildMappings, exports.getInitialChildMapping = getInitialChildMapping, exports.getNextChildMapping = getNextChildMapping;
                var _react = require("react")
            }, {
                react: 455
            }],
            453: [function(require, module, exports) {
                "use strict";

                function _interopRequireDefault(e) {
                    return e && e.__esModule ? e : {
                        default: e
                    }
                }
                exports.__esModule = !0, exports.classNamesShape = exports.timeoutsShape = void 0;
                var timeoutsShape = (_interopRequireDefault(require("prop-types")), null);
                exports.timeoutsShape = timeoutsShape;
                var classNamesShape = null;
                exports.classNamesShape = classNamesShape
            }, {
                "prop-types": 450
            }],
            454: [function(require, module, exports) {
                "use strict";

                function aa(e, r, t, n, o, u, l, i) {
                    if (!e) {
                        if (e = void 0, void 0 === r) e = Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
                        else {
                            var c = [t, n, o, u, l, i],
                                f = 0;
                            (e = Error(r.replace(/%s/g, function() {
                                return c[f++]
                            }))).name = "Invariant Violation"
                        }
                        throw e.framesToPop = 1, e
                    }
                }

                function D(e) {
                    for (var r = arguments.length - 1, t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 0; n < r; n++) t += "&args[]=" + encodeURIComponent(arguments[n + 1]);
                    aa(!1, "Minified React error #" + e + "; visit %s for the full message or use the non-minified dev environment for full errors and additional helpful warnings. ", t)
                }

                function G(e, r, t) {
                    this.props = e, this.context = r, this.refs = F, this.updater = t || E
                }

                function H() {}

                function I(e, r, t) {
                    this.props = e, this.context = r, this.refs = F, this.updater = t || E
                }

                function N(e, r, t) {
                    var n = void 0,
                        o = {},
                        u = null,
                        l = null;
                    if (null != r)
                        for (n in void 0 !== r.ref && (l = r.ref), void 0 !== r.key && (u = "" + r.key), r) L.call(r, n) && !M.hasOwnProperty(n) && (o[n] = r[n]);
                    var i = arguments.length - 2;
                    if (1 === i) o.children = t;
                    else if (1 < i) {
                        for (var c = Array(i), f = 0; f < i; f++) c[f] = arguments[f + 2];
                        o.children = c
                    }
                    if (e && e.defaultProps)
                        for (n in i = e.defaultProps) void 0 === o[n] && (o[n] = i[n]);
                    return {
                        $$typeof: p,
                        type: e,
                        key: u,
                        ref: l,
                        props: o,
                        _owner: K.current
                    }
                }

                function ba(e, r) {
                    return {
                        $$typeof: p,
                        type: e.type,
                        key: r,
                        ref: e.ref,
                        props: e.props,
                        _owner: e._owner
                    }
                }

                function O(e) {
                    return "object" == _typeof2(e) && null !== e && e.$$typeof === p
                }

                function escape(e) {
                    var r = {
                        "=": "=0",
                        ":": "=2"
                    };
                    return "$" + ("" + e).replace(/[=:]/g, function(e) {
                        return r[e]
                    })
                }

                function R(e, r, t, n) {
                    if (Q.length) {
                        var o = Q.pop();
                        return o.result = e, o.keyPrefix = r, o.func = t, o.context = n, o.count = 0, o
                    }
                    return {
                        result: e,
                        keyPrefix: r,
                        func: t,
                        context: n,
                        count: 0
                    }
                }

                function S(e) {
                    e.result = null, e.keyPrefix = null, e.func = null, e.context = null, e.count = 0, 10 > Q.length && Q.push(e)
                }

                function T(e, r, t, n) {
                    var o = _typeof2(e);
                    "undefined" !== o && "boolean" !== o || (e = null);
                    var u = !1;
                    if (null === e) u = !0;
                    else switch (o) {
                        case "string":
                        case "number":
                            u = !0;
                            break;
                        case "object":
                            switch (e.$$typeof) {
                                case p:
                                case q:
                                    u = !0
                            }
                    }
                    if (u) return t(n, e, "" === r ? "." + U(e, 0) : r), 1;
                    if (u = 0, r = "" === r ? "." : r + ":", Array.isArray(e))
                        for (var l = 0; l < e.length; l++) {
                            var i = r + U(o = e[l], l);
                            u += T(o, i, t, n)
                        } else if (i = null === e || "object" != _typeof2(e) ? null : "function" == typeof(i = C && e[C] || e["@@iterator"]) ? i : null, "function" == typeof i)
                            for (e = i.call(e), l = 0; !(o = e.next()).done;) u += T(o = o.value, i = r + U(o, l++), t, n);
                        else "object" === o && D("31", "[object Object]" == (t = "" + e) ? "object with keys {" + Object.keys(e).join(", ") + "}" : t, "");
                    return u
                }

                function V(e, r, t) {
                    return null == e ? 0 : T(e, "", r, t)
                }

                function U(e, r) {
                    return "object" == _typeof2(e) && null !== e && null != e.key ? escape(e.key) : r.toString(36)
                }

                function ca(e, r) {
                    e.func.call(e.context, r, e.count++)
                }

                function da(e, r, t) {
                    var n = e.result,
                        o = e.keyPrefix;
                    e = e.func.call(e.context, r, e.count++), Array.isArray(e) ? W(e, n, t, function(e) {
                        return e
                    }) : null != e && (O(e) && (e = ba(e, o + (!e.key || r && r.key === e.key ? "" : ("" + e.key).replace(P, "$&/") + "/") + t)), n.push(e))
                }

                function W(e, r, t, n, o) {
                    var u = "";
                    null != t && (u = ("" + t).replace(P, "$&/") + "/"), V(e, da, r = R(r, u, n, o)), S(r)
                }
                var k = require("object-assign"),
                    n = "function" == typeof Symbol && Symbol.for,
                    p = n ? Symbol.for("react.element") : 60103,
                    q = n ? Symbol.for("react.portal") : 60106,
                    r = n ? Symbol.for("react.fragment") : 60107,
                    t = n ? Symbol.for("react.strict_mode") : 60108,
                    u = n ? Symbol.for("react.profiler") : 60114,
                    v = n ? Symbol.for("react.provider") : 60109,
                    w = n ? Symbol.for("react.context") : 60110,
                    x = n ? Symbol.for("react.concurrent_mode") : 60111,
                    y = n ? Symbol.for("react.forward_ref") : 60112,
                    z = n ? Symbol.for("react.suspense") : 60113,
                    A = n ? Symbol.for("react.memo") : 60115,
                    B = n ? Symbol.for("react.lazy") : 60116,
                    C = "function" == typeof Symbol && Symbol.iterator,
                    E = {
                        isMounted: function() {
                            return !1
                        },
                        enqueueForceUpdate: function() {},
                        enqueueReplaceState: function() {},
                        enqueueSetState: function() {}
                    },
                    F = {};
                G.prototype.isReactComponent = {}, G.prototype.setState = function(e, r) {
                    "object" != _typeof2(e) && "function" != typeof e && null != e && D("85"), this.updater.enqueueSetState(this, e, r, "setState")
                }, G.prototype.forceUpdate = function(e) {
                    this.updater.enqueueForceUpdate(this, e, "forceUpdate")
                }, H.prototype = G.prototype;
                var J = I.prototype = new H;
                J.constructor = I, k(J, G.prototype), J.isPureReactComponent = !0;
                var K = {
                        current: null,
                        currentDispatcher: null
                    },
                    L = Object.prototype.hasOwnProperty,
                    M = {
                        key: !0,
                        ref: !0,
                        __self: !0,
                        __source: !0
                    },
                    P = /\/+/g,
                    Q = [],
                    X = {
                        Children: {
                            map: function(e, r, t) {
                                if (null == e) return e;
                                var n = [];
                                return W(e, n, null, r, t), n
                            },
                            forEach: function(e, r, t) {
                                return null == e ? e : (V(e, ca, r = R(null, null, r, t)), void S(r))
                            },
                            count: function(e) {
                                return V(e, function() {
                                    return null
                                }, null)
                            },
                            toArray: function(e) {
                                var r = [];
                                return W(e, r, null, function(e) {
                                    return e
                                }), r
                            },
                            only: function(e) {
                                return O(e) || D("143"), e
                            }
                        },
                        createRef: function() {
                            return {
                                current: null
                            }
                        },
                        Component: G,
                        PureComponent: I,
                        createContext: function(e, r) {
                            return void 0 === r && (r = null), (e = {
                                $$typeof: w,
                                _calculateChangedBits: r,
                                _currentValue: e,
                                _currentValue2: e,
                                Provider: null,
                                Consumer: null
                            }).Provider = {
                                $$typeof: v,
                                _context: e
                            }, e.Consumer = e
                        },
                        forwardRef: function(e) {
                            return {
                                $$typeof: y,
                                render: e
                            }
                        },
                        lazy: function(e) {
                            return {
                                $$typeof: B,
                                _ctor: e,
                                _status: -1,
                                _result: null
                            }
                        },
                        memo: function(e, r) {
                            return {
                                $$typeof: A,
                                type: e,
                                compare: void 0 === r ? null : r
                            }
                        },
                        Fragment: r,
                        StrictMode: t,
                        unstable_ConcurrentMode: x,
                        Suspense: z,
                        unstable_Profiler: u,
                        createElement: N,
                        cloneElement: function(e, r, t) {
                            null == e && D("267", e);
                            var n = void 0,
                                o = k({}, e.props),
                                u = e.key,
                                l = e.ref,
                                i = e._owner;
                            if (null != r) {
                                void 0 !== r.ref && (l = r.ref, i = K.current), void 0 !== r.key && (u = "" + r.key);
                                var c = void 0;
                                for (n in e.type && e.type.defaultProps && (c = e.type.defaultProps), r) L.call(r, n) && !M.hasOwnProperty(n) && (o[n] = void 0 === r[n] && void 0 !== c ? c[n] : r[n])
                            }
                            if (1 === (n = arguments.length - 2)) o.children = t;
                            else if (1 < n) {
                                c = Array(n);
                                for (var f = 0; f < n; f++) c[f] = arguments[f + 2];
                                o.children = c
                            }
                            return {
                                $$typeof: p,
                                type: e.type,
                                key: u,
                                ref: l,
                                props: o,
                                _owner: i
                            }
                        },
                        createFactory: function(e) {
                            var r = N.bind(null, e);
                            return r.type = e, r
                        },
                        isValidElement: O,
                        version: "16.6.0",
                        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: {
                            ReactCurrentOwner: K,
                            assign: k
                        }
                    },
                    Y = {
                        default: X
                    },
                    Z = Y && X || Y;
                module.exports = Z.default || Z
            }, {
                "object-assign": 421
            }],
            455: [function(require, module, exports) {
                "use strict";
                module.exports = require("./cjs/react.production.min.js")
            }, {
                "./cjs/react.production.min.js": 454
            }],
            456: [function(require, module, exports) {
                "use strict";
                var isFinite = require("is-finite");
                module.exports = function(e, i) {
                    if ("string" != typeof e) throw new TypeError("Expected a string as the first argument");
                    if (i < 0 || !isFinite(i)) throw new TypeError("Expected a finite positive number");
                    var r = "";
                    do 1 & i && (r += e), e += e; while (i >>= 1);
                    return r
                }
            }, {
                "is-finite": 194
            }],
            457: [function(require, module, exports) {
                "use strict";

                function r() {
                    if (!l) {
                        var e = c.expirationTime;
                        m ? t() : m = !0, _u(v, e)
                    }
                }

                function w() {
                    var e = c,
                        n = c.next;
                    if (c === n) c = null;
                    else {
                        var t = c.previous;
                        c = t.next = n, n.previous = t
                    }
                    e.next = e.previous = null, t = e.callback, n = e.expirationTime, e = e.priorityLevel;
                    var i = f,
                        o = k;
                    f = e, k = n;
                    try {
                        var l = t(q)
                    } finally {
                        f = i, k = o
                    }
                    if ("function" == typeof l)
                        if (l = {
                                callback: l,
                                priorityLevel: e,
                                expirationTime: n,
                                next: null,
                                previous: null
                            }, null === c) c = l.next = l.previous = l;
                        else {
                            t = null, e = c;
                            do {
                                if (e.expirationTime >= n) {
                                    t = e;
                                    break
                                }
                                e = e.next
                            } while (e !== c);
                            null === t ? t = c : t === c && (c = l, r()), (n = t.previous).next = t.previous = l, l.next = t, l.previous = n
                        }
                }

                function x() {
                    if (-1 === h && null !== c && 1 === c.priorityLevel) {
                        l = !0, q.didTimeout = !0;
                        try {
                            do w(); while (null !== c && 1 === c.priorityLevel)
                        } finally {
                            l = !1, null !== c ? r() : m = !1
                        }
                    }
                }

                function v(e) {
                    l = !0, q.didTimeout = e;
                    try {
                        if (e)
                            for (; null !== c;) {
                                var n = exports.unstable_now();
                                if (!(c.expirationTime <= n)) break;
                                do w(); while (null !== c && c.expirationTime <= n)
                            } else if (null !== c)
                                do w(); while (null !== c && 0 < p() - exports.unstable_now())
                    } finally {
                        l = !1, null !== c ? r() : m = !1, x()
                    }
                }

                function F(e) {
                    D = B(function(n) {
                        A(E), e(n)
                    }), E = z(function() {
                        C(D), e(exports.unstable_now())
                    }, 100)
                }
                Object.defineProperty(exports, "__esModule", {
                    value: !0
                });
                var D, E, _u, t, p, c = null,
                    f = 3,
                    h = -1,
                    k = -1,
                    l = !1,
                    m = !1,
                    n = "object" == ("undefined" == typeof performance ? "undefined" : _typeof2(performance)) && "function" == typeof performance.now,
                    q = {
                        timeRemaining: n ? function() {
                            if (null !== c && c.expirationTime < k) return 0;
                            var e = p() - performance.now();
                            return 0 < e ? e : 0
                        } : function() {
                            if (null !== c && c.expirationTime < k) return 0;
                            var e = p() - Date.now();
                            return 0 < e ? e : 0
                        },
                        didTimeout: !1
                    },
                    y = Date,
                    z = "function" == typeof setTimeout ? setTimeout : void 0,
                    A = "function" == typeof clearTimeout ? clearTimeout : void 0,
                    B = "function" == typeof requestAnimationFrame ? requestAnimationFrame : void 0,
                    C = "function" == typeof cancelAnimationFrame ? cancelAnimationFrame : void 0;
                if (n) {
                    var G = performance;
                    exports.unstable_now = function() {
                        return G.now()
                    }
                } else exports.unstable_now = function() {
                    return y.now()
                };
                if ("undefined" != typeof window && window._schedMock) {
                    var H = window._schedMock;
                    _u = H[0], t = H[1], p = H[2]
                } else if ("undefined" == typeof window || "function" != typeof window.addEventListener) {
                    var I = null,
                        J = -1,
                        K = function(e, n) {
                            if (null !== I) {
                                var t = I;
                                I = null;
                                try {
                                    J = n, t(e)
                                } finally {
                                    J = -1
                                }
                            }
                        };
                    _u = function(e, n) {
                        -1 !== J ? setTimeout(_u, 0, e, n) : (I = e, setTimeout(K, n, !0, n), setTimeout(K, 1073741823, !1, 1073741823))
                    }, t = function() {
                        I = null
                    }, p = function() {
                        return 1 / 0
                    }, exports.unstable_now = function() {
                        return -1 === J ? 0 : J
                    }
                } else {
                    "undefined" != typeof console && ("function" != typeof B && console.error("This browser doesn't support requestAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"), "function" != typeof C && console.error("This browser doesn't support cancelAnimationFrame. Make sure that you load a polyfill in older browsers. https://fb.me/react-polyfills"));
                    var L = null,
                        M = !1,
                        N = -1,
                        O = !1,
                        P = !1,
                        Q = 0,
                        S = 33,
                        T = 33;
                    p = function() {
                        return Q
                    };
                    var U = "__reactIdleCallback$" + Math.random().toString(36).slice(2);
                    window.addEventListener("message", function(e) {
                        if (e.source === window && e.data === U) {
                            M = !1, e = L;
                            var n = N;
                            L = null, N = -1;
                            var t = exports.unstable_now(),
                                i = !1;
                            if (0 >= Q - t) {
                                if (!(-1 !== n && n <= t)) return O || (O = !0, F(V)), L = e, void(N = n);
                                i = !0
                            }
                            if (null !== e) {
                                P = !0;
                                try {
                                    e(i)
                                } finally {
                                    P = !1
                                }
                            }
                        }
                    }, !1);
                    var V = function V(e) {
                        if (null !== L) {
                            F(V);
                            var n = e - Q + T;
                            n < T && S < T ? (8 > n && (n = 8), T = n < S ? S : n) : S = n, Q = e + T, M || (M = !0, window.postMessage(U, "*"))
                        } else O = !1
                    };
                    _u = function(e, n) {
                        L = e, N = n, P || 0 > n ? window.postMessage(U, "*") : O || (O = !0, F(V))
                    }, t = function() {
                        L = null, M = !1, N = -1
                    }
                }
                exports.unstable_ImmediatePriority = 1, exports.unstable_UserBlockingPriority = 2, exports.unstable_NormalPriority = 3, exports.unstable_IdlePriority = 4, exports.unstable_runWithPriority = function(e, n) {
                    switch (e) {
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        default:
                            e = 3
                    }
                    var t = f,
                        i = h;
                    f = e, h = exports.unstable_now();
                    try {
                        return n()
                    } finally {
                        f = t, h = i, x()
                    }
                }, exports.unstable_scheduleCallback = function(e, n) {
                    var t = -1 !== h ? h : exports.unstable_now();
                    if ("object" == _typeof2(n) && null !== n && "number" == typeof n.timeout) n = t + n.timeout;
                    else switch (f) {
                        case 1:
                            n = t + -1;
                            break;
                        case 2:
                            n = t + 250;
                            break;
                        case 4:
                            n = t + 1073741823;
                            break;
                        default:
                            n = t + 5e3
                    }
                    if (e = {
                            callback: e,
                            priorityLevel: f,
                            expirationTime: n,
                            next: null,
                            previous: null
                        }, null === c) c = e.next = e.previous = e, r();
                    else {
                        t = null;
                        var i = c;
                        do {
                            if (i.expirationTime > n) {
                                t = i;
                                break
                            }
                            i = i.next
                        } while (i !== c);
                        null === t ? t = c : t === c && (c = e, r()), (n = t.previous).next = t.previous = e, e.next = t, e.previous = n
                    }
                    return e
                }, exports.unstable_cancelCallback = function(e) {
                    var n = e.next;
                    if (null !== n) {
                        if (n === e) c = null;
                        else {
                            e === c && (c = n);
                            var t = e.previous;
                            t.next = n, n.previous = t
                        }
                        e.next = e.previous = null
                    }
                }, exports.unstable_wrapCallback = function(e) {
                    var n = f;
                    return function() {
                        var t = f,
                            i = h;
                        f = n, h = exports.unstable_now();
                        try {
                            return e.apply(this, arguments)
                        } finally {
                            f = t, h = i, x()
                        }
                    }
                }, exports.unstable_getCurrentPriorityLevel = function() {
                    return f
                }
            }, {}],
            458: [function(require, module, exports) {
                "use strict";
                module.exports = require("./cjs/scheduler.production.min.js")
            }, {
                "./cjs/scheduler.production.min.js": 457
            }],
            459: [function(require, module, exports) {
                (function(process, global) {
                    ! function(e, t) {
                        "use strict";

                        function d(e) {
                            delete r[e]
                        }

                        function g(e) {
                            if (f) setTimeout(g, 0, e);
                            else {
                                var n = r[e];
                                if (n) {
                                    f = !0;
                                    try {
                                        ! function(e) {
                                            var n = e.callback,
                                                a = e.args;
                                            switch (a.length) {
                                                case 0:
                                                    n();
                                                    break;
                                                case 1:
                                                    n(a[0]);
                                                    break;
                                                case 2:
                                                    n(a[0], a[1]);
                                                    break;
                                                case 3:
                                                    n(a[0], a[1], a[2]);
                                                    break;
                                                default:
                                                    n.apply(t, a)
                                            }
                                        }(n)
                                    } finally {
                                        d(e), f = !1
                                    }
                                }
                            }
                        }
                        if (!e.setImmediate) {
                            var n, a, s, o, c, i = 1,
                                r = {},
                                f = !1,
                                l = e.document,
                                u = Object.getPrototypeOf && Object.getPrototypeOf(e);
                            u = u && u.setTimeout ? u : e, "[object process]" === {}.toString.call(e.process) ? n = function(e) {
                                process.nextTick(function() {
                                    g(e)
                                })
                            } : function() {
                                if (e.postMessage && !e.importScripts) {
                                    var t = !0,
                                        n = e.onmessage;
                                    return e.onmessage = function() {
                                        t = !1
                                    }, e.postMessage("", "*"), e.onmessage = n, t
                                }
                            }() ? (o = "setImmediate$" + Math.random() + "$", c = function(t) {
                                t.source === e && "string" == typeof t.data && 0 === t.data.indexOf(o) && g(+t.data.slice(o.length))
                            }, e.addEventListener ? e.addEventListener("message", c, !1) : e.attachEvent("onmessage", c), n = function(t) {
                                e.postMessage(o + t, "*")
                            }) : e.MessageChannel ? ((s = new MessageChannel).port1.onmessage = function(e) {
                                g(e.data)
                            }, n = function(e) {
                                s.port2.postMessage(e)
                            }) : l && "onreadystatechange" in l.createElement("script") ? (a = l.documentElement, n = function(e) {
                                var t = l.createElement("script");
                                t.onreadystatechange = function() {
                                    g(e), t.onreadystatechange = null, a.removeChild(t), t = null
                                }, a.appendChild(t)
                            }) : n = function(e) {
                                setTimeout(g, 0, e)
                            }, u.setImmediate = function(e) {
                                "function" != typeof e && (e = new Function("" + e));
                                for (var t = new Array(arguments.length - 1), a = 0; a < t.length; a++) t[a] = arguments[a + 1];
                                var s = {
                                    callback: e,
                                    args: t
                                };
                                return r[i] = s, n(i), i++
                            }, u.clearImmediate = d
                        }
                    }("undefined" == typeof self ? "undefined" == typeof global ? this : global : self)
                }).call(this, require("_process"), "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
            }, {
                _process: 433
            }],
            460: [function(require, module, exports) {
                ! function(i, s) {
                    "use strict";
                    var e = "model",
                        o = "name",
                        r = "type",
                        n = "vendor",
                        a = "version",
                        t = "mobile",
                        d = "tablet",
                        l = {
                            extend: function(i, s) {
                                var e = {};
                                for (var o in i) s[o] && s[o].length % 2 == 0 ? e[o] = s[o].concat(i[o]) : e[o] = i[o];
                                return e
                            },
                            has: function(i, s) {
                                return "string" == typeof i && -1 !== s.toLowerCase().indexOf(i.toLowerCase())
                            },
                            lowerize: function(i) {
                                return i.toLowerCase()
                            },
                            major: function(i) {
                                return "string" == typeof i ? i.replace(/[^\d\.]/g, "").split(".")[0] : void 0
                            },
                            trim: function(i) {
                                return i.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "")
                            }
                        },
                        w = {
                            rgx: function(i, s) {
                                for (var e, o, r, n, a, t, d = 0; d < s.length && !a;) {
                                    var l = s[d],
                                        w = s[d + 1];
                                    for (e = o = 0; e < l.length && !a;)
                                        if (a = l[e++].exec(i))
                                            for (r = 0; r < w.length; r++) t = a[++o], "object" == _typeof2(n = w[r]) && n.length > 0 ? 2 == n.length ? "function" == typeof n[1] ? this[n[0]] = n[1].call(this, t) : this[n[0]] = n[1] : 3 == n.length ? "function" != typeof n[1] || n[1].exec && n[1].test ? this[n[0]] = t ? t.replace(n[1], n[2]) : void 0 : this[n[0]] = t ? n[1].call(this, t, n[2]) : void 0 : 4 == n.length && (this[n[0]] = t ? n[3].call(this, t.replace(n[1], n[2])) : void 0) : this[n] = t || void 0;
                                    d += 2
                                }
                            },
                            str: function(i, s) {
                                for (var e in s)
                                    if ("object" == _typeof2(s[e]) && s[e].length > 0) {
                                        for (var o = 0; o < s[e].length; o++)
                                            if (l.has(s[e][o], i)) return "?" === e ? void 0 : e
                                    } else if (l.has(s[e], i)) return "?" === e ? void 0 : e;
                                return i
                            }
                        },
                        u = {
                            browser: {
                                oldsafari: {
                                    version: {
                                        "1.0": "/8",
                                        1.2: "/1",
                                        1.3: "/3",
                                        "2.0": "/412",
                                        "2.0.2": "/416",
                                        "2.0.3": "/417",
                                        "2.0.4": "/419",
                                        "?": "/"
                                    }
                                }
                            },
                            device: {
                                amazon: {
                                    model: {
                                        "Fire Phone": ["SD", "KF"]
                                    }
                                },
                                sprint: {
                                    model: {
                                        "Evo Shift 4G": "7373KT"
                                    },
                                    vendor: {
                                        HTC: "APA",
                                        Sprint: "Sprint"
                                    }
                                }
                            },
                            os: {
                                windows: {
                                    version: {
                                        ME: "4.90",
                                        "NT 3.11": "NT3.51",
                                        "NT 4.0": "NT4.0",
                                        2e3: "NT 5.0",
                                        XP: ["NT 5.1", "NT 5.2"],
                                        Vista: "NT 6.0",
                                        7: "NT 6.1",
                                        8: "NT 6.2",
                                        8.1: "NT 6.3",
                                        10: ["NT 6.4", "NT 10.0"],
                                        RT: "ARM"
                                    }
                                }
                            }
                        },
                        c = {
                            browser: [
                                [/(opera\smini)\/([\w\.-]+)/i, /(opera\s[mobiletab]+).+version\/([\w\.-]+)/i, /(opera).+version\/([\w\.]+)/i, /(opera)[\/\s]+([\w\.]+)/i],
                                [o, a],
                                [/(opios)[\/\s]+([\w\.]+)/i],
                                [
                                    [o, "Opera Mini"], a
                                ],
                                [/\s(opr)\/([\w\.]+)/i],
                                [
                                    [o, "Opera"], a
                                ],
                                [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/\s]?([\w\.]+)*/i, /(avant\s|iemobile|slim|baidu)(?:browser)?[\/\s]?([\w\.]*)/i, /(?:ms|\()(ie)\s([\w\.]+)/i, /(rekonq)\/([\w\.]+)*/i, /(chromium|flock|rockmelt|midori|epiphany|silk|skyfire|ovibrowser|bolt|iron|vivaldi|iridium|phantomjs|bowser)\/([\w\.-]+)/i],
                                [o, a],
                                [/(trident).+rv[:\s]([\w\.]+).+like\sgecko/i],
                                [
                                    [o, "IE"], a
                                ],
                                [/(edge)\/((\d+)?[\w\.]+)/i],
                                [o, a],
                                [/(yabrowser)\/([\w\.]+)/i],
                                [
                                    [o, "Yandex"], a
                                ],
                                [/(puffin)\/([\w\.]+)/i],
                                [
                                    [o, "Puffin"], a
                                ],
                                [/((?:[\s\/])uc?\s?browser|(?:juc.+)ucweb)[\/\s]?([\w\.]+)/i],
                                [
                                    [o, "UCBrowser"], a
                                ],
                                [/(comodo_dragon)\/([\w\.]+)/i],
                                [
                                    [o, /_/g, " "], a
                                ],
                                [/(micromessenger)\/([\w\.]+)/i],
                                [
                                    [o, "WeChat"], a
                                ],
                                [/(QQ)\/([\d\.]+)/i],
                                [o, a],
                                [/m?(qqbrowser)[\/\s]?([\w\.]+)/i],
                                [o, a],
                                [/xiaomi\/miuibrowser\/([\w\.]+)/i],
                                [a, [o, "MIUI Browser"]],
                                [/;fbav\/([\w\.]+);/i],
                                [a, [o, "Facebook"]],
                                [/headlesschrome(?:\/([\w\.]+)|\s)/i],
                                [a, [o, "Chrome Headless"]],
                                [/\swv\).+(chrome)\/([\w\.]+)/i],
                                [
                                    [o, /(.+)/, "$1 WebView"], a
                                ],
                                [/((?:oculus|samsung)browser)\/([\w\.]+)/i],
                                [
                                    [o, /(.+(?:g|us))(.+)/, "$1 $2"], a
                                ],
                                [/android.+version\/([\w\.]+)\s+(?:mobile\s?safari|safari)*/i],
                                [a, [o, "Android Browser"]],
                                [/(chrome|omniweb|arora|[tizenoka]{5}\s?browser)\/v?([\w\.]+)/i],
                                [o, a],
                                [/(dolfin)\/([\w\.]+)/i],
                                [
                                    [o, "Dolphin"], a
                                ],
                                [/((?:android.+)crmo|crios)\/([\w\.]+)/i],
                                [
                                    [o, "Chrome"], a
                                ],
                                [/(coast)\/([\w\.]+)/i],
                                [
                                    [o, "Opera Coast"], a
                                ],
                                [/fxios\/([\w\.-]+)/i],
                                [a, [o, "Firefox"]],
                                [/version\/([\w\.]+).+?mobile\/\w+\s(safari)/i],
                                [a, [o, "Mobile Safari"]],
                                [/version\/([\w\.]+).+?(mobile\s?safari|safari)/i],
                                [a, o],
                                [/webkit.+?(gsa)\/([\w\.]+).+?(mobile\s?safari|safari)(\/[\w\.]+)/i],
                                [
                                    [o, "GSA"], a
                                ],
                                [/webkit.+?(mobile\s?safari|safari)(\/[\w\.]+)/i],
                                [o, [a, w.str, u.browser.oldsafari.version]],
                                [/(konqueror)\/([\w\.]+)/i, /(webkit|khtml)\/([\w\.]+)/i],
                                [o, a],
                                [/(navigator|netscape)\/([\w\.-]+)/i],
                                [
                                    [o, "Netscape"], a
                                ],
                                [/(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo\sbrowser|minimo|conkeror)[\/\s]?([\w\.\+]+)/i, /(firefox|seamonkey|k-meleon|icecat|iceape|firebird|phoenix)\/([\w\.-]+)/i, /(mozilla)\/([\w\.]+).+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir)[\/\s]?([\w\.]+)/i, /(links)\s\(([\w\.]+)/i, /(gobrowser)\/?([\w\.]+)*/i, /(ice\s?browser)\/v?([\w\._]+)/i, /(mosaic)[\/\s]([\w\.]+)/i],
                                [o, a]
                            ],
                            cpu: [
                                [/(?:(amd|x(?:(?:86|64)[_-])?|wow|win)64)[;\)]/i],
                                [
                                    ["architecture", "amd64"]
                                ],
                                [/(ia32(?=;))/i],
                                [
                                    ["architecture", l.lowerize]
                                ],
                                [/((?:i[346]|x)86)[;\)]/i],
                                [
                                    ["architecture", "ia32"]
                                ],
                                [/windows\s(ce|mobile);\sppc;/i],
                                [
                                    ["architecture", "arm"]
                                ],
                                [/((?:ppc|powerpc)(?:64)?)(?:\smac|;|\))/i],
                                [
                                    ["architecture", /ower/, "", l.lowerize]
                                ],
                                [/(sun4\w)[;\)]/i],
                                [
                                    ["architecture", "sparc"]
                                ],
                                [/((?:avr32|ia64(?=;))|68k(?=\))|arm(?:64|(?=v\d+;))|(?=atmel\s)avr|(?:irix|mips|sparc)(?:64)?(?=;)|pa-risc)/i],
                                [
                                    ["architecture", l.lowerize]
                                ]
                            ],
                            device: [
                                [/\((ipad|playbook);[\w\s\);-]+(rim|apple)/i],
                                [e, n, [r, d]],
                                [/applecoremedia\/[\w\.]+ \((ipad)/],
                                [e, [n, "Apple"],
                                    [r, d]
                                ],
                                [/(apple\s{0,1}tv)/i],
                                [
                                    [e, "Apple TV"],
                                    [n, "Apple"]
                                ],
                                [/(archos)\s(gamepad2?)/i, /(hp).+(touchpad)/i, /(hp).+(tablet)/i, /(kindle)\/([\w\.]+)/i, /\s(nook)[\w\s]+build\/(\w+)/i, /(dell)\s(strea[kpr\s\d]*[\dko])/i],
                                [n, e, [r, d]],
                                [/(kf[A-z]+)\sbuild\/[\w\.]+.*silk\//i],
                                [e, [n, "Amazon"],
                                    [r, d]
                                ],
                                [/(sd|kf)[0349hijorstuw]+\sbuild\/[\w\.]+.*silk\//i],
                                [
                                    [e, w.str, u.device.amazon.model],
                                    [n, "Amazon"],
                                    [r, t]
                                ],
                                [/\((ip[honed|\s\w*]+);.+(apple)/i],
                                [e, n, [r, t]],
                                [/\((ip[honed|\s\w*]+);/i],
                                [e, [n, "Apple"],
                                    [r, t]
                                ],
                                [/(blackberry)[\s-]?(\w+)/i, /(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron)[\s_-]?([\w-]+)*/i, /(hp)\s([\w\s]+\w)/i, /(asus)-?(\w+)/i],
                                [n, e, [r, t]],
                                [/\(bb10;\s(\w+)/i],
                                [e, [n, "BlackBerry"],
                                    [r, t]
                                ],
                                [/android.+(transfo[prime\s]{4,10}\s\w+|eeepc|slider\s\w+|nexus 7|padfone)/i],
                                [e, [n, "Asus"],
                                    [r, d]
                                ],
                                [/(sony)\s(tablet\s[ps])\sbuild\//i, /(sony)?(?:sgp.+)\sbuild\//i],
                                [
                                    [n, "Sony"],
                                    [e, "Xperia Tablet"],
                                    [r, d]
                                ],
                                [/android.+\s([c-g]\d{4}|so[-l]\w+)\sbuild\//i],
                                [e, [n, "Sony"],
                                    [r, t]
                                ],
                                [/\s(ouya)\s/i, /(nintendo)\s([wids3u]+)/i],
                                [n, e, [r, "console"]],
                                [/android.+;\s(shield)\sbuild/i],
                                [e, [n, "Nvidia"],
                                    [r, "console"]
                                ],
                                [/(playstation\s[34portablevi]+)/i],
                                [e, [n, "Sony"],
                                    [r, "console"]
                                ],
                                [/(sprint\s(\w+))/i],
                                [
                                    [n, w.str, u.device.sprint.vendor],
                                    [e, w.str, u.device.sprint.model],
                                    [r, t]
                                ],
                                [/(lenovo)\s?(S(?:5000|6000)+(?:[-][\w+]))/i],
                                [n, e, [r, d]],
                                [/(htc)[;_\s-]+([\w\s]+(?=\))|\w+)*/i, /(zte)-(\w+)*/i, /(alcatel|geeksphone|lenovo|nexian|panasonic|(?=;\s)sony)[_\s-]?([\w-]+)*/i],
                                [n, [e, /_/g, " "],
                                    [r, t]
                                ],
                                [/(nexus\s9)/i],
                                [e, [n, "HTC"],
                                    [r, d]
                                ],
                                [/d\/huawei([\w\s-]+)[;\)]/i, /(nexus\s6p)/i],
                                [e, [n, "Huawei"],
                                    [r, t]
                                ],
                                [/(microsoft);\s(lumia[\s\w]+)/i],
                                [n, e, [r, t]],
                                [/[\s\(;](xbox(?:\sone)?)[\s\);]/i],
                                [e, [n, "Microsoft"],
                                    [r, "console"]
                                ],
                                [/(kin\.[onetw]{3})/i],
                                [
                                    [e, /\./g, " "],
                                    [n, "Microsoft"],
                                    [r, t]
                                ],
                                [/\s(milestone|droid(?:[2-4x]|\s(?:bionic|x2|pro|razr))?(:?\s4g)?)[\w\s]+build\//i, /mot[\s-]?(\w+)*/i, /(XT\d{3,4}) build\//i, /(nexus\s6)/i],
                                [e, [n, "Motorola"],
                                    [r, t]
                                ],
                                [/android.+\s(mz60\d|xoom[\s2]{0,2})\sbuild\//i],
                                [e, [n, "Motorola"],
                                    [r, d]
                                ],
                                [/hbbtv\/\d+\.\d+\.\d+\s+\([\w\s]*;\s*(\w[^;]*);([^;]*)/i],
                                [
                                    [n, l.trim],
                                    [e, l.trim],
                                    [r, "smarttv"]
                                ],
                                [/hbbtv.+maple;(\d+)/i],
                                [
                                    [e, /^/, "SmartTV"],
                                    [n, "Samsung"],
                                    [r, "smarttv"]
                                ],
                                [/\(dtv[\);].+(aquos)/i],
                                [e, [n, "Sharp"],
                                    [r, "smarttv"]
                                ],
                                [/android.+((sch-i[89]0\d|shw-m380s|gt-p\d{4}|gt-n\d+|sgh-t8[56]9|nexus 10))/i, /((SM-T\w+))/i],
                                [
                                    [n, "Samsung"], e, [r, d]
                                ],
                                [/smart-tv.+(samsung)/i],
                                [n, [r, "smarttv"], e],
                                [/((s[cgp]h-\w+|gt-\w+|galaxy\snexus|sm-\w[\w\d]+))/i, /(sam[sung]*)[\s-]*(\w+-?[\w-]*)*/i, /sec-((sgh\w+))/i],
                                [
                                    [n, "Samsung"], e, [r, t]
                                ],
                                [/sie-(\w+)*/i],
                                [e, [n, "Siemens"],
                                    [r, t]
                                ],
                                [/(maemo|nokia).*(n900|lumia\s\d+)/i, /(nokia)[\s_-]?([\w-]+)*/i],
                                [
                                    [n, "Nokia"], e, [r, t]
                                ],
                                [/android\s3\.[\s\w;-]{10}(a\d{3})/i],
                                [e, [n, "Acer"],
                                    [r, d]
                                ],
                                [/android.+([vl]k\-?\d{3})\s+build/i],
                                [e, [n, "LG"],
                                    [r, d]
                                ],
                                [/android\s3\.[\s\w;-]{10}(lg?)-([06cv9]{3,4})/i],
                                [
                                    [n, "LG"], e, [r, d]
                                ],
                                [/(lg) netcast\.tv/i],
                                [n, e, [r, "smarttv"]],
                                [/(nexus\s[45])/i, /lg[e;\s\/-]+(\w+)*/i, /android.+lg(\-?[\d\w]+)\s+build/i],
                                [e, [n, "LG"],
                                    [r, t]
                                ],
                                [/android.+(ideatab[a-z0-9\-\s]+)/i],
                                [e, [n, "Lenovo"],
                                    [r, d]
                                ],
                                [/linux;.+((jolla));/i],
                                [n, e, [r, t]],
                                [/((pebble))app\/[\d\.]+\s/i],
                                [n, e, [r, "wearable"]],
                                [/android.+;\s(oppo)\s?([\w\s]+)\sbuild/i],
                                [n, e, [r, t]],
                                [/crkey/i],
                                [
                                    [e, "Chromecast"],
                                    [n, "Google"]
                                ],
                                [/android.+;\s(glass)\s\d/i],
                                [e, [n, "Google"],
                                    [r, "wearable"]
                                ],
                                [/android.+;\s(pixel c)\s/i],
                                [e, [n, "Google"],
                                    [r, d]
                                ],
                                [/android.+;\s(pixel xl|pixel)\s/i],
                                [e, [n, "Google"],
                                    [r, t]
                                ],
                                [/android.+(\w+)\s+build\/hm\1/i, /android.+(hm[\s\-_]*note?[\s_]*(?:\d\w)?)\s+build/i, /android.+(mi[\s\-_]*(?:one|one[\s_]plus|note lte)?[\s_]*(?:\d\w)?)\s+build/i, /android.+(redmi[\s\-_]*(?:note)?(?:[\s_]*[\w\s]+)?)\s+build/i],
                                [
                                    [e, /_/g, " "],
                                    [n, "Xiaomi"],
                                    [r, t]
                                ],
                                [/android.+(mi[\s\-_]*(?:pad)?(?:[\s_]*[\w\s]+)?)\s+build/i],
                                [
                                    [e, /_/g, " "],
                                    [n, "Xiaomi"],
                                    [r, d]
                                ],
                                [/android.+;\s(m[1-5]\snote)\sbuild/i],
                                [e, [n, "Meizu"],
                                    [r, d]
                                ],
                                [/android.+a000(1)\s+build/i],
                                [e, [n, "OnePlus"],
                                    [r, t]
                                ],
                                [/android.+[;\/]\s*(RCT[\d\w]+)\s+build/i],
                                [e, [n, "RCA"],
                                    [r, d]
                                ],
                                [/android.+[;\/]\s*(Venue[\d\s]*)\s+build/i],
                                [e, [n, "Dell"],
                                    [r, d]
                                ],
                                [/android.+[;\/]\s*(Q[T|M][\d\w]+)\s+build/i],
                                [e, [n, "Verizon"],
                                    [r, d]
                                ],
                                [/android.+[;\/]\s+(Barnes[&\s]+Noble\s+|BN[RT])(V?.*)\s+build/i],
                                [
                                    [n, "Barnes & Noble"], e, [r, d]
                                ],
                                [/android.+[;\/]\s+(TM\d{3}.*\b)\s+build/i],
                                [e, [n, "NuVision"],
                                    [r, d]
                                ],
                                [/android.+[;\/]\s*(zte)?.+(k\d{2})\s+build/i],
                                [
                                    [n, "ZTE"], e, [r, d]
                                ],
                                [/android.+[;\/]\s*(gen\d{3})\s+build.*49h/i],
                                [e, [n, "Swiss"],
                                    [r, t]
                                ],
                                [/android.+[;\/]\s*(zur\d{3})\s+build/i],
                                [e, [n, "Swiss"],
                                    [r, d]
                                ],
                                [/android.+[;\/]\s*((Zeki)?TB.*\b)\s+build/i],
                                [e, [n, "Zeki"],
                                    [r, d]
                                ],
                                [/(android).+[;\/]\s+([YR]\d{2}x?.*)\s+build/i, /android.+[;\/]\s+(Dragon[\-\s]+Touch\s+|DT)(.+)\s+build/i],
                                [
                                    [n, "Dragon Touch"], e, [r, d]
                                ],
                                [/android.+[;\/]\s*(NS-?.+)\s+build/i],
                                [e, [n, "Insignia"],
                                    [r, d]
                                ],
                                [/android.+[;\/]\s*((NX|Next)-?.+)\s+build/i],
                                [e, [n, "NextBook"],
                                    [r, d]
                                ],
                                [/android.+[;\/]\s*(Xtreme\_?)?(V(1[045]|2[015]|30|40|60|7[05]|90))\s+build/i],
                                [
                                    [n, "Voice"], e, [r, t]
                                ],
                                [/android.+[;\/]\s*(LVTEL\-?)?(V1[12])\s+build/i],
                                [
                                    [n, "LvTel"], e, [r, t]
                                ],
                                [/android.+[;\/]\s*(V(100MD|700NA|7011|917G).*\b)\s+build/i],
                                [e, [n, "Envizen"],
                                    [r, d]
                                ],
                                [/android.+[;\/]\s*(Le[\s\-]+Pan)[\s\-]+(.*\b)\s+build/i],
                                [n, e, [r, d]],
                                [/android.+[;\/]\s*(Trio[\s\-]*.*)\s+build/i],
                                [e, [n, "MachSpeed"],
                                    [r, d]
                                ],
                                [/android.+[;\/]\s*(Trinity)[\-\s]*(T\d{3})\s+build/i],
                                [n, e, [r, d]],
                                [/android.+[;\/]\s*TU_(1491)\s+build/i],
                                [e, [n, "Rotor"],
                                    [r, d]
                                ],
                                [/android.+(KS(.+))\s+build/i],
                                [e, [n, "Amazon"],
                                    [r, d]
                                ],
                                [/android.+(Gigaset)[\s\-]+(Q.+)\s+build/i],
                                [n, e, [r, d]],
                                [/\s(tablet|tab)[;\/]/i, /\s(mobile)(?:[;\/]|\ssafari)/i],
                                [
                                    [r, l.lowerize], n, e
                                ],
                                [/(android.+)[;\/].+build/i],
                                [e, [n, "Generic"]]
                            ],
                            engine: [
                                [/windows.+\sedge\/([\w\.]+)/i],
                                [a, [o, "EdgeHTML"]],
                                [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m)\/([\w\.]+)/i, /(khtml|tasman|links)[\/\s]\(?([\w\.]+)/i, /(icab)[\/\s]([23]\.[\d\.]+)/i],
                                [o, a],
                                [/rv\:([\w\.]+).*(gecko)/i],
                                [a, o]
                            ],
                            os: [
                                [/microsoft\s(windows)\s(vista|xp)/i],
                                [o, a],
                                [/(windows)\snt\s6\.2;\s(arm)/i, /(windows\sphone(?:\sos)*)[\s\/]?([\d\.\s]+\w)*/i, /(windows\smobile|windows)[\s\/]?([ntce\d\.\s]+\w)/i],
                                [o, [a, w.str, u.os.windows.version]],
                                [/(win(?=3|9|n)|win\s9x\s)([nt\d\.]+)/i],
                                [
                                    [o, "Windows"],
                                    [a, w.str, u.os.windows.version]
                                ],
                                [/\((bb)(10);/i],
                                [
                                    [o, "BlackBerry"], a
                                ],
                                [/(blackberry)\w*\/?([\w\.]+)*/i, /(tizen)[\/\s]([\w\.]+)/i, /(android|webos|palm\sos|qnx|bada|rim\stablet\sos|meego|contiki)[\/\s-]?([\w\.]+)*/i, /linux;.+(sailfish);/i],
                                [o, a],
                                [/(symbian\s?os|symbos|s60(?=;))[\/\s-]?([\w\.]+)*/i],
                                [
                                    [o, "Symbian"], a
                                ],
                                [/\((series40);/i],
                                [o],
                                [/mozilla.+\(mobile;.+gecko.+firefox/i],
                                [
                                    [o, "Firefox OS"], a
                                ],
                                [/(nintendo|playstation)\s([wids34portablevu]+)/i, /(mint)[\/\s\(]?(\w+)*/i, /(mageia|vectorlinux)[;\s]/i, /(joli|[kxln]?ubuntu|debian|[open]*suse|gentoo|(?=\s)arch|slackware|fedora|mandriva|centos|pclinuxos|redhat|zenwalk|linpus)[\/\s-]?(?!chrom)([\w\.-]+)*/i, /(hurd|linux)\s?([\w\.]+)*/i, /(gnu)\s?([\w\.]+)*/i],
                                [o, a],
                                [/(cros)\s[\w]+\s([\w\.]+\w)/i],
                                [
                                    [o, "Chromium OS"], a
                                ],
                                [/(sunos)\s?([\w\.]+\d)*/i],
                                [
                                    [o, "Solaris"], a
                                ],
                                [/\s([frentopc-]{0,4}bsd|dragonfly)\s?([\w\.]+)*/i],
                                [o, a],
                                [/(haiku)\s(\w+)/i],
                                [o, a],
                                [/cfnetwork\/.+darwin/i, /ip[honead]+(?:.*os\s([\w]+)\slike\smac|;\sopera)/i],
                                [
                                    [a, /_/g, "."],
                                    [o, "iOS"]
                                ],
                                [/(mac\sos\sx)\s?([\w\s\.]+\w)*/i, /(macintosh|mac(?=_powerpc)\s)/i],
                                [
                                    [o, "Mac OS"],
                                    [a, /_/g, "."]
                                ],
                                [/((?:open)?solaris)[\/\s-]?([\w\.]+)*/i, /(aix)\s((\d)(?=\.|\)|\s)[\w\.]*)*/i, /(plan\s9|minix|beos|os\/2|amigaos|morphos|risc\sos|openvms)/i, /(unix)\s?([\w\.]+)*/i],
                                [o, a]
                            ]
                        },
                        m = function m(s, e) {
                            if ("object" == _typeof2(s) && (e = s, s = void 0), !(this instanceof m)) return new m(s, e).getResult();
                            var o = s || (i && i.navigator && i.navigator.userAgent ? i.navigator.userAgent : ""),
                                r = e ? l.extend(c, e) : c;
                            return this.getBrowser = function() {
                                var i = {
                                    name: void 0,
                                    version: void 0
                                };
                                return w.rgx.call(i, o, r.browser), i.major = l.major(i.version), i
                            }, this.getCPU = function() {
                                var i = {
                                    architecture: void 0
                                };
                                return w.rgx.call(i, o, r.cpu), i
                            }, this.getDevice = function() {
                                var i = {
                                    vendor: void 0,
                                    model: void 0,
                                    type: void 0
                                };
                                return w.rgx.call(i, o, r.device), i
                            }, this.getEngine = function() {
                                var i = {
                                    name: void 0,
                                    version: void 0
                                };
                                return w.rgx.call(i, o, r.engine), i
                            }, this.getOS = function() {
                                var i = {
                                    name: void 0,
                                    version: void 0
                                };
                                return w.rgx.call(i, o, r.os), i
                            }, this.getResult = function() {
                                return {
                                    ua: this.getUA(),
                                    browser: this.getBrowser(),
                                    engine: this.getEngine(),
                                    os: this.getOS(),
                                    device: this.getDevice(),
                                    cpu: this.getCPU()
                                }
                            }, this.getUA = function() {
                                return o
                            }, this.setUA = function(i) {
                                return o = i, this
                            }, this
                        };
                    m.VERSION = "0.7.17", m.BROWSER = {
                        NAME: o,
                        MAJOR: "major",
                        VERSION: a
                    }, m.CPU = {
                        ARCHITECTURE: "architecture"
                    }, m.DEVICE = {
                        MODEL: e,
                        VENDOR: n,
                        TYPE: r,
                        CONSOLE: "console",
                        MOBILE: t,
                        SMARTTV: "smarttv",
                        TABLET: d,
                        WEARABLE: "wearable",
                        EMBEDDED: "embedded"
                    }, m.ENGINE = {
                        NAME: o,
                        VERSION: a
                    }, m.OS = {
                        NAME: o,
                        VERSION: a
                    }, "undefined" != typeof exports ? ("undefined" != typeof module && module.exports && (exports = module.exports = m), exports.UAParser = m) : "function" == typeof define && define.amd ? define(function() {
                        return m
                    }) : i && (i.UAParser = m);
                    var b = i && (i.jQuery || i.Zepto);
                    if (void 0 !== b) {
                        var p = new m;
                        b.ua = p.getResult(), b.ua.get = function() {
                            return p.getUA()
                        }, b.ua.set = function(i) {
                            p.setUA(i);
                            var s = p.getResult();
                            for (var e in s) b.ua[e] = s[e]
                        }
                    }
                }("object" == ("undefined" == typeof window ? "undefined" : _typeof2(window)) ? window : this)
            }, {}],
            461: [function(require, module, exports) {
                module.exports = /[\0-\x1F\x7F-\x9F]/
            }, {}],
            462: [function(require, module, exports) {
                module.exports = /[!-#%-\*,-/:;\?@\[-\]_\{\}\xA1\xA7\xAB\xB6\xB7\xBB\xBF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E44\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]|\uD800[\uDD00-\uDD02\uDF9F\uDFD0]|\uD801\uDD6F|\uD802[\uDC57\uDD1F\uDD3F\uDE50-\uDE58\uDE7F\uDEF0-\uDEF6\uDF39-\uDF3F\uDF99-\uDF9C]|\uD804[\uDC47-\uDC4D\uDCBB\uDCBC\uDCBE-\uDCC1\uDD40-\uDD43\uDD74\uDD75\uDDC5-\uDDC9\uDDCD\uDDDB\uDDDD-\uDDDF\uDE38-\uDE3D\uDEA9]|\uD805[\uDC4B-\uDC4F\uDC5B\uDC5D\uDCC6\uDDC1-\uDDD7\uDE41-\uDE43\uDE60-\uDE6C\uDF3C-\uDF3E]|\uD807[\uDC41-\uDC45\uDC70\uDC71]|\uD809[\uDC70-\uDC74]|\uD81A[\uDE6E\uDE6F\uDEF5\uDF37-\uDF3B\uDF44]|\uD82F\uDC9F|\uD836[\uDE87-\uDE8B]|\uD83A[\uDD5E\uDD5F]/
            }, {}],
            463: [function(require, module, exports) {
                module.exports = /[ \xA0\u1680\u2000-\u200A\u202F\u205F\u3000]/
            }, {}],
            464: [function(require, module, exports) {
                module.exports = /[\0-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/
            }, {}]
        }, {}, [36])(36)
    }), ! function(r) {
        function e(n) {
            if (o[n]) return o[n].exports;
            var t = o[n] = {
                exports: {},
                id: n,
                loaded: !1
            };
            return r[n].call(t.exports, t, t.exports, e), t.loaded = !0, t.exports
        }
        var o = {};
        return e.m = r, e.c = o, e.p = "", e(0)
    }([function(r, e, o) {
        "use strict";
        var n = o(1),
            t = o(4);
        _rollbarConfig = _rollbarConfig || {}, _rollbarConfig.rollbarJsUrl = _rollbarConfig.rollbarJsUrl || "https://cdnjs.cloudflare.com/ajax/libs/rollbar.js/2.4.1/rollbar.min.js", _rollbarConfig.async = void 0 === _rollbarConfig.async || _rollbarConfig.async;
        var a = n.setupShim(window, _rollbarConfig),
            l = t(_rollbarConfig);
        window.rollbar = n.Rollbar, a.loadFull(window, document, !_rollbarConfig.async, _rollbarConfig, l)
    }, function(r, e, o) {
        "use strict";

        function n(r) {
            return function() {
                try {
                    return r.apply(this, arguments)
                } catch (r) {
                    try {
                        console.error("[Rollbar]: Internal error", r)
                    } catch (r) {}
                }
            }
        }

        function t(r, e) {
            this.options = r, this._rollbarOldOnError = null;
            var o = s++;
            this.shimId = function() {
                return o
            }, "undefined" != typeof window && window._rollbarShims && (window._rollbarShims[o] = {
                handler: e,
                messages: []
            })
        }

        function a(r, e) {
            if (r) {
                var o = e.globalAlias || "Rollbar";
                if ("object" == _typeof2(r[o])) return r[o];
                r._rollbarShims = {}, r._rollbarWrappedError = null;
                var t = new p(e);
                return n(function() {
                    e.captureUncaught && (t._rollbarOldOnError = r.onerror, i.captureUncaughtExceptions(r, t, !0), i.wrapGlobals(r, t, !0)), e.captureUnhandledRejections && i.captureUnhandledRejections(r, t, !0);
                    var n = e.autoInstrument;
                    return e.enabled !== !1 && (void 0 === n || n === !0 || "object" == _typeof2(n) && n.network) && r.addEventListener && (r.addEventListener("load", t.captureLoad.bind(t)), r.addEventListener("DOMContentLoaded", t.captureDomContentLoaded.bind(t))), r[o] = t, t
                })()
            }
        }

        function l(r) {
            return n(function() {
                var e = this,
                    o = Array.prototype.slice.call(arguments, 0),
                    n = {
                        shim: e,
                        method: r,
                        args: o,
                        ts: new Date
                    };
                window._rollbarShims[this.shimId()].messages.push(n)
            })
        }
        var i = o(2),
            s = 0,
            d = o(3),
            c = function(r, e) {
                return new t(r, e)
            },
            p = d.bind(null, c);
        t.prototype.loadFull = function(r, e, o, t, a) {
            var l = function l() {
                    var e;
                    if (void 0 === r._rollbarDidLoad) {
                        e = new Error("rollbar.js did not load");
                        for (var o, n, t, l, i = 0; o = r._rollbarShims[i++];)
                            for (o = o.messages || []; n = o.shift();)
                                for (t = n.args || [], i = 0; i < t.length; ++i)
                                    if (l = t[i], "function" == typeof l) {
                                        l(e);
                                        break
                                    }
                    }
                    "function" == typeof a && a(e)
                },
                i = !1,
                s = e.createElement("script"),
                d = e.getElementsByTagName("script")[0],
                c = d.parentNode;
            s.crossOrigin = "", s.src = t.rollbarJsUrl, o || (s.async = !0), s.onload = s.onreadystatechange = n(function() {
                if (!(i || this.readyState && "loaded" !== this.readyState && "complete" !== this.readyState)) {
                    s.onload = s.onreadystatechange = null;
                    try {
                        c.removeChild(s)
                    } catch (r) {}
                    i = !0, l()
                }
            }), c.insertBefore(s, d)
        }, t.prototype.wrap = function(r, e, o) {
            try {
                var n;
                if (n = "function" == typeof e ? e : function() {
                        return e || {}
                    }, "function" != typeof r) return r;
                if (r._isWrap) return r;
                if (!r._rollbar_wrapped && (r._rollbar_wrapped = function() {
                        o && "function" == typeof o && o.apply(this, arguments);
                        try {
                            return r.apply(this, arguments)
                        } catch (o) {
                            var e = o;
                            throw e && ("string" == typeof e && (e = new String(e)), e._rollbarContext = n() || {}, e._rollbarContext._wrappedSource = r.toString(), window._rollbarWrappedError = e), e
                        }
                    }, r._rollbar_wrapped._isWrap = !0, r.hasOwnProperty))
                    for (var t in r) r.hasOwnProperty(t) && (r._rollbar_wrapped[t] = r[t]);
                return r._rollbar_wrapped
            } catch (e) {
                return r
            }
        };
        for (var u = "log,debug,info,warn,warning,error,critical,global,configure,handleUncaughtException,handleUnhandledRejection,captureEvent,captureDomContentLoaded,captureLoad".split(","), f = 0; f < u.length; ++f) t.prototype[u[f]] = l(u[f]);
        r.exports = {
            setupShim: a,
            Rollbar: p
        }
    }, function(r, e) {
        "use strict";

        function o(r, e, o) {
            if (r) {
                var t;
                "function" == typeof e._rollbarOldOnError ? t = e._rollbarOldOnError : r.onerror && !r.onerror.belongsToShim && (t = r.onerror, e._rollbarOldOnError = t);
                var a = function() {
                    var o = Array.prototype.slice.call(arguments, 0);
                    n(r, e, t, o)
                };
                a.belongsToShim = o, r.onerror = a
            }
        }

        function n(r, e, o, n) {
            r._rollbarWrappedError && (n[4] || (n[4] = r._rollbarWrappedError), n[5] || (n[5] = r._rollbarWrappedError._rollbarContext), r._rollbarWrappedError = null), e.handleUncaughtException.apply(e, n), o && o.apply(r, n)
        }

        function t(r, e, o) {
            if (r) {
                "function" == typeof r._rollbarURH && r._rollbarURH.belongsToShim && r.removeEventListener("unhandledrejection", r._rollbarURH);
                var n = function n(r) {
                    var o, n, t;
                    try {
                        o = r.reason
                    } catch (r) {
                        o = void 0
                    }
                    try {
                        n = r.promise
                    } catch (r) {
                        n = "[unhandledrejection] error getting `promise` from event"
                    }
                    try {
                        t = r.detail, !o && t && (o = t.reason, n = t.promise)
                    } catch (r) {
                        t = "[unhandledrejection] error getting `detail` from event"
                    }
                    o || (o = "[unhandledrejection] error getting `reason` from event"), e && e.handleUnhandledRejection && e.handleUnhandledRejection(o, n)
                };
                n.belongsToShim = o, r._rollbarURH = n, r.addEventListener("unhandledrejection", n)
            }
        }

        function a(r, e, o) {
            if (r) {
                var n, t, a = "EventTarget,Window,Node,ApplicationCache,AudioTrackList,ChannelMergerNode,CryptoOperation,EventSource,FileReader,HTMLUnknownElement,IDBDatabase,IDBRequest,IDBTransaction,KeyOperation,MediaController,MessagePort,ModalWindow,Notification,SVGElementInstance,Screen,TextTrack,TextTrackCue,TextTrackList,WebSocket,WebSocketWorker,Worker,XMLHttpRequest,XMLHttpRequestEventTarget,XMLHttpRequestUpload".split(",");
                for (n = 0; n < a.length; ++n) t = a[n], r[t] && r[t].prototype && l(e, r[t].prototype, o)
            }
        }

        function l(r, e, o) {
            if (e.hasOwnProperty && e.hasOwnProperty("addEventListener")) {
                for (var n = e.addEventListener; n._rollbarOldAdd && n.belongsToShim;) n = n._rollbarOldAdd;
                var t = function(e, o, _t2) {
                    n.call(this, e, r.wrap(o), _t2)
                };
                t._rollbarOldAdd = n, t.belongsToShim = o, e.addEventListener = t;
                for (var a = e.removeEventListener; a._rollbarOldRemove && a.belongsToShim;) a = a._rollbarOldRemove;
                var l = function(r, e, o) {
                    a.call(this, r, e && e._rollbar_wrapped || e, o)
                };
                l._rollbarOldRemove = a, l.belongsToShim = o, e.removeEventListener = l
            }
        }
        r.exports = {
            captureUncaughtExceptions: o,
            captureUnhandledRejections: t,
            wrapGlobals: a
        }
    }, function(r, e) {
        "use strict";

        function o(r, e) {
            this.impl = r(e, this), this.options = e, n(o.prototype)
        }

        function n(r) {
            for (var e = function(r) {
                    return function() {
                        var e = Array.prototype.slice.call(arguments, 0);
                        if (this.impl[r]) return this.impl[r].apply(this.impl, e)
                    }
                }, o = "log,debug,info,warn,warning,error,critical,global,configure,handleUncaughtException,handleUnhandledRejection,_createItem,wrap,loadFull,shimId,captureEvent,captureDomContentLoaded,captureLoad".split(","), n = 0; n < o.length; n++) r[o[n]] = e(o[n])
        }
        o.prototype._swapAndProcessMessages = function(r, e) {
            this.impl = r(this.options);
            for (var o, n, t; o = e.shift();) n = o.method, t = o.args, this[n] && "function" == typeof this[n] && ("captureDomContentLoaded" === n || "captureLoad" === n ? this[n].apply(this, [t[0], o.ts]) : this[n].apply(this, t));
            return this
        }, r.exports = o
    }, function(r, e) {
        "use strict";
        r.exports = function(r) {
            return function(e) {
                if (!e && !window._rollbarInitialized) {
                    r = r || {};
                    for (var o, n, t = r.globalAlias || "Rollbar", a = window.rollbar, l = function(r) {
                            return new a(r)
                        }, i = 0; o = window._rollbarShims[i++];) n || (n = o.handler), o.handler._swapAndProcessMessages(l, o.messages);
                    window[t] = n, window._rollbarInitialized = !0
                }
            }
        }
    }]),
    function(f) {
        if ("object" === ("undefined" == typeof exports ? "undefined" : _typeof2(exports)) && "undefined" != typeof module) module.exports = f();
        else if ("function" == typeof define && define.amd) define([], f);
        else {
            var g;
            g = "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : this, g.JSZip = f()
        }
    }(function() {
        return function e(t, n, r) {
            function s(o, u) {
                if (!n[o]) {
                    if (!t[o]) {
                        var a = "function" == typeof require && require;
                        if (!u && a) return a(o, !0);
                        if (i) return i(o, !0);
                        var f = new Error("Cannot find module '" + o + "'");
                        throw f.code = "MODULE_NOT_FOUND", f
                    }
                    var l = n[o] = {
                        exports: {}
                    };
                    t[o][0].call(l.exports, function(e) {
                        var n = t[o][1][e];
                        return s(n ? n : e)
                    }, l, l.exports, e, t, n, r)
                }
                return n[o].exports
            }
            for (var i = "function" == typeof require && require, o = 0; o < r.length; o++) s(r[o]);
            return s
        }({
            1: [function(require, module, exports) {
                "use strict";
                var utils = require("./utils"),
                    support = require("./support"),
                    _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
                exports.encode = function(input) {
                    for (var chr1, chr2, chr3, enc1, enc2, enc3, enc4, output = [], i = 0, len = input.length, remainingBytes = len, isArray = "string" !== utils.getTypeOf(input); i < input.length;) remainingBytes = len - i, isArray ? (chr1 = input[i++], chr2 = i < len ? input[i++] : 0, chr3 = i < len ? input[i++] : 0) : (chr1 = input.charCodeAt(i++), chr2 = i < len ? input.charCodeAt(i++) : 0, chr3 = i < len ? input.charCodeAt(i++) : 0), enc1 = chr1 >> 2, enc2 = (3 & chr1) << 4 | chr2 >> 4, enc3 = remainingBytes > 1 ? (15 & chr2) << 2 | chr3 >> 6 : 64, enc4 = remainingBytes > 2 ? 63 & chr3 : 64, output.push(_keyStr.charAt(enc1) + _keyStr.charAt(enc2) + _keyStr.charAt(enc3) + _keyStr.charAt(enc4));
                    return output.join("")
                }, exports.decode = function(input) {
                    var chr1, chr2, chr3, enc1, enc2, enc3, enc4, i = 0,
                        resultIndex = 0,
                        dataUrlPrefix = "data:";
                    if (input.substr(0, dataUrlPrefix.length) === dataUrlPrefix) throw new Error("Invalid base64 input, it looks like a data url.");
                    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
                    var totalLength = 3 * input.length / 4;
                    if (input.charAt(input.length - 1) === _keyStr.charAt(64) && totalLength--, input.charAt(input.length - 2) === _keyStr.charAt(64) && totalLength--, totalLength % 1 !== 0) throw new Error("Invalid base64 input, bad content length.");
                    var output;
                    for (output = support.uint8array ? new Uint8Array(0 | totalLength) : new Array(0 | totalLength); i < input.length;) enc1 = _keyStr.indexOf(input.charAt(i++)), enc2 = _keyStr.indexOf(input.charAt(i++)), enc3 = _keyStr.indexOf(input.charAt(i++)), enc4 = _keyStr.indexOf(input.charAt(i++)), chr1 = enc1 << 2 | enc2 >> 4, chr2 = (15 & enc2) << 4 | enc3 >> 2, chr3 = (3 & enc3) << 6 | enc4, output[resultIndex++] = chr1, 64 !== enc3 && (output[resultIndex++] = chr2), 64 !== enc4 && (output[resultIndex++] = chr3);
                    return output
                }
            }, {
                "./support": 30,
                "./utils": 32
            }],
            2: [function(require, module, exports) {
                "use strict";

                function CompressedObject(compressedSize, uncompressedSize, crc32, compression, data) {
                    this.compressedSize = compressedSize, this.uncompressedSize = uncompressedSize, this.crc32 = crc32, this.compression = compression, this.compressedContent = data
                }
                var external = require("./external"),
                    DataWorker = require("./stream/DataWorker"),
                    DataLengthProbe = require("./stream/DataLengthProbe"),
                    Crc32Probe = require("./stream/Crc32Probe"),
                    DataLengthProbe = require("./stream/DataLengthProbe");
                CompressedObject.prototype = {
                    getContentWorker: function() {
                        var worker = new DataWorker(external.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new DataLengthProbe("data_length")),
                            that = this;
                        return worker.on("end", function() {
                            if (this.streamInfo.data_length !== that.uncompressedSize) throw new Error("Bug : uncompressed data size mismatch")
                        }), worker
                    },
                    getCompressedWorker: function() {
                        return new DataWorker(external.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize", this.compressedSize).withStreamInfo("uncompressedSize", this.uncompressedSize).withStreamInfo("crc32", this.crc32).withStreamInfo("compression", this.compression)
                    }
                }, CompressedObject.createWorkerFrom = function(uncompressedWorker, compression, compressionOptions) {
                    return uncompressedWorker.pipe(new Crc32Probe).pipe(new DataLengthProbe("uncompressedSize")).pipe(compression.compressWorker(compressionOptions)).pipe(new DataLengthProbe("compressedSize")).withStreamInfo("compression", compression)
                }, module.exports = CompressedObject
            }, {
                "./external": 6,
                "./stream/Crc32Probe": 25,
                "./stream/DataLengthProbe": 26,
                "./stream/DataWorker": 27
            }],
            3: [function(require, module, exports) {
                "use strict";
                var GenericWorker = require("./stream/GenericWorker");
                exports.STORE = {
                    magic: "\0\0",
                    compressWorker: function(compressionOptions) {
                        return new GenericWorker("STORE compression")
                    },
                    uncompressWorker: function() {
                        return new GenericWorker("STORE decompression")
                    }
                }, exports.DEFLATE = require("./flate")
            }, {
                "./flate": 7,
                "./stream/GenericWorker": 28
            }],
            4: [function(require, module, exports) {
                "use strict";

                function makeTable() {
                    for (var c, table = [], n = 0; n < 256; n++) {
                        c = n;
                        for (var k = 0; k < 8; k++) c = 1 & c ? 3988292384 ^ c >>> 1 : c >>> 1;
                        table[n] = c
                    }
                    return table
                }

                function crc32(crc, buf, len, pos) {
                    var t = crcTable,
                        end = pos + len;
                    crc ^= -1;
                    for (var i = pos; i < end; i++) crc = crc >>> 8 ^ t[255 & (crc ^ buf[i])];
                    return crc ^ -1
                }

                function crc32str(crc, str, len, pos) {
                    var t = crcTable,
                        end = pos + len;
                    crc ^= -1;
                    for (var i = pos; i < end; i++) crc = crc >>> 8 ^ t[255 & (crc ^ str.charCodeAt(i))];
                    return crc ^ -1
                }
                var utils = require("./utils"),
                    crcTable = makeTable();
                module.exports = function(input, crc) {
                    if ("undefined" == typeof input || !input.length) return 0;
                    var isArray = "string" !== utils.getTypeOf(input);
                    return isArray ? crc32(0 | crc, input, input.length, 0) : crc32str(0 | crc, input, input.length, 0)
                }
            }, {
                "./utils": 32
            }],
            5: [function(require, module, exports) {
                "use strict";
                exports.base64 = !1, exports.binary = !1, exports.dir = !1, exports.createFolders = !0, exports.date = null, exports.compression = null, exports.compressionOptions = null, exports.comment = null, exports.unixPermissions = null, exports.dosPermissions = null
            }, {}],
            6: [function(require, module, exports) {
                "use strict";
                var ES6Promise = null;
                ES6Promise = "undefined" != typeof Promise ? Promise : require("lie"), module.exports = {
                    Promise: ES6Promise
                }
            }, {
                lie: 58
            }],
            7: [function(require, module, exports) {
                "use strict";

                function FlateWorker(action, options) {
                    GenericWorker.call(this, "FlateWorker/" + action), this._pako = null, this._pakoAction = action, this._pakoOptions = options, this.meta = {}
                }
                var USE_TYPEDARRAY = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Uint32Array,
                    pako = require("pako"),
                    utils = require("./utils"),
                    GenericWorker = require("./stream/GenericWorker"),
                    ARRAY_TYPE = USE_TYPEDARRAY ? "uint8array" : "array";
                exports.magic = "\b\0", utils.inherits(FlateWorker, GenericWorker), FlateWorker.prototype.processChunk = function(chunk) {
                    this.meta = chunk.meta, null === this._pako && this._createPako(), this._pako.push(utils.transformTo(ARRAY_TYPE, chunk.data), !1)
                }, FlateWorker.prototype.flush = function() {
                    GenericWorker.prototype.flush.call(this), null === this._pako && this._createPako(), this._pako.push([], !0)
                }, FlateWorker.prototype.cleanUp = function() {
                    GenericWorker.prototype.cleanUp.call(this), this._pako = null
                }, FlateWorker.prototype._createPako = function() {
                    this._pako = new pako[this._pakoAction]({
                        raw: !0,
                        level: this._pakoOptions.level || -1
                    });
                    var self = this;
                    this._pako.onData = function(data) {
                        self.push({
                            data: data,
                            meta: self.meta
                        })
                    }
                }, exports.compressWorker = function(compressionOptions) {
                    return new FlateWorker("Deflate", compressionOptions)
                }, exports.uncompressWorker = function() {
                    return new FlateWorker("Inflate", {})
                }
            }, {
                "./stream/GenericWorker": 28,
                "./utils": 32,
                pako: 59
            }],
            8: [function(require, module, exports) {
                "use strict";

                function ZipFileWorker(streamFiles, comment, platform, encodeFileName) {
                    GenericWorker.call(this, "ZipFileWorker"), this.bytesWritten = 0, this.zipComment = comment, this.zipPlatform = platform, this.encodeFileName = encodeFileName, this.streamFiles = streamFiles, this.accumulate = !1, this.contentBuffer = [], this.dirRecords = [], this.currentSourceOffset = 0, this.entriesCount = 0, this.currentFile = null, this._sources = []
                }
                var utils = require("../utils"),
                    GenericWorker = require("../stream/GenericWorker"),
                    utf8 = require("../utf8"),
                    crc32 = require("../crc32"),
                    signature = require("../signature"),
                    decToHex = function(dec, bytes) {
                        var i, hex = "";
                        for (i = 0; i < bytes; i++) hex += String.fromCharCode(255 & dec), dec >>>= 8;
                        return hex
                    },
                    generateUnixExternalFileAttr = function(unixPermissions, isDir) {
                        var result = unixPermissions;
                        return unixPermissions || (result = isDir ? 16893 : 33204), (65535 & result) << 16
                    },
                    generateDosExternalFileAttr = function(dosPermissions, isDir) {
                        return 63 & (dosPermissions || 0)
                    },
                    generateZipParts = function(streamInfo, streamedContent, streamingEnded, offset, platform, encodeFileName) {
                        var dosTime, dosDate, file = streamInfo.file,
                            compression = streamInfo.compression,
                            useCustomEncoding = encodeFileName !== utf8.utf8encode,
                            encodedFileName = utils.transformTo("string", encodeFileName(file.name)),
                            utfEncodedFileName = utils.transformTo("string", utf8.utf8encode(file.name)),
                            comment = file.comment,
                            encodedComment = utils.transformTo("string", encodeFileName(comment)),
                            utfEncodedComment = utils.transformTo("string", utf8.utf8encode(comment)),
                            useUTF8ForFileName = utfEncodedFileName.length !== file.name.length,
                            useUTF8ForComment = utfEncodedComment.length !== comment.length,
                            extraFields = "",
                            unicodePathExtraField = "",
                            unicodeCommentExtraField = "",
                            dir = file.dir,
                            date = file.date,
                            dataInfo = {
                                crc32: 0,
                                compressedSize: 0,
                                uncompressedSize: 0
                            };
                        streamedContent && !streamingEnded || (dataInfo.crc32 = streamInfo.crc32, dataInfo.compressedSize = streamInfo.compressedSize, dataInfo.uncompressedSize = streamInfo.uncompressedSize);
                        var bitflag = 0;
                        streamedContent && (bitflag |= 8), useCustomEncoding || !useUTF8ForFileName && !useUTF8ForComment || (bitflag |= 2048);
                        var extFileAttr = 0,
                            versionMadeBy = 0;
                        dir && (extFileAttr |= 16), "UNIX" === platform ? (versionMadeBy = 798, extFileAttr |= generateUnixExternalFileAttr(file.unixPermissions, dir)) : (versionMadeBy = 20, extFileAttr |= generateDosExternalFileAttr(file.dosPermissions, dir)), dosTime = date.getUTCHours(), dosTime <<= 6, dosTime |= date.getUTCMinutes(), dosTime <<= 5, dosTime |= date.getUTCSeconds() / 2, dosDate = date.getUTCFullYear() - 1980, dosDate <<= 4, dosDate |= date.getUTCMonth() + 1, dosDate <<= 5, dosDate |= date.getUTCDate(), useUTF8ForFileName && (unicodePathExtraField = decToHex(1, 1) + decToHex(crc32(encodedFileName), 4) + utfEncodedFileName, extraFields += "up" + decToHex(unicodePathExtraField.length, 2) + unicodePathExtraField), useUTF8ForComment && (unicodeCommentExtraField = decToHex(1, 1) + decToHex(crc32(encodedComment), 4) + utfEncodedComment, extraFields += "uc" + decToHex(unicodeCommentExtraField.length, 2) + unicodeCommentExtraField);
                        var header = "";
                        header += "\n\0", header += decToHex(bitflag, 2), header += compression.magic, header += decToHex(dosTime, 2), header += decToHex(dosDate, 2), header += decToHex(dataInfo.crc32, 4), header += decToHex(dataInfo.compressedSize, 4), header += decToHex(dataInfo.uncompressedSize, 4), header += decToHex(encodedFileName.length, 2), header += decToHex(extraFields.length, 2);
                        var fileRecord = signature.LOCAL_FILE_HEADER + header + encodedFileName + extraFields,
                            dirRecord = signature.CENTRAL_FILE_HEADER + decToHex(versionMadeBy, 2) + header + decToHex(encodedComment.length, 2) + "\0\0\0\0" + decToHex(extFileAttr, 4) + decToHex(offset, 4) + encodedFileName + extraFields + encodedComment;
                        return {
                            fileRecord: fileRecord,
                            dirRecord: dirRecord
                        }
                    },
                    generateCentralDirectoryEnd = function(entriesCount, centralDirLength, localDirLength, comment, encodeFileName) {
                        var dirEnd = "",
                            encodedComment = utils.transformTo("string", encodeFileName(comment));
                        return dirEnd = signature.CENTRAL_DIRECTORY_END + "\0\0\0\0" + decToHex(entriesCount, 2) + decToHex(entriesCount, 2) + decToHex(centralDirLength, 4) + decToHex(localDirLength, 4) + decToHex(encodedComment.length, 2) + encodedComment
                    },
                    generateDataDescriptors = function(streamInfo) {
                        var descriptor = "";
                        return descriptor = signature.DATA_DESCRIPTOR + decToHex(streamInfo.crc32, 4) + decToHex(streamInfo.compressedSize, 4) + decToHex(streamInfo.uncompressedSize, 4)
                    };
                utils.inherits(ZipFileWorker, GenericWorker), ZipFileWorker.prototype.push = function(chunk) {
                    var currentFilePercent = chunk.meta.percent || 0,
                        entriesCount = this.entriesCount,
                        remainingFiles = this._sources.length;
                    this.accumulate ? this.contentBuffer.push(chunk) : (this.bytesWritten += chunk.data.length, GenericWorker.prototype.push.call(this, {
                        data: chunk.data,
                        meta: {
                            currentFile: this.currentFile,
                            percent: entriesCount ? (currentFilePercent + 100 * (entriesCount - remainingFiles - 1)) / entriesCount : 100
                        }
                    }))
                }, ZipFileWorker.prototype.openedSource = function(streamInfo) {
                    this.currentSourceOffset = this.bytesWritten, this.currentFile = streamInfo.file.name;
                    var streamedContent = this.streamFiles && !streamInfo.file.dir;
                    if (streamedContent) {
                        var record = generateZipParts(streamInfo, streamedContent, !1, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                        this.push({
                            data: record.fileRecord,
                            meta: {
                                percent: 0
                            }
                        })
                    } else this.accumulate = !0
                }, ZipFileWorker.prototype.closedSource = function(streamInfo) {
                    this.accumulate = !1;
                    var streamedContent = this.streamFiles && !streamInfo.file.dir,
                        record = generateZipParts(streamInfo, streamedContent, !0, this.currentSourceOffset, this.zipPlatform, this.encodeFileName);
                    if (this.dirRecords.push(record.dirRecord), streamedContent) this.push({
                        data: generateDataDescriptors(streamInfo),
                        meta: {
                            percent: 100
                        }
                    });
                    else
                        for (this.push({
                                data: record.fileRecord,
                                meta: {
                                    percent: 0
                                }
                            }); this.contentBuffer.length;) this.push(this.contentBuffer.shift());
                    this.currentFile = null
                }, ZipFileWorker.prototype.flush = function() {
                    for (var localDirLength = this.bytesWritten, i = 0; i < this.dirRecords.length; i++) this.push({
                        data: this.dirRecords[i],
                        meta: {
                            percent: 100
                        }
                    });
                    var centralDirLength = this.bytesWritten - localDirLength,
                        dirEnd = generateCentralDirectoryEnd(this.dirRecords.length, centralDirLength, localDirLength, this.zipComment, this.encodeFileName);
                    this.push({
                        data: dirEnd,
                        meta: {
                            percent: 100
                        }
                    })
                }, ZipFileWorker.prototype.prepareNextSource = function() {
                    this.previous = this._sources.shift(), this.openedSource(this.previous.streamInfo), this.isPaused ? this.previous.pause() : this.previous.resume()
                }, ZipFileWorker.prototype.registerPrevious = function(previous) {
                    this._sources.push(previous);
                    var self = this;
                    return previous.on("data", function(chunk) {
                        self.processChunk(chunk)
                    }), previous.on("end", function() {
                        self.closedSource(self.previous.streamInfo), self._sources.length ? self.prepareNextSource() : self.end()
                    }), previous.on("error", function(e) {
                        self.error(e)
                    }), this
                }, ZipFileWorker.prototype.resume = function() {
                    return !!GenericWorker.prototype.resume.call(this) && (!this.previous && this._sources.length ? (this.prepareNextSource(), !0) : this.previous || this._sources.length || this.generatedError ? void 0 : (this.end(), !0))
                }, ZipFileWorker.prototype.error = function(e) {
                    var sources = this._sources;
                    if (!GenericWorker.prototype.error.call(this, e)) return !1;
                    for (var i = 0; i < sources.length; i++) try {
                        sources[i].error(e)
                    } catch (e) {}
                    return !0
                }, ZipFileWorker.prototype.lock = function() {
                    GenericWorker.prototype.lock.call(this);
                    for (var sources = this._sources, i = 0; i < sources.length; i++) sources[i].lock()
                }, module.exports = ZipFileWorker
            }, {
                "../crc32": 4,
                "../signature": 23,
                "../stream/GenericWorker": 28,
                "../utf8": 31,
                "../utils": 32
            }],
            9: [function(require, module, exports) {
                "use strict";
                var compressions = require("../compressions"),
                    ZipFileWorker = require("./ZipFileWorker"),
                    getCompression = function(fileCompression, zipCompression) {
                        var compressionName = fileCompression || zipCompression,
                            compression = compressions[compressionName];
                        if (!compression) throw new Error(compressionName + " is not a valid compression method !");
                        return compression
                    };
                exports.generateWorker = function(zip, options, comment) {
                    var zipFileWorker = new ZipFileWorker(options.streamFiles, comment, options.platform, options.encodeFileName),
                        entriesCount = 0;
                    try {
                        zip.forEach(function(relativePath, file) {
                            entriesCount++;
                            var compression = getCompression(file.options.compression, options.compression),
                                compressionOptions = file.options.compressionOptions || options.compressionOptions || {},
                                dir = file.dir,
                                date = file.date;
                            file._compressWorker(compression, compressionOptions).withStreamInfo("file", {
                                name: relativePath,
                                dir: dir,
                                date: date,
                                comment: file.comment || "",
                                unixPermissions: file.unixPermissions,
                                dosPermissions: file.dosPermissions
                            }).pipe(zipFileWorker)
                        }), zipFileWorker.entriesCount = entriesCount
                    } catch (e) {
                        zipFileWorker.error(e)
                    }
                    return zipFileWorker
                }
            }, {
                "../compressions": 3,
                "./ZipFileWorker": 8
            }],
            10: [function(require, module, exports) {
                "use strict";

                function JSZip() {
                    if (!(this instanceof JSZip)) return new JSZip;
                    if (arguments.length) throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");
                    this.files = {}, this.comment = null, this.root = "", this.clone = function() {
                        var newObj = new JSZip;
                        for (var i in this) "function" != typeof this[i] && (newObj[i] = this[i]);
                        return newObj
                    }
                }
                JSZip.prototype = require("./object"), JSZip.prototype.loadAsync = require("./load"), JSZip.support = require("./support"), JSZip.defaults = require("./defaults"), JSZip.version = "3.1.5", JSZip.loadAsync = function(content, options) {
                    return (new JSZip).loadAsync(content, options)
                }, JSZip.external = require("./external"), module.exports = JSZip
            }, {
                "./defaults": 5,
                "./external": 6,
                "./load": 11,
                "./object": 15,
                "./support": 30
            }],
            11: [function(require, module, exports) {
                "use strict";

                function checkEntryCRC32(zipEntry) {
                    return new external.Promise(function(resolve, reject) {
                        var worker = zipEntry.decompressed.getContentWorker().pipe(new Crc32Probe);
                        worker.on("error", function(e) {
                            reject(e)
                        }).on("end", function() {
                            worker.streamInfo.crc32 !== zipEntry.decompressed.crc32 ? reject(new Error("Corrupted zip : CRC32 mismatch")) : resolve()
                        }).resume()
                    })
                }
                var utils = require("./utils"),
                    external = require("./external"),
                    utf8 = require("./utf8"),
                    utils = require("./utils"),
                    ZipEntries = require("./zipEntries"),
                    Crc32Probe = require("./stream/Crc32Probe"),
                    nodejsUtils = require("./nodejsUtils");
                module.exports = function(data, options) {
                    var zip = this;
                    return options = utils.extend(options || {}, {
                        base64: !1,
                        checkCRC32: !1,
                        optimizedBinaryString: !1,
                        createFolders: !1,
                        decodeFileName: utf8.utf8decode
                    }), nodejsUtils.isNode && nodejsUtils.isStream(data) ? external.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")) : utils.prepareContent("the loaded zip file", data, !0, options.optimizedBinaryString, options.base64).then(function(data) {
                        var zipEntries = new ZipEntries(options);
                        return zipEntries.load(data), zipEntries
                    }).then(function(zipEntries) {
                        var promises = [external.Promise.resolve(zipEntries)],
                            files = zipEntries.files;
                        if (options.checkCRC32)
                            for (var i = 0; i < files.length; i++) promises.push(checkEntryCRC32(files[i]));
                        return external.Promise.all(promises)
                    }).then(function(results) {
                        for (var zipEntries = results.shift(), files = zipEntries.files, i = 0; i < files.length; i++) {
                            var input = files[i];
                            zip.file(input.fileNameStr, input.decompressed, {
                                binary: !0,
                                optimizedBinaryString: !0,
                                date: input.date,
                                dir: input.dir,
                                comment: input.fileCommentStr.length ? input.fileCommentStr : null,
                                unixPermissions: input.unixPermissions,
                                dosPermissions: input.dosPermissions,
                                createFolders: options.createFolders
                            })
                        }
                        return zipEntries.zipComment.length && (zip.comment = zipEntries.zipComment), zip
                    })
                }
            }, {
                "./external": 6,
                "./nodejsUtils": 14,
                "./stream/Crc32Probe": 25,
                "./utf8": 31,
                "./utils": 32,
                "./zipEntries": 33
            }],
            12: [function(require, module, exports) {
                "use strict";

                function NodejsStreamInputAdapter(filename, stream) {
                    GenericWorker.call(this, "Nodejs stream input adapter for " + filename), this._upstreamEnded = !1, this._bindStream(stream)
                }
                var utils = require("../utils"),
                    GenericWorker = require("../stream/GenericWorker");
                utils.inherits(NodejsStreamInputAdapter, GenericWorker), NodejsStreamInputAdapter.prototype._bindStream = function(stream) {
                    var self = this;
                    this._stream = stream, stream.pause(), stream.on("data", function(chunk) {
                        self.push({
                            data: chunk,
                            meta: {
                                percent: 0
                            }
                        })
                    }).on("error", function(e) {
                        self.isPaused ? this.generatedError = e : self.error(e)
                    }).on("end", function() {
                        self.isPaused ? self._upstreamEnded = !0 : self.end()
                    })
                }, NodejsStreamInputAdapter.prototype.pause = function() {
                    return !!GenericWorker.prototype.pause.call(this) && (this._stream.pause(), !0)
                }, NodejsStreamInputAdapter.prototype.resume = function() {
                    return !!GenericWorker.prototype.resume.call(this) && (this._upstreamEnded ? this.end() : this._stream.resume(), !0)
                }, module.exports = NodejsStreamInputAdapter
            }, {
                "../stream/GenericWorker": 28,
                "../utils": 32
            }],
            13: [function(require, module, exports) {
                "use strict";

                function NodejsStreamOutputAdapter(helper, options, updateCb) {
                    Readable.call(this, options), this._helper = helper;
                    var self = this;
                    helper.on("data", function(data, meta) {
                        self.push(data) || self._helper.pause(), updateCb && updateCb(meta)
                    }).on("error", function(e) {
                        self.emit("error", e)
                    }).on("end", function() {
                        self.push(null)
                    })
                }
                var Readable = require("readable-stream").Readable,
                    utils = require("../utils");
                utils.inherits(NodejsStreamOutputAdapter, Readable), NodejsStreamOutputAdapter.prototype._read = function() {
                    this._helper.resume()
                }, module.exports = NodejsStreamOutputAdapter
            }, {
                "../utils": 32,
                "readable-stream": 16
            }],
            14: [function(require, module, exports) {
                "use strict";
                module.exports = {
                    isNode: "undefined" != typeof Buffer,
                    newBufferFrom: function(data, encoding) {
                        return new Buffer(data, encoding)
                    },
                    allocBuffer: function(size) {
                        return Buffer.alloc ? Buffer.alloc(size) : new Buffer(size)
                    },
                    isBuffer: function(b) {
                        return Buffer.isBuffer(b)
                    },
                    isStream: function(obj) {
                        return obj && "function" == typeof obj.on && "function" == typeof obj.pause && "function" == typeof obj.resume
                    }
                }
            }, {}],
            15: [function(require, module, exports) {
                "use strict";

                function isRegExp(object) {
                    return "[object RegExp]" === Object.prototype.toString.call(object)
                }
                var utf8 = require("./utf8"),
                    utils = require("./utils"),
                    GenericWorker = require("./stream/GenericWorker"),
                    StreamHelper = require("./stream/StreamHelper"),
                    defaults = require("./defaults"),
                    CompressedObject = require("./compressedObject"),
                    ZipObject = require("./zipObject"),
                    generate = require("./generate"),
                    nodejsUtils = require("./nodejsUtils"),
                    NodejsStreamInputAdapter = require("./nodejs/NodejsStreamInputAdapter"),
                    fileAdd = function(name, data, originalOptions) {
                        var parent, dataType = utils.getTypeOf(data),
                            o = utils.extend(originalOptions || {}, defaults);
                        o.date = o.date || new Date, null !== o.compression && (o.compression = o.compression.toUpperCase()), "string" == typeof o.unixPermissions && (o.unixPermissions = parseInt(o.unixPermissions, 8)), o.unixPermissions && 16384 & o.unixPermissions && (o.dir = !0), o.dosPermissions && 16 & o.dosPermissions && (o.dir = !0), o.dir && (name = forceTrailingSlash(name)), o.createFolders && (parent = parentFolder(name)) && folderAdd.call(this, parent, !0);
                        var isUnicodeString = "string" === dataType && o.binary === !1 && o.base64 === !1;
                        originalOptions && "undefined" != typeof originalOptions.binary || (o.binary = !isUnicodeString);
                        var isCompressedEmpty = data instanceof CompressedObject && 0 === data.uncompressedSize;
                        (isCompressedEmpty || o.dir || !data || 0 === data.length) && (o.base64 = !1, o.binary = !0, data = "", o.compression = "STORE", dataType = "string");
                        var zipObjectContent = null;
                        zipObjectContent = data instanceof CompressedObject || data instanceof GenericWorker ? data : nodejsUtils.isNode && nodejsUtils.isStream(data) ? new NodejsStreamInputAdapter(name, data) : utils.prepareContent(name, data, o.binary, o.optimizedBinaryString, o.base64);
                        var object = new ZipObject(name, zipObjectContent, o);
                        this.files[name] = object
                    },
                    parentFolder = function(path) {
                        "/" === path.slice(-1) && (path = path.substring(0, path.length - 1));
                        var lastSlash = path.lastIndexOf("/");
                        return lastSlash > 0 ? path.substring(0, lastSlash) : ""
                    },
                    forceTrailingSlash = function(path) {
                        return "/" !== path.slice(-1) && (path += "/"), path
                    },
                    folderAdd = function(name, createFolders) {
                        return createFolders = "undefined" != typeof createFolders ? createFolders : defaults.createFolders, name = forceTrailingSlash(name), this.files[name] || fileAdd.call(this, name, null, {
                            dir: !0,
                            createFolders: createFolders
                        }), this.files[name]
                    },
                    out = {
                        load: function() {
                            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")
                        },
                        forEach: function(cb) {
                            var filename, relativePath, file;
                            for (filename in this.files) this.files.hasOwnProperty(filename) && (file = this.files[filename], relativePath = filename.slice(this.root.length, filename.length), relativePath && filename.slice(0, this.root.length) === this.root && cb(relativePath, file))
                        },
                        filter: function(search) {
                            var result = [];
                            return this.forEach(function(relativePath, entry) {
                                search(relativePath, entry) && result.push(entry)
                            }), result
                        },
                        file: function(name, data, o) {
                            if (1 === arguments.length) {
                                if (isRegExp(name)) {
                                    var regexp = name;
                                    return this.filter(function(relativePath, file) {
                                        return !file.dir && regexp.test(relativePath)
                                    })
                                }
                                var obj = this.files[this.root + name];
                                return obj && !obj.dir ? obj : null
                            }
                            return name = this.root + name, fileAdd.call(this, name, data, o), this
                        },
                        folder: function(arg) {
                            if (!arg) return this;
                            if (isRegExp(arg)) return this.filter(function(relativePath, file) {
                                return file.dir && arg.test(relativePath)
                            });
                            var name = this.root + arg,
                                newFolder = folderAdd.call(this, name),
                                ret = this.clone();
                            return ret.root = newFolder.name, ret
                        },
                        remove: function(name) {
                            name = this.root + name;
                            var file = this.files[name];
                            if (file || ("/" !== name.slice(-1) && (name += "/"), file = this.files[name]), file && !file.dir) delete this.files[name];
                            else
                                for (var kids = this.filter(function(relativePath, file) {
                                        return file.name.slice(0, name.length) === name
                                    }), i = 0; i < kids.length; i++) delete this.files[kids[i].name];
                            return this
                        },
                        generate: function(options) {
                            throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")
                        },
                        generateInternalStream: function(options) {
                            var worker, opts = {};
                            try {
                                if (opts = utils.extend(options || {}, {
                                        streamFiles: !1,
                                        compression: "STORE",
                                        compressionOptions: null,
                                        type: "",
                                        platform: "DOS",
                                        comment: null,
                                        mimeType: "application/zip",
                                        encodeFileName: utf8.utf8encode
                                    }), opts.type = opts.type.toLowerCase(), opts.compression = opts.compression.toUpperCase(), "binarystring" === opts.type && (opts.type = "string"), !opts.type) throw new Error("No output type specified.");
                                utils.checkSupport(opts.type), "darwin" !== opts.platform && "freebsd" !== opts.platform && "linux" !== opts.platform && "sunos" !== opts.platform || (opts.platform = "UNIX"), "win32" === opts.platform && (opts.platform = "DOS");
                                var comment = opts.comment || this.comment || "";
                                worker = generate.generateWorker(this, opts, comment)
                            } catch (e) {
                                worker = new GenericWorker("error"), worker.error(e)
                            }
                            return new StreamHelper(worker, opts.type || "string", opts.mimeType)
                        },
                        generateAsync: function(options, onUpdate) {
                            return this.generateInternalStream(options).accumulate(onUpdate)
                        },
                        generateNodeStream: function(options, onUpdate) {
                            return options = options || {}, options.type || (options.type = "nodebuffer"), this.generateInternalStream(options).toNodejsStream(onUpdate)
                        }
                    };
                module.exports = out
            }, {
                "./compressedObject": 2,
                "./defaults": 5,
                "./generate": 9,
                "./nodejs/NodejsStreamInputAdapter": 12,
                "./nodejsUtils": 14,
                "./stream/GenericWorker": 28,
                "./stream/StreamHelper": 29,
                "./utf8": 31,
                "./utils": 32,
                "./zipObject": 35
            }],
            16: [function(require, module, exports) {
                module.exports = require("stream")
            }, {
                stream: void 0
            }],
            17: [function(require, module, exports) {
                "use strict";

                function ArrayReader(data) {
                    DataReader.call(this, data);
                    for (var i = 0; i < this.data.length; i++) data[i] = 255 & data[i]
                }
                var DataReader = require("./DataReader"),
                    utils = require("../utils");
                utils.inherits(ArrayReader, DataReader), ArrayReader.prototype.byteAt = function(i) {
                    return this.data[this.zero + i]
                }, ArrayReader.prototype.lastIndexOfSignature = function(sig) {
                    for (var sig0 = sig.charCodeAt(0), sig1 = sig.charCodeAt(1), sig2 = sig.charCodeAt(2), sig3 = sig.charCodeAt(3), i = this.length - 4; i >= 0; --i)
                        if (this.data[i] === sig0 && this.data[i + 1] === sig1 && this.data[i + 2] === sig2 && this.data[i + 3] === sig3) return i - this.zero;
                    return -1
                }, ArrayReader.prototype.readAndCheckSignature = function(sig) {
                    var sig0 = sig.charCodeAt(0),
                        sig1 = sig.charCodeAt(1),
                        sig2 = sig.charCodeAt(2),
                        sig3 = sig.charCodeAt(3),
                        data = this.readData(4);
                    return sig0 === data[0] && sig1 === data[1] && sig2 === data[2] && sig3 === data[3]
                }, ArrayReader.prototype.readData = function(size) {
                    if (this.checkOffset(size), 0 === size) return [];
                    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
                    return this.index += size, result
                }, module.exports = ArrayReader
            }, {
                "../utils": 32,
                "./DataReader": 18
            }],
            18: [function(require, module, exports) {
                "use strict";

                function DataReader(data) {
                    this.data = data, this.length = data.length, this.index = 0, this.zero = 0
                }
                var utils = require("../utils");
                DataReader.prototype = {
                    checkOffset: function(offset) {
                        this.checkIndex(this.index + offset)
                    },
                    checkIndex: function(newIndex) {
                        if (this.length < this.zero + newIndex || newIndex < 0) throw new Error("End of data reached (data length = " + this.length + ", asked index = " + newIndex + "). Corrupted zip ?")
                    },
                    setIndex: function(newIndex) {
                        this.checkIndex(newIndex), this.index = newIndex
                    },
                    skip: function(n) {
                        this.setIndex(this.index + n)
                    },
                    byteAt: function(i) {},
                    readInt: function(size) {
                        var i, result = 0;
                        for (this.checkOffset(size), i = this.index + size - 1; i >= this.index; i--) result = (result << 8) + this.byteAt(i);
                        return this.index += size, result
                    },
                    readString: function(size) {
                        return utils.transformTo("string", this.readData(size))
                    },
                    readData: function(size) {},
                    lastIndexOfSignature: function(sig) {},
                    readAndCheckSignature: function(sig) {},
                    readDate: function() {
                        var dostime = this.readInt(4);
                        return new Date(Date.UTC((dostime >> 25 & 127) + 1980, (dostime >> 21 & 15) - 1, dostime >> 16 & 31, dostime >> 11 & 31, dostime >> 5 & 63, (31 & dostime) << 1))
                    }
                }, module.exports = DataReader
            }, {
                "../utils": 32
            }],
            19: [function(require, module, exports) {
                "use strict";

                function NodeBufferReader(data) {
                    Uint8ArrayReader.call(this, data)
                }
                var Uint8ArrayReader = require("./Uint8ArrayReader"),
                    utils = require("../utils");
                utils.inherits(NodeBufferReader, Uint8ArrayReader), NodeBufferReader.prototype.readData = function(size) {
                    this.checkOffset(size);
                    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
                    return this.index += size, result
                }, module.exports = NodeBufferReader
            }, {
                "../utils": 32,
                "./Uint8ArrayReader": 21
            }],
            20: [function(require, module, exports) {
                "use strict";

                function StringReader(data) {
                    DataReader.call(this, data)
                }
                var DataReader = require("./DataReader"),
                    utils = require("../utils");
                utils.inherits(StringReader, DataReader), StringReader.prototype.byteAt = function(i) {
                    return this.data.charCodeAt(this.zero + i)
                }, StringReader.prototype.lastIndexOfSignature = function(sig) {
                    return this.data.lastIndexOf(sig) - this.zero
                }, StringReader.prototype.readAndCheckSignature = function(sig) {
                    var data = this.readData(4);
                    return sig === data
                }, StringReader.prototype.readData = function(size) {
                    this.checkOffset(size);
                    var result = this.data.slice(this.zero + this.index, this.zero + this.index + size);
                    return this.index += size, result
                }, module.exports = StringReader
            }, {
                "../utils": 32,
                "./DataReader": 18
            }],
            21: [function(require, module, exports) {
                "use strict";

                function Uint8ArrayReader(data) {
                    ArrayReader.call(this, data)
                }
                var ArrayReader = require("./ArrayReader"),
                    utils = require("../utils");
                utils.inherits(Uint8ArrayReader, ArrayReader), Uint8ArrayReader.prototype.readData = function(size) {
                    if (this.checkOffset(size), 0 === size) return new Uint8Array(0);
                    var result = this.data.subarray(this.zero + this.index, this.zero + this.index + size);
                    return this.index += size, result
                }, module.exports = Uint8ArrayReader
            }, {
                "../utils": 32,
                "./ArrayReader": 17
            }],
            22: [function(require, module, exports) {
                "use strict";
                var utils = require("../utils"),
                    support = require("../support"),
                    ArrayReader = require("./ArrayReader"),
                    StringReader = require("./StringReader"),
                    NodeBufferReader = require("./NodeBufferReader"),
                    Uint8ArrayReader = require("./Uint8ArrayReader");
                module.exports = function(data) {
                    var type = utils.getTypeOf(data);
                    return utils.checkSupport(type), "string" !== type || support.uint8array ? "nodebuffer" === type ? new NodeBufferReader(data) : support.uint8array ? new Uint8ArrayReader(utils.transformTo("uint8array", data)) : new ArrayReader(utils.transformTo("array", data)) : new StringReader(data)
                }
            }, {
                "../support": 30,
                "../utils": 32,
                "./ArrayReader": 17,
                "./NodeBufferReader": 19,
                "./StringReader": 20,
                "./Uint8ArrayReader": 21
            }],
            23: [function(require, module, exports) {
                "use strict";
                exports.LOCAL_FILE_HEADER = "PK", exports.CENTRAL_FILE_HEADER = "PK", exports.CENTRAL_DIRECTORY_END = "PK", exports.ZIP64_CENTRAL_DIRECTORY_LOCATOR = "PK", exports.ZIP64_CENTRAL_DIRECTORY_END = "PK", exports.DATA_DESCRIPTOR = "PK\b"
            }, {}],
            24: [function(require, module, exports) {
                "use strict";

                function ConvertWorker(destType) {
                    GenericWorker.call(this, "ConvertWorker to " + destType), this.destType = destType
                }
                var GenericWorker = require("./GenericWorker"),
                    utils = require("../utils");
                utils.inherits(ConvertWorker, GenericWorker), ConvertWorker.prototype.processChunk = function(chunk) {
                    this.push({
                        data: utils.transformTo(this.destType, chunk.data),
                        meta: chunk.meta
                    })
                }, module.exports = ConvertWorker
            }, {
                "../utils": 32,
                "./GenericWorker": 28
            }],
            25: [function(require, module, exports) {
                "use strict";

                function Crc32Probe() {
                    GenericWorker.call(this, "Crc32Probe"), this.withStreamInfo("crc32", 0)
                }
                var GenericWorker = require("./GenericWorker"),
                    crc32 = require("../crc32"),
                    utils = require("../utils");
                utils.inherits(Crc32Probe, GenericWorker), Crc32Probe.prototype.processChunk = function(chunk) {
                    this.streamInfo.crc32 = crc32(chunk.data, this.streamInfo.crc32 || 0), this.push(chunk)
                }, module.exports = Crc32Probe
            }, {
                "../crc32": 4,
                "../utils": 32,
                "./GenericWorker": 28
            }],
            26: [function(require, module, exports) {
                "use strict";

                function DataLengthProbe(propName) {
                    GenericWorker.call(this, "DataLengthProbe for " + propName), this.propName = propName, this.withStreamInfo(propName, 0)
                }
                var utils = require("../utils"),
                    GenericWorker = require("./GenericWorker");
                utils.inherits(DataLengthProbe, GenericWorker), DataLengthProbe.prototype.processChunk = function(chunk) {
                    if (chunk) {
                        var length = this.streamInfo[this.propName] || 0;
                        this.streamInfo[this.propName] = length + chunk.data.length
                    }
                    GenericWorker.prototype.processChunk.call(this, chunk)
                }, module.exports = DataLengthProbe
            }, {
                "../utils": 32,
                "./GenericWorker": 28
            }],
            27: [function(require, module, exports) {
                "use strict";

                function DataWorker(dataP) {
                    GenericWorker.call(this, "DataWorker");
                    var self = this;
                    this.dataIsReady = !1, this.index = 0, this.max = 0, this.data = null, this.type = "", this._tickScheduled = !1, dataP.then(function(data) {
                        self.dataIsReady = !0, self.data = data, self.max = data && data.length || 0, self.type = utils.getTypeOf(data), self.isPaused || self._tickAndRepeat()
                    }, function(e) {
                        self.error(e)
                    })
                }
                var utils = require("../utils"),
                    GenericWorker = require("./GenericWorker"),
                    DEFAULT_BLOCK_SIZE = 16384;
                utils.inherits(DataWorker, GenericWorker), DataWorker.prototype.cleanUp = function() {
                    GenericWorker.prototype.cleanUp.call(this), this.data = null
                }, DataWorker.prototype.resume = function() {
                    return !!GenericWorker.prototype.resume.call(this) && (!this._tickScheduled && this.dataIsReady && (this._tickScheduled = !0, utils.delay(this._tickAndRepeat, [], this)), !0)
                }, DataWorker.prototype._tickAndRepeat = function() {
                    this._tickScheduled = !1, this.isPaused || this.isFinished || (this._tick(), this.isFinished || (utils.delay(this._tickAndRepeat, [], this), this._tickScheduled = !0))
                }, DataWorker.prototype._tick = function() {
                    if (this.isPaused || this.isFinished) return !1;
                    var size = DEFAULT_BLOCK_SIZE,
                        data = null,
                        nextIndex = Math.min(this.max, this.index + size);
                    if (this.index >= this.max) return this.end();
                    switch (this.type) {
                        case "string":
                            data = this.data.substring(this.index, nextIndex);
                            break;
                        case "uint8array":
                            data = this.data.subarray(this.index, nextIndex);
                            break;
                        case "array":
                        case "nodebuffer":
                            data = this.data.slice(this.index, nextIndex)
                    }
                    return this.index = nextIndex, this.push({
                        data: data,
                        meta: {
                            percent: this.max ? this.index / this.max * 100 : 0
                        }
                    })
                }, module.exports = DataWorker
            }, {
                "../utils": 32,
                "./GenericWorker": 28
            }],
            28: [function(require, module, exports) {
                "use strict";

                function GenericWorker(name) {
                    this.name = name || "default", this.streamInfo = {}, this.generatedError = null, this.extraStreamInfo = {}, this.isPaused = !0, this.isFinished = !1, this.isLocked = !1, this._listeners = {
                        data: [],
                        end: [],
                        error: []
                    }, this.previous = null
                }
                GenericWorker.prototype = {
                    push: function(chunk) {
                        this.emit("data", chunk)
                    },
                    end: function() {
                        if (this.isFinished) return !1;
                        this.flush();
                        try {
                            this.emit("end"), this.cleanUp(), this.isFinished = !0
                        } catch (e) {
                            this.emit("error", e)
                        }
                        return !0
                    },
                    error: function(e) {
                        return !this.isFinished && (this.isPaused ? this.generatedError = e : (this.isFinished = !0, this.emit("error", e), this.previous && this.previous.error(e), this.cleanUp()), !0)
                    },
                    on: function(name, listener) {
                        return this._listeners[name].push(listener), this
                    },
                    cleanUp: function() {
                        this.streamInfo = this.generatedError = this.extraStreamInfo = null, this._listeners = []
                    },
                    emit: function(name, arg) {
                        if (this._listeners[name])
                            for (var i = 0; i < this._listeners[name].length; i++) this._listeners[name][i].call(this, arg)
                    },
                    pipe: function(next) {
                        return next.registerPrevious(this)
                    },
                    registerPrevious: function(previous) {
                        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
                        this.streamInfo = previous.streamInfo, this.mergeStreamInfo(), this.previous = previous;
                        var self = this;
                        return previous.on("data", function(chunk) {
                            self.processChunk(chunk)
                        }), previous.on("end", function() {
                            self.end()
                        }), previous.on("error", function(e) {
                            self.error(e)
                        }), this
                    },
                    pause: function() {
                        return !this.isPaused && !this.isFinished && (this.isPaused = !0, this.previous && this.previous.pause(), !0)
                    },
                    resume: function() {
                        if (!this.isPaused || this.isFinished) return !1;
                        this.isPaused = !1;
                        var withError = !1;
                        return this.generatedError && (this.error(this.generatedError), withError = !0), this.previous && this.previous.resume(), !withError
                    },
                    flush: function() {},
                    processChunk: function(chunk) {
                        this.push(chunk)
                    },
                    withStreamInfo: function(key, value) {
                        return this.extraStreamInfo[key] = value, this.mergeStreamInfo(), this
                    },
                    mergeStreamInfo: function() {
                        for (var key in this.extraStreamInfo) this.extraStreamInfo.hasOwnProperty(key) && (this.streamInfo[key] = this.extraStreamInfo[key])
                    },
                    lock: function() {
                        if (this.isLocked) throw new Error("The stream '" + this + "' has already been used.");
                        this.isLocked = !0, this.previous && this.previous.lock()
                    },
                    toString: function() {
                        var me = "Worker " + this.name;
                        return this.previous ? this.previous + " -> " + me : me
                    }
                }, module.exports = GenericWorker
            }, {}],
            29: [function(require, module, exports) {
                "use strict";

                function transformZipOutput(type, content, mimeType) {
                    switch (type) {
                        case "blob":
                            return utils.newBlob(utils.transformTo("arraybuffer", content), mimeType);
                        case "base64":
                            return base64.encode(content);
                        default:
                            return utils.transformTo(type, content)
                    }
                }

                function concat(type, dataArray) {
                    var i, index = 0,
                        res = null,
                        totalLength = 0;
                    for (i = 0; i < dataArray.length; i++) totalLength += dataArray[i].length;
                    switch (type) {
                        case "string":
                            return dataArray.join("");
                        case "array":
                            return Array.prototype.concat.apply([], dataArray);
                        case "uint8array":
                            for (res = new Uint8Array(totalLength), i = 0; i < dataArray.length; i++) res.set(dataArray[i], index), index += dataArray[i].length;
                            return res;
                        case "nodebuffer":
                            return Buffer.concat(dataArray);
                        default:
                            throw new Error("concat : unsupported type '" + type + "'")
                    }
                }

                function _accumulate(helper, updateCallback) {
                    return new external.Promise(function(resolve, reject) {
                        var dataArray = [],
                            chunkType = helper._internalType,
                            resultType = helper._outputType,
                            mimeType = helper._mimeType;
                        helper.on("data", function(data, meta) {
                            dataArray.push(data), updateCallback && updateCallback(meta)
                        }).on("error", function(err) {
                            dataArray = [], reject(err)
                        }).on("end", function() {
                            try {
                                var result = transformZipOutput(resultType, concat(chunkType, dataArray), mimeType);
                                resolve(result)
                            } catch (e) {
                                reject(e)
                            }
                            dataArray = []
                        }).resume()
                    })
                }

                function StreamHelper(worker, outputType, mimeType) {
                    var internalType = outputType;
                    switch (outputType) {
                        case "blob":
                        case "arraybuffer":
                            internalType = "uint8array";
                            break;
                        case "base64":
                            internalType = "string"
                    }
                    try {
                        this._internalType = internalType, this._outputType = outputType, this._mimeType = mimeType, utils.checkSupport(internalType), this._worker = worker.pipe(new ConvertWorker(internalType)), worker.lock()
                    } catch (e) {
                        this._worker = new GenericWorker("error"), this._worker.error(e)
                    }
                }
                var utils = require("../utils"),
                    ConvertWorker = require("./ConvertWorker"),
                    GenericWorker = require("./GenericWorker"),
                    base64 = require("../base64"),
                    support = require("../support"),
                    external = require("../external"),
                    NodejsStreamOutputAdapter = null;
                if (support.nodestream) try {
                    NodejsStreamOutputAdapter = require("../nodejs/NodejsStreamOutputAdapter")
                } catch (e) {}
                StreamHelper.prototype = {
                    accumulate: function(updateCb) {
                        return _accumulate(this, updateCb)
                    },
                    on: function(evt, fn) {
                        var self = this;
                        return "data" === evt ? this._worker.on(evt, function(chunk) {
                            fn.call(self, chunk.data, chunk.meta)
                        }) : this._worker.on(evt, function() {
                            utils.delay(fn, arguments, self)
                        }), this
                    },
                    resume: function() {
                        return utils.delay(this._worker.resume, [], this._worker), this
                    },
                    pause: function() {
                        return this._worker.pause(), this
                    },
                    toNodejsStream: function(updateCb) {
                        if (utils.checkSupport("nodestream"), "nodebuffer" !== this._outputType) throw new Error(this._outputType + " is not supported by this method");
                        return new NodejsStreamOutputAdapter(this, {
                            objectMode: "nodebuffer" !== this._outputType
                        }, updateCb)
                    }
                }, module.exports = StreamHelper
            }, {
                "../base64": 1,
                "../external": 6,
                "../nodejs/NodejsStreamOutputAdapter": 13,
                "../support": 30,
                "../utils": 32,
                "./ConvertWorker": 24,
                "./GenericWorker": 28
            }],
            30: [function(require, module, exports) {
                "use strict";
                if (exports.base64 = !0, exports.array = !0, exports.string = !0, exports.arraybuffer = "undefined" != typeof ArrayBuffer && "undefined" != typeof Uint8Array, exports.nodebuffer = "undefined" != typeof Buffer, exports.uint8array = "undefined" != typeof Uint8Array, "undefined" == typeof ArrayBuffer) exports.blob = !1;
                else {
                    var buffer = new ArrayBuffer(0);
                    try {
                        exports.blob = 0 === new Blob([buffer], {
                            type: "application/zip"
                        }).size
                    } catch (e) {
                        try {
                            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder,
                                builder = new Builder;
                            builder.append(buffer), exports.blob = 0 === builder.getBlob("application/zip").size
                        } catch (e) {
                            exports.blob = !1
                        }
                    }
                }
                try {
                    exports.nodestream = !!require("readable-stream").Readable
                } catch (e) {
                    exports.nodestream = !1
                }
            }, {
                "readable-stream": 16
            }],
            31: [function(require, module, exports) {
                "use strict";

                function Utf8DecodeWorker() {
                    GenericWorker.call(this, "utf-8 decode"), this.leftOver = null
                }

                function Utf8EncodeWorker() {
                    GenericWorker.call(this, "utf-8 encode")
                }
                for (var utils = require("./utils"), support = require("./support"), nodejsUtils = require("./nodejsUtils"), GenericWorker = require("./stream/GenericWorker"), _utf8len = new Array(256), i = 0; i < 256; i++) _utf8len[i] = i >= 252 ? 6 : i >= 248 ? 5 : i >= 240 ? 4 : i >= 224 ? 3 : i >= 192 ? 2 : 1;
                _utf8len[254] = _utf8len[254] = 1;
                var string2buf = function(str) {
                        var buf, c, c2, m_pos, i, str_len = str.length,
                            buf_len = 0;
                        for (m_pos = 0; m_pos < str_len; m_pos++) c = str.charCodeAt(m_pos), 55296 === (64512 & c) && m_pos + 1 < str_len && (c2 = str.charCodeAt(m_pos + 1), 56320 === (64512 & c2) && (c = 65536 + (c - 55296 << 10) + (c2 - 56320), m_pos++)), buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
                        for (buf = support.uint8array ? new Uint8Array(buf_len) : new Array(buf_len), i = 0, m_pos = 0; i < buf_len; m_pos++) c = str.charCodeAt(m_pos), 55296 === (64512 & c) && m_pos + 1 < str_len && (c2 = str.charCodeAt(m_pos + 1), 56320 === (64512 & c2) && (c = 65536 + (c - 55296 << 10) + (c2 - 56320), m_pos++)), c < 128 ? buf[i++] = c : c < 2048 ? (buf[i++] = 192 | c >>> 6, buf[i++] = 128 | 63 & c) : c < 65536 ? (buf[i++] = 224 | c >>> 12, buf[i++] = 128 | c >>> 6 & 63, buf[i++] = 128 | 63 & c) : (buf[i++] = 240 | c >>> 18, buf[i++] = 128 | c >>> 12 & 63, buf[i++] = 128 | c >>> 6 & 63, buf[i++] = 128 | 63 & c);
                        return buf
                    },
                    utf8border = function(buf, max) {
                        var pos;
                        for (max = max || buf.length, max > buf.length && (max = buf.length), pos = max - 1; pos >= 0 && 128 === (192 & buf[pos]);) pos--;
                        return pos < 0 ? max : 0 === pos ? max : pos + _utf8len[buf[pos]] > max ? pos : max
                    },
                    buf2string = function(buf) {
                        var i, out, c, c_len, len = buf.length,
                            utf16buf = new Array(2 * len);
                        for (out = 0, i = 0; i < len;)
                            if (c = buf[i++], c < 128) utf16buf[out++] = c;
                            else if (c_len = _utf8len[c], c_len > 4) utf16buf[out++] = 65533, i += c_len - 1;
                        else {
                            for (c &= 2 === c_len ? 31 : 3 === c_len ? 15 : 7; c_len > 1 && i < len;) c = c << 6 | 63 & buf[i++], c_len--;
                            c_len > 1 ? utf16buf[out++] = 65533 : c < 65536 ? utf16buf[out++] = c : (c -= 65536, utf16buf[out++] = 55296 | c >> 10 & 1023, utf16buf[out++] = 56320 | 1023 & c)
                        }
                        return utf16buf.length !== out && (utf16buf.subarray ? utf16buf = utf16buf.subarray(0, out) : utf16buf.length = out), utils.applyFromCharCode(utf16buf)
                    };
                exports.utf8encode = function(str) {
                    return support.nodebuffer ? nodejsUtils.newBufferFrom(str, "utf-8") : string2buf(str)
                }, exports.utf8decode = function(buf) {
                    return support.nodebuffer ? utils.transformTo("nodebuffer", buf).toString("utf-8") : (buf = utils.transformTo(support.uint8array ? "uint8array" : "array", buf), buf2string(buf))
                }, utils.inherits(Utf8DecodeWorker, GenericWorker), Utf8DecodeWorker.prototype.processChunk = function(chunk) {
                    var data = utils.transformTo(support.uint8array ? "uint8array" : "array", chunk.data);
                    if (this.leftOver && this.leftOver.length) {
                        if (support.uint8array) {
                            var previousData = data;
                            data = new Uint8Array(previousData.length + this.leftOver.length), data.set(this.leftOver, 0), data.set(previousData, this.leftOver.length)
                        } else data = this.leftOver.concat(data);
                        this.leftOver = null
                    }
                    var nextBoundary = utf8border(data),
                        usableData = data;
                    nextBoundary !== data.length && (support.uint8array ? (usableData = data.subarray(0, nextBoundary), this.leftOver = data.subarray(nextBoundary, data.length)) : (usableData = data.slice(0, nextBoundary), this.leftOver = data.slice(nextBoundary, data.length))), this.push({
                        data: exports.utf8decode(usableData),
                        meta: chunk.meta
                    })
                }, Utf8DecodeWorker.prototype.flush = function() {
                    this.leftOver && this.leftOver.length && (this.push({
                        data: exports.utf8decode(this.leftOver),
                        meta: {}
                    }), this.leftOver = null)
                }, exports.Utf8DecodeWorker = Utf8DecodeWorker, utils.inherits(Utf8EncodeWorker, GenericWorker), Utf8EncodeWorker.prototype.processChunk = function(chunk) {
                    this.push({
                        data: exports.utf8encode(chunk.data),
                        meta: chunk.meta
                    })
                }, exports.Utf8EncodeWorker = Utf8EncodeWorker
            }, {
                "./nodejsUtils": 14,
                "./stream/GenericWorker": 28,
                "./support": 30,
                "./utils": 32
            }],
            32: [function(require, module, exports) {
                "use strict";

                function string2binary(str) {
                    var result = null;
                    return result = support.uint8array ? new Uint8Array(str.length) : new Array(str.length), stringToArrayLike(str, result)
                }

                function identity(input) {
                    return input
                }

                function stringToArrayLike(str, array) {
                    for (var i = 0; i < str.length; ++i) array[i] = 255 & str.charCodeAt(i);
                    return array
                }

                function arrayLikeToString(array) {
                    var chunk = 65536,
                        type = exports.getTypeOf(array),
                        canUseApply = !0;
                    if ("uint8array" === type ? canUseApply = arrayToStringHelper.applyCanBeUsed.uint8array : "nodebuffer" === type && (canUseApply = arrayToStringHelper.applyCanBeUsed.nodebuffer), canUseApply)
                        for (; chunk > 1;) try {
                            return arrayToStringHelper.stringifyByChunk(array, type, chunk)
                        } catch (e) {
                            chunk = Math.floor(chunk / 2)
                        }
                    return arrayToStringHelper.stringifyByChar(array)
                }

                function arrayLikeToArrayLike(arrayFrom, arrayTo) {
                    for (var i = 0; i < arrayFrom.length; i++) arrayTo[i] = arrayFrom[i];
                    return arrayTo
                }
                var support = require("./support"),
                    base64 = require("./base64"),
                    nodejsUtils = require("./nodejsUtils"),
                    setImmediate = require("core-js/library/fn/set-immediate"),
                    external = require("./external");
                exports.newBlob = function(part, type) {
                    exports.checkSupport("blob");
                    try {
                        return new Blob([part], {
                            type: type
                        })
                    } catch (e) {
                        try {
                            var Builder = self.BlobBuilder || self.WebKitBlobBuilder || self.MozBlobBuilder || self.MSBlobBuilder,
                                builder = new Builder;
                            return builder.append(part), builder.getBlob(type)
                        } catch (e) {
                            throw new Error("Bug : can't construct the Blob.")
                        }
                    }
                };
                var arrayToStringHelper = {
                    stringifyByChunk: function(array, type, chunk) {
                        var result = [],
                            k = 0,
                            len = array.length;
                        if (len <= chunk) return String.fromCharCode.apply(null, array);
                        for (; k < len;) "array" === type || "nodebuffer" === type ? result.push(String.fromCharCode.apply(null, array.slice(k, Math.min(k + chunk, len)))) : result.push(String.fromCharCode.apply(null, array.subarray(k, Math.min(k + chunk, len)))), k += chunk;
                        return result.join("")
                    },
                    stringifyByChar: function(array) {
                        for (var resultStr = "", i = 0; i < array.length; i++) resultStr += String.fromCharCode(array[i]);
                        return resultStr
                    },
                    applyCanBeUsed: {
                        uint8array: function() {
                            try {
                                return support.uint8array && 1 === String.fromCharCode.apply(null, new Uint8Array(1)).length
                            } catch (e) {
                                return !1
                            }
                        }(),
                        nodebuffer: function() {
                            try {
                                return support.nodebuffer && 1 === String.fromCharCode.apply(null, nodejsUtils.allocBuffer(1)).length
                            } catch (e) {
                                return !1
                            }
                        }()
                    }
                };
                exports.applyFromCharCode = arrayLikeToString;
                var transform = {};
                transform.string = {
                    string: identity,
                    array: function(input) {
                        return stringToArrayLike(input, new Array(input.length))
                    },
                    arraybuffer: function(input) {
                        return transform.string.uint8array(input).buffer
                    },
                    uint8array: function(input) {
                        return stringToArrayLike(input, new Uint8Array(input.length))
                    },
                    nodebuffer: function(input) {
                        return stringToArrayLike(input, nodejsUtils.allocBuffer(input.length))
                    }
                }, transform.array = {
                    string: arrayLikeToString,
                    array: identity,
                    arraybuffer: function(input) {
                        return new Uint8Array(input).buffer
                    },
                    uint8array: function(input) {
                        return new Uint8Array(input)
                    },
                    nodebuffer: function(input) {
                        return nodejsUtils.newBufferFrom(input)
                    }
                }, transform.arraybuffer = {
                    string: function(input) {
                        return arrayLikeToString(new Uint8Array(input))
                    },
                    array: function(input) {
                        return arrayLikeToArrayLike(new Uint8Array(input), new Array(input.byteLength))
                    },
                    arraybuffer: identity,
                    uint8array: function(input) {
                        return new Uint8Array(input)
                    },
                    nodebuffer: function(input) {
                        return nodejsUtils.newBufferFrom(new Uint8Array(input))
                    }
                }, transform.uint8array = {
                    string: arrayLikeToString,
                    array: function(input) {
                        return arrayLikeToArrayLike(input, new Array(input.length))
                    },
                    arraybuffer: function(input) {
                        return input.buffer
                    },
                    uint8array: identity,
                    nodebuffer: function(input) {
                        return nodejsUtils.newBufferFrom(input)
                    }
                }, transform.nodebuffer = {
                    string: arrayLikeToString,
                    array: function(input) {
                        return arrayLikeToArrayLike(input, new Array(input.length))
                    },
                    arraybuffer: function(input) {
                        return transform.nodebuffer.uint8array(input).buffer
                    },
                    uint8array: function(input) {
                        return arrayLikeToArrayLike(input, new Uint8Array(input.length))
                    },
                    nodebuffer: identity
                }, exports.transformTo = function(outputType, input) {
                    if (input || (input = ""), !outputType) return input;
                    exports.checkSupport(outputType);
                    var inputType = exports.getTypeOf(input),
                        result = transform[inputType][outputType](input);
                    return result
                }, exports.getTypeOf = function(input) {
                    return "string" == typeof input ? "string" : "[object Array]" === Object.prototype.toString.call(input) ? "array" : support.nodebuffer && nodejsUtils.isBuffer(input) ? "nodebuffer" : support.uint8array && input instanceof Uint8Array ? "uint8array" : support.arraybuffer && input instanceof ArrayBuffer ? "arraybuffer" : void 0
                }, exports.checkSupport = function(type) {
                    var supported = support[type.toLowerCase()];
                    if (!supported) throw new Error(type + " is not supported by this platform")
                }, exports.MAX_VALUE_16BITS = 65535, exports.MAX_VALUE_32BITS = -1, exports.pretty = function(str) {
                    var code, i, res = "";
                    for (i = 0; i < (str || "").length; i++) code = str.charCodeAt(i), res += "\\x" + (code < 16 ? "0" : "") + code.toString(16).toUpperCase();
                    return res
                }, exports.delay = function(callback, args, self) {
                    setImmediate(function() {
                        callback.apply(self || null, args || [])
                    })
                }, exports.inherits = function(ctor, superCtor) {
                    var Obj = function() {};
                    Obj.prototype = superCtor.prototype, ctor.prototype = new Obj
                }, exports.extend = function() {
                    var i, attr, result = {};
                    for (i = 0; i < arguments.length; i++)
                        for (attr in arguments[i]) arguments[i].hasOwnProperty(attr) && "undefined" == typeof result[attr] && (result[attr] = arguments[i][attr]);
                    return result
                }, exports.prepareContent = function(name, inputData, isBinary, isOptimizedBinaryString, isBase64) {
                    var promise = external.Promise.resolve(inputData).then(function(data) {
                        var isBlob = support.blob && (data instanceof Blob || ["[object File]", "[object Blob]"].indexOf(Object.prototype.toString.call(data)) !== -1);
                        return isBlob && "undefined" != typeof FileReader ? new external.Promise(function(resolve, reject) {
                            var reader = new FileReader;
                            reader.onload = function(e) {
                                resolve(e.target.result)
                            }, reader.onerror = function(e) {
                                reject(e.target.error)
                            }, reader.readAsArrayBuffer(data)
                        }) : data
                    });
                    return promise.then(function(data) {
                        var dataType = exports.getTypeOf(data);
                        return dataType ? ("arraybuffer" === dataType ? data = exports.transformTo("uint8array", data) : "string" === dataType && (isBase64 ? data = base64.decode(data) : isBinary && isOptimizedBinaryString !== !0 && (data = string2binary(data))), data) : external.Promise.reject(new Error("Can't read the data of '" + name + "'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))
                    })
                }
            }, {
                "./base64": 1,
                "./external": 6,
                "./nodejsUtils": 14,
                "./support": 30,
                "core-js/library/fn/set-immediate": 36
            }],
            33: [function(require, module, exports) {
                "use strict";

                function ZipEntries(loadOptions) {
                    this.files = [], this.loadOptions = loadOptions
                }
                var readerFor = require("./reader/readerFor"),
                    utils = require("./utils"),
                    sig = require("./signature"),
                    ZipEntry = require("./zipEntry"),
                    support = (require("./utf8"), require("./support"));
                ZipEntries.prototype = {
                    checkSignature: function(expectedSignature) {
                        if (!this.reader.readAndCheckSignature(expectedSignature)) {
                            this.reader.index -= 4;
                            var signature = this.reader.readString(4);
                            throw new Error("Corrupted zip or bug: unexpected signature (" + utils.pretty(signature) + ", expected " + utils.pretty(expectedSignature) + ")")
                        }
                    },
                    isSignature: function(askedIndex, expectedSignature) {
                        var currentIndex = this.reader.index;
                        this.reader.setIndex(askedIndex);
                        var signature = this.reader.readString(4),
                            result = signature === expectedSignature;
                        return this.reader.setIndex(currentIndex), result
                    },
                    readBlockEndOfCentral: function() {
                        this.diskNumber = this.reader.readInt(2), this.diskWithCentralDirStart = this.reader.readInt(2), this.centralDirRecordsOnThisDisk = this.reader.readInt(2), this.centralDirRecords = this.reader.readInt(2), this.centralDirSize = this.reader.readInt(4), this.centralDirOffset = this.reader.readInt(4), this.zipCommentLength = this.reader.readInt(2);
                        var zipComment = this.reader.readData(this.zipCommentLength),
                            decodeParamType = support.uint8array ? "uint8array" : "array",
                            decodeContent = utils.transformTo(decodeParamType, zipComment);
                        this.zipComment = this.loadOptions.decodeFileName(decodeContent)
                    },
                    readBlockZip64EndOfCentral: function() {
                        this.zip64EndOfCentralSize = this.reader.readInt(8), this.reader.skip(4), this.diskNumber = this.reader.readInt(4), this.diskWithCentralDirStart = this.reader.readInt(4), this.centralDirRecordsOnThisDisk = this.reader.readInt(8), this.centralDirRecords = this.reader.readInt(8), this.centralDirSize = this.reader.readInt(8), this.centralDirOffset = this.reader.readInt(8), this.zip64ExtensibleData = {};
                        for (var extraFieldId, extraFieldLength, extraFieldValue, extraDataSize = this.zip64EndOfCentralSize - 44, index = 0; index < extraDataSize;) extraFieldId = this.reader.readInt(2), extraFieldLength = this.reader.readInt(4), extraFieldValue = this.reader.readData(extraFieldLength), this.zip64ExtensibleData[extraFieldId] = {
                            id: extraFieldId,
                            length: extraFieldLength,
                            value: extraFieldValue
                        }
                    },
                    readBlockZip64EndOfCentralLocator: function() {
                        if (this.diskWithZip64CentralDirStart = this.reader.readInt(4), this.relativeOffsetEndOfZip64CentralDir = this.reader.readInt(8), this.disksCount = this.reader.readInt(4), this.disksCount > 1) throw new Error("Multi-volumes zip are not supported")
                    },
                    readLocalFiles: function() {
                        var i, file;
                        for (i = 0; i < this.files.length; i++) file = this.files[i], this.reader.setIndex(file.localHeaderOffset), this.checkSignature(sig.LOCAL_FILE_HEADER), file.readLocalPart(this.reader), file.handleUTF8(), file.processAttributes()
                    },
                    readCentralDir: function() {
                        var file;
                        for (this.reader.setIndex(this.centralDirOffset); this.reader.readAndCheckSignature(sig.CENTRAL_FILE_HEADER);) file = new ZipEntry({
                            zip64: this.zip64
                        }, this.loadOptions), file.readCentralPart(this.reader), this.files.push(file);
                        if (this.centralDirRecords !== this.files.length && 0 !== this.centralDirRecords && 0 === this.files.length) throw new Error("Corrupted zip or bug: expected " + this.centralDirRecords + " records in central dir, got " + this.files.length)
                    },
                    readEndOfCentral: function() {
                        var offset = this.reader.lastIndexOfSignature(sig.CENTRAL_DIRECTORY_END);
                        if (offset < 0) {
                            var isGarbage = !this.isSignature(0, sig.LOCAL_FILE_HEADER);
                            throw isGarbage ? new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html") : new Error("Corrupted zip: can't find end of central directory")
                        }
                        this.reader.setIndex(offset);
                        var endOfCentralDirOffset = offset;
                        if (this.checkSignature(sig.CENTRAL_DIRECTORY_END), this.readBlockEndOfCentral(), this.diskNumber === utils.MAX_VALUE_16BITS || this.diskWithCentralDirStart === utils.MAX_VALUE_16BITS || this.centralDirRecordsOnThisDisk === utils.MAX_VALUE_16BITS || this.centralDirRecords === utils.MAX_VALUE_16BITS || this.centralDirSize === utils.MAX_VALUE_32BITS || this.centralDirOffset === utils.MAX_VALUE_32BITS) {
                            if (this.zip64 = !0, offset = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR), offset < 0) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");
                            if (this.reader.setIndex(offset), this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_LOCATOR), this.readBlockZip64EndOfCentralLocator(), !this.isSignature(this.relativeOffsetEndOfZip64CentralDir, sig.ZIP64_CENTRAL_DIRECTORY_END) && (this.relativeOffsetEndOfZip64CentralDir = this.reader.lastIndexOfSignature(sig.ZIP64_CENTRAL_DIRECTORY_END), this.relativeOffsetEndOfZip64CentralDir < 0)) throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");
                            this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir), this.checkSignature(sig.ZIP64_CENTRAL_DIRECTORY_END), this.readBlockZip64EndOfCentral()
                        }
                        var expectedEndOfCentralDirOffset = this.centralDirOffset + this.centralDirSize;
                        this.zip64 && (expectedEndOfCentralDirOffset += 20, expectedEndOfCentralDirOffset += 12 + this.zip64EndOfCentralSize);
                        var extraBytes = endOfCentralDirOffset - expectedEndOfCentralDirOffset;
                        if (extraBytes > 0) this.isSignature(endOfCentralDirOffset, sig.CENTRAL_FILE_HEADER) || (this.reader.zero = extraBytes);
                        else if (extraBytes < 0) throw new Error("Corrupted zip: missing " + Math.abs(extraBytes) + " bytes.")
                    },
                    prepareReader: function(data) {
                        this.reader = readerFor(data)
                    },
                    load: function(data) {
                        this.prepareReader(data), this.readEndOfCentral(), this.readCentralDir(), this.readLocalFiles()
                    }
                }, module.exports = ZipEntries
            }, {
                "./reader/readerFor": 22,
                "./signature": 23,
                "./support": 30,
                "./utf8": 31,
                "./utils": 32,
                "./zipEntry": 34
            }],
            34: [function(require, module, exports) {
                "use strict";

                function ZipEntry(options, loadOptions) {
                    this.options = options, this.loadOptions = loadOptions
                }
                var readerFor = require("./reader/readerFor"),
                    utils = require("./utils"),
                    CompressedObject = require("./compressedObject"),
                    crc32fn = require("./crc32"),
                    utf8 = require("./utf8"),
                    compressions = require("./compressions"),
                    support = require("./support"),
                    MADE_BY_DOS = 0,
                    MADE_BY_UNIX = 3,
                    findCompression = function(compressionMethod) {
                        for (var method in compressions)
                            if (compressions.hasOwnProperty(method) && compressions[method].magic === compressionMethod) return compressions[method];
                        return null
                    };
                ZipEntry.prototype = {
                    isEncrypted: function() {
                        return 1 === (1 & this.bitFlag)
                    },
                    useUTF8: function() {
                        return 2048 === (2048 & this.bitFlag)
                    },
                    readLocalPart: function(reader) {
                        var compression, localExtraFieldsLength;
                        if (reader.skip(22), this.fileNameLength = reader.readInt(2), localExtraFieldsLength = reader.readInt(2), this.fileName = reader.readData(this.fileNameLength), reader.skip(localExtraFieldsLength), this.compressedSize === -1 || this.uncompressedSize === -1) throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize === -1 || uncompressedSize === -1)");
                        if (compression = findCompression(this.compressionMethod), null === compression) throw new Error("Corrupted zip : compression " + utils.pretty(this.compressionMethod) + " unknown (inner file : " + utils.transformTo("string", this.fileName) + ")");
                        this.decompressed = new CompressedObject(this.compressedSize, this.uncompressedSize, this.crc32, compression, reader.readData(this.compressedSize))
                    },
                    readCentralPart: function(reader) {
                        this.versionMadeBy = reader.readInt(2), reader.skip(2), this.bitFlag = reader.readInt(2), this.compressionMethod = reader.readString(2), this.date = reader.readDate(), this.crc32 = reader.readInt(4), this.compressedSize = reader.readInt(4), this.uncompressedSize = reader.readInt(4);
                        var fileNameLength = reader.readInt(2);
                        if (this.extraFieldsLength = reader.readInt(2), this.fileCommentLength = reader.readInt(2), this.diskNumberStart = reader.readInt(2), this.internalFileAttributes = reader.readInt(2), this.externalFileAttributes = reader.readInt(4), this.localHeaderOffset = reader.readInt(4), this.isEncrypted()) throw new Error("Encrypted zip are not supported");
                        reader.skip(fileNameLength), this.readExtraFields(reader), this.parseZIP64ExtraField(reader), this.fileComment = reader.readData(this.fileCommentLength)
                    },
                    processAttributes: function() {
                        this.unixPermissions = null, this.dosPermissions = null;
                        var madeBy = this.versionMadeBy >> 8;
                        this.dir = !!(16 & this.externalFileAttributes), madeBy === MADE_BY_DOS && (this.dosPermissions = 63 & this.externalFileAttributes), madeBy === MADE_BY_UNIX && (this.unixPermissions = this.externalFileAttributes >> 16 & 65535), this.dir || "/" !== this.fileNameStr.slice(-1) || (this.dir = !0)
                    },
                    parseZIP64ExtraField: function(reader) {
                        if (this.extraFields[1]) {
                            var extraReader = readerFor(this.extraFields[1].value);
                            this.uncompressedSize === utils.MAX_VALUE_32BITS && (this.uncompressedSize = extraReader.readInt(8)), this.compressedSize === utils.MAX_VALUE_32BITS && (this.compressedSize = extraReader.readInt(8)), this.localHeaderOffset === utils.MAX_VALUE_32BITS && (this.localHeaderOffset = extraReader.readInt(8)), this.diskNumberStart === utils.MAX_VALUE_32BITS && (this.diskNumberStart = extraReader.readInt(4))
                        }
                    },
                    readExtraFields: function(reader) {
                        var extraFieldId, extraFieldLength, extraFieldValue, end = reader.index + this.extraFieldsLength;
                        for (this.extraFields || (this.extraFields = {}); reader.index < end;) extraFieldId = reader.readInt(2), extraFieldLength = reader.readInt(2), extraFieldValue = reader.readData(extraFieldLength), this.extraFields[extraFieldId] = {
                            id: extraFieldId,
                            length: extraFieldLength,
                            value: extraFieldValue
                        }
                    },
                    handleUTF8: function() {
                        var decodeParamType = support.uint8array ? "uint8array" : "array";
                        if (this.useUTF8()) this.fileNameStr = utf8.utf8decode(this.fileName), this.fileCommentStr = utf8.utf8decode(this.fileComment);
                        else {
                            var upath = this.findExtraFieldUnicodePath();
                            if (null !== upath) this.fileNameStr = upath;
                            else {
                                var fileNameByteArray = utils.transformTo(decodeParamType, this.fileName);
                                this.fileNameStr = this.loadOptions.decodeFileName(fileNameByteArray)
                            }
                            var ucomment = this.findExtraFieldUnicodeComment();
                            if (null !== ucomment) this.fileCommentStr = ucomment;
                            else {
                                var commentByteArray = utils.transformTo(decodeParamType, this.fileComment);
                                this.fileCommentStr = this.loadOptions.decodeFileName(commentByteArray)
                            }
                        }
                    },
                    findExtraFieldUnicodePath: function() {
                        var upathField = this.extraFields[28789];
                        if (upathField) {
                            var extraReader = readerFor(upathField.value);
                            return 1 !== extraReader.readInt(1) ? null : crc32fn(this.fileName) !== extraReader.readInt(4) ? null : utf8.utf8decode(extraReader.readData(upathField.length - 5))
                        }
                        return null
                    },
                    findExtraFieldUnicodeComment: function() {
                        var ucommentField = this.extraFields[25461];
                        if (ucommentField) {
                            var extraReader = readerFor(ucommentField.value);
                            return 1 !== extraReader.readInt(1) ? null : crc32fn(this.fileComment) !== extraReader.readInt(4) ? null : utf8.utf8decode(extraReader.readData(ucommentField.length - 5))
                        }
                        return null
                    }
                }, module.exports = ZipEntry
            }, {
                "./compressedObject": 2,
                "./compressions": 3,
                "./crc32": 4,
                "./reader/readerFor": 22,
                "./support": 30,
                "./utf8": 31,
                "./utils": 32
            }],
            35: [function(require, module, exports) {
                "use strict";
                var StreamHelper = require("./stream/StreamHelper"),
                    DataWorker = require("./stream/DataWorker"),
                    utf8 = require("./utf8"),
                    CompressedObject = require("./compressedObject"),
                    GenericWorker = require("./stream/GenericWorker"),
                    ZipObject = function(name, data, options) {
                        this.name = name, this.dir = options.dir, this.date = options.date, this.comment = options.comment, this.unixPermissions = options.unixPermissions, this.dosPermissions = options.dosPermissions, this._data = data, this._dataBinary = options.binary, this.options = {
                            compression: options.compression,
                            compressionOptions: options.compressionOptions
                        }
                    };
                ZipObject.prototype = {
                    internalStream: function(type) {
                        var result = null,
                            outputType = "string";
                        try {
                            if (!type) throw new Error("No output type specified.");
                            outputType = type.toLowerCase();
                            var askUnicodeString = "string" === outputType || "text" === outputType;
                            "binarystring" !== outputType && "text" !== outputType || (outputType = "string"), result = this._decompressWorker();
                            var isUnicodeString = !this._dataBinary;
                            isUnicodeString && !askUnicodeString && (result = result.pipe(new utf8.Utf8EncodeWorker)), !isUnicodeString && askUnicodeString && (result = result.pipe(new utf8.Utf8DecodeWorker))
                        } catch (e) {
                            result = new GenericWorker("error"), result.error(e)
                        }
                        return new StreamHelper(result, outputType, "")
                    },
                    async: function(type, onUpdate) {
                        return this.internalStream(type).accumulate(onUpdate)
                    },
                    nodeStream: function(type, onUpdate) {
                        return this.internalStream(type || "nodebuffer").toNodejsStream(onUpdate)
                    },
                    _compressWorker: function(compression, compressionOptions) {
                        if (this._data instanceof CompressedObject && this._data.compression.magic === compression.magic) return this._data.getCompressedWorker();
                        var result = this._decompressWorker();
                        return this._dataBinary || (result = result.pipe(new utf8.Utf8EncodeWorker)), CompressedObject.createWorkerFrom(result, compression, compressionOptions)
                    },
                    _decompressWorker: function() {
                        return this._data instanceof CompressedObject ? this._data.getContentWorker() : this._data instanceof GenericWorker ? this._data : new DataWorker(this._data)
                    }
                };
                for (var removedMethods = ["asText", "asBinary", "asNodeBuffer", "asUint8Array", "asArrayBuffer"], removedFn = function() {
                        throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")
                    }, i = 0; i < removedMethods.length; i++) ZipObject.prototype[removedMethods[i]] = removedFn;
                module.exports = ZipObject
            }, {
                "./compressedObject": 2,
                "./stream/DataWorker": 27,
                "./stream/GenericWorker": 28,
                "./stream/StreamHelper": 29,
                "./utf8": 31
            }],
            36: [function(require, module, exports) {
                require("../modules/web.immediate"), module.exports = require("../modules/_core").setImmediate
            }, {
                "../modules/_core": 40,
                "../modules/web.immediate": 56
            }],
            37: [function(require, module, exports) {
                module.exports = function(it) {
                    if ("function" != typeof it) throw TypeError(it + " is not a function!");
                    return it
                }
            }, {}],
            38: [function(require, module, exports) {
                var isObject = require("./_is-object");
                module.exports = function(it) {
                    if (!isObject(it)) throw TypeError(it + " is not an object!");
                    return it
                }
            }, {
                "./_is-object": 51
            }],
            39: [function(require, module, exports) {
                var toString = {}.toString;
                module.exports = function(it) {
                    return toString.call(it).slice(8, -1)
                }
            }, {}],
            40: [function(require, module, exports) {
                var core = module.exports = {
                    version: "2.3.0"
                };
                "number" == typeof __e && (__e = core)
            }, {}],
            41: [function(require, module, exports) {
                var aFunction = require("./_a-function");
                module.exports = function(fn, that, length) {
                    if (aFunction(fn), void 0 === that) return fn;
                    switch (length) {
                        case 1:
                            return function(a) {
                                return fn.call(that, a)
                            };
                        case 2:
                            return function(a, b) {
                                return fn.call(that, a, b)
                            };
                        case 3:
                            return function(a, b, c) {
                                return fn.call(that, a, b, c)
                            }
                    }
                    return function() {
                        return fn.apply(that, arguments)
                    }
                }
            }, {
                "./_a-function": 37
            }],
            42: [function(require, module, exports) {
                module.exports = !require("./_fails")(function() {
                    return 7 != Object.defineProperty({}, "a", {
                        get: function() {
                            return 7
                        }
                    }).a
                })
            }, {
                "./_fails": 45
            }],
            43: [function(require, module, exports) {
                var isObject = require("./_is-object"),
                    document = require("./_global").document,
                    is = isObject(document) && isObject(document.createElement);
                module.exports = function(it) {
                    return is ? document.createElement(it) : {}
                }
            }, {
                "./_global": 46,
                "./_is-object": 51
            }],
            44: [function(require, module, exports) {
                var global = require("./_global"),
                    core = require("./_core"),
                    ctx = require("./_ctx"),
                    hide = require("./_hide"),
                    PROTOTYPE = "prototype",
                    $export = function $export(type, name, source) {
                        var key, own, out, IS_FORCED = type & $export.F,
                            IS_GLOBAL = type & $export.G,
                            IS_STATIC = type & $export.S,
                            IS_PROTO = type & $export.P,
                            IS_BIND = type & $export.B,
                            IS_WRAP = type & $export.W,
                            exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
                            expProto = exports[PROTOTYPE],
                            target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
                        IS_GLOBAL && (source = name);
                        for (key in source) own = !IS_FORCED && target && void 0 !== target[key], own && key in exports || (out = own ? target[key] : source[key], exports[key] = IS_GLOBAL && "function" != typeof target[key] ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? function(C) {
                            var F = function(a, b, c) {
                                if (this instanceof C) {
                                    switch (arguments.length) {
                                        case 0:
                                            return new C;
                                        case 1:
                                            return new C(a);
                                        case 2:
                                            return new C(a, b)
                                    }
                                    return new C(a, b, c)
                                }
                                return C.apply(this, arguments)
                            };
                            return F[PROTOTYPE] = C[PROTOTYPE], F
                        }(out) : IS_PROTO && "function" == typeof out ? ctx(Function.call, out) : out, IS_PROTO && ((exports.virtual || (exports.virtual = {}))[key] = out, type & $export.R && expProto && !expProto[key] && hide(expProto, key, out)))
                    };
                $export.F = 1, $export.G = 2, $export.S = 4, $export.P = 8, $export.B = 16, $export.W = 32, $export.U = 64, $export.R = 128, module.exports = $export
            }, {
                "./_core": 40,
                "./_ctx": 41,
                "./_global": 46,
                "./_hide": 47
            }],
            45: [function(require, module, exports) {
                module.exports = function(exec) {
                    try {
                        return !!exec()
                    } catch (e) {
                        return !0
                    }
                }
            }, {}],
            46: [function(require, module, exports) {
                var global = module.exports = "undefined" != typeof window && window.Math == Math ? window : "undefined" != typeof self && self.Math == Math ? self : Function("return this")();
                "number" == typeof __g && (__g = global)
            }, {}],
            47: [function(require, module, exports) {
                var dP = require("./_object-dp"),
                    createDesc = require("./_property-desc");
                module.exports = require("./_descriptors") ? function(object, key, value) {
                    return dP.f(object, key, createDesc(1, value))
                } : function(object, key, value) {
                    return object[key] = value, object
                }
            }, {
                "./_descriptors": 42,
                "./_object-dp": 52,
                "./_property-desc": 53
            }],
            48: [function(require, module, exports) {
                module.exports = require("./_global").document && document.documentElement
            }, {
                "./_global": 46
            }],
            49: [function(require, module, exports) {
                module.exports = !require("./_descriptors") && !require("./_fails")(function() {
                    return 7 != Object.defineProperty(require("./_dom-create")("div"), "a", {
                        get: function() {
                            return 7
                        }
                    }).a
                })
            }, {
                "./_descriptors": 42,
                "./_dom-create": 43,
                "./_fails": 45
            }],
            50: [function(require, module, exports) {
                module.exports = function(fn, args, that) {
                    var un = void 0 === that;
                    switch (args.length) {
                        case 0:
                            return un ? fn() : fn.call(that);
                        case 1:
                            return un ? fn(args[0]) : fn.call(that, args[0]);
                        case 2:
                            return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);
                        case 3:
                            return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);
                        case 4:
                            return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3])
                    }
                    return fn.apply(that, args)
                }
            }, {}],
            51: [function(require, module, exports) {
                module.exports = function(it) {
                    return "object" === _typeof2(it) ? null !== it : "function" == typeof it
                }
            }, {}],
            52: [function(require, module, exports) {
                var anObject = require("./_an-object"),
                    IE8_DOM_DEFINE = require("./_ie8-dom-define"),
                    toPrimitive = require("./_to-primitive"),
                    dP = Object.defineProperty;
                exports.f = require("./_descriptors") ? Object.defineProperty : function(O, P, Attributes) {
                    if (anObject(O), P = toPrimitive(P, !0), anObject(Attributes), IE8_DOM_DEFINE) try {
                        return dP(O, P, Attributes)
                    } catch (e) {}
                    if ("get" in Attributes || "set" in Attributes) throw TypeError("Accessors not supported!");
                    return "value" in Attributes && (O[P] = Attributes.value), O
                }
            }, {
                "./_an-object": 38,
                "./_descriptors": 42,
                "./_ie8-dom-define": 49,
                "./_to-primitive": 55
            }],
            53: [function(require, module, exports) {
                module.exports = function(bitmap, value) {
                    return {
                        enumerable: !(1 & bitmap),
                        configurable: !(2 & bitmap),
                        writable: !(4 & bitmap),
                        value: value
                    }
                }
            }, {}],
            54: [function(require, module, exports) {
                var defer, channel, port, ctx = require("./_ctx"),
                    invoke = require("./_invoke"),
                    html = require("./_html"),
                    cel = require("./_dom-create"),
                    global = require("./_global"),
                    process = global.process,
                    setTask = global.setImmediate,
                    clearTask = global.clearImmediate,
                    MessageChannel = global.MessageChannel,
                    counter = 0,
                    queue = {},
                    ONREADYSTATECHANGE = "onreadystatechange",
                    run = function() {
                        var id = +this;
                        if (queue.hasOwnProperty(id)) {
                            var fn = queue[id];
                            delete queue[id], fn()
                        }
                    },
                    listener = function(event) {
                        run.call(event.data)
                    };
                setTask && clearTask || (setTask = function(fn) {
                    for (var args = [], i = 1; arguments.length > i;) args.push(arguments[i++]);
                    return queue[++counter] = function() {
                        invoke("function" == typeof fn ? fn : Function(fn), args)
                    }, defer(counter), counter
                }, clearTask = function(id) {
                    delete queue[id]
                }, "process" == require("./_cof")(process) ? defer = function(id) {
                    process.nextTick(ctx(run, id, 1))
                } : MessageChannel ? (channel = new MessageChannel, port = channel.port2, channel.port1.onmessage = listener, defer = ctx(port.postMessage, port, 1)) : global.addEventListener && "function" == typeof postMessage && !global.importScripts ? (defer = function(id) {
                    global.postMessage(id + "", "*")
                }, global.addEventListener("message", listener, !1)) : defer = ONREADYSTATECHANGE in cel("script") ? function(id) {
                    html.appendChild(cel("script"))[ONREADYSTATECHANGE] = function() {
                        html.removeChild(this), run.call(id)
                    }
                } : function(id) {
                    setTimeout(ctx(run, id, 1), 0)
                }), module.exports = {
                    set: setTask,
                    clear: clearTask
                }
            }, {
                "./_cof": 39,
                "./_ctx": 41,
                "./_dom-create": 43,
                "./_global": 46,
                "./_html": 48,
                "./_invoke": 50
            }],
            55: [function(require, module, exports) {
                var isObject = require("./_is-object");
                module.exports = function(it, S) {
                    if (!isObject(it)) return it;
                    var fn, val;
                    if (S && "function" == typeof(fn = it.toString) && !isObject(val = fn.call(it))) return val;
                    if ("function" == typeof(fn = it.valueOf) && !isObject(val = fn.call(it))) return val;
                    if (!S && "function" == typeof(fn = it.toString) && !isObject(val = fn.call(it))) return val;
                    throw TypeError("Can't convert object to primitive value")
                }
            }, {
                "./_is-object": 51
            }],
            56: [function(require, module, exports) {
                var $export = require("./_export"),
                    $task = require("./_task");
                $export($export.G + $export.B, {
                    setImmediate: $task.set,
                    clearImmediate: $task.clear
                })
            }, {
                "./_export": 44,
                "./_task": 54
            }],
            57: [function(require, module, exports) {
                (function(global) {
                    "use strict";

                    function nextTick() {
                        draining = !0;
                        for (var i, oldQueue, len = queue.length; len;) {
                            for (oldQueue = queue, queue = [], i = -1; ++i < len;) oldQueue[i]();
                            len = queue.length
                        }
                        draining = !1
                    }

                    function immediate(task) {
                        1 !== queue.push(task) || draining || scheduleDrain()
                    }
                    var scheduleDrain, Mutation = global.MutationObserver || global.WebKitMutationObserver;
                    if (Mutation) {
                        var called = 0,
                            observer = new Mutation(nextTick),
                            element = global.document.createTextNode("");
                        observer.observe(element, {
                            characterData: !0
                        }), scheduleDrain = function() {
                            element.data = called = ++called % 2
                        }
                    } else if (global.setImmediate || "undefined" == typeof global.MessageChannel) scheduleDrain = "document" in global && "onreadystatechange" in global.document.createElement("script") ? function() {
                        var scriptEl = global.document.createElement("script");
                        scriptEl.onreadystatechange = function() {
                            nextTick(), scriptEl.onreadystatechange = null, scriptEl.parentNode.removeChild(scriptEl), scriptEl = null
                        }, global.document.documentElement.appendChild(scriptEl)
                    } : function() {
                        setTimeout(nextTick, 0)
                    };
                    else {
                        var channel = new global.MessageChannel;
                        channel.port1.onmessage = nextTick, scheduleDrain = function() {
                            channel.port2.postMessage(0)
                        }
                    }
                    var draining, queue = [];
                    module.exports = immediate
                }).call(this, "undefined" != typeof global ? global : "undefined" != typeof self ? self : "undefined" != typeof window ? window : {})
            }, {}],
            58: [function(require, module, exports) {
                "use strict";

                function INTERNAL() {}

                function Promise(resolver) {
                    if ("function" != typeof resolver) throw new TypeError("resolver must be a function");
                    this.state = PENDING, this.queue = [], this.outcome = void 0, resolver !== INTERNAL && safelyResolveThenable(this, resolver)
                }

                function QueueItem(promise, onFulfilled, onRejected) {
                    this.promise = promise, "function" == typeof onFulfilled && (this.onFulfilled = onFulfilled, this.callFulfilled = this.otherCallFulfilled), "function" == typeof onRejected && (this.onRejected = onRejected, this.callRejected = this.otherCallRejected)
                }

                function unwrap(promise, func, value) {
                    immediate(function() {
                        var returnValue;
                        try {
                            returnValue = func(value)
                        } catch (e) {
                            return handlers.reject(promise, e)
                        }
                        returnValue === promise ? handlers.reject(promise, new TypeError("Cannot resolve promise with itself")) : handlers.resolve(promise, returnValue)
                    })
                }

                function getThen(obj) {
                    var then = obj && obj.then;
                    if (obj && ("object" === _typeof2(obj) || "function" == typeof obj) && "function" == typeof then) return function() {
                        then.apply(obj, arguments)
                    }
                }

                function safelyResolveThenable(self, thenable) {
                    function onError(value) {
                        called || (called = !0, handlers.reject(self, value))
                    }

                    function onSuccess(value) {
                        called || (called = !0, handlers.resolve(self, value))
                    }

                    function tryToUnwrap() {
                        thenable(onSuccess, onError)
                    }
                    var called = !1,
                        result = tryCatch(tryToUnwrap);
                    "error" === result.status && onError(result.value)
                }

                function tryCatch(func, value) {
                    var out = {};
                    try {
                        out.value = func(value), out.status = "success"
                    } catch (e) {
                        out.status = "error", out.value = e
                    }
                    return out
                }

                function resolve(value) {
                    return value instanceof this ? value : handlers.resolve(new this(INTERNAL), value)
                }

                function reject(reason) {
                    var promise = new this(INTERNAL);
                    return handlers.reject(promise, reason)
                }

                function all(iterable) {
                    function allResolver(value, i) {
                        function resolveFromAll(outValue) {
                            values[i] = outValue, ++resolved !== len || called || (called = !0, handlers.resolve(promise, values))
                        }
                        self.resolve(value).then(resolveFromAll, function(error) {
                            called || (called = !0, handlers.reject(promise, error))
                        })
                    }
                    var self = this;
                    if ("[object Array]" !== Object.prototype.toString.call(iterable)) return this.reject(new TypeError("must be an array"));
                    var len = iterable.length,
                        called = !1;
                    if (!len) return this.resolve([]);
                    for (var values = new Array(len), resolved = 0, i = -1, promise = new this(INTERNAL); ++i < len;) allResolver(iterable[i], i);
                    return promise
                }

                function race(iterable) {
                    function resolver(value) {
                        self.resolve(value).then(function(response) {
                            called || (called = !0, handlers.resolve(promise, response))
                        }, function(error) {
                            called || (called = !0, handlers.reject(promise, error))
                        })
                    }
                    var self = this;
                    if ("[object Array]" !== Object.prototype.toString.call(iterable)) return this.reject(new TypeError("must be an array"));
                    var len = iterable.length,
                        called = !1;
                    if (!len) return this.resolve([]);
                    for (var i = -1, promise = new this(INTERNAL); ++i < len;) resolver(iterable[i]);
                    return promise
                }
                var immediate = require("immediate"),
                    handlers = {},
                    REJECTED = ["REJECTED"],
                    FULFILLED = ["FULFILLED"],
                    PENDING = ["PENDING"];
                module.exports = Promise, Promise.prototype.catch = function(onRejected) {
                    return this.then(null, onRejected)
                }, Promise.prototype.then = function(onFulfilled, onRejected) {
                    if ("function" != typeof onFulfilled && this.state === FULFILLED || "function" != typeof onRejected && this.state === REJECTED) return this;
                    var promise = new this.constructor(INTERNAL);
                    if (this.state !== PENDING) {
                        var resolver = this.state === FULFILLED ? onFulfilled : onRejected;
                        unwrap(promise, resolver, this.outcome)
                    } else this.queue.push(new QueueItem(promise, onFulfilled, onRejected));
                    return promise
                }, QueueItem.prototype.callFulfilled = function(value) {
                    handlers.resolve(this.promise, value)
                }, QueueItem.prototype.otherCallFulfilled = function(value) {
                    unwrap(this.promise, this.onFulfilled, value)
                }, QueueItem.prototype.callRejected = function(value) {
                    handlers.reject(this.promise, value)
                }, QueueItem.prototype.otherCallRejected = function(value) {
                    unwrap(this.promise, this.onRejected, value)
                }, handlers.resolve = function(self, value) {
                    var result = tryCatch(getThen, value);
                    if ("error" === result.status) return handlers.reject(self, result.value);
                    var thenable = result.value;
                    if (thenable) safelyResolveThenable(self, thenable);
                    else {
                        self.state = FULFILLED, self.outcome = value;
                        for (var i = -1, len = self.queue.length; ++i < len;) self.queue[i].callFulfilled(value)
                    }
                    return self
                }, handlers.reject = function(self, error) {
                    self.state = REJECTED, self.outcome = error;
                    for (var i = -1, len = self.queue.length; ++i < len;) self.queue[i].callRejected(error);
                    return self
                }, Promise.resolve = resolve, Promise.reject = reject, Promise.all = all, Promise.race = race
            }, {
                immediate: 57
            }],
            59: [function(require, module, exports) {
                "use strict";
                var assign = require("./lib/utils/common").assign,
                    deflate = require("./lib/deflate"),
                    inflate = require("./lib/inflate"),
                    constants = require("./lib/zlib/constants"),
                    pako = {};
                assign(pako, deflate, inflate, constants), module.exports = pako
            }, {
                "./lib/deflate": 60,
                "./lib/inflate": 61,
                "./lib/utils/common": 62,
                "./lib/zlib/constants": 65
            }],
            60: [function(require, module, exports) {
                "use strict";

                function Deflate(options) {
                    if (!(this instanceof Deflate)) return new Deflate(options);
                    this.options = utils.assign({
                        level: Z_DEFAULT_COMPRESSION,
                        method: Z_DEFLATED,
                        chunkSize: 16384,
                        windowBits: 15,
                        memLevel: 8,
                        strategy: Z_DEFAULT_STRATEGY,
                        to: ""
                    }, options || {});
                    var opt = this.options;
                    opt.raw && opt.windowBits > 0 ? opt.windowBits = -opt.windowBits : opt.gzip && opt.windowBits > 0 && opt.windowBits < 16 && (opt.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new ZStream, this.strm.avail_out = 0;
                    var status = zlib_deflate.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);
                    if (status !== Z_OK) throw new Error(msg[status]);
                    if (opt.header && zlib_deflate.deflateSetHeader(this.strm, opt.header), opt.dictionary) {
                        var dict;
                        if (dict = "string" == typeof opt.dictionary ? strings.string2buf(opt.dictionary) : "[object ArrayBuffer]" === toString.call(opt.dictionary) ? new Uint8Array(opt.dictionary) : opt.dictionary, status = zlib_deflate.deflateSetDictionary(this.strm, dict), status !== Z_OK) throw new Error(msg[status]);
                        this._dict_set = !0
                    }
                }

                function deflate(input, options) {
                    var deflator = new Deflate(options);
                    if (deflator.push(input, !0), deflator.err) throw deflator.msg || msg[deflator.err];
                    return deflator.result
                }

                function deflateRaw(input, options) {
                    return options = options || {}, options.raw = !0, deflate(input, options)
                }

                function gzip(input, options) {
                    return options = options || {}, options.gzip = !0, deflate(input, options)
                }
                var zlib_deflate = require("./zlib/deflate"),
                    utils = require("./utils/common"),
                    strings = require("./utils/strings"),
                    msg = require("./zlib/messages"),
                    ZStream = require("./zlib/zstream"),
                    toString = Object.prototype.toString,
                    Z_NO_FLUSH = 0,
                    Z_FINISH = 4,
                    Z_OK = 0,
                    Z_STREAM_END = 1,
                    Z_SYNC_FLUSH = 2,
                    Z_DEFAULT_COMPRESSION = -1,
                    Z_DEFAULT_STRATEGY = 0,
                    Z_DEFLATED = 8;
                Deflate.prototype.push = function(data, mode) {
                    var status, _mode, strm = this.strm,
                        chunkSize = this.options.chunkSize;
                    if (this.ended) return !1;
                    _mode = mode === ~~mode ? mode : mode === !0 ? Z_FINISH : Z_NO_FLUSH, "string" == typeof data ? strm.input = strings.string2buf(data) : "[object ArrayBuffer]" === toString.call(data) ? strm.input = new Uint8Array(data) : strm.input = data, strm.next_in = 0, strm.avail_in = strm.input.length;
                    do {
                        if (0 === strm.avail_out && (strm.output = new utils.Buf8(chunkSize), strm.next_out = 0, strm.avail_out = chunkSize), status = zlib_deflate.deflate(strm, _mode), status !== Z_STREAM_END && status !== Z_OK) return this.onEnd(status), this.ended = !0, !1;
                        0 !== strm.avail_out && (0 !== strm.avail_in || _mode !== Z_FINISH && _mode !== Z_SYNC_FLUSH) || ("string" === this.options.to ? this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out))) : this.onData(utils.shrinkBuf(strm.output, strm.next_out)))
                    } while ((strm.avail_in > 0 || 0 === strm.avail_out) && status !== Z_STREAM_END);
                    return _mode === Z_FINISH ? (status = zlib_deflate.deflateEnd(this.strm), this.onEnd(status), this.ended = !0, status === Z_OK) : _mode !== Z_SYNC_FLUSH || (this.onEnd(Z_OK), strm.avail_out = 0, !0)
                }, Deflate.prototype.onData = function(chunk) {
                    this.chunks.push(chunk)
                }, Deflate.prototype.onEnd = function(status) {
                    status === Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = utils.flattenChunks(this.chunks)), this.chunks = [], this.err = status, this.msg = this.strm.msg
                }, exports.Deflate = Deflate, exports.deflate = deflate, exports.deflateRaw = deflateRaw, exports.gzip = gzip
            }, {
                "./utils/common": 62,
                "./utils/strings": 63,
                "./zlib/deflate": 67,
                "./zlib/messages": 72,
                "./zlib/zstream": 74
            }],
            61: [function(require, module, exports) {
                "use strict";

                function Inflate(options) {
                    if (!(this instanceof Inflate)) return new Inflate(options);
                    this.options = utils.assign({
                        chunkSize: 16384,
                        windowBits: 0,
                        to: ""
                    }, options || {});
                    var opt = this.options;
                    opt.raw && opt.windowBits >= 0 && opt.windowBits < 16 && (opt.windowBits = -opt.windowBits, 0 === opt.windowBits && (opt.windowBits = -15)), !(opt.windowBits >= 0 && opt.windowBits < 16) || options && options.windowBits || (opt.windowBits += 32), opt.windowBits > 15 && opt.windowBits < 48 && 0 === (15 & opt.windowBits) && (opt.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new ZStream, this.strm.avail_out = 0;
                    var status = zlib_inflate.inflateInit2(this.strm, opt.windowBits);
                    if (status !== c.Z_OK) throw new Error(msg[status]);
                    this.header = new GZheader, zlib_inflate.inflateGetHeader(this.strm, this.header)
                }

                function inflate(input, options) {
                    var inflator = new Inflate(options);
                    if (inflator.push(input, !0), inflator.err) throw inflator.msg || msg[inflator.err];
                    return inflator.result
                }

                function inflateRaw(input, options) {
                    return options = options || {}, options.raw = !0, inflate(input, options)
                }
                var zlib_inflate = require("./zlib/inflate"),
                    utils = require("./utils/common"),
                    strings = require("./utils/strings"),
                    c = require("./zlib/constants"),
                    msg = require("./zlib/messages"),
                    ZStream = require("./zlib/zstream"),
                    GZheader = require("./zlib/gzheader"),
                    toString = Object.prototype.toString;
                Inflate.prototype.push = function(data, mode) {
                    var status, _mode, next_out_utf8, tail, utf8str, dict, strm = this.strm,
                        chunkSize = this.options.chunkSize,
                        dictionary = this.options.dictionary,
                        allowBufError = !1;
                    if (this.ended) return !1;
                    _mode = mode === ~~mode ? mode : mode === !0 ? c.Z_FINISH : c.Z_NO_FLUSH, "string" == typeof data ? strm.input = strings.binstring2buf(data) : "[object ArrayBuffer]" === toString.call(data) ? strm.input = new Uint8Array(data) : strm.input = data, strm.next_in = 0, strm.avail_in = strm.input.length;
                    do {
                        if (0 === strm.avail_out && (strm.output = new utils.Buf8(chunkSize), strm.next_out = 0, strm.avail_out = chunkSize), status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH), status === c.Z_NEED_DICT && dictionary && (dict = "string" == typeof dictionary ? strings.string2buf(dictionary) : "[object ArrayBuffer]" === toString.call(dictionary) ? new Uint8Array(dictionary) : dictionary, status = zlib_inflate.inflateSetDictionary(this.strm, dict)), status === c.Z_BUF_ERROR && allowBufError === !0 && (status = c.Z_OK, allowBufError = !1), status !== c.Z_STREAM_END && status !== c.Z_OK) return this.onEnd(status), this.ended = !0, !1;
                        strm.next_out && (0 !== strm.avail_out && status !== c.Z_STREAM_END && (0 !== strm.avail_in || _mode !== c.Z_FINISH && _mode !== c.Z_SYNC_FLUSH) || ("string" === this.options.to ? (next_out_utf8 = strings.utf8border(strm.output, strm.next_out), tail = strm.next_out - next_out_utf8, utf8str = strings.buf2string(strm.output, next_out_utf8), strm.next_out = tail, strm.avail_out = chunkSize - tail, tail && utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0), this.onData(utf8str)) : this.onData(utils.shrinkBuf(strm.output, strm.next_out)))), 0 === strm.avail_in && 0 === strm.avail_out && (allowBufError = !0)
                    } while ((strm.avail_in > 0 || 0 === strm.avail_out) && status !== c.Z_STREAM_END);
                    return status === c.Z_STREAM_END && (_mode = c.Z_FINISH), _mode === c.Z_FINISH ? (status = zlib_inflate.inflateEnd(this.strm), this.onEnd(status), this.ended = !0, status === c.Z_OK) : _mode !== c.Z_SYNC_FLUSH || (this.onEnd(c.Z_OK), strm.avail_out = 0, !0)
                }, Inflate.prototype.onData = function(chunk) {
                    this.chunks.push(chunk)
                }, Inflate.prototype.onEnd = function(status) {
                    status === c.Z_OK && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = utils.flattenChunks(this.chunks)), this.chunks = [], this.err = status, this.msg = this.strm.msg
                }, exports.Inflate = Inflate, exports.inflate = inflate, exports.inflateRaw = inflateRaw, exports.ungzip = inflate
            }, {
                "./utils/common": 62,
                "./utils/strings": 63,
                "./zlib/constants": 65,
                "./zlib/gzheader": 68,
                "./zlib/inflate": 70,
                "./zlib/messages": 72,
                "./zlib/zstream": 74
            }],
            62: [function(require, module, exports) {
                "use strict";
                var TYPED_OK = "undefined" != typeof Uint8Array && "undefined" != typeof Uint16Array && "undefined" != typeof Int32Array;
                exports.assign = function(obj) {
                    for (var sources = Array.prototype.slice.call(arguments, 1); sources.length;) {
                        var source = sources.shift();
                        if (source) {
                            if ("object" !== _typeof2(source)) throw new TypeError(source + "must be non-object");
                            for (var p in source) source.hasOwnProperty(p) && (obj[p] = source[p])
                        }
                    }
                    return obj
                }, exports.shrinkBuf = function(buf, size) {
                    return buf.length === size ? buf : buf.subarray ? buf.subarray(0, size) : (buf.length = size, buf)
                };
                var fnTyped = {
                        arraySet: function(dest, src, src_offs, len, dest_offs) {
                            if (src.subarray && dest.subarray) return void dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
                            for (var i = 0; i < len; i++) dest[dest_offs + i] = src[src_offs + i]
                        },
                        flattenChunks: function(chunks) {
                            var i, l, len, pos, chunk, result;
                            for (len = 0, i = 0, l = chunks.length; i < l; i++) len += chunks[i].length;
                            for (result = new Uint8Array(len), pos = 0, i = 0, l = chunks.length; i < l; i++) chunk = chunks[i], result.set(chunk, pos), pos += chunk.length;
                            return result
                        }
                    },
                    fnUntyped = {
                        arraySet: function(dest, src, src_offs, len, dest_offs) {
                            for (var i = 0; i < len; i++) dest[dest_offs + i] = src[src_offs + i]
                        },
                        flattenChunks: function(chunks) {
                            return [].concat.apply([], chunks)
                        }
                    };
                exports.setTyped = function(on) {
                    on ? (exports.Buf8 = Uint8Array, exports.Buf16 = Uint16Array, exports.Buf32 = Int32Array, exports.assign(exports, fnTyped)) : (exports.Buf8 = Array, exports.Buf16 = Array, exports.Buf32 = Array, exports.assign(exports, fnUntyped))
                }, exports.setTyped(TYPED_OK)
            }, {}],
            63: [function(require, module, exports) {
                "use strict";

                function buf2binstring(buf, len) {
                    if (len < 65537 && (buf.subarray && STR_APPLY_UIA_OK || !buf.subarray && STR_APPLY_OK)) return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));
                    for (var result = "", i = 0; i < len; i++) result += String.fromCharCode(buf[i]);
                    return result
                }
                var utils = require("./common"),
                    STR_APPLY_OK = !0,
                    STR_APPLY_UIA_OK = !0;
                try {
                    String.fromCharCode.apply(null, [0])
                } catch (__) {
                    STR_APPLY_OK = !1
                }
                try {
                    String.fromCharCode.apply(null, new Uint8Array(1))
                } catch (__) {
                    STR_APPLY_UIA_OK = !1
                }
                for (var _utf8len = new utils.Buf8(256), q = 0; q < 256; q++) _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
                _utf8len[254] = _utf8len[254] = 1, exports.string2buf = function(str) {
                    var buf, c, c2, m_pos, i, str_len = str.length,
                        buf_len = 0;
                    for (m_pos = 0; m_pos < str_len; m_pos++) c = str.charCodeAt(m_pos), 55296 === (64512 & c) && m_pos + 1 < str_len && (c2 = str.charCodeAt(m_pos + 1), 56320 === (64512 & c2) && (c = 65536 + (c - 55296 << 10) + (c2 - 56320), m_pos++)), buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
                    for (buf = new utils.Buf8(buf_len), i = 0, m_pos = 0; i < buf_len; m_pos++) c = str.charCodeAt(m_pos), 55296 === (64512 & c) && m_pos + 1 < str_len && (c2 = str.charCodeAt(m_pos + 1), 56320 === (64512 & c2) && (c = 65536 + (c - 55296 << 10) + (c2 - 56320), m_pos++)), c < 128 ? buf[i++] = c : c < 2048 ? (buf[i++] = 192 | c >>> 6, buf[i++] = 128 | 63 & c) : c < 65536 ? (buf[i++] = 224 | c >>> 12, buf[i++] = 128 | c >>> 6 & 63, buf[i++] = 128 | 63 & c) : (buf[i++] = 240 | c >>> 18, buf[i++] = 128 | c >>> 12 & 63, buf[i++] = 128 | c >>> 6 & 63, buf[i++] = 128 | 63 & c);
                    return buf
                }, exports.buf2binstring = function(buf) {
                    return buf2binstring(buf, buf.length)
                }, exports.binstring2buf = function(str) {
                    for (var buf = new utils.Buf8(str.length), i = 0, len = buf.length; i < len; i++) buf[i] = str.charCodeAt(i);
                    return buf
                }, exports.buf2string = function(buf, max) {
                    var i, out, c, c_len, len = max || buf.length,
                        utf16buf = new Array(2 * len);
                    for (out = 0, i = 0; i < len;)
                        if (c = buf[i++], c < 128) utf16buf[out++] = c;
                        else if (c_len = _utf8len[c], c_len > 4) utf16buf[out++] = 65533, i += c_len - 1;
                    else {
                        for (c &= 2 === c_len ? 31 : 3 === c_len ? 15 : 7; c_len > 1 && i < len;) c = c << 6 | 63 & buf[i++], c_len--;
                        c_len > 1 ? utf16buf[out++] = 65533 : c < 65536 ? utf16buf[out++] = c : (c -= 65536, utf16buf[out++] = 55296 | c >> 10 & 1023, utf16buf[out++] = 56320 | 1023 & c)
                    }
                    return buf2binstring(utf16buf, out)
                }, exports.utf8border = function(buf, max) {
                    var pos;
                    for (max = max || buf.length, max > buf.length && (max = buf.length), pos = max - 1; pos >= 0 && 128 === (192 & buf[pos]);) pos--;
                    return pos < 0 ? max : 0 === pos ? max : pos + _utf8len[buf[pos]] > max ? pos : max
                }
            }, {
                "./common": 62
            }],
            64: [function(require, module, exports) {
                "use strict";

                function adler32(adler, buf, len, pos) {
                    for (var s1 = 65535 & adler | 0, s2 = adler >>> 16 & 65535 | 0, n = 0; 0 !== len;) {
                        n = len > 2e3 ? 2e3 : len, len -= n;
                        do s1 = s1 + buf[pos++] | 0, s2 = s2 + s1 | 0; while (--n);
                        s1 %= 65521, s2 %= 65521
                    }
                    return s1 | s2 << 16 | 0
                }
                module.exports = adler32
            }, {}],
            65: [function(require, module, exports) {
                "use strict";
                module.exports = {
                    Z_NO_FLUSH: 0,
                    Z_PARTIAL_FLUSH: 1,
                    Z_SYNC_FLUSH: 2,
                    Z_FULL_FLUSH: 3,
                    Z_FINISH: 4,
                    Z_BLOCK: 5,
                    Z_TREES: 6,
                    Z_OK: 0,
                    Z_STREAM_END: 1,
                    Z_NEED_DICT: 2,
                    Z_ERRNO: -1,
                    Z_STREAM_ERROR: -2,
                    Z_DATA_ERROR: -3,
                    Z_BUF_ERROR: -5,
                    Z_NO_COMPRESSION: 0,
                    Z_BEST_SPEED: 1,
                    Z_BEST_COMPRESSION: 9,
                    Z_DEFAULT_COMPRESSION: -1,
                    Z_FILTERED: 1,
                    Z_HUFFMAN_ONLY: 2,
                    Z_RLE: 3,
                    Z_FIXED: 4,
                    Z_DEFAULT_STRATEGY: 0,
                    Z_BINARY: 0,
                    Z_TEXT: 1,
                    Z_UNKNOWN: 2,
                    Z_DEFLATED: 8
                }
            }, {}],
            66: [function(require, module, exports) {
                "use strict";

                function makeTable() {
                    for (var c, table = [], n = 0; n < 256; n++) {
                        c = n;
                        for (var k = 0; k < 8; k++) c = 1 & c ? 3988292384 ^ c >>> 1 : c >>> 1;
                        table[n] = c
                    }
                    return table
                }

                function crc32(crc, buf, len, pos) {
                    var t = crcTable,
                        end = pos + len;
                    crc ^= -1;
                    for (var i = pos; i < end; i++) crc = crc >>> 8 ^ t[255 & (crc ^ buf[i])];
                    return crc ^ -1
                }
                var crcTable = makeTable();
                module.exports = crc32
            }, {}],
            67: [function(require, module, exports) {
                "use strict";

                function err(strm, errorCode) {
                    return strm.msg = msg[errorCode], errorCode
                }

                function rank(f) {
                    return (f << 1) - (f > 4 ? 9 : 0)
                }

                function zero(buf) {
                    for (var len = buf.length; --len >= 0;) buf[len] = 0
                }

                function flush_pending(strm) {
                    var s = strm.state,
                        len = s.pending;
                    len > strm.avail_out && (len = strm.avail_out), 0 !== len && (utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out), strm.next_out += len, s.pending_out += len, strm.total_out += len, strm.avail_out -= len, s.pending -= len, 0 === s.pending && (s.pending_out = 0))
                }

                function flush_block_only(s, last) {
                    trees._tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last), s.block_start = s.strstart, flush_pending(s.strm)
                }

                function put_byte(s, b) {
                    s.pending_buf[s.pending++] = b
                }

                function putShortMSB(s, b) {
                    s.pending_buf[s.pending++] = b >>> 8 & 255, s.pending_buf[s.pending++] = 255 & b
                }

                function read_buf(strm, buf, start, size) {
                    var len = strm.avail_in;
                    return len > size && (len = size), 0 === len ? 0 : (strm.avail_in -= len, utils.arraySet(buf, strm.input, strm.next_in, len, start), 1 === strm.state.wrap ? strm.adler = adler32(strm.adler, buf, len, start) : 2 === strm.state.wrap && (strm.adler = crc32(strm.adler, buf, len, start)), strm.next_in += len, strm.total_in += len, len)
                }

                function longest_match(s, cur_match) {
                    var match, len, chain_length = s.max_chain_length,
                        scan = s.strstart,
                        best_len = s.prev_length,
                        nice_match = s.nice_match,
                        limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0,
                        _win = s.window,
                        wmask = s.w_mask,
                        prev = s.prev,
                        strend = s.strstart + MAX_MATCH,
                        scan_end1 = _win[scan + best_len - 1],
                        scan_end = _win[scan + best_len];
                    s.prev_length >= s.good_match && (chain_length >>= 2), nice_match > s.lookahead && (nice_match = s.lookahead);
                    do
                        if (match = cur_match, _win[match + best_len] === scan_end && _win[match + best_len - 1] === scan_end1 && _win[match] === _win[scan] && _win[++match] === _win[scan + 1]) {
                            scan += 2, match++;
                            do; while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
                            if (len = MAX_MATCH - (strend - scan), scan = strend - MAX_MATCH, len > best_len) {
                                if (s.match_start = cur_match, best_len = len, len >= nice_match) break;
                                scan_end1 = _win[scan + best_len - 1], scan_end = _win[scan + best_len]
                            }
                        } while ((cur_match = prev[cur_match & wmask]) > limit && 0 !== --chain_length);
                    return best_len <= s.lookahead ? best_len : s.lookahead
                }

                function fill_window(s) {
                    var p, n, m, more, str, _w_size = s.w_size;
                    do {
                        if (more = s.window_size - s.lookahead - s.strstart, s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
                            utils.arraySet(s.window, s.window, _w_size, _w_size, 0), s.match_start -= _w_size, s.strstart -= _w_size, s.block_start -= _w_size, n = s.hash_size, p = n;
                            do m = s.head[--p], s.head[p] = m >= _w_size ? m - _w_size : 0; while (--n);
                            n = _w_size, p = n;
                            do m = s.prev[--p], s.prev[p] = m >= _w_size ? m - _w_size : 0; while (--n);
                            more += _w_size
                        }
                        if (0 === s.strm.avail_in) break;
                        if (n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more), s.lookahead += n, s.lookahead + s.insert >= MIN_MATCH)
                            for (str = s.strstart - s.insert, s.ins_h = s.window[str], s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask; s.insert && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask, s.prev[str & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = str, str++, s.insert--, !(s.lookahead + s.insert < MIN_MATCH)););
                    } while (s.lookahead < MIN_LOOKAHEAD && 0 !== s.strm.avail_in)
                }

                function deflate_stored(s, flush) {
                    var max_block_size = 65535;
                    for (max_block_size > s.pending_buf_size - 5 && (max_block_size = s.pending_buf_size - 5);;) {
                        if (s.lookahead <= 1) {
                            if (fill_window(s), 0 === s.lookahead && flush === Z_NO_FLUSH) return BS_NEED_MORE;
                            if (0 === s.lookahead) break
                        }
                        s.strstart += s.lookahead, s.lookahead = 0;
                        var max_start = s.block_start + max_block_size;
                        if ((0 === s.strstart || s.strstart >= max_start) && (s.lookahead = s.strstart - max_start, s.strstart = max_start, flush_block_only(s, !1), 0 === s.strm.avail_out)) return BS_NEED_MORE;
                        if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD && (flush_block_only(s, !1), 0 === s.strm.avail_out)) return BS_NEED_MORE
                    }
                    return s.insert = 0, flush === Z_FINISH ? (flush_block_only(s, !0), 0 === s.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE) : s.strstart > s.block_start && (flush_block_only(s, !1), 0 === s.strm.avail_out) ? BS_NEED_MORE : BS_NEED_MORE
                }

                function deflate_fast(s, flush) {
                    for (var hash_head, bflush;;) {
                        if (s.lookahead < MIN_LOOKAHEAD) {
                            if (fill_window(s), s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) return BS_NEED_MORE;
                            if (0 === s.lookahead) break
                        }
                        if (hash_head = 0, s.lookahead >= MIN_MATCH && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask, hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), 0 !== hash_head && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD && (s.match_length = longest_match(s, hash_head)), s.match_length >= MIN_MATCH)
                            if (bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH), s.lookahead -= s.match_length, s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {
                                s.match_length--;
                                do s.strstart++, s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask, hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart; while (0 !== --s.match_length);
                                s.strstart++
                            } else s.strstart += s.match_length, s.match_length = 0, s.ins_h = s.window[s.strstart], s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
                        else bflush = trees._tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, s.strstart++;
                        if (bflush && (flush_block_only(s, !1), 0 === s.strm.avail_out)) return BS_NEED_MORE
                    }
                    return s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1, flush === Z_FINISH ? (flush_block_only(s, !0), 0 === s.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE) : s.last_lit && (flush_block_only(s, !1), 0 === s.strm.avail_out) ? BS_NEED_MORE : BS_BLOCK_DONE
                }

                function deflate_slow(s, flush) {
                    for (var hash_head, bflush, max_insert;;) {
                        if (s.lookahead < MIN_LOOKAHEAD) {
                            if (fill_window(s), s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) return BS_NEED_MORE;
                            if (0 === s.lookahead) break
                        }
                        if (hash_head = 0, s.lookahead >= MIN_MATCH && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask, hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart), s.prev_length = s.match_length, s.prev_match = s.match_start, s.match_length = MIN_MATCH - 1, 0 !== hash_head && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD && (s.match_length = longest_match(s, hash_head), s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096) && (s.match_length = MIN_MATCH - 1)), s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {
                            max_insert = s.strstart + s.lookahead - MIN_MATCH, bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH), s.lookahead -= s.prev_length - 1, s.prev_length -= 2;
                            do ++s.strstart <= max_insert && (s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask, hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = s.strstart); while (0 !== --s.prev_length);
                            if (s.match_available = 0, s.match_length = MIN_MATCH - 1, s.strstart++, bflush && (flush_block_only(s, !1), 0 === s.strm.avail_out)) return BS_NEED_MORE
                        } else if (s.match_available) {
                            if (bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]), bflush && flush_block_only(s, !1), s.strstart++, s.lookahead--, 0 === s.strm.avail_out) return BS_NEED_MORE
                        } else s.match_available = 1, s.strstart++, s.lookahead--
                    }
                    return s.match_available && (bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]), s.match_available = 0), s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1, flush === Z_FINISH ? (flush_block_only(s, !0), 0 === s.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE) : s.last_lit && (flush_block_only(s, !1), 0 === s.strm.avail_out) ? BS_NEED_MORE : BS_BLOCK_DONE
                }

                function deflate_rle(s, flush) {
                    for (var bflush, prev, scan, strend, _win = s.window;;) {
                        if (s.lookahead <= MAX_MATCH) {
                            if (fill_window(s), s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) return BS_NEED_MORE;
                            if (0 === s.lookahead) break
                        }
                        if (s.match_length = 0, s.lookahead >= MIN_MATCH && s.strstart > 0 && (scan = s.strstart - 1, prev = _win[scan], prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan])) {
                            strend = s.strstart + MAX_MATCH;
                            do; while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
                            s.match_length = MAX_MATCH - (strend - scan), s.match_length > s.lookahead && (s.match_length = s.lookahead)
                        }
                        if (s.match_length >= MIN_MATCH ? (bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH), s.lookahead -= s.match_length, s.strstart += s.match_length, s.match_length = 0) : (bflush = trees._tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, s.strstart++), bflush && (flush_block_only(s, !1), 0 === s.strm.avail_out)) return BS_NEED_MORE
                    }
                    return s.insert = 0, flush === Z_FINISH ? (flush_block_only(s, !0), 0 === s.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE) : s.last_lit && (flush_block_only(s, !1), 0 === s.strm.avail_out) ? BS_NEED_MORE : BS_BLOCK_DONE
                }

                function deflate_huff(s, flush) {
                    for (var bflush;;) {
                        if (0 === s.lookahead && (fill_window(s), 0 === s.lookahead)) {
                            if (flush === Z_NO_FLUSH) return BS_NEED_MORE;
                            break
                        }
                        if (s.match_length = 0, bflush = trees._tr_tally(s, 0, s.window[s.strstart]), s.lookahead--, s.strstart++, bflush && (flush_block_only(s, !1), 0 === s.strm.avail_out)) return BS_NEED_MORE
                    }
                    return s.insert = 0, flush === Z_FINISH ? (flush_block_only(s, !0), 0 === s.strm.avail_out ? BS_FINISH_STARTED : BS_FINISH_DONE) : s.last_lit && (flush_block_only(s, !1), 0 === s.strm.avail_out) ? BS_NEED_MORE : BS_BLOCK_DONE
                }

                function Config(good_length, max_lazy, nice_length, max_chain, func) {
                    this.good_length = good_length, this.max_lazy = max_lazy, this.nice_length = nice_length, this.max_chain = max_chain, this.func = func
                }

                function lm_init(s) {
                    s.window_size = 2 * s.w_size, zero(s.head), s.max_lazy_match = configuration_table[s.level].max_lazy, s.good_match = configuration_table[s.level].good_length, s.nice_match = configuration_table[s.level].nice_length, s.max_chain_length = configuration_table[s.level].max_chain, s.strstart = 0, s.block_start = 0, s.lookahead = 0, s.insert = 0, s.match_length = s.prev_length = MIN_MATCH - 1, s.match_available = 0, s.ins_h = 0
                }

                function DeflateState() {
                    this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = Z_DEFLATED, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new utils.Buf16(2 * HEAP_SIZE), this.dyn_dtree = new utils.Buf16(2 * (2 * D_CODES + 1)), this.bl_tree = new utils.Buf16(2 * (2 * BL_CODES + 1)), zero(this.dyn_ltree), zero(this.dyn_dtree), zero(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new utils.Buf16(MAX_BITS + 1), this.heap = new utils.Buf16(2 * L_CODES + 1), zero(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new utils.Buf16(2 * L_CODES + 1), zero(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0
                }

                function deflateResetKeep(strm) {
                    var s;
                    return strm && strm.state ? (strm.total_in = strm.total_out = 0, strm.data_type = Z_UNKNOWN, s = strm.state, s.pending = 0, s.pending_out = 0, s.wrap < 0 && (s.wrap = -s.wrap), s.status = s.wrap ? INIT_STATE : BUSY_STATE, strm.adler = 2 === s.wrap ? 0 : 1, s.last_flush = Z_NO_FLUSH, trees._tr_init(s), Z_OK) : err(strm, Z_STREAM_ERROR)
                }

                function deflateReset(strm) {
                    var ret = deflateResetKeep(strm);
                    return ret === Z_OK && lm_init(strm.state), ret
                }

                function deflateSetHeader(strm, head) {
                    return strm && strm.state ? 2 !== strm.state.wrap ? Z_STREAM_ERROR : (strm.state.gzhead = head, Z_OK) : Z_STREAM_ERROR
                }

                function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
                    if (!strm) return Z_STREAM_ERROR;
                    var wrap = 1;
                    if (level === Z_DEFAULT_COMPRESSION && (level = 6), windowBits < 0 ? (wrap = 0, windowBits = -windowBits) : windowBits > 15 && (wrap = 2, windowBits -= 16), memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) return err(strm, Z_STREAM_ERROR);
                    8 === windowBits && (windowBits = 9);
                    var s = new DeflateState;
                    return strm.state = s, s.strm = strm, s.wrap = wrap, s.gzhead = null, s.w_bits = windowBits, s.w_size = 1 << s.w_bits, s.w_mask = s.w_size - 1, s.hash_bits = memLevel + 7, s.hash_size = 1 << s.hash_bits, s.hash_mask = s.hash_size - 1, s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH), s.window = new utils.Buf8(2 * s.w_size), s.head = new utils.Buf16(s.hash_size), s.prev = new utils.Buf16(s.w_size), s.lit_bufsize = 1 << memLevel + 6, s.pending_buf_size = 4 * s.lit_bufsize, s.pending_buf = new utils.Buf8(s.pending_buf_size), s.d_buf = 1 * s.lit_bufsize, s.l_buf = 3 * s.lit_bufsize, s.level = level, s.strategy = strategy, s.method = method, deflateReset(strm)
                }

                function deflateInit(strm, level) {
                    return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY)
                }

                function deflate(strm, flush) {
                    var old_flush, s, beg, val;
                    if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
                    if (s = strm.state, !strm.output || !strm.input && 0 !== strm.avail_in || s.status === FINISH_STATE && flush !== Z_FINISH) return err(strm, 0 === strm.avail_out ? Z_BUF_ERROR : Z_STREAM_ERROR);
                    if (s.strm = strm, old_flush = s.last_flush, s.last_flush = flush, s.status === INIT_STATE)
                        if (2 === s.wrap) strm.adler = 0, put_byte(s, 31), put_byte(s, 139), put_byte(s, 8), s.gzhead ? (put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (s.gzhead.extra ? 4 : 0) + (s.gzhead.name ? 8 : 0) + (s.gzhead.comment ? 16 : 0)), put_byte(s, 255 & s.gzhead.time), put_byte(s, s.gzhead.time >> 8 & 255), put_byte(s, s.gzhead.time >> 16 & 255), put_byte(s, s.gzhead.time >> 24 & 255), put_byte(s, 9 === s.level ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0), put_byte(s, 255 & s.gzhead.os), s.gzhead.extra && s.gzhead.extra.length && (put_byte(s, 255 & s.gzhead.extra.length), put_byte(s, s.gzhead.extra.length >> 8 & 255)), s.gzhead.hcrc && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0)), s.gzindex = 0, s.status = EXTRA_STATE) : (put_byte(s, 0), put_byte(s, 0), put_byte(s, 0), put_byte(s, 0), put_byte(s, 0), put_byte(s, 9 === s.level ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0), put_byte(s, OS_CODE), s.status = BUSY_STATE);
                        else {
                            var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8,
                                level_flags = -1;
                            level_flags = s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 0 : s.level < 6 ? 1 : 6 === s.level ? 2 : 3, header |= level_flags << 6, 0 !== s.strstart && (header |= PRESET_DICT), header += 31 - header % 31, s.status = BUSY_STATE, putShortMSB(s, header), 0 !== s.strstart && (putShortMSB(s, strm.adler >>> 16), putShortMSB(s, 65535 & strm.adler)), strm.adler = 1
                        } if (s.status === EXTRA_STATE)
                        if (s.gzhead.extra) {
                            for (beg = s.pending; s.gzindex < (65535 & s.gzhead.extra.length) && (s.pending !== s.pending_buf_size || (s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), flush_pending(strm), beg = s.pending, s.pending !== s.pending_buf_size));) put_byte(s, 255 & s.gzhead.extra[s.gzindex]), s.gzindex++;
                            s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), s.gzindex === s.gzhead.extra.length && (s.gzindex = 0, s.status = NAME_STATE)
                        } else s.status = NAME_STATE;
                    if (s.status === NAME_STATE)
                        if (s.gzhead.name) {
                            beg = s.pending;
                            do {
                                if (s.pending === s.pending_buf_size && (s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), flush_pending(strm), beg = s.pending, s.pending === s.pending_buf_size)) {
                                    val = 1;
                                    break
                                }
                                val = s.gzindex < s.gzhead.name.length ? 255 & s.gzhead.name.charCodeAt(s.gzindex++) : 0, put_byte(s, val)
                            } while (0 !== val);
                            s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), 0 === val && (s.gzindex = 0, s.status = COMMENT_STATE)
                        } else s.status = COMMENT_STATE;
                    if (s.status === COMMENT_STATE)
                        if (s.gzhead.comment) {
                            beg = s.pending;
                            do {
                                if (s.pending === s.pending_buf_size && (s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), flush_pending(strm), beg = s.pending, s.pending === s.pending_buf_size)) {
                                    val = 1;
                                    break
                                }
                                val = s.gzindex < s.gzhead.comment.length ? 255 & s.gzhead.comment.charCodeAt(s.gzindex++) : 0, put_byte(s, val)
                            } while (0 !== val);
                            s.gzhead.hcrc && s.pending > beg && (strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)), 0 === val && (s.status = HCRC_STATE)
                        } else s.status = HCRC_STATE;
                    if (s.status === HCRC_STATE && (s.gzhead.hcrc ? (s.pending + 2 > s.pending_buf_size && flush_pending(strm), s.pending + 2 <= s.pending_buf_size && (put_byte(s, 255 & strm.adler), put_byte(s, strm.adler >> 8 & 255), strm.adler = 0, s.status = BUSY_STATE)) : s.status = BUSY_STATE), 0 !== s.pending) {
                        if (flush_pending(strm), 0 === strm.avail_out) return s.last_flush = -1, Z_OK
                    } else if (0 === strm.avail_in && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) return err(strm, Z_BUF_ERROR);
                    if (s.status === FINISH_STATE && 0 !== strm.avail_in) return err(strm, Z_BUF_ERROR);
                    if (0 !== strm.avail_in || 0 !== s.lookahead || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
                        var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);
                        if (bstate !== BS_FINISH_STARTED && bstate !== BS_FINISH_DONE || (s.status = FINISH_STATE), bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) return 0 === strm.avail_out && (s.last_flush = -1), Z_OK;
                        if (bstate === BS_BLOCK_DONE && (flush === Z_PARTIAL_FLUSH ? trees._tr_align(s) : flush !== Z_BLOCK && (trees._tr_stored_block(s, 0, 0, !1), flush === Z_FULL_FLUSH && (zero(s.head), 0 === s.lookahead && (s.strstart = 0, s.block_start = 0, s.insert = 0))), flush_pending(strm), 0 === strm.avail_out)) return s.last_flush = -1, Z_OK
                    }
                    return flush !== Z_FINISH ? Z_OK : s.wrap <= 0 ? Z_STREAM_END : (2 === s.wrap ? (put_byte(s, 255 & strm.adler), put_byte(s, strm.adler >> 8 & 255), put_byte(s, strm.adler >> 16 & 255), put_byte(s, strm.adler >> 24 & 255), put_byte(s, 255 & strm.total_in), put_byte(s, strm.total_in >> 8 & 255), put_byte(s, strm.total_in >> 16 & 255), put_byte(s, strm.total_in >> 24 & 255)) : (putShortMSB(s, strm.adler >>> 16), putShortMSB(s, 65535 & strm.adler)), flush_pending(strm), s.wrap > 0 && (s.wrap = -s.wrap), 0 !== s.pending ? Z_OK : Z_STREAM_END)
                }

                function deflateEnd(strm) {
                    var status;
                    return strm && strm.state ? (status = strm.state.status, status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE ? err(strm, Z_STREAM_ERROR) : (strm.state = null, status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK)) : Z_STREAM_ERROR
                }

                function deflateSetDictionary(strm, dictionary) {
                    var s, str, n, wrap, avail, next, input, tmpDict, dictLength = dictionary.length;
                    if (!strm || !strm.state) return Z_STREAM_ERROR;
                    if (s = strm.state, wrap = s.wrap, 2 === wrap || 1 === wrap && s.status !== INIT_STATE || s.lookahead) return Z_STREAM_ERROR;
                    for (1 === wrap && (strm.adler = adler32(strm.adler, dictionary, dictLength, 0)), s.wrap = 0, dictLength >= s.w_size && (0 === wrap && (zero(s.head), s.strstart = 0, s.block_start = 0, s.insert = 0), tmpDict = new utils.Buf8(s.w_size), utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0), dictionary = tmpDict, dictLength = s.w_size), avail = strm.avail_in, next = strm.next_in, input = strm.input, strm.avail_in = dictLength, strm.next_in = 0, strm.input = dictionary, fill_window(s); s.lookahead >= MIN_MATCH;) {
                        str = s.strstart, n = s.lookahead - (MIN_MATCH - 1);
                        do s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask, s.prev[str & s.w_mask] = s.head[s.ins_h], s.head[s.ins_h] = str, str++; while (--n);
                        s.strstart = str, s.lookahead = MIN_MATCH - 1, fill_window(s)
                    }
                    return s.strstart += s.lookahead, s.block_start = s.strstart, s.insert = s.lookahead, s.lookahead = 0, s.match_length = s.prev_length = MIN_MATCH - 1, s.match_available = 0, strm.next_in = next, strm.input = input, strm.avail_in = avail, s.wrap = wrap, Z_OK
                }
                var configuration_table, utils = require("../utils/common"),
                    trees = require("./trees"),
                    adler32 = require("./adler32"),
                    crc32 = require("./crc32"),
                    msg = require("./messages"),
                    Z_NO_FLUSH = 0,
                    Z_PARTIAL_FLUSH = 1,
                    Z_FULL_FLUSH = 3,
                    Z_FINISH = 4,
                    Z_BLOCK = 5,
                    Z_OK = 0,
                    Z_STREAM_END = 1,
                    Z_STREAM_ERROR = -2,
                    Z_DATA_ERROR = -3,
                    Z_BUF_ERROR = -5,
                    Z_DEFAULT_COMPRESSION = -1,
                    Z_FILTERED = 1,
                    Z_HUFFMAN_ONLY = 2,
                    Z_RLE = 3,
                    Z_FIXED = 4,
                    Z_DEFAULT_STRATEGY = 0,
                    Z_UNKNOWN = 2,
                    Z_DEFLATED = 8,
                    MAX_MEM_LEVEL = 9,
                    MAX_WBITS = 15,
                    DEF_MEM_LEVEL = 8,
                    LENGTH_CODES = 29,
                    LITERALS = 256,
                    L_CODES = LITERALS + 1 + LENGTH_CODES,
                    D_CODES = 30,
                    BL_CODES = 19,
                    HEAP_SIZE = 2 * L_CODES + 1,
                    MAX_BITS = 15,
                    MIN_MATCH = 3,
                    MAX_MATCH = 258,
                    MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1,
                    PRESET_DICT = 32,
                    INIT_STATE = 42,
                    EXTRA_STATE = 69,
                    NAME_STATE = 73,
                    COMMENT_STATE = 91,
                    HCRC_STATE = 103,
                    BUSY_STATE = 113,
                    FINISH_STATE = 666,
                    BS_NEED_MORE = 1,
                    BS_BLOCK_DONE = 2,
                    BS_FINISH_STARTED = 3,
                    BS_FINISH_DONE = 4,
                    OS_CODE = 3;
                configuration_table = [new Config(0, 0, 0, 0, deflate_stored), new Config(4, 4, 8, 4, deflate_fast), new Config(4, 5, 16, 8, deflate_fast), new Config(4, 6, 32, 32, deflate_fast), new Config(4, 4, 16, 16, deflate_slow), new Config(8, 16, 32, 32, deflate_slow), new Config(8, 16, 128, 128, deflate_slow), new Config(8, 32, 128, 256, deflate_slow), new Config(32, 128, 258, 1024, deflate_slow), new Config(32, 258, 258, 4096, deflate_slow)], exports.deflateInit = deflateInit, exports.deflateInit2 = deflateInit2, exports.deflateReset = deflateReset, exports.deflateResetKeep = deflateResetKeep, exports.deflateSetHeader = deflateSetHeader, exports.deflate = deflate, exports.deflateEnd = deflateEnd, exports.deflateSetDictionary = deflateSetDictionary, exports.deflateInfo = "pako deflate (from Nodeca project)"
            }, {
                "../utils/common": 62,
                "./adler32": 64,
                "./crc32": 66,
                "./messages": 72,
                "./trees": 73
            }],
            68: [function(require, module, exports) {
                "use strict";

                function GZheader() {
                    this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1
                }
                module.exports = GZheader
            }, {}],
            69: [function(require, module, exports) {
                "use strict";
                var BAD = 30,
                    TYPE = 12;
                module.exports = function(strm, start) {
                    var state, _in, last, _out, beg, end, dmax, wsize, whave, wnext, s_window, hold, bits, lcode, dcode, lmask, dmask, here, op, len, dist, from, from_source, input, output;
                    state = strm.state, _in = strm.next_in, input = strm.input, last = _in + (strm.avail_in - 5), _out = strm.next_out, output = strm.output, beg = _out - (start - strm.avail_out), end = _out + (strm.avail_out - 257), dmax = state.dmax, wsize = state.wsize, whave = state.whave, wnext = state.wnext, s_window = state.window, hold = state.hold, bits = state.bits, lcode = state.lencode, dcode = state.distcode, lmask = (1 << state.lenbits) - 1, dmask = (1 << state.distbits) - 1;
                    top: do {
                        bits < 15 && (hold += input[_in++] << bits, bits += 8, hold += input[_in++] << bits, bits += 8), here = lcode[hold & lmask];
                        dolen: for (;;) {
                            if (op = here >>> 24, hold >>>= op, bits -= op, op = here >>> 16 & 255, 0 === op) output[_out++] = 65535 & here;
                            else {
                                if (!(16 & op)) {
                                    if (0 === (64 & op)) {
                                        here = lcode[(65535 & here) + (hold & (1 << op) - 1)];
                                        continue dolen
                                    }
                                    if (32 & op) {
                                        state.mode = TYPE;
                                        break top
                                    }
                                    strm.msg = "invalid literal/length code", state.mode = BAD;
                                    break top
                                }
                                len = 65535 & here, op &= 15, op && (bits < op && (hold += input[_in++] << bits, bits += 8), len += hold & (1 << op) - 1, hold >>>= op, bits -= op), bits < 15 && (hold += input[_in++] << bits, bits += 8, hold += input[_in++] << bits, bits += 8), here = dcode[hold & dmask];
                                dodist: for (;;) {
                                    if (op = here >>> 24, hold >>>= op, bits -= op, op = here >>> 16 & 255, !(16 & op)) {
                                        if (0 === (64 & op)) {
                                            here = dcode[(65535 & here) + (hold & (1 << op) - 1)];
                                            continue dodist
                                        }
                                        strm.msg = "invalid distance code", state.mode = BAD;
                                        break top
                                    }
                                    if (dist = 65535 & here, op &= 15, bits < op && (hold += input[_in++] << bits, bits += 8, bits < op && (hold += input[_in++] << bits, bits += 8)), dist += hold & (1 << op) - 1, dist > dmax) {
                                        strm.msg = "invalid distance too far back", state.mode = BAD;
                                        break top
                                    }
                                    if (hold >>>= op, bits -= op, op = _out - beg, dist > op) {
                                        if (op = dist - op, op > whave && state.sane) {
                                            strm.msg = "invalid distance too far back", state.mode = BAD;
                                            break top
                                        }
                                        if (from = 0, from_source = s_window, 0 === wnext) {
                                            if (from += wsize - op, op < len) {
                                                len -= op;
                                                do output[_out++] = s_window[from++]; while (--op);
                                                from = _out - dist, from_source = output
                                            }
                                        } else if (wnext < op) {
                                            if (from += wsize + wnext - op, op -= wnext, op < len) {
                                                len -= op;
                                                do output[_out++] = s_window[from++]; while (--op);
                                                if (from = 0, wnext < len) {
                                                    op = wnext, len -= op;
                                                    do output[_out++] = s_window[from++]; while (--op);
                                                    from = _out - dist, from_source = output
                                                }
                                            }
                                        } else if (from += wnext - op, op < len) {
                                            len -= op;
                                            do output[_out++] = s_window[from++]; while (--op);
                                            from = _out - dist, from_source = output
                                        }
                                        for (; len > 2;) output[_out++] = from_source[from++], output[_out++] = from_source[from++], output[_out++] = from_source[from++], len -= 3;
                                        len && (output[_out++] = from_source[from++], len > 1 && (output[_out++] = from_source[from++]))
                                    } else {
                                        from = _out - dist;
                                        do output[_out++] = output[from++], output[_out++] = output[from++], output[_out++] = output[from++], len -= 3; while (len > 2);
                                        len && (output[_out++] = output[from++], len > 1 && (output[_out++] = output[from++]))
                                    }
                                    break
                                }
                            }
                            break
                        }
                    } while (_in < last && _out < end);
                    len = bits >> 3, _in -= len, bits -= len << 3, hold &= (1 << bits) - 1, strm.next_in = _in, strm.next_out = _out, strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last), strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end), state.hold = hold, state.bits = bits
                }
            }, {}],
            70: [function(require, module, exports) {
                "use strict";

                function zswap32(q) {
                    return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((65280 & q) << 8) + ((255 & q) << 24)
                }

                function InflateState() {
                    this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new utils.Buf16(320), this.work = new utils.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0
                }

                function inflateResetKeep(strm) {
                    var state;
                    return strm && strm.state ? (state = strm.state, strm.total_in = strm.total_out = state.total = 0, strm.msg = "", state.wrap && (strm.adler = 1 & state.wrap), state.mode = HEAD, state.last = 0, state.havedict = 0, state.dmax = 32768, state.head = null, state.hold = 0, state.bits = 0, state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS), state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS), state.sane = 1, state.back = -1, Z_OK) : Z_STREAM_ERROR
                }

                function inflateReset(strm) {
                    var state;
                    return strm && strm.state ? (state = strm.state, state.wsize = 0, state.whave = 0, state.wnext = 0, inflateResetKeep(strm)) : Z_STREAM_ERROR
                }

                function inflateReset2(strm, windowBits) {
                    var wrap, state;
                    return strm && strm.state ? (state = strm.state, windowBits < 0 ? (wrap = 0, windowBits = -windowBits) : (wrap = (windowBits >> 4) + 1, windowBits < 48 && (windowBits &= 15)), windowBits && (windowBits < 8 || windowBits > 15) ? Z_STREAM_ERROR : (null !== state.window && state.wbits !== windowBits && (state.window = null), state.wrap = wrap, state.wbits = windowBits, inflateReset(strm))) : Z_STREAM_ERROR
                }

                function inflateInit2(strm, windowBits) {
                    var ret, state;
                    return strm ? (state = new InflateState, strm.state = state, state.window = null, ret = inflateReset2(strm, windowBits), ret !== Z_OK && (strm.state = null), ret) : Z_STREAM_ERROR
                }

                function inflateInit(strm) {
                    return inflateInit2(strm, DEF_WBITS)
                }

                function fixedtables(state) {
                    if (virgin) {
                        var sym;
                        for (lenfix = new utils.Buf32(512), distfix = new utils.Buf32(32), sym = 0; sym < 144;) state.lens[sym++] = 8;
                        for (; sym < 256;) state.lens[sym++] = 9;
                        for (; sym < 280;) state.lens[sym++] = 7;
                        for (; sym < 288;) state.lens[sym++] = 8;
                        for (inflate_table(LENS, state.lens, 0, 288, lenfix, 0, state.work, {
                                bits: 9
                            }), sym = 0; sym < 32;) state.lens[sym++] = 5;
                        inflate_table(DISTS, state.lens, 0, 32, distfix, 0, state.work, {
                            bits: 5
                        }), virgin = !1
                    }
                    state.lencode = lenfix, state.lenbits = 9, state.distcode = distfix, state.distbits = 5
                }

                function updatewindow(strm, src, end, copy) {
                    var dist, state = strm.state;
                    return null === state.window && (state.wsize = 1 << state.wbits, state.wnext = 0, state.whave = 0, state.window = new utils.Buf8(state.wsize)), copy >= state.wsize ? (utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0), state.wnext = 0, state.whave = state.wsize) : (dist = state.wsize - state.wnext, dist > copy && (dist = copy), utils.arraySet(state.window, src, end - copy, dist, state.wnext), copy -= dist, copy ? (utils.arraySet(state.window, src, end - copy, copy, 0), state.wnext = copy, state.whave = state.wsize) : (state.wnext += dist, state.wnext === state.wsize && (state.wnext = 0), state.whave < state.wsize && (state.whave += dist))), 0
                }

                function inflate(strm, flush) {
                    var state, input, output, next, put, have, left, hold, bits, _in, _out, copy, from, from_source, here_bits, here_op, here_val, last_bits, last_op, last_val, len, ret, opts, n, here = 0,
                        hbuf = new utils.Buf8(4),
                        order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
                    if (!strm || !strm.state || !strm.output || !strm.input && 0 !== strm.avail_in) return Z_STREAM_ERROR;
                    state = strm.state, state.mode === TYPE && (state.mode = TYPEDO), put = strm.next_out, output = strm.output, left = strm.avail_out, next = strm.next_in, input = strm.input, have = strm.avail_in, hold = state.hold, bits = state.bits, _in = have, _out = left, ret = Z_OK;
                    inf_leave: for (;;) switch (state.mode) {
                        case HEAD:
                            if (0 === state.wrap) {
                                state.mode = TYPEDO;
                                break
                            }
                            for (; bits < 16;) {
                                if (0 === have) break inf_leave;
                                have--, hold += input[next++] << bits, bits += 8
                            }
                            if (2 & state.wrap && 35615 === hold) {
                                state.check = 0, hbuf[0] = 255 & hold, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0), hold = 0, bits = 0, state.mode = FLAGS;
                                break
                            }
                            if (state.flags = 0, state.head && (state.head.done = !1), !(1 & state.wrap) || (((255 & hold) << 8) + (hold >> 8)) % 31) {
                                strm.msg = "incorrect header check", state.mode = BAD;
                                break
                            }
                            if ((15 & hold) !== Z_DEFLATED) {
                                strm.msg = "unknown compression method", state.mode = BAD;
                                break
                            }
                            if (hold >>>= 4, bits -= 4, len = (15 & hold) + 8, 0 === state.wbits) state.wbits = len;
                            else if (len > state.wbits) {
                                strm.msg = "invalid window size", state.mode = BAD;
                                break
                            }
                            state.dmax = 1 << len, strm.adler = state.check = 1, state.mode = 512 & hold ? DICTID : TYPE, hold = 0, bits = 0;
                            break;
                        case FLAGS:
                            for (; bits < 16;) {
                                if (0 === have) break inf_leave;
                                have--, hold += input[next++] << bits, bits += 8
                            }
                            if (state.flags = hold, (255 & state.flags) !== Z_DEFLATED) {
                                strm.msg = "unknown compression method", state.mode = BAD;
                                break
                            }
                            if (57344 & state.flags) {
                                strm.msg = "unknown header flags set", state.mode = BAD;
                                break
                            }
                            state.head && (state.head.text = hold >> 8 & 1), 512 & state.flags && (hbuf[0] = 255 & hold, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0)), hold = 0, bits = 0, state.mode = TIME;
                        case TIME:
                            for (; bits < 32;) {
                                if (0 === have) break inf_leave;
                                have--, hold += input[next++] << bits, bits += 8
                            }
                            state.head && (state.head.time = hold), 512 & state.flags && (hbuf[0] = 255 & hold, hbuf[1] = hold >>> 8 & 255, hbuf[2] = hold >>> 16 & 255, hbuf[3] = hold >>> 24 & 255, state.check = crc32(state.check, hbuf, 4, 0)), hold = 0, bits = 0, state.mode = OS;
                        case OS:
                            for (; bits < 16;) {
                                if (0 === have) break inf_leave;
                                have--, hold += input[next++] << bits, bits += 8
                            }
                            state.head && (state.head.xflags = 255 & hold, state.head.os = hold >> 8), 512 & state.flags && (hbuf[0] = 255 & hold, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0)), hold = 0, bits = 0, state.mode = EXLEN;
                        case EXLEN:
                            if (1024 & state.flags) {
                                for (; bits < 16;) {
                                    if (0 === have) break inf_leave;
                                    have--, hold += input[next++] << bits, bits += 8
                                }
                                state.length = hold, state.head && (state.head.extra_len = hold), 512 & state.flags && (hbuf[0] = 255 & hold, hbuf[1] = hold >>> 8 & 255, state.check = crc32(state.check, hbuf, 2, 0)), hold = 0, bits = 0
                            } else state.head && (state.head.extra = null);
                            state.mode = EXTRA;
                        case EXTRA:
                            if (1024 & state.flags && (copy = state.length, copy > have && (copy = have), copy && (state.head && (len = state.head.extra_len - state.length, state.head.extra || (state.head.extra = new Array(state.head.extra_len)), utils.arraySet(state.head.extra, input, next, copy, len)), 512 & state.flags && (state.check = crc32(state.check, input, copy, next)), have -= copy, next += copy, state.length -= copy), state.length)) break inf_leave;
                            state.length = 0, state.mode = NAME;
                        case NAME:
                            if (2048 & state.flags) {
                                if (0 === have) break inf_leave;
                                copy = 0;
                                do len = input[next + copy++], state.head && len && state.length < 65536 && (state.head.name += String.fromCharCode(len)); while (len && copy < have);
                                if (512 & state.flags && (state.check = crc32(state.check, input, copy, next)), have -= copy, next += copy, len) break inf_leave
                            } else state.head && (state.head.name = null);
                            state.length = 0, state.mode = COMMENT;
                        case COMMENT:
                            if (4096 & state.flags) {
                                if (0 === have) break inf_leave;
                                copy = 0;
                                do len = input[next + copy++], state.head && len && state.length < 65536 && (state.head.comment += String.fromCharCode(len)); while (len && copy < have);
                                if (512 & state.flags && (state.check = crc32(state.check, input, copy, next)), have -= copy, next += copy, len) break inf_leave
                            } else state.head && (state.head.comment = null);
                            state.mode = HCRC;
                        case HCRC:
                            if (512 & state.flags) {
                                for (; bits < 16;) {
                                    if (0 === have) break inf_leave;
                                    have--, hold += input[next++] << bits, bits += 8
                                }
                                if (hold !== (65535 & state.check)) {
                                    strm.msg = "header crc mismatch", state.mode = BAD;
                                    break
                                }
                                hold = 0, bits = 0
                            }
                            state.head && (state.head.hcrc = state.flags >> 9 & 1, state.head.done = !0), strm.adler = state.check = 0, state.mode = TYPE;
                            break;
                        case DICTID:
                            for (; bits < 32;) {
                                if (0 === have) break inf_leave;
                                have--, hold += input[next++] << bits, bits += 8
                            }
                            strm.adler = state.check = zswap32(hold), hold = 0, bits = 0, state.mode = DICT;
                        case DICT:
                            if (0 === state.havedict) return strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, state.hold = hold, state.bits = bits, Z_NEED_DICT;
                            strm.adler = state.check = 1, state.mode = TYPE;
                        case TYPE:
                            if (flush === Z_BLOCK || flush === Z_TREES) break inf_leave;
                        case TYPEDO:
                            if (state.last) {
                                hold >>>= 7 & bits, bits -= 7 & bits, state.mode = CHECK;
                                break
                            }
                            for (; bits < 3;) {
                                if (0 === have) break inf_leave;
                                have--, hold += input[next++] << bits, bits += 8
                            }
                            switch (state.last = 1 & hold, hold >>>= 1, bits -= 1, 3 & hold) {
                                case 0:
                                    state.mode = STORED;
                                    break;
                                case 1:
                                    if (fixedtables(state), state.mode = LEN_, flush === Z_TREES) {
                                        hold >>>= 2, bits -= 2;
                                        break inf_leave
                                    }
                                    break;
                                case 2:
                                    state.mode = TABLE;
                                    break;
                                case 3:
                                    strm.msg = "invalid block type", state.mode = BAD
                            }
                            hold >>>= 2, bits -= 2;
                            break;
                        case STORED:
                            for (hold >>>= 7 & bits, bits -= 7 & bits; bits < 32;) {
                                if (0 === have) break inf_leave;
                                have--, hold += input[next++] << bits, bits += 8
                            }
                            if ((65535 & hold) !== (hold >>> 16 ^ 65535)) {
                                strm.msg = "invalid stored block lengths", state.mode = BAD;
                                break
                            }
                            if (state.length = 65535 & hold, hold = 0, bits = 0, state.mode = COPY_, flush === Z_TREES) break inf_leave;
                        case COPY_:
                            state.mode = COPY;
                        case COPY:
                            if (copy = state.length) {
                                if (copy > have && (copy = have), copy > left && (copy = left), 0 === copy) break inf_leave;
                                utils.arraySet(output, input, next, copy, put), have -= copy, next += copy, left -= copy, put += copy, state.length -= copy;
                                break
                            }
                            state.mode = TYPE;
                            break;
                        case TABLE:
                            for (; bits < 14;) {
                                if (0 === have) break inf_leave;
                                have--, hold += input[next++] << bits, bits += 8
                            }
                            if (state.nlen = (31 & hold) + 257, hold >>>= 5, bits -= 5, state.ndist = (31 & hold) + 1, hold >>>= 5, bits -= 5, state.ncode = (15 & hold) + 4, hold >>>= 4, bits -= 4, state.nlen > 286 || state.ndist > 30) {
                                strm.msg = "too many length or distance symbols", state.mode = BAD;
                                break
                            }
                            state.have = 0, state.mode = LENLENS;
                        case LENLENS:
                            for (; state.have < state.ncode;) {
                                for (; bits < 3;) {
                                    if (0 === have) break inf_leave;
                                    have--, hold += input[next++] << bits, bits += 8
                                }
                                state.lens[order[state.have++]] = 7 & hold, hold >>>= 3, bits -= 3
                            }
                            for (; state.have < 19;) state.lens[order[state.have++]] = 0;
                            if (state.lencode = state.lendyn, state.lenbits = 7, opts = {
                                    bits: state.lenbits
                                }, ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts), state.lenbits = opts.bits, ret) {
                                strm.msg = "invalid code lengths set", state.mode = BAD;
                                break
                            }
                            state.have = 0, state.mode = CODELENS;
                        case CODELENS:
                            for (; state.have < state.nlen + state.ndist;) {
                                for (; here = state.lencode[hold & (1 << state.lenbits) - 1], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = 65535 & here, !(here_bits <= bits);) {
                                    if (0 === have) break inf_leave;
                                    have--, hold += input[next++] << bits, bits += 8
                                }
                                if (here_val < 16) hold >>>= here_bits, bits -= here_bits, state.lens[state.have++] = here_val;
                                else {
                                    if (16 === here_val) {
                                        for (n = here_bits + 2; bits < n;) {
                                            if (0 === have) break inf_leave;
                                            have--, hold += input[next++] << bits, bits += 8
                                        }
                                        if (hold >>>= here_bits, bits -= here_bits, 0 === state.have) {
                                            strm.msg = "invalid bit length repeat", state.mode = BAD;
                                            break
                                        }
                                        len = state.lens[state.have - 1], copy = 3 + (3 & hold), hold >>>= 2, bits -= 2
                                    } else if (17 === here_val) {
                                        for (n = here_bits + 3; bits < n;) {
                                            if (0 === have) break inf_leave;
                                            have--, hold += input[next++] << bits, bits += 8
                                        }
                                        hold >>>= here_bits, bits -= here_bits, len = 0, copy = 3 + (7 & hold), hold >>>= 3, bits -= 3
                                    } else {
                                        for (n = here_bits + 7; bits < n;) {
                                            if (0 === have) break inf_leave;
                                            have--, hold += input[next++] << bits, bits += 8
                                        }
                                        hold >>>= here_bits, bits -= here_bits, len = 0, copy = 11 + (127 & hold), hold >>>= 7, bits -= 7
                                    }
                                    if (state.have + copy > state.nlen + state.ndist) {
                                        strm.msg = "invalid bit length repeat", state.mode = BAD;
                                        break
                                    }
                                    for (; copy--;) state.lens[state.have++] = len
                                }
                            }
                            if (state.mode === BAD) break;
                            if (0 === state.lens[256]) {
                                strm.msg = "invalid code -- missing end-of-block", state.mode = BAD;
                                break
                            }
                            if (state.lenbits = 9, opts = {
                                    bits: state.lenbits
                                }, ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts), state.lenbits = opts.bits, ret) {
                                strm.msg = "invalid literal/lengths set", state.mode = BAD;
                                break
                            }
                            if (state.distbits = 6, state.distcode = state.distdyn, opts = {
                                    bits: state.distbits
                                }, ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts), state.distbits = opts.bits, ret) {
                                strm.msg = "invalid distances set", state.mode = BAD;
                                break
                            }
                            if (state.mode = LEN_, flush === Z_TREES) break inf_leave;
                        case LEN_:
                            state.mode = LEN;
                        case LEN:
                            if (have >= 6 && left >= 258) {
                                strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, state.hold = hold, state.bits = bits, inflate_fast(strm, _out), put = strm.next_out, output = strm.output, left = strm.avail_out, next = strm.next_in, input = strm.input, have = strm.avail_in, hold = state.hold, bits = state.bits, state.mode === TYPE && (state.back = -1);
                                break
                            }
                            for (state.back = 0; here = state.lencode[hold & (1 << state.lenbits) - 1], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = 65535 & here, !(here_bits <= bits);) {
                                if (0 === have) break inf_leave;
                                have--, hold += input[next++] << bits, bits += 8
                            }
                            if (here_op && 0 === (240 & here_op)) {
                                for (last_bits = here_bits, last_op = here_op, last_val = here_val; here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = 65535 & here, !(last_bits + here_bits <= bits);) {
                                    if (0 === have) break inf_leave;
                                    have--, hold += input[next++] << bits, bits += 8
                                }
                                hold >>>= last_bits, bits -= last_bits, state.back += last_bits
                            }
                            if (hold >>>= here_bits, bits -= here_bits, state.back += here_bits, state.length = here_val, 0 === here_op) {
                                state.mode = LIT;
                                break
                            }
                            if (32 & here_op) {
                                state.back = -1, state.mode = TYPE;
                                break
                            }
                            if (64 & here_op) {
                                strm.msg = "invalid literal/length code", state.mode = BAD;
                                break
                            }
                            state.extra = 15 & here_op, state.mode = LENEXT;
                        case LENEXT:
                            if (state.extra) {
                                for (n = state.extra; bits < n;) {
                                    if (0 === have) break inf_leave;
                                    have--, hold += input[next++] << bits, bits += 8
                                }
                                state.length += hold & (1 << state.extra) - 1, hold >>>= state.extra, bits -= state.extra, state.back += state.extra
                            }
                            state.was = state.length, state.mode = DIST;
                        case DIST:
                            for (; here = state.distcode[hold & (1 << state.distbits) - 1], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = 65535 & here, !(here_bits <= bits);) {
                                if (0 === have) break inf_leave;
                                have--, hold += input[next++] << bits, bits += 8
                            }
                            if (0 === (240 & here_op)) {
                                for (last_bits = here_bits, last_op = here_op, last_val = here_val; here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)], here_bits = here >>> 24, here_op = here >>> 16 & 255, here_val = 65535 & here, !(last_bits + here_bits <= bits);) {
                                    if (0 === have) break inf_leave;
                                    have--, hold += input[next++] << bits, bits += 8
                                }
                                hold >>>= last_bits, bits -= last_bits, state.back += last_bits
                            }
                            if (hold >>>= here_bits, bits -= here_bits, state.back += here_bits, 64 & here_op) {
                                strm.msg = "invalid distance code", state.mode = BAD;
                                break
                            }
                            state.offset = here_val, state.extra = 15 & here_op, state.mode = DISTEXT;
                        case DISTEXT:
                            if (state.extra) {
                                for (n = state.extra; bits < n;) {
                                    if (0 === have) break inf_leave;
                                    have--, hold += input[next++] << bits, bits += 8
                                }
                                state.offset += hold & (1 << state.extra) - 1, hold >>>= state.extra, bits -= state.extra, state.back += state.extra
                            }
                            if (state.offset > state.dmax) {
                                strm.msg = "invalid distance too far back", state.mode = BAD;
                                break
                            }
                            state.mode = MATCH;
                        case MATCH:
                            if (0 === left) break inf_leave;
                            if (copy = _out - left, state.offset > copy) {
                                if (copy = state.offset - copy, copy > state.whave && state.sane) {
                                    strm.msg = "invalid distance too far back", state.mode = BAD;
                                    break
                                }
                                copy > state.wnext ? (copy -= state.wnext, from = state.wsize - copy) : from = state.wnext - copy, copy > state.length && (copy = state.length), from_source = state.window
                            } else from_source = output, from = put - state.offset, copy = state.length;
                            copy > left && (copy = left), left -= copy, state.length -= copy;
                            do output[put++] = from_source[from++]; while (--copy);
                            0 === state.length && (state.mode = LEN);
                            break;
                        case LIT:
                            if (0 === left) break inf_leave;
                            output[put++] = state.length, left--, state.mode = LEN;
                            break;
                        case CHECK:
                            if (state.wrap) {
                                for (; bits < 32;) {
                                    if (0 === have) break inf_leave;
                                    have--, hold |= input[next++] << bits, bits += 8
                                }
                                if (_out -= left, strm.total_out += _out, state.total += _out, _out && (strm.adler = state.check = state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out)), _out = left, (state.flags ? hold : zswap32(hold)) !== state.check) {
                                    strm.msg = "incorrect data check", state.mode = BAD;
                                    break
                                }
                                hold = 0, bits = 0
                            }
                            state.mode = LENGTH;
                        case LENGTH:
                            if (state.wrap && state.flags) {
                                for (; bits < 32;) {
                                    if (0 === have) break inf_leave;
                                    have--, hold += input[next++] << bits, bits += 8
                                }
                                if (hold !== (4294967295 & state.total)) {
                                    strm.msg = "incorrect length check", state.mode = BAD;
                                    break
                                }
                                hold = 0, bits = 0
                            }
                            state.mode = DONE;
                        case DONE:
                            ret = Z_STREAM_END;
                            break inf_leave;
                        case BAD:
                            ret = Z_DATA_ERROR;
                            break inf_leave;
                        case MEM:
                            return Z_MEM_ERROR;
                        case SYNC:
                        default:
                            return Z_STREAM_ERROR
                    }
                    return strm.next_out = put, strm.avail_out = left, strm.next_in = next, strm.avail_in = have, state.hold = hold, state.bits = bits, (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH)) && updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out) ? (state.mode = MEM, Z_MEM_ERROR) : (_in -= strm.avail_in, _out -= strm.avail_out, strm.total_in += _in, strm.total_out += _out, state.total += _out, state.wrap && _out && (strm.adler = state.check = state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out)), strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0), (0 === _in && 0 === _out || flush === Z_FINISH) && ret === Z_OK && (ret = Z_BUF_ERROR), ret)
                }

                function inflateEnd(strm) {
                    if (!strm || !strm.state) return Z_STREAM_ERROR;
                    var state = strm.state;
                    return state.window && (state.window = null), strm.state = null, Z_OK
                }

                function inflateGetHeader(strm, head) {
                    var state;
                    return strm && strm.state ? (state = strm.state, 0 === (2 & state.wrap) ? Z_STREAM_ERROR : (state.head = head, head.done = !1, Z_OK)) : Z_STREAM_ERROR
                }

                function inflateSetDictionary(strm, dictionary) {
                    var state, dictid, ret, dictLength = dictionary.length;
                    return strm && strm.state ? (state = strm.state, 0 !== state.wrap && state.mode !== DICT ? Z_STREAM_ERROR : state.mode === DICT && (dictid = 1, dictid = adler32(dictid, dictionary, dictLength, 0), dictid !== state.check) ? Z_DATA_ERROR : (ret = updatewindow(strm, dictionary, dictLength, dictLength)) ? (state.mode = MEM, Z_MEM_ERROR) : (state.havedict = 1, Z_OK)) : Z_STREAM_ERROR
                }
                var lenfix, distfix, utils = require("../utils/common"),
                    adler32 = require("./adler32"),
                    crc32 = require("./crc32"),
                    inflate_fast = require("./inffast"),
                    inflate_table = require("./inftrees"),
                    CODES = 0,
                    LENS = 1,
                    DISTS = 2,
                    Z_FINISH = 4,
                    Z_BLOCK = 5,
                    Z_TREES = 6,
                    Z_OK = 0,
                    Z_STREAM_END = 1,
                    Z_NEED_DICT = 2,
                    Z_STREAM_ERROR = -2,
                    Z_DATA_ERROR = -3,
                    Z_MEM_ERROR = -4,
                    Z_BUF_ERROR = -5,
                    Z_DEFLATED = 8,
                    HEAD = 1,
                    FLAGS = 2,
                    TIME = 3,
                    OS = 4,
                    EXLEN = 5,
                    EXTRA = 6,
                    NAME = 7,
                    COMMENT = 8,
                    HCRC = 9,
                    DICTID = 10,
                    DICT = 11,
                    TYPE = 12,
                    TYPEDO = 13,
                    STORED = 14,
                    COPY_ = 15,
                    COPY = 16,
                    TABLE = 17,
                    LENLENS = 18,
                    CODELENS = 19,
                    LEN_ = 20,
                    LEN = 21,
                    LENEXT = 22,
                    DIST = 23,
                    DISTEXT = 24,
                    MATCH = 25,
                    LIT = 26,
                    CHECK = 27,
                    LENGTH = 28,
                    DONE = 29,
                    BAD = 30,
                    MEM = 31,
                    SYNC = 32,
                    ENOUGH_LENS = 852,
                    ENOUGH_DISTS = 592,
                    MAX_WBITS = 15,
                    DEF_WBITS = MAX_WBITS,
                    virgin = !0;
                exports.inflateReset = inflateReset, exports.inflateReset2 = inflateReset2, exports.inflateResetKeep = inflateResetKeep, exports.inflateInit = inflateInit, exports.inflateInit2 = inflateInit2, exports.inflate = inflate, exports.inflateEnd = inflateEnd, exports.inflateGetHeader = inflateGetHeader, exports.inflateSetDictionary = inflateSetDictionary, exports.inflateInfo = "pako inflate (from Nodeca project)"
            }, {
                "../utils/common": 62,
                "./adler32": 64,
                "./crc32": 66,
                "./inffast": 69,
                "./inftrees": 71
            }],
            71: [function(require, module, exports) {
                "use strict";
                var utils = require("../utils/common"),
                    MAXBITS = 15,
                    ENOUGH_LENS = 852,
                    ENOUGH_DISTS = 592,
                    CODES = 0,
                    LENS = 1,
                    DISTS = 2,
                    lbase = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0],
                    lext = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78],
                    dbase = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0],
                    dext = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
                module.exports = function(type, lens, lens_index, codes, table, table_index, work, opts) {
                    var incr, fill, low, mask, next, end, here_bits, here_op, here_val, bits = opts.bits,
                        len = 0,
                        sym = 0,
                        min = 0,
                        max = 0,
                        root = 0,
                        curr = 0,
                        drop = 0,
                        left = 0,
                        used = 0,
                        huff = 0,
                        base = null,
                        base_index = 0,
                        count = new utils.Buf16(MAXBITS + 1),
                        offs = new utils.Buf16(MAXBITS + 1),
                        extra = null,
                        extra_index = 0;
                    for (len = 0; len <= MAXBITS; len++) count[len] = 0;
                    for (sym = 0; sym < codes; sym++) count[lens[lens_index + sym]]++;
                    for (root = bits, max = MAXBITS; max >= 1 && 0 === count[max]; max--);
                    if (root > max && (root = max), 0 === max) return table[table_index++] = 20971520, table[table_index++] = 20971520, opts.bits = 1, 0;
                    for (min = 1; min < max && 0 === count[min]; min++);
                    for (root < min && (root = min), left = 1, len = 1; len <= MAXBITS; len++)
                        if (left <<= 1, left -= count[len], left < 0) return -1;
                    if (left > 0 && (type === CODES || 1 !== max)) return -1;
                    for (offs[1] = 0, len = 1; len < MAXBITS; len++) offs[len + 1] = offs[len] + count[len];
                    for (sym = 0; sym < codes; sym++) 0 !== lens[lens_index + sym] && (work[offs[lens[lens_index + sym]]++] = sym);
                    if (type === CODES ? (base = extra = work, end = 19) : type === LENS ? (base = lbase, base_index -= 257, extra = lext, extra_index -= 257, end = 256) : (base = dbase, extra = dext, end = -1), huff = 0, sym = 0, len = min, next = table_index, curr = root, drop = 0, low = -1, used = 1 << root, mask = used - 1, type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) return 1;
                    for (;;) {
                        here_bits = len - drop, work[sym] < end ? (here_op = 0, here_val = work[sym]) : work[sym] > end ? (here_op = extra[extra_index + work[sym]], here_val = base[base_index + work[sym]]) : (here_op = 96, here_val = 0), incr = 1 << len - drop, fill = 1 << curr, min = fill;
                        do fill -= incr, table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0; while (0 !== fill);
                        for (incr = 1 << len - 1; huff & incr;) incr >>= 1;
                        if (0 !== incr ? (huff &= incr - 1, huff += incr) : huff = 0, sym++, 0 === --count[len]) {
                            if (len === max) break;
                            len = lens[lens_index + work[sym]]
                        }
                        if (len > root && (huff & mask) !== low) {
                            for (0 === drop && (drop = root), next += min, curr = len - drop, left = 1 << curr; curr + drop < max && (left -= count[curr + drop], !(left <= 0));) curr++, left <<= 1;
                            if (used += 1 << curr, type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) return 1;
                            low = huff & mask, table[low] = root << 24 | curr << 16 | next - table_index | 0
                        }
                    }
                    return 0 !== huff && (table[next + huff] = len - drop << 24 | 64 << 16 | 0), opts.bits = root, 0
                }
            }, {
                "../utils/common": 62
            }],
            72: [function(require, module, exports) {
                "use strict";
                module.exports = {
                    2: "need dictionary",
                    1: "stream end",
                    0: "",
                    "-1": "file error",
                    "-2": "stream error",
                    "-3": "data error",
                    "-4": "insufficient memory",
                    "-5": "buffer error",
                    "-6": "incompatible version"
                }
            }, {}],
            73: [function(require, module, exports) {
                "use strict";

                function zero(buf) {
                    for (var len = buf.length; --len >= 0;) buf[len] = 0
                }

                function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
                    this.static_tree = static_tree, this.extra_bits = extra_bits, this.extra_base = extra_base, this.elems = elems, this.max_length = max_length, this.has_stree = static_tree && static_tree.length
                }

                function TreeDesc(dyn_tree, stat_desc) {
                    this.dyn_tree = dyn_tree, this.max_code = 0, this.stat_desc = stat_desc
                }

                function d_code(dist) {
                    return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)]
                }

                function put_short(s, w) {
                    s.pending_buf[s.pending++] = 255 & w, s.pending_buf[s.pending++] = w >>> 8 & 255
                }

                function send_bits(s, value, length) {
                    s.bi_valid > Buf_size - length ? (s.bi_buf |= value << s.bi_valid & 65535, put_short(s, s.bi_buf), s.bi_buf = value >> Buf_size - s.bi_valid, s.bi_valid += length - Buf_size) : (s.bi_buf |= value << s.bi_valid & 65535, s.bi_valid += length)
                }

                function send_code(s, c, tree) {
                    send_bits(s, tree[2 * c], tree[2 * c + 1])
                }

                function bi_reverse(code, len) {
                    var res = 0;
                    do res |= 1 & code, code >>>= 1, res <<= 1; while (--len > 0);
                    return res >>> 1
                }

                function bi_flush(s) {
                    16 === s.bi_valid ? (put_short(s, s.bi_buf), s.bi_buf = 0, s.bi_valid = 0) : s.bi_valid >= 8 && (s.pending_buf[s.pending++] = 255 & s.bi_buf, s.bi_buf >>= 8, s.bi_valid -= 8)
                }

                function gen_bitlen(s, desc) {
                    var h, n, m, bits, xbits, f, tree = desc.dyn_tree,
                        max_code = desc.max_code,
                        stree = desc.stat_desc.static_tree,
                        has_stree = desc.stat_desc.has_stree,
                        extra = desc.stat_desc.extra_bits,
                        base = desc.stat_desc.extra_base,
                        max_length = desc.stat_desc.max_length,
                        overflow = 0;
                    for (bits = 0; bits <= MAX_BITS; bits++) s.bl_count[bits] = 0;
                    for (tree[2 * s.heap[s.heap_max] + 1] = 0, h = s.heap_max + 1; h < HEAP_SIZE; h++) n = s.heap[h], bits = tree[2 * tree[2 * n + 1] + 1] + 1, bits > max_length && (bits = max_length, overflow++), tree[2 * n + 1] = bits, n > max_code || (s.bl_count[bits]++, xbits = 0, n >= base && (xbits = extra[n - base]), f = tree[2 * n], s.opt_len += f * (bits + xbits), has_stree && (s.static_len += f * (stree[2 * n + 1] + xbits)));
                    if (0 !== overflow) {
                        do {
                            for (bits = max_length - 1; 0 === s.bl_count[bits];) bits--;
                            s.bl_count[bits]--, s.bl_count[bits + 1] += 2, s.bl_count[max_length]--, overflow -= 2
                        } while (overflow > 0);
                        for (bits = max_length; 0 !== bits; bits--)
                            for (n = s.bl_count[bits]; 0 !== n;) m = s.heap[--h], m > max_code || (tree[2 * m + 1] !== bits && (s.opt_len += (bits - tree[2 * m + 1]) * tree[2 * m], tree[2 * m + 1] = bits), n--)
                    }
                }

                function gen_codes(tree, max_code, bl_count) {
                    var bits, n, next_code = new Array(MAX_BITS + 1),
                        code = 0;
                    for (bits = 1; bits <= MAX_BITS; bits++) next_code[bits] = code = code + bl_count[bits - 1] << 1;
                    for (n = 0; n <= max_code; n++) {
                        var len = tree[2 * n + 1];
                        0 !== len && (tree[2 * n] = bi_reverse(next_code[len]++, len))
                    }
                }

                function tr_static_init() {
                    var n, bits, length, code, dist, bl_count = new Array(MAX_BITS + 1);
                    for (length = 0, code = 0; code < LENGTH_CODES - 1; code++)
                        for (base_length[code] = length, n = 0; n < 1 << extra_lbits[code]; n++) _length_code[length++] = code;
                    for (_length_code[length - 1] = code, dist = 0, code = 0; code < 16; code++)
                        for (base_dist[code] = dist, n = 0; n < 1 << extra_dbits[code]; n++) _dist_code[dist++] = code;
                    for (dist >>= 7; code < D_CODES; code++)
                        for (base_dist[code] = dist << 7, n = 0; n < 1 << extra_dbits[code] - 7; n++) _dist_code[256 + dist++] = code;
                    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
                    for (n = 0; n <= 143;) static_ltree[2 * n + 1] = 8, n++, bl_count[8]++;
                    for (; n <= 255;) static_ltree[2 * n + 1] = 9, n++, bl_count[9]++;
                    for (; n <= 279;) static_ltree[2 * n + 1] = 7, n++, bl_count[7]++;
                    for (; n <= 287;) static_ltree[2 * n + 1] = 8, n++, bl_count[8]++;
                    for (gen_codes(static_ltree, L_CODES + 1, bl_count), n = 0; n < D_CODES; n++) static_dtree[2 * n + 1] = 5, static_dtree[2 * n] = bi_reverse(n, 5);
                    static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS), static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS), static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS)
                }

                function init_block(s) {
                    var n;
                    for (n = 0; n < L_CODES; n++) s.dyn_ltree[2 * n] = 0;
                    for (n = 0; n < D_CODES; n++) s.dyn_dtree[2 * n] = 0;
                    for (n = 0; n < BL_CODES; n++) s.bl_tree[2 * n] = 0;
                    s.dyn_ltree[2 * END_BLOCK] = 1, s.opt_len = s.static_len = 0, s.last_lit = s.matches = 0
                }

                function bi_windup(s) {
                    s.bi_valid > 8 ? put_short(s, s.bi_buf) : s.bi_valid > 0 && (s.pending_buf[s.pending++] = s.bi_buf), s.bi_buf = 0, s.bi_valid = 0
                }

                function copy_block(s, buf, len, header) {
                    bi_windup(s), header && (put_short(s, len), put_short(s, ~len)), utils.arraySet(s.pending_buf, s.window, buf, len, s.pending), s.pending += len
                }

                function smaller(tree, n, m, depth) {
                    var _n2 = 2 * n,
                        _m2 = 2 * m;
                    return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m]
                }

                function pqdownheap(s, tree, k) {
                    for (var v = s.heap[k], j = k << 1; j <= s.heap_len && (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth) && j++, !smaller(tree, v, s.heap[j], s.depth));) s.heap[k] = s.heap[j], k = j, j <<= 1;
                    s.heap[k] = v
                }

                function compress_block(s, ltree, dtree) {
                    var dist, lc, code, extra, lx = 0;
                    if (0 !== s.last_lit)
                        do dist = s.pending_buf[s.d_buf + 2 * lx] << 8 | s.pending_buf[s.d_buf + 2 * lx + 1], lc = s.pending_buf[s.l_buf + lx], lx++, 0 === dist ? send_code(s, lc, ltree) : (code = _length_code[lc], send_code(s, code + LITERALS + 1, ltree), extra = extra_lbits[code], 0 !== extra && (lc -= base_length[code], send_bits(s, lc, extra)), dist--, code = d_code(dist), send_code(s, code, dtree), extra = extra_dbits[code], 0 !== extra && (dist -= base_dist[code], send_bits(s, dist, extra))); while (lx < s.last_lit);
                    send_code(s, END_BLOCK, ltree)
                }

                function build_tree(s, desc) {
                    var n, m, node, tree = desc.dyn_tree,
                        stree = desc.stat_desc.static_tree,
                        has_stree = desc.stat_desc.has_stree,
                        elems = desc.stat_desc.elems,
                        max_code = -1;
                    for (s.heap_len = 0, s.heap_max = HEAP_SIZE, n = 0; n < elems; n++) 0 !== tree[2 * n] ? (s.heap[++s.heap_len] = max_code = n, s.depth[n] = 0) : tree[2 * n + 1] = 0;
                    for (; s.heap_len < 2;) node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0, tree[2 * node] = 1, s.depth[node] = 0, s.opt_len--, has_stree && (s.static_len -= stree[2 * node + 1]);
                    for (desc.max_code = max_code, n = s.heap_len >> 1; n >= 1; n--) pqdownheap(s, tree, n);
                    node = elems;
                    do n = s.heap[1], s.heap[1] = s.heap[s.heap_len--], pqdownheap(s, tree, 1), m = s.heap[1], s.heap[--s.heap_max] = n, s.heap[--s.heap_max] = m, tree[2 * node] = tree[2 * n] + tree[2 * m], s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1, tree[2 * n + 1] = tree[2 * m + 1] = node, s.heap[1] = node++, pqdownheap(s, tree, 1); while (s.heap_len >= 2);
                    s.heap[--s.heap_max] = s.heap[1], gen_bitlen(s, desc), gen_codes(tree, max_code, s.bl_count)
                }

                function scan_tree(s, tree, max_code) {
                    var n, curlen, prevlen = -1,
                        nextlen = tree[1],
                        count = 0,
                        max_count = 7,
                        min_count = 4;
                    for (0 === nextlen && (max_count = 138, min_count = 3), tree[2 * (max_code + 1) + 1] = 65535, n = 0; n <= max_code; n++) curlen = nextlen, nextlen = tree[2 * (n + 1) + 1], ++count < max_count && curlen === nextlen || (count < min_count ? s.bl_tree[2 * curlen] += count : 0 !== curlen ? (curlen !== prevlen && s.bl_tree[2 * curlen]++, s.bl_tree[2 * REP_3_6]++) : count <= 10 ? s.bl_tree[2 * REPZ_3_10]++ : s.bl_tree[2 * REPZ_11_138]++, count = 0, prevlen = curlen, 0 === nextlen ? (max_count = 138, min_count = 3) : curlen === nextlen ? (max_count = 6, min_count = 3) : (max_count = 7, min_count = 4))
                }

                function send_tree(s, tree, max_code) {
                    var n, curlen, prevlen = -1,
                        nextlen = tree[1],
                        count = 0,
                        max_count = 7,
                        min_count = 4;
                    for (0 === nextlen && (max_count = 138, min_count = 3), n = 0; n <= max_code; n++)
                        if (curlen = nextlen, nextlen = tree[2 * (n + 1) + 1],
                            !(++count < max_count && curlen === nextlen)) {
                            if (count < min_count) {
                                do send_code(s, curlen, s.bl_tree); while (0 !== --count)
                            } else 0 !== curlen ? (curlen !== prevlen && (send_code(s, curlen, s.bl_tree), count--), send_code(s, REP_3_6, s.bl_tree), send_bits(s, count - 3, 2)) : count <= 10 ? (send_code(s, REPZ_3_10, s.bl_tree), send_bits(s, count - 3, 3)) : (send_code(s, REPZ_11_138, s.bl_tree), send_bits(s, count - 11, 7));
                            count = 0, prevlen = curlen, 0 === nextlen ? (max_count = 138, min_count = 3) : curlen === nextlen ? (max_count = 6, min_count = 3) : (max_count = 7, min_count = 4)
                        }
                }

                function build_bl_tree(s) {
                    var max_blindex;
                    for (scan_tree(s, s.dyn_ltree, s.l_desc.max_code), scan_tree(s, s.dyn_dtree, s.d_desc.max_code), build_tree(s, s.bl_desc), max_blindex = BL_CODES - 1; max_blindex >= 3 && 0 === s.bl_tree[2 * bl_order[max_blindex] + 1]; max_blindex--);
                    return s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4, max_blindex
                }

                function send_all_trees(s, lcodes, dcodes, blcodes) {
                    var rank;
                    for (send_bits(s, lcodes - 257, 5), send_bits(s, dcodes - 1, 5), send_bits(s, blcodes - 4, 4), rank = 0; rank < blcodes; rank++) send_bits(s, s.bl_tree[2 * bl_order[rank] + 1], 3);
                    send_tree(s, s.dyn_ltree, lcodes - 1), send_tree(s, s.dyn_dtree, dcodes - 1)
                }

                function detect_data_type(s) {
                    var n, black_mask = 4093624447;
                    for (n = 0; n <= 31; n++, black_mask >>>= 1)
                        if (1 & black_mask && 0 !== s.dyn_ltree[2 * n]) return Z_BINARY;
                    if (0 !== s.dyn_ltree[18] || 0 !== s.dyn_ltree[20] || 0 !== s.dyn_ltree[26]) return Z_TEXT;
                    for (n = 32; n < LITERALS; n++)
                        if (0 !== s.dyn_ltree[2 * n]) return Z_TEXT;
                    return Z_BINARY
                }

                function _tr_init(s) {
                    static_init_done || (tr_static_init(), static_init_done = !0), s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc), s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc), s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc), s.bi_buf = 0, s.bi_valid = 0, init_block(s)
                }

                function _tr_stored_block(s, buf, stored_len, last) {
                    send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3), copy_block(s, buf, stored_len, !0)
                }

                function _tr_align(s) {
                    send_bits(s, STATIC_TREES << 1, 3), send_code(s, END_BLOCK, static_ltree), bi_flush(s)
                }

                function _tr_flush_block(s, buf, stored_len, last) {
                    var opt_lenb, static_lenb, max_blindex = 0;
                    s.level > 0 ? (s.strm.data_type === Z_UNKNOWN && (s.strm.data_type = detect_data_type(s)), build_tree(s, s.l_desc), build_tree(s, s.d_desc), max_blindex = build_bl_tree(s), opt_lenb = s.opt_len + 3 + 7 >>> 3, static_lenb = s.static_len + 3 + 7 >>> 3, static_lenb <= opt_lenb && (opt_lenb = static_lenb)) : opt_lenb = static_lenb = stored_len + 5, stored_len + 4 <= opt_lenb && buf !== -1 ? _tr_stored_block(s, buf, stored_len, last) : s.strategy === Z_FIXED || static_lenb === opt_lenb ? (send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3), compress_block(s, static_ltree, static_dtree)) : (send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3), send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1), compress_block(s, s.dyn_ltree, s.dyn_dtree)), init_block(s), last && bi_windup(s)
                }

                function _tr_tally(s, dist, lc) {
                    return s.pending_buf[s.d_buf + 2 * s.last_lit] = dist >>> 8 & 255, s.pending_buf[s.d_buf + 2 * s.last_lit + 1] = 255 & dist, s.pending_buf[s.l_buf + s.last_lit] = 255 & lc, s.last_lit++, 0 === dist ? s.dyn_ltree[2 * lc]++ : (s.matches++, dist--, s.dyn_ltree[2 * (_length_code[lc] + LITERALS + 1)]++, s.dyn_dtree[2 * d_code(dist)]++), s.last_lit === s.lit_bufsize - 1
                }
                var utils = require("../utils/common"),
                    Z_FIXED = 4,
                    Z_BINARY = 0,
                    Z_TEXT = 1,
                    Z_UNKNOWN = 2,
                    STORED_BLOCK = 0,
                    STATIC_TREES = 1,
                    DYN_TREES = 2,
                    MIN_MATCH = 3,
                    MAX_MATCH = 258,
                    LENGTH_CODES = 29,
                    LITERALS = 256,
                    L_CODES = LITERALS + 1 + LENGTH_CODES,
                    D_CODES = 30,
                    BL_CODES = 19,
                    HEAP_SIZE = 2 * L_CODES + 1,
                    MAX_BITS = 15,
                    Buf_size = 16,
                    MAX_BL_BITS = 7,
                    END_BLOCK = 256,
                    REP_3_6 = 16,
                    REPZ_3_10 = 17,
                    REPZ_11_138 = 18,
                    extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0],
                    extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13],
                    extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7],
                    bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15],
                    DIST_CODE_LEN = 512,
                    static_ltree = new Array(2 * (L_CODES + 2));
                zero(static_ltree);
                var static_dtree = new Array(2 * D_CODES);
                zero(static_dtree);
                var _dist_code = new Array(DIST_CODE_LEN);
                zero(_dist_code);
                var _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
                zero(_length_code);
                var base_length = new Array(LENGTH_CODES);
                zero(base_length);
                var base_dist = new Array(D_CODES);
                zero(base_dist);
                var static_l_desc, static_d_desc, static_bl_desc, static_init_done = !1;
                exports._tr_init = _tr_init, exports._tr_stored_block = _tr_stored_block, exports._tr_flush_block = _tr_flush_block, exports._tr_tally = _tr_tally, exports._tr_align = _tr_align
            }, {
                "../utils/common": 62
            }],
            74: [function(require, module, exports) {
                "use strict";

                function ZStream() {
                    this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0
                }
                module.exports = ZStream
            }, {}]
        }, {}, [10])(10)
    }), angular.module("custom.ui.bootstrap", ["custom.ui.bootstrap.transition", "custom.ui.bootstrap.modal"]), angular.module("custom.ui.bootstrap.modal", ["custom.ui.bootstrap.transition"]).factory("$$stackedMap", function() {
        return {
            createNew: function() {
                var stack = [];
                return {
                    add: function(key, value) {
                        stack.push({
                            key: key,
                            value: value
                        })
                    },
                    get: function(key) {
                        for (var i = 0; i < stack.length; i++)
                            if (key == stack[i].key) return stack[i]
                    },
                    keys: function keys() {
                        for (var keys = [], i = 0; i < stack.length; i++) keys.push(stack[i].key);
                        return keys
                    },
                    top: function() {
                        return stack[stack.length - 1]
                    },
                    remove: function(key) {
                        for (var idx = -1, i = 0; i < stack.length; i++)
                            if (key == stack[i].key) {
                                idx = i;
                                break
                            } return stack.splice(idx, 1)[0]
                    },
                    removeTop: function() {
                        return stack.splice(stack.length - 1, 1)[0]
                    },
                    length: function() {
                        return stack.length
                    }
                }
            }
        }
    }).directive("modalBackdrop", ["$timeout", function($timeout) {
        return {
            restrict: "EA",
            replace: !0,
            templateUrl: "/scripts/libs/uiBootstrapCustom/views/modal/backdrop.view.html",
            link: function(scope, element, attrs) {
                scope.backdropClass = attrs.backdropClass || "", scope.animate = !1, $timeout(function() {
                    scope.animate = !0
                }, 10)
            }
        }
    }]).directive("modalWindow", ["$modalStack", "$timeout", function($modalStack, $timeout) {
        return {
            restrict: "EA",
            scope: {
                index: "@",
                animate: "="
            },
            replace: !0,
            transclude: !0,
            templateUrl: function(tElement, tAttrs) {
                return tAttrs.templateUrl || "/scripts/libs/uiBootstrapCustom/views/modal/window.view.html"
            },
            link: function(scope, element, attrs) {
                element.addClass(attrs.windowClass || ""), scope.size = attrs.size, $timeout(function() {
                    scope.animate = !0, element[0].querySelectorAll("[autofocus]").length || element[0].focus()
                }, 10), scope.isClosingBlocked = $modalStack.getTop().value.closeBlocked, scope.close = function(evt) {
                    var modal = $modalStack.getTop();
                    if (modal && evt.target === evt.currentTarget) {
                        if (modal.value.closeBlocked) return;
                        evt.preventDefault(), evt.stopPropagation(), $modalStack.dismiss(modal.key, "backdrop click")
                    }
                }
            }
        }
    }]).directive("modalTransclude", function() {
        return {
            link: function($scope, $element, $attrs, controller, $transclude) {
                $transclude($scope.$parent, function(clone) {
                    $element.empty(), $element.append(clone)
                })
            }
        }
    }).factory("$modalStack", ["$transition", "$timeout", "$document", "$compile", "$rootScope", "$$stackedMap", function($transition, $timeout, $document, $compile, $rootScope, $$stackedMap) {
        function backdropIndex() {
            for (var topBackdropIndex = -1, opened = openedWindows.keys(), i = 0; i < opened.length; i++) openedWindows.get(opened[i]).value.backdrop && (topBackdropIndex = i);
            return topBackdropIndex
        }

        function removeModalWindow(modalInstance) {
            var body = $document.find("body").eq(0),
                modalWindow = openedWindows.get(modalInstance).value;
            openedWindows.remove(modalInstance), removeAfterAnimate(modalWindow.modalDomEl, modalWindow.modalScope, 300, function() {
                modalWindow.modalScope.$destroy(), body.toggleClass(OPENED_MODAL_CLASS, openedWindows.length() > 0), checkRemoveBackdrop()
            })
        }

        function checkRemoveBackdrop() {
            if (backdropDomEl && backdropIndex() == -1) {
                var backdropScopeRef = backdropScope;
                removeAfterAnimate(backdropDomEl, backdropScope, 150, function() {
                    backdropScopeRef.$destroy(), backdropScopeRef = null
                }), backdropDomEl = void 0, backdropScope = void 0
            }
        }

        function removeAfterAnimate(domEl, scope, emulateTime, done) {
            function afterAnimating() {
                afterAnimating.done || (afterAnimating.done = !0, domEl.remove(), done && done())
            }
            scope.animate = !1;
            var transitionEndEventName = $transition.transitionEndEventName;
            if (transitionEndEventName) {
                var timeout = $timeout(afterAnimating, emulateTime);
                domEl.bind(transitionEndEventName, function() {
                    $timeout.cancel(timeout), afterAnimating(), scope.$apply()
                })
            } else $timeout(afterAnimating)
        }
        var backdropDomEl, backdropScope, OPENED_MODAL_CLASS = "modal-open",
            openedWindows = $$stackedMap.createNew(),
            $modalStack = {};
        return $rootScope.$watch(backdropIndex, function(newBackdropIndex) {
            backdropScope && (backdropScope.index = newBackdropIndex)
        }), $document.bind("keydown", function(evt) {
            var modal;
            27 === evt.which && (modal = openedWindows.top(), modal && modal.value.keyboard && (evt.preventDefault(), $rootScope.$apply(function() {
                $modalStack.dismiss(modal.key, "escape key press")
            })))
        }), $modalStack.open = function(modalInstance, modal) {
            openedWindows.add(modalInstance, {
                deferred: modal.deferred,
                modalScope: modal.scope,
                backdrop: modal.backdrop,
                keyboard: modal.keyboard,
                closeBlocked: modal.closeBlocked
            });
            var body = $document.find("body").eq(0),
                currBackdropIndex = backdropIndex();
            if (currBackdropIndex >= 0 && !backdropDomEl) {
                backdropScope = $rootScope.$new(!0), backdropScope.index = currBackdropIndex;
                var angularBackgroundDomEl = angular.element("<div modal-backdrop></div>");
                angularBackgroundDomEl.attr("backdrop-class", modal.backdropClass), backdropDomEl = $compile(angularBackgroundDomEl)(backdropScope), body.append(backdropDomEl)
            }
            var angularDomEl = angular.element("<div modal-window></div>");
            angularDomEl.attr({
                "template-url": modal.windowTemplateUrl,
                "window-class": modal.windowClass,
                size: modal.size,
                index: openedWindows.length() - 1,
                animate: "animate"
            }).html(modal.content);
            var modalDomEl = $compile(angularDomEl)(modal.scope);
            openedWindows.top().value.modalDomEl = modalDomEl, body.append(modalDomEl), body.addClass(OPENED_MODAL_CLASS)
        }, $modalStack.close = function(modalInstance, result) {
            var modalWindow = openedWindows.get(modalInstance);
            modalWindow && (modalWindow.value.deferred.resolve(result), removeModalWindow(modalInstance))
        }, $modalStack.dismiss = function(modalInstance, reason) {
            var modalWindow = openedWindows.get(modalInstance);
            modalWindow && (modalWindow.value.deferred.reject(reason), removeModalWindow(modalInstance))
        }, $modalStack.dismissAll = function(reason) {
            for (var topModal = this.getTop(); topModal;) this.dismiss(topModal.key, reason), topModal = this.getTop()
        }, $modalStack.getTop = function() {
            return openedWindows.top()
        }, $modalStack
    }]).provider("$modal", function() {
        var $modalProvider = {
            options: {
                backdrop: !1,
                keyboard: !0
            },
            $get: ["$injector", "$rootScope", "$q", "$http", "$templateCache", "$controller", "$modalStack", function($injector, $rootScope, $q, $http, $templateCache, $controller, $modalStack) {
                function getTemplatePromise(options) {
                    return options.template ? $q.when(options.template) : $http.get(angular.isFunction(options.templateUrl) ? options.templateUrl() : options.templateUrl, {
                        cache: $templateCache
                    }).then(function(result) {
                        return result.data
                    })
                }

                function getResolvePromises(resolves) {
                    var promisesArr = [];
                    return angular.forEach(resolves, function(value) {
                        (angular.isFunction(value) || angular.isArray(value)) && promisesArr.push($q.when($injector.invoke(value)))
                    }), promisesArr
                }
                var $modal = {};
                return $modal.open = function(modalOptions) {
                    var modalResultDeferred = $q.defer(),
                        modalOpenedDeferred = $q.defer(),
                        modalInstance = {
                            result: modalResultDeferred.promise,
                            opened: modalOpenedDeferred.promise,
                            close: function(result) {
                                $modalStack.close(modalInstance, result)
                            },
                            dismiss: function(reason) {
                                $modalStack.dismiss(modalInstance, reason)
                            }
                        };
                    if (modalOptions = angular.extend({}, $modalProvider.options, modalOptions), modalOptions.resolve = modalOptions.resolve || {}, !modalOptions.template && !modalOptions.templateUrl) throw new Error("One of template or templateUrl options is required.");
                    var templateAndResolvePromise = $q.all([getTemplatePromise(modalOptions)].concat(getResolvePromises(modalOptions.resolve)));
                    return templateAndResolvePromise.then(function(tplAndVars) {
                        var modalScope = (modalOptions.scope || $rootScope).$new();
                        modalScope.$close = modalInstance.close, modalScope.$dismiss = modalInstance.dismiss;
                        var ctrlInstance, ctrlLocals = {},
                            resolveIter = 1;
                        modalOptions.controller && (ctrlLocals.$scope = modalScope, ctrlLocals.$modalInstance = modalInstance, angular.forEach(modalOptions.resolve, function(value, key) {
                            ctrlLocals[key] = tplAndVars[resolveIter++]
                        }), ctrlInstance = $controller(modalOptions.controller, ctrlLocals), modalOptions.controllerAs && (modalScope[modalOptions.controllerAs] = ctrlInstance)), $modalStack.open(modalInstance, {
                            scope: modalScope,
                            deferred: modalResultDeferred,
                            content: tplAndVars[0],
                            backdrop: modalOptions.backdrop,
                            keyboard: modalOptions.keyboard,
                            backdropClass: modalOptions.backdropClass,
                            windowClass: modalOptions.windowClass,
                            windowTemplateUrl: modalOptions.windowTemplateUrl,
                            size: modalOptions.size,
                            closeBlocked: modalOptions.closeBlocked
                        })
                    }, function(reason) {
                        modalResultDeferred.reject(reason)
                    }), templateAndResolvePromise.then(function() {
                        modalOpenedDeferred.resolve(!0)
                    }, function() {
                        modalOpenedDeferred.reject(!1)
                    }), modalInstance
                }, $modal
            }]
        };
        return $modalProvider
    }), angular.module("custom.ui.bootstrap.transition", []).factory("$transition", ["$q", "$timeout", "$rootScope", function($q, $timeout, $rootScope) {
        function findEndEventName(endEventNames) {
            for (var name in endEventNames)
                if (void 0 !== transElement.style[name]) return endEventNames[name]
        }
        var $transition = function $transition(element, trigger, options) {
                options = options || {};
                var deferred = $q.defer(),
                    endEventName = $transition[options.animation ? "animationEndEventName" : "transitionEndEventName"],
                    transitionEndHandler = function transitionEndHandler(event) {
                        $rootScope.$apply(function() {
                            element.unbind(endEventName, transitionEndHandler), deferred.resolve(element)
                        })
                    };
                return endEventName && element.bind(endEventName, transitionEndHandler), $timeout(function() {
                    angular.isString(trigger) ? element.addClass(trigger) : angular.isFunction(trigger) ? trigger(element) : angular.isObject(trigger) && element.css(trigger), endEventName || deferred.resolve(element)
                }), deferred.promise.cancel = function() {
                    endEventName && element.unbind(endEventName, transitionEndHandler), deferred.reject("Transition cancelled")
                }, deferred.promise
            },
            transElement = document.createElement("trans"),
            transitionEndEventNames = {
                WebkitTransition: "webkitTransitionEnd",
                MozTransition: "transitionend",
                OTransition: "oTransitionEnd",
                transition: "transitionend"
            },
            animationEndEventNames = {
                WebkitTransition: "webkitAnimationEnd",
                MozTransition: "animationend",
                OTransition: "oAnimationEnd",
                transition: "animationend"
            };
        return $transition.transitionEndEventName = findEndEventName(transitionEndEventNames), $transition.animationEndEventName = findEndEventName(animationEndEventNames), $transition
    }]), ! function(a) {
        "use strict";

        function b(a, b) {
            var c = (65535 & a) + (65535 & b),
                d = (a >> 16) + (b >> 16) + (c >> 16);
            return d << 16 | 65535 & c
        }

        function c(a, b) {
            return a << b | a >>> 32 - b
        }

        function d(a, d, e, f, g, h) {
            return b(c(b(b(d, a), b(f, h)), g), e)
        }

        function e(a, b, c, e, f, g, h) {
            return d(b & c | ~b & e, a, b, f, g, h)
        }

        function f(a, b, c, e, f, g, h) {
            return d(b & e | c & ~e, a, b, f, g, h)
        }

        function g(a, b, c, e, f, g, h) {
            return d(b ^ c ^ e, a, b, f, g, h)
        }

        function h(a, b, c, e, f, g, h) {
            return d(c ^ (b | ~e), a, b, f, g, h)
        }

        function i(a, c) {
            a[c >> 5] |= 128 << c % 32, a[(c + 64 >>> 9 << 4) + 14] = c;
            var d, i, j, k, l, m = 1732584193,
                n = -271733879,
                o = -1732584194,
                p = 271733878;
            for (d = 0; d < a.length; d += 16) i = m, j = n, k = o, l = p, m = e(m, n, o, p, a[d], 7, -680876936), p = e(p, m, n, o, a[d + 1], 12, -389564586), o = e(o, p, m, n, a[d + 2], 17, 606105819), n = e(n, o, p, m, a[d + 3], 22, -1044525330), m = e(m, n, o, p, a[d + 4], 7, -176418897), p = e(p, m, n, o, a[d + 5], 12, 1200080426), o = e(o, p, m, n, a[d + 6], 17, -1473231341), n = e(n, o, p, m, a[d + 7], 22, -45705983), m = e(m, n, o, p, a[d + 8], 7, 1770035416), p = e(p, m, n, o, a[d + 9], 12, -1958414417), o = e(o, p, m, n, a[d + 10], 17, -42063), n = e(n, o, p, m, a[d + 11], 22, -1990404162), m = e(m, n, o, p, a[d + 12], 7, 1804603682), p = e(p, m, n, o, a[d + 13], 12, -40341101), o = e(o, p, m, n, a[d + 14], 17, -1502002290), n = e(n, o, p, m, a[d + 15], 22, 1236535329), m = f(m, n, o, p, a[d + 1], 5, -165796510), p = f(p, m, n, o, a[d + 6], 9, -1069501632), o = f(o, p, m, n, a[d + 11], 14, 643717713), n = f(n, o, p, m, a[d], 20, -373897302), m = f(m, n, o, p, a[d + 5], 5, -701558691), p = f(p, m, n, o, a[d + 10], 9, 38016083), o = f(o, p, m, n, a[d + 15], 14, -660478335), n = f(n, o, p, m, a[d + 4], 20, -405537848), m = f(m, n, o, p, a[d + 9], 5, 568446438), p = f(p, m, n, o, a[d + 14], 9, -1019803690), o = f(o, p, m, n, a[d + 3], 14, -187363961), n = f(n, o, p, m, a[d + 8], 20, 1163531501), m = f(m, n, o, p, a[d + 13], 5, -1444681467), p = f(p, m, n, o, a[d + 2], 9, -51403784), o = f(o, p, m, n, a[d + 7], 14, 1735328473), n = f(n, o, p, m, a[d + 12], 20, -1926607734), m = g(m, n, o, p, a[d + 5], 4, -378558), p = g(p, m, n, o, a[d + 8], 11, -2022574463), o = g(o, p, m, n, a[d + 11], 16, 1839030562), n = g(n, o, p, m, a[d + 14], 23, -35309556), m = g(m, n, o, p, a[d + 1], 4, -1530992060), p = g(p, m, n, o, a[d + 4], 11, 1272893353), o = g(o, p, m, n, a[d + 7], 16, -155497632), n = g(n, o, p, m, a[d + 10], 23, -1094730640), m = g(m, n, o, p, a[d + 13], 4, 681279174), p = g(p, m, n, o, a[d], 11, -358537222), o = g(o, p, m, n, a[d + 3], 16, -722521979), n = g(n, o, p, m, a[d + 6], 23, 76029189), m = g(m, n, o, p, a[d + 9], 4, -640364487), p = g(p, m, n, o, a[d + 12], 11, -421815835), o = g(o, p, m, n, a[d + 15], 16, 530742520), n = g(n, o, p, m, a[d + 2], 23, -995338651), m = h(m, n, o, p, a[d], 6, -198630844), p = h(p, m, n, o, a[d + 7], 10, 1126891415), o = h(o, p, m, n, a[d + 14], 15, -1416354905), n = h(n, o, p, m, a[d + 5], 21, -57434055), m = h(m, n, o, p, a[d + 12], 6, 1700485571), p = h(p, m, n, o, a[d + 3], 10, -1894986606), o = h(o, p, m, n, a[d + 10], 15, -1051523), n = h(n, o, p, m, a[d + 1], 21, -2054922799), m = h(m, n, o, p, a[d + 8], 6, 1873313359), p = h(p, m, n, o, a[d + 15], 10, -30611744), o = h(o, p, m, n, a[d + 6], 15, -1560198380), n = h(n, o, p, m, a[d + 13], 21, 1309151649), m = h(m, n, o, p, a[d + 4], 6, -145523070), p = h(p, m, n, o, a[d + 11], 10, -1120210379), o = h(o, p, m, n, a[d + 2], 15, 718787259), n = h(n, o, p, m, a[d + 9], 21, -343485551), m = b(m, i), n = b(n, j), o = b(o, k), p = b(p, l);
            return [m, n, o, p]
        }

        function j(a) {
            var b, c = "";
            for (b = 0; b < 32 * a.length; b += 8) c += String.fromCharCode(a[b >> 5] >>> b % 32 & 255);
            return c
        }

        function k(a) {
            var b, c = [];
            for (c[(a.length >> 2) - 1] = void 0, b = 0; b < c.length; b += 1) c[b] = 0;
            for (b = 0; b < 8 * a.length; b += 8) c[b >> 5] |= (255 & a.charCodeAt(b / 8)) << b % 32;
            return c
        }

        function l(a) {
            return j(i(k(a), 8 * a.length))
        }

        function m(a, b) {
            var c, d, e = k(a),
                f = [],
                g = [];
            for (f[15] = g[15] = void 0, e.length > 16 && (e = i(e, 8 * a.length)), c = 0; 16 > c; c += 1) f[c] = 909522486 ^ e[c], g[c] = 1549556828 ^ e[c];
            return d = i(f.concat(k(b)), 512 + 8 * b.length), j(i(g.concat(d), 640))
        }

        function n(a) {
            var b, c, d = "0123456789abcdef",
                e = "";
            for (c = 0; c < a.length; c += 1) b = a.charCodeAt(c), e += d.charAt(b >>> 4 & 15) + d.charAt(15 & b);
            return e
        }

        function o(a) {
            return unescape(encodeURIComponent(a))
        }

        function p(a) {
            return l(o(a))
        }

        function q(a) {
            return n(p(a))
        }

        function r(a, b) {
            return m(o(a), o(b))
        }

        function s(a, b) {
            return n(r(a, b))
        }

        function t(a, b, c) {
            return b ? c ? r(b, a) : s(b, a) : c ? p(a) : q(a)
        }
        "function" == typeof define && define.amd ? define(function() {
            return t
        }) : a.md5 = t
    }(this),
    function() {
        function isFunction(obj) {
            return "[object Function]" === Object.prototype.toString.call(obj)
        }

        function has(obj, property) {
            return Object.prototype.hasOwnProperty.call(obj, property)
        }

        function extend(obj) {
            return _.forEach(Array.prototype.slice.call(arguments, 1), function(source) {
                source && _.forIn(source, function(value, key) {
                    obj[key] = value
                })
            }), obj
        }
        var root = this,
            Base = function() {};
        root.Base = Base, Base.prototype.constructor = function() {}, Base.prototype._getParentFn = function(caller) {
            var parentFn = function() {};
            if (caller && caller.__name__) {
                var _owner = caller.__owner__,
                    _name = caller.__name__;
                if (!_owner.prototype[_name]) throw new Error("Parent function `" + _name + "` not found.");
                parentFn = _owner.prototype[_name]
            }
            return parentFn
        }, Base._getParentFn = function(caller) {
            var parentFn = function() {};
            if (caller && caller.__name__) {
                var _owner = caller.__owner__,
                    _name = caller.__name__;
                if (!_owner[_name]) throw new Error("Parent function `" + _name + "` not found.");
                parentFn = _owner[_name]
            }
            return parentFn
        }, Base.parent = Base.prototype.parent = function() {
            var caller = arguments.callee.caller,
                parentFn = this._getParentFn(caller);
            return parentFn.apply(this, arguments)
        }, Base.applyParent = Base.prototype.applyParent = function(params) {
            var caller = arguments.callee.caller,
                parentFn = this._getParentFn(caller);
            return parentFn.apply(this, params)
        }, Base.__getInterfaces = function() {
            return []
        }, Base.implement = function(iface) {
            return this.extend(null, {
                __getInterfaces: function() {
                    var ifaces = this.parent();
                    return ifaces.push(iface.prototype), ifaces
                }
            })
        }, Base.prototype.isImplementing = function(iface) {
            if (iface && !isFunction(iface)) throw new Error("Given interface " + iface + " is not function");
            iface = iface.prototype;
            for (var cnstr = this.constructor, interfaces = cnstr.__getInterfaces(), length = interfaces.length, i = 0; i < length; i++)
                if (interfaces[i] === iface) return !0;
            return !1
        }, Base.use = function(mixin) {
            if (mixin && !isFunction(mixin)) throw new Error("Given prototype mixin " + mixin + "is not function");
            return this.extend(mixin, mixin)
        }, Base.extend = function(protoProps, staticProps) {
            var ignoreConstructor = !1;
            protoProps && (isFunction(protoProps) && (protoProps = protoProps.prototype, ignoreConstructor = !0), _.forEach(this.__getInterfaces(), function(iface) {
                for (var member in iface)
                    if (member in protoProps);
                    else if (!(member in this.prototype)) throw new Error("Interface member `" + member + "` is not implemented!")
            }, this)), protoProps = protoProps || {};
            var child, key, parent = this;
            for (key in protoProps) isFunction(protoProps[key]) && (protoProps[key].__name__ = key, protoProps[key].__owner__ = parent);
            for (key in staticProps) isFunction(staticProps[key]) && (staticProps[key].__name__ = key, staticProps[key].__owner__ = parent);
            protoProps && has(protoProps, "constructor") && !ignoreConstructor ? child = protoProps.constructor : (protoProps.constructor = function() {
                parent.apply(this, arguments)
            }, protoProps.constructor.__name__ = "constructor", protoProps.constructor.__owner__ = parent, child = protoProps.constructor), extend(child, parent, staticProps);
            var Surrogate = function() {
                this.constructor = child
            };
            return Surrogate.prototype = parent.prototype, child.prototype = new Surrogate, protoProps && extend(child.prototype, protoProps), child.__owner__ = parent, child
        }
    }(),
    function() {
        this.Class = function(params) {
            var instantiate = function instantiate(params) {
                var c;
                return params.Extends ? (c = instantiate(params.Extends), c = c.extend(params)) : c = Base.extend(params), c
            };
            params.constructor = function() {
                "function" == typeof this.initialize && this.initialize.apply(this, arguments)
            };
            var c = instantiate(params);
            return params.Implements && params.Implements.length && _.forEach(params.Implements, function(mixin) {
                c = c.use(mixin)
            }), c
        }
    }(),
    function() {
        this.Options = new Class({
            setOptions: function() {
                return this.options = _.clone(_.extend(this.options, arguments[0])), this
            }
        })
    }(),
    function(nsp) {
        "use strict";
        nsp.UXPAnimationsMap = {
            easing: {
                LINEAR: {
                    value: "easeNone",
                    label: "Linear"
                },
                EASE_IN: {
                    value: "easeIn",
                    label: "Ease In"
                },
                EASE_OUT: {
                    value: "easeOut",
                    label: "Ease Out"
                },
                EASE_IN_OUT: {
                    value: "easeInOut",
                    label: "Ease In Out"
                }
            },
            easingType: {
                POWER0: {
                    value: "Power0",
                    label: "None",
                    hidden: !0
                },
                QUAD: {
                    value: "Power1",
                    label: "Quadratic"
                },
                CUBIC: {
                    value: "Power2",
                    label: "Cubic"
                },
                QUART: {
                    value: "Power3",
                    label: "Quartic"
                },
                QUINT: {
                    value: "Power4",
                    label: "Quintic"
                },
                SINE: {
                    value: "Sine",
                    label: "Sine"
                },
                EXPO: {
                    value: "Expo",
                    label: "Exponential"
                },
                CIRC: {
                    value: "Circ",
                    label: "Circular"
                },
                ELASTIC: {
                    value: "Elastic",
                    label: "Elastic"
                },
                BOUNCE: {
                    value: "Bounce",
                    label: "Bounce"
                },
                BACK: {
                    value: "Back",
                    label: "Back"
                }
            }
        }, UXPAnimationsMap.legacyEasing = {
            linear: {
                easing: UXPAnimationsMap.easing.LINEAR.value,
                easingType: UXPAnimationsMap.easingType.POWER0.value
            },
            "ease-in": {
                easing: UXPAnimationsMap.easing.EASE_IN.value,
                easingType: UXPAnimationsMap.easingType.CUBIC.value
            },
            "ease-out": {
                easing: UXPAnimationsMap.easing.EASE_OUT.value,
                easingType: UXPAnimationsMap.easingType.CUBIC.value
            },
            "ease-in-out": {
                easing: UXPAnimationsMap.easing.EASE_IN_OUT.value,
                easingType: UXPAnimationsMap.easingType.CUBIC.value
            },
            "back-out": {
                easing: UXPAnimationsMap.easing.EASE_OUT.value,
                easingType: UXPAnimationsMap.easingType.BACK.value
            },
            "elastic-out": {
                easing: UXPAnimationsMap.easing.EASE_OUT.value,
                easingType: UXPAnimationsMap.easingType.ELASTIC.value
            }
        }, nsp.UXPAnimationsMap = UXPAnimationsMap
    }(window),
    function(global) {
        "use strict";
        var InteractionsAnimations = function(el) {
            this.el = el, this.prefix = this.getPrefix(), this.animations = {}, this.parseCurrentAnimations()
        };
        InteractionsAnimations.prototype.getPrefix = function() {
            var prefix = "";
            for (var css_prefix in InteractionsAnimations.prefixes)
                if (InteractionsAnimations.prefixes.hasOwnProperty(css_prefix) && "undefined" != typeof window.getComputedStyle(this.el)[InteractionsAnimations.prefixes[css_prefix] + "Transform"]) {
                    prefix = css_prefix;
                    break
                } return prefix
        }, InteractionsAnimations.prototype.getDefineType = function(type) {
            return "undefined" == typeof this.animations[type] && (this.animations[type] = {
                property: [],
                duration: [],
                function: []
            }), this.animations[type]
        }, InteractionsAnimations.prototype.parseCurrentAnimations = function() {
            var property, index, transitions = this.parseTransitions();
            for (var type in InteractionsAnimations.definitions)
                if (InteractionsAnimations.definitions.hasOwnProperty(type))
                    for (var i in InteractionsAnimations.definitions[type])
                        if (InteractionsAnimations.definitions[type].hasOwnProperty(i)) {
                            if (property = InteractionsAnimations.definitions[type][i], property.match(/^\-.*$/) && (property = "-" + this.prefix + property), index = transitions.property.indexOf(property), !(index > -1)) break;
                            var animation = this.getDefineType(type);
                            animation.property.push(property), animation.duration.push(transitions.duration[index]), animation.function.push(transitions["timing-function"][index]), transitions.property.splice(index, 1), transitions.duration.splice(index, 1), transitions["timing-function"].splice(index, 1)
                        }
        }, InteractionsAnimations.prototype.parseTransitions = function() {
            var transitions = {};
            return transitions.property = window.getComputedStyle(this.el)[InteractionsAnimations.prefixes[this.prefix] + "TransitionProperty"].split(",").map(function(val) {
                return val.trim()
            }), transitions.duration = window.getComputedStyle(this.el)[InteractionsAnimations.prefixes[this.prefix] + "TransitionDuration"].split(",").map(function(val) {
                return val.trim()
            }), transitions["timing-function"] = window.getComputedStyle(this.el)[InteractionsAnimations.prefixes[this.prefix] + "TransitionTimingFunction"].split(",").map(function(val) {
                return val.trim()
            }), transitions
        }, InteractionsAnimations.prototype.addAnimation = function(type, timing_function, duration) {
            var animation = this.getDefineType(type),
                prefix = this.prefix;
            InteractionsAnimations.definitions[type].forEach(function(property) {
                property.match(/^\-.*$/) && (property = "-" + prefix + property), animation.property.push(property), animation.duration.push(duration), animation.function.push(timing_function)
            }), this.apply()
        }, InteractionsAnimations.prototype.apply = function() {
            var transition_property = [],
                transition_duration = [],
                transition_function = [],
                property_cbk = function(property) {
                    transition_property.push(property)
                },
                duration_cbk = function(duration) {
                    transition_duration.push(duration)
                },
                function_cbk = function(func) {
                    transition_function.push(func)
                };
            for (var type in this.animations) this.animations.hasOwnProperty(type) && (this.animations[type].property.forEach(property_cbk), this.animations[type].duration.forEach(duration_cbk), this.animations[type].function.forEach(function_cbk));
            this.el.style[InteractionsAnimations.prefixes[this.prefix] + "TransitionProperty"] = transition_property.join(", "), this.el.style[InteractionsAnimations.prefixes[this.prefix] + "TransitionDuration"] = transition_duration.join(", "), this.el.style[InteractionsAnimations.prefixes[this.prefix] + "TransitionTimingFunction"] = transition_function.join(", ")
        }, InteractionsAnimations.prototype.remove = function(type) {
            this.parseCurrentAnimations(), "undefined" != typeof this.animations[type] && delete this.animations[type], this.apply()
        }, InteractionsAnimations.prototype.removeAll = function() {
            this.animations = {}, this.apply()
        }, InteractionsAnimations.prefixes = {
            webkit: "webkit",
            moz: "Moz",
            ms: "ms",
            o: "o"
        }, InteractionsAnimations.definitions = {
            show: ["opacity", "visibility", "margin"],
            move: ["top", "left"],
            resize: ["width", "height"],
            scale: ["-transform"],
            rotate: ["-transform"],
            opacity: ["opacity"],
            style: ["color", "background-color", "border-color"],
            style_navi: ["background-color", "border-color"]
        }, InteractionsAnimations.timeouts = {
            show: {},
            move: {},
            resize: {},
            scale: {},
            rotate: {},
            opacity: {},
            style: {},
            style_navi: {}
        }, InteractionsAnimations.timing = {
            linear: function(t, b, c, d) {
                return t /= d, b + c * t
            },
            "ease-out": function(t, b, c, d) {
                var ts = (t /= d) * t,
                    tc = ts * t;
                return b + c * (tc * ts + -5 * ts * ts + 10 * tc + -10 * ts + 5 * t)
            },
            "ease-in": function(t, b, c, d) {
                var ts = (t /= d) * t,
                    tc = ts * t;
                return b + c * (tc * ts)
            },
            "ease-in-out": function(t, b, c, d) {
                var ts = (t /= d) * t,
                    tc = ts * t;
                return b + c * (6 * tc * ts + -15 * ts * ts + 10 * tc)
            }
        }, InteractionsAnimations.setDefaultEasingValues = function(data) {
            var easingData = _.defaults(data || {}, {
                easing: UXPAnimationsMap.easing.LINEAR.value,
                easingType: UXPAnimationsMap.easingType.POWER0.value,
                duration: 0
            });
            return data && data.easing || (easingData.duration = 0), easingData.style && Object.keys(UXPAnimationsMap.legacyEasing).indexOf(easingData.style) > -1 && (easingData.duration = easingData.time || easingData.duration || 0, easingData.easing = UXPAnimationsMap.legacyEasing[easingData.style].easing, easingData.easingType = UXPAnimationsMap.legacyEasing[easingData.style].easingType), easingData
        }, InteractionsAnimations.getEasing = function(data) {
            var easing;
            if (data.easingType === UXPAnimationsMap.easingType.ELASTIC.value) {
                var springness = data.springness / Math.pow(10, 2 * (String(data.springness).length - 2) + 1);
                easing = window[data.easingType][data.easing].config(data.amplitude / 100, springness)
            } else easing = window[data.easingType][data.easing];
            return easing
        }, InteractionsAnimations.processScroll = function(el, to, duration, animation) {
            animation = InteractionsAnimations.setDefaultEasingValues(animation), InteractionsAnimations.scroll(el, to, duration, InteractionsAnimations.getEasing(animation))
        }, InteractionsAnimations.scroll = function(el, to, duration, easing) {
            TweenLite.to(el, duration / 1e3, {
                scrollTo: {
                    y: to
                },
                ease: easing
            })
        }, InteractionsAnimations.positionTop = function(el, to, duration, timing, start) {
            start = start || parseInt(window.getComputedStyle(el).top);
            var change = to - start,
                currentTime = 0,
                increment = 5,
                animateTop = function animateTop() {
                    currentTime += increment, el.style.top = InteractionsAnimations.timing[timing](currentTime, start, change, duration) + "px", currentTime < duration && setTimeout(animateTop, increment)
                };
            animateTop()
        }, InteractionsAnimations.getTimeoutTime = function(time) {
            return time > 20 ? time - 10 : 10
        }, global.InteractionsAnimations = InteractionsAnimations
    }(window);
//# sourceMappingURL=maps/vendors.js.map